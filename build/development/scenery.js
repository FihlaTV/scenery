(function() {
  if ( !window.hasOwnProperty( '_' ) ) {
    throw new Error( 'Underscore/Lodash not found: _' );
  }
  if ( !window.hasOwnProperty( '$' ) ) {
    throw new Error( 'jQuery not found: $' );
  }

// Copyright 2013-2015, University of Colorado Boulder

/*
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

(function() {
  'use strict';

  window.assertions = window.assertions || {};
  window.assertions.assertFunction = window.assertions.assertFunction || function( predicate, message ) {
    var result = typeof predicate === 'function' ? predicate() : predicate;

    if ( !result ) {

      //Log the stack trace to IE.  Just creating an Error is not enough, it has to be caught to get a stack.
      if ( window.navigator && window.navigator.appName === 'Microsoft Internet Explorer' ) {
        try { throw new Error(); }
        catch( e ) { message = message + ', stack=\n' + e.stack; }
      }

      console && console.log && console.log( 'Assertion failed: ' + message );
      throw new Error( 'Assertion failed: ' + message );
    }
  };

  window.assert = window.assert || null;
  window.assertSlow = window.assertSlow || null;

  window.assertions.enableAssert = function() {
    window.assert = window.assertions.assertFunction;
    window.console && window.console.log && window.console.log( 'enabling assert' );
  };
  window.assertions.disableAssert = function() {
    window.assert = null;
    window.console && window.console.log && window.console.log( 'disabling assert' );
  };

  window.assertions.enableAssertSlow = function() {
    window.assertSlow = window.assertions.assertFunction;
    window.console && window.console.log && window.console.log( 'enabling assertSlow' );
  };
  window.assertions.disableAssertSlow = function() {
    window.assertSlow = null;
    window.console && window.console.log && window.console.log( 'disabling assertSlow' );
  };
})();
/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

// Copyright 2015, University of Colorado Boulder

/**
 * @author Jonathan Olson
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'PHET_CORE/Namespace',['require'],function( require ) {
  'use strict';

  /**
   * @param {string} name
   * @constructor
   */
  function Namespace( name ) {

    this.name = name; // @public (read-only)

    if ( window.phet ) {
      assert && assert( !window.phet[ name ], 'namespace ' + name + ' already exists' );
      window.phet[ name ] = this;
    }
  }

  Namespace.prototype = {

    constructor: Namespace,

    /**
     * Registers a key-value pair with the namespace.
     *
     * If there are no dots ('.') in the key, it will be assigned to the namespace. For example:
     * - x.register( 'A', A );
     * will set x.A = A.
     *
     * If the key contains one or more dots ('.'), it's treated somewhat like a path expression. For instance, if the
     * following is called:
     * - x.register( 'A.B.C', C );
     * then the register function will navigate to the object x.A.B and add x.A.B.C = C.
     *
     * @param {string} key
     * @param {*} value
     * @public
     */
    register: function( key, value ) {

      // If the key isn't compound (doesn't contain '.'), we can just look it up on this namespace
      if ( key.indexOf( '.' ) < 0 ) {
        assert && assert( !this[ key ], key + ' is already registered for namespace ' + this.name );
        this[ key ] = value;
      }
      // Compound (contains '.' at least once). x.register( 'A.B.C', C ) should set x.A.B.C.
      else {
        var keys = key.split( '.' ); // e.g. [ 'A', 'B', 'C' ]

        // Walk into the namespace, verifying that each level exists. e.g. parent => x.A.B
        var parent = this;
        for ( var i = 0; i < keys.length - 1; i++ ) { // for all but the last key
          assert && assert( !!parent[ keys[ i ] ],
            [ this.name ].concat( keys.slice( 0, i + 1 ) ).join( '.' ) + ' needs to be defined to register ' + key );

          parent = parent[ keys[ i ] ];
        }

        // Write into the inner namespace, e.g. x.A.B[ 'C' ] = C
        var lastKey = keys[ keys.length - 1 ];
        assert && assert( !parent[ lastKey ], key + ' is already registered for namespace ' + this.name );
        parent[ lastKey ] = value;
      }

      return value;
    }
  };

  return Namespace;
} );

// Copyright 2013-2015, University of Colorado Boulder

define( 'PHET_CORE/phetCore',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );

  // no phetAllocation initialized, since we don't need it with just phet-core, and this file is required before that

  var phetCore = new Namespace( 'phetCore' );

  // Namespace can't require this file, so we register it as a special case.
  phetCore.register( 'Namespace', Namespace );

  return phetCore;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Like Underscore's _.extend, but with hardcoded support for ES5 getters/setters.
 *
 * See https://github.com/documentcloud/underscore/pull/986.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/extend',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function extend( obj ) {
    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
      if ( source ) {
        for ( var prop in source ) {
          Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
        }
      }
    } );
    return obj;
  }

  phetCore.register( 'extend', extend );

  return extend;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Object instance allocation tracking, so we can cut down on garbage collection.
 *
 * Sample usage:
 * 1. Run the sim and set up the scenario that you wish to profile
 * 2. In the JS console, type: window.alloc={}
 * 3. Wait until you have taken enough data
 * 4. Type x = window.alloc; delete window.alloc;
 *
 * Now you can inspect the x variable which contains the allocation information.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/phetAllocation',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function phetAllocation( name ) {
    if ( window.alloc ) {
      var stack;
      try { throw new Error(); }
      catch( e ) { stack = e.stack; }

      if ( !window.alloc[ name ] ) {
        window.alloc[ name ] = { count: 0, stacks: {} };
      }
      var log = window.alloc[ name ];

      log.count++;
      if ( !log.stacks[ stack ] ) {
        log.stacks[ stack ] = 1;
      }
      else {
        log.stacks[ stack ] += 1;
      }
      log.report = function() {
        var stacks = Object.keys( log.stacks );
        stacks = _.sortBy( stacks, function( key ) { return log.stacks[ key ]; } );
        _.each( stacks, function( stack ) {
          console.log( log.stacks[ stack ] + ': ' + stack );
        } );
      };
    }
  }

  phetCore.register( 'phetAllocation', phetAllocation );

  return phetAllocation;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * The main 'scenery' namespace object for the exported (non-Require.js) API. Used internally
 * since it prevents Require.js issues with circular dependencies.
 *
 * The returned scenery object namespace may be incomplete if not all modules are listed as
 * dependencies. Please use the 'main' module for that purpose if all of Scenery is desired.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/scenery',['require','PHET_CORE/Namespace','PHET_CORE/extend','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );
  var extend = require( 'PHET_CORE/extend' );

  // @public (scenery-internal)
  window.sceneryLog = null;
  window.sceneryAccessibilityLog = null;

  // Initialize object allocation tracking, if it hasn't been already.
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );

  var scratchCanvas = document.createElement( 'canvas' );
  var scratchContext = scratchCanvas.getContext( '2d' );

  var logPadding = '';

  var scenery = new Namespace( 'scenery' );

  // @public - A Canvas and 2D Canvas context used for convenience functions (think of it as having arbitrary state).
  scenery.register( 'scratchCanvas', scratchCanvas );
  scenery.register( 'scratchContext', scratchContext );

  // @public - SVG namespace, used for document.createElementNS( scenery.svgns, name );
  scenery.register( 'svgns', 'http://www.w3.org/2000/svg' );

  // @public - X-link namespace, used for SVG image URLs (xlink:href)
  scenery.register( 'xlinkns', 'http://www.w3.org/1999/xlink' );

  /*---------------------------------------------------------------------------*
   * Logging
   * TODO: Move this out of scenery.js if possible
   *---------------------------------------------------------------------------*/

  // @private - Scenery internal log function to be used to log to scenery.logString (does not include color/css)
  function stringLogFunction( message ) {
    scenery.logString += message.replace( /%c/g, '' ) + '\n';
  }

  // @private - Scenery internal log function to be used to log to the console.
  function consoleLogFunction() {
    // allow for the console to not exist
    window.console && window.console.log && window.console.log.apply( window.console, Array.prototype.slice.call( arguments, 0 ) );
  }

  // @private - List of Scenery's loggers, with their display name and (if using console) the display style.
  var logProperties = {
    dirty: { name: 'dirty', style: 'color: #aaa;' },
    bounds: { name: 'bounds', style: 'color: #aaa;' },
    hitTest: { name: 'hitTest', style: 'color: #aaa;' },
    PerfCritical: { name: 'Perf', style: 'color: #f00;' },
    PerfMajor: { name: 'Perf', style: 'color: #aa0;' },
    PerfMinor: { name: 'Perf', style: 'color: #088;' },
    PerfVerbose: { name: 'Perf', style: 'color: #888;' },
    Cursor: { name: 'Cursor', style: 'color: #000;' },
    Stitch: { name: 'Stitch', style: 'color: #000;' },
    StitchDrawables: { name: 'Stitch', style: 'color: #000;' },
    GreedyStitcher: { name: 'Greedy', style: 'color: #088;' },
    GreedyVerbose: { name: 'Greedy', style: 'color: #888;' },
    RelativeTransform: { name: 'RelativeTransform', style: 'color: #606;' },
    BackboneDrawable: { name: 'Backbone', style: 'color: #a00;' },
    CanvasBlock: { name: 'Canvas', style: 'color: #000;' },
    WebGLBlock: { name: 'WebGL', style: 'color: #000;' },
    Display: { name: 'Display', style: 'color: #000;' },
    DOMBlock: { name: 'DOM', style: 'color: #000;' },
    Drawable: { name: '', style: 'color: #000;' },
    FittedBlock: { name: 'FittedBlock', style: 'color: #000;' },
    Input: { name: 'Input', style: 'color: #000;' },
    InputEvent: { name: 'InputEvent', style: 'color: #000;' },
    Instance: { name: 'Instance', style: 'color: #000;' },
    InstanceTree: { name: 'InstanceTree', style: 'color: #000;' },
    ChangeInterval: { name: 'ChangeInterval', style: 'color: #0a0;' },
    SVGBlock: { name: 'SVG', style: 'color: #000;' },
    SVGGroup: { name: 'SVGGroup', style: 'color: #000;' },
    ImageSVGDrawable: { name: 'ImageSVGDrawable', style: 'color: #000;' },
    Paints: { name: 'Paints', style: 'color: #000;' },
    Accessibility: { name: 'Accessibility', style: 'color: #000;' },
    AccessibleInstance: { name: 'AccessibleInstance', style: 'color: #000;' }
  };

  // will be filled in by other modules
  extend( scenery, {
    // @public - Scenery log string (accumulated if switchLogToString() is used).
    logString: '',

    // @private - Scenery internal log function (switchable implementation, the main reference)
    logFunction: function() {
      // allow for the console to not exist
      window.console && window.console.log && window.console.log.apply( window.console, Array.prototype.slice.call( arguments, 0 ) );
    },

    // @public - Switches Scenery's logging to print to the developer console.
    switchLogToConsole: function() {
      scenery.logFunction = consoleLogFunction;
    },

    // @public - Switches Scenery's logging to append to scenery.logString
    switchLogToString: function() {
      window.console && window.console.log( 'switching to string log' );
      scenery.logFunction = stringLogFunction;
    },

    // @public - Enables a specific single logger, OR a composite logger ('stitch'/'perf')
    enableIndividualLog: function( name ) {
      if ( name === 'stitch' ) {
        this.enableIndividualLog( 'Stitch' );
        this.enableIndividualLog( 'StitchDrawables' );
        this.enableIndividualLog( 'GreedyStitcher' );
        this.enableIndividualLog( 'GreedyVerbose' );
        return;
      }

      if ( name === 'perf' ) {
        this.enableIndividualLog( 'PerfCritical' );
        this.enableIndividualLog( 'PerfMajor' );
        this.enableIndividualLog( 'PerfMinor' );
        this.enableIndividualLog( 'PerfVerbose' );
        return;
      }

      if ( name ) {
        assert && assert( logProperties[ name ],
          'Unknown logger: ' + name + ', please use periods (.) to separate different log names' );

        window.sceneryLog[ name ] = window.sceneryLog[ name ] || function( ob, styleOverride ) {
            var data = logProperties[ name ];

            var prefix = data.name ? '[' + data.name + '] ' : '';
            var padStyle = 'color: #ddd;';
            scenery.logFunction( '%c' + logPadding + '%c' + prefix + ob, padStyle, styleOverride ? styleOverride : data.style );
          };
      }
    },

    // @public - Disables a specific log. TODO: handle stitch and perf composite loggers
    disableIndividualLog: function( name ) {
      if ( name ) {
        delete window.sceneryLog[ name ];
      }
    },

    /**
     * Enables multiple loggers.
     * @public
     *
     * @param {Array.<string>} logNames - keys from logProperties
     */
    enableLogging: function( logNames ) {
      if ( !logNames ) {
        logNames = [ 'stitch' ];
      }

      window.sceneryLog = function( ob ) { scenery.logFunction( ob ); };

      window.sceneryLog.push = function() {
        logPadding += '| ';
      };
      window.sceneryLog.pop = function() {
        logPadding = logPadding.slice( 0, -2 );
      };

      for ( var i = 0; i < logNames.length; i++ ) {
        this.enableIndividualLog( logNames[ i ] );
      }
    },

    // @public - Disables Scenery logging
    disableLogging: function() {
      window.sceneryLog = null;
    },

    // @public (scenery-internal) - Whether performance logging is active (may actually reduce performance)
    isLoggingPerformance: function() {
      return window.sceneryLog.PerfCritical || window.sceneryLog.PerfMajor ||
             window.sceneryLog.PerfMinor || window.sceneryLog.PerfVerbose;
    }
  } );

  return scenery;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Utility function for setting up prototypal inheritance.
 * Maintains supertype.prototype.constructor while properly copying ES5 getters and setters.
 * Supports adding functions to both the prototype itself and the constructor function.
 *
 * Usage:
 *
 * // Call the supertype constructor somewhere in the subtype's constructor.
 * function A() { scenery.Node.call( this ); };
 *
 * // Add prototype functions and/or 'static' functions
 * return inherit( scenery.Node, A, {
 *   customBehavior: function() { ... },
 *   isAnA: true
 * }, {
 *   someStaticFunction: function() { ...}
 * } );
 *
 * // client calls
 * new A().isAnA; // true
 * new scenery.Node().isAnA; // undefined
 * new A().constructor.name; // 'A'
 * A.someStaticFunction();
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'PHET_CORE/inherit',['require','PHET_CORE/phetCore','PHET_CORE/extend'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );
  var extend = require( 'PHET_CORE/extend' );

  /**
   * @param supertype           Constructor for the supertype.
   * @param subtype             Constructor for the subtype. Generally should contain supertype.call( this, ... )
   * @param prototypeProperties [optional] object containing properties that will be set on the prototype.
   * @param staticProperties [optional] object containing properties that will be set on the constructor function itself
   */
  function inherit( supertype, subtype, prototypeProperties, staticProperties ) {
    assert && assert( typeof supertype === 'function' );

    function F() {}

    F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype

    subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy
      new F(),                  // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely
      { constructor: subtype }, // overrides the constructor properly
      prototypeProperties       // [optional] additional properties for the prototype, as an object.
    );

    //Copy the static properties onto the subtype constructor so they can be accessed 'statically'
    extend( subtype, staticProperties );

    return subtype; // pass back the subtype so it can be returned immediately as a module export
  }

  phetCore.register( 'inherit', inherit );

  return inherit;
} );
// Copyright 2015, University of Colorado Boulder

/**
 * Object pooling mix-in, for cases where creating new objects is expensive, and we'd rather mark some objects as able
 * to be reused (i.e. 'in the pool'). This provides a pool of objects for each type it is invoked on. It allows for
 * getting "new" objects that can either be constructed OR pulled in from a pool, and requires that the objects are
 * essentially able to "re-run" the constructor.
 *
 * This is usually done by having an initialize() method on the objects with the same call signature as the constructor,
 * and the constructor basically forwards to initialize(). Thus most "construction" logic is in the initialize() call.
 * Then when putting the object back in the pool, references should be released, so memory isn't leaked. The initialize()
 * function needs to support being called multiple times, and generally shouldn't create additional objects on calls
 * after the first.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/Poolable',['require','PHET_CORE/phetCore','PHET_CORE/extend'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );
  var extend = require( 'PHET_CORE/extend' );

  var Poolable = {
    /**
     * Adds the pool and some static methods to the type, and adds the instance method freeToPool() to the type's
     * prototype.
     * @public
     *
     * Options available:
     * - maxPoolSize {number} - Maximum number of items that can be allowed in the pool
     * - initialSize {number} - If non-zero, that many fresh items will be constructed if there is a defaultFactory
     * - defaultFactory {function() => Type} - Factory function with no parameters that creates an instance of the type.
     *     Allows Type.dirtyFromPool() and Type.fillPool()
     * - constructorDuplicateFactory { function( pool ) => function( ... ) => Type}
     *     Creates a factory function that takes the same parameters as the type's constructors. Allows
     *     Type.createFromPool( ... )
     *
     * @param {function} type - The constructor for the type
     * @param {Object} [options] -
     */
    mixin: function( type, options ) {
      var proto = type.prototype;

      // defaults
      options = extend( {
        maxPoolSize: 50, // since we don't want to blow too much memory
        initialSize: 0
      }, options );

      var pool = type.pool = [];

      /*
       * For example: defaultFactory: function() { return new Vector2(); }
       */
      if ( options.defaultFactory ) {
        // @public
        type.dirtyFromPool = function() {
          if ( pool.length ) {
            // return an instance in an arbitrary (dirty) state
            return pool.pop();
          }
          else {
            // else return a new default instance
            return options.defaultFactory();
          }
        };

        // @public - fills the object pool up to n instances
        type.fillPool = function( n ) {
          // fill up the object pool to the initial size
          while ( pool.length < n ) {
            pool.push( options.defaultFactory() );
          }
        };

        // fill the pool initially to the initial size
        type.fillPool( options.initialSize );
      }

      /*
       * For example: constructorDuplicateFactory:
       *                function( pool ) {
       *                  return function( x, y ) {
       *                    if ( pool.length ) {
       *                      return pool.pop().set( x, y );
       *                    } else {
       *                      return new Vector2( x, y );
       *                    }
       *                  }
       *                }
       * It allows arbitrary creation (from the constructor / etc) or mutation (from the pooled instance).
       */
      if ( options.constructorDuplicateFactory ) {
        // @public
        type.createFromPool = options.constructorDuplicateFactory( pool );
      }

      /*
       * @public
       * Frees the object to the pool (instance.freeToPool())
       */
      proto.freeToPool = function() {
        if ( pool.length < options.maxPoolSize ) {
          pool.push( this );
        }
      };
    }
  };
  phetCore.register( 'Poolable', Poolable );

  return Poolable;
} );
// Copyright 2013-2015, University of Colorado Boulder

define( 'AXON/axon',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'axon' );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * If given an Array, removes all of its elements and returns it. Otherwise, if given a falsy value
 * (null/undefined/etc.), it will create and return a fresh Array.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/cleanArray',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function cleanArray( arr ) {
    assert && assert( !arr || ( arr instanceof Array ), 'cleanArray either takes an Array' );

    if ( arr ) {
      // fastest way to clear an array (http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript, http://jsperf.com/array-destroy/32)
      // also, better than length=0, since it doesn't create significant garbage collection (like length=0), tested on Chrome 34.
      while ( arr.length ) {
        arr.pop();
      }
      return arr;
    }
    else {
      return [];
    }
  }

  phetCore.register( 'cleanArray', cleanArray );

  return cleanArray;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Lightweight event & listener abstraction.
 * @author Sam Reid
 */
define( 'AXON/Events',['require','AXON/axon','PHET_CORE/cleanArray'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );

  /**
   * @class Events
   * @constructor
   */
  function Events( options ) {

    this._eventListeners = {}; // @private
    this._staticEventListeners = {}; // @private

    options && options.tandem && options.tandem.addInstance( this );
    this.disposeEvents = function() {
      options && options.tandem && options.tandem.removeInstance( this );
    };
  }

  axon.register( 'Events', Events );

  Events.prototype = {

    // @public
    dispose: function() {
      this.disposeEvents();
    },

    /////////////////////////////////////////////
    // Below this point are the functions for event handling, basically orthogonal to property value change notifications

    /**
     * Register a listener when the specified eventName is triggered. Use off() to remove.
     * Concurrent modification of listeners (on/off) from within the callback is acceptable.
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @public
     */
    on: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      this._eventListeners[ eventName ] = this._eventListeners[ eventName ] || [];
      this._eventListeners[ eventName ].push( callback );
    },

    /**
     * Register a listener when the specified eventName is triggered. Listener should be "static", meaning:
     *   1. It shall not add/remove any "static" listeners (including itself) while it is being called (as any type of side-effect), and
     *   2. "static" listeners should not be added while a non-static listener (on the same object) is being called.
     * These restrictions allow us to guarantee that all listeners attached when an event is triggered are called.
     * Since static listeners are stored separately, use offStatic() to remove listeners added with onStatic()
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @public
     */
    onStatic: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      this._staticEventListeners[ eventName ] = this._staticEventListeners[ eventName ] || [];
      this._staticEventListeners[ eventName ].push( callback );
    },

    /**
     * Adds a function which will only be called back once, after which it is removed as a listener.
     * If you need to remove a function added with 'once' you will have to remove its handle, which is returned by the function.
     * @param {string} eventName the name for the event channel
     * @param {function} callback function to be called back once (if at all)
     * @public
     */
    once: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var events = this;
      var wrappedCallback = function() {
        events.off( eventName, wrappedCallback );

        //If no arguments being passed through, call back without processing arguments, for possible speed
        if ( arguments.length === 0 ) {
          callback();
        }
        else {

          //General case of passing events through to the wrapped callback function
          callback.apply( this, Array.prototype.slice.call( arguments, 0 ) );
        }
      };
      this.on( eventName, wrappedCallback );

      //Return the handle in case it needs to be removed.
      return wrappedCallback;
    },

    /**
     * Remove a listener added with on() from the specified event type.  Does nothing if the listener did not exist.
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @public
     */
    off: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var index = -1;
      if ( this._eventListeners[ eventName ] ) {
        index = this._eventListeners[ eventName ].indexOf( callback );
        if ( index !== -1 ) {
          this._eventListeners[ eventName ].splice( index, 1 );
        }
      }

      return index; // so we can tell if we actually removed a listener
    },

    /**
     * Remove a listener added with onStatic() from the specified event type.  Does nothing if the listener did not exist.
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @public
     */
    offStatic: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var index = -1;
      if ( this._staticEventListeners[ eventName ] ) {
        index = this._staticEventListeners[ eventName ].indexOf( callback );
        if ( index !== -1 ) {
          this._staticEventListeners[ eventName ].splice( index, 1 );
        }
      }

      return index; // so we can tell if we actually removed a listener
    },

    /**
     * Checks for the existence of a specific listener, attached to a specific event name. Doesn't check for static listeners
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @returns {boolean}
     * @public
     */
    hasListener: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var array = this._eventListeners[ eventName ];
      return !!array && array.indexOf( callback ) >= 0;
    },

    /**
     * Checks for the existence of a specific static listener, attached to a specific event name. Doesn't check for non-static listeners
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @returns {boolean}
     * @public
     */
    hasStaticListener: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var array = this._staticEventListeners[ eventName ];
      return !!array && array.indexOf( callback ) >= 0;
    },

    /**
     * Removes all listeners added with on() and onStatic().
     * @public
     */
    removeAllEventListeners: function() {
      var eventName;
      for ( eventName in this._eventListeners ) {
        cleanArray( this._eventListeners[ eventName ] );
      }
      for ( eventName in this._staticEventListeners ) {
        cleanArray( this._staticEventListeners[ eventName ] );
      }
    },

    /**
     * Trigger an event with the specified name and arguments.
     * @param {string} eventName the name for the event channel
     * @param args... optional arguments to pass to the listeners
     * @public
     */
    trigger: function( eventName ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );

      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];

      // listener quantities for normal and static
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;

      // only compute our arguments suffix once, instead of in our inner loop
      var suffix;
      var hasNoArguments = arguments.length === 1;
      if ( !hasNoArguments && ( count > 0 || staticCount > 0 ) ) {
        phetAllocation && phetAllocation( 'Array' );
        suffix = Array.prototype.slice.call( arguments, 1 );
      }

      // make a copy of non-static listeners, in case callback removes listener
      if ( count > 0 ) {
        listeners = listeners.slice();
      }

      var i;

      for ( i = 0; i < count; i++ ) {
        var listener = listeners[ i ];

        //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)
        if ( hasNoArguments ) {
          listener();
        }
        else {
          listener.apply( this, suffix );
        }

        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }

      for ( i = 0; i < staticCount; i++ ) {
        var staticListener = staticListeners[ i ];

        //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)
        if ( hasNoArguments ) {
          staticListener( arguments );
        }
        else {
          staticListener.apply( this, suffix );
        }

        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },

    /**
     * Trigger an event with the specified name, with no arguments.  Since the number of arguments is known
     * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).
     * @param {string} eventName the name for the event channel
     * @public
     */
    trigger0: function( eventName ) {
      assert && assert( arguments.length === 1 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );

      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];

      // listener quantities for normal and static
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;

      // make a copy of non-static listeners, in case callback removes listener
      if ( count > 0 ) {
        listeners = listeners.slice();
      }

      var i;

      for ( i = 0; i < count; i++ ) {
        listeners[ i ]();

        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }

      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]();

        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },

    /**
     * Trigger an event with the specified name, with a single argument.  Since the number of arguments is known
     * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).
     * @param {string} eventName the name for the event channel
     * @param {Object} param1 - the argument to pass through to the listeners
     * @public
     */
    trigger1: function( eventName, param1 ) {
      assert && assert( arguments.length === 2 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );

      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];

      // listener quantities for normal and static
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;

      // make a copy of non-static listeners, in case callback removes listener
      if ( count > 0 ) {
        listeners = listeners.slice();
      }

      var i;

      for ( i = 0; i < count; i++ ) {
        listeners[ i ]( param1 );

        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }

      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]( param1 );

        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },

    /**
     * Trigger an event with the specified name, with two arguments.  Since the number of arguments is known
     * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).
     * @param {string} eventName the name for the event channel
     * @param {Object} param1 - the first parameter
     * @param {Object} param2 - the second parameter
     * @public
     */
    trigger2: function( eventName, param1, param2 ) {
      assert && assert( arguments.length === 3 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );

      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];

      // listener quantities for normal and static
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;

      // make a copy of non-static listeners, in case callback removes listener
      if ( count > 0 ) {
        listeners = listeners.slice();
      }

      var i;

      for ( i = 0; i < count; i++ ) {
        listeners[ i ]( param1, param2 );

        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }

      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]( param1, param2 );

        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    }
  };

  return Events;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * An instance that is synchronously created, for handling accessibility needs.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/accessibility/AccessibleInstance',['require','PHET_CORE/inherit','PHET_CORE/Poolable','AXON/Events','SCENERY/scenery','PHET_CORE/cleanArray'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  // var AccessiblePeer = require( 'SCENERY/accessibility/AccessiblePeer' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );

  var globalId = 1;

  function AccessibleInstance( parent, display, trail ) {
    this.initializeAccessibleInstance( parent, display, trail );
  }

  scenery.register( 'AccessibleInstance', AccessibleInstance );

  inherit( Events, AccessibleInstance, {
    /**
     * @param {AccessibleInstance|null} parent
     * @param {Display} display
     * @param {DOMElement} [domElement] - If not included here, subtype is responsible for setting it in the constructor.
     */
    initializeAccessibleInstance: function( parent, display, trail ) {
      Events.call( this ); // TODO: is Events worth mixing in by default? Will we need to listen to events?

      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );

      // unique ID
      this.id = this.id || globalId++;

      this.parent = parent;
      this.display = display;
      this.trail = trail;
      this.node = trail.lastNode();
      this.isRootInstance = this.trail.length === 0;

      this.children = cleanArray( this.children );

      // If we are the root accessible instance, we won't actually have a reference to a node.
      if ( this.node ) {
        this.node.addAccessibleInstance( this );
      }

      this.isSorted = true;

      if ( this.isRootInstance ) {
        var accessibilityContainer = document.createElement( 'div' );
        accessibilityContainer.className = 'accessibility';
        accessibilityContainer.style.position = 'absolute';
        accessibilityContainer.style.left = '0';
        accessibilityContainer.style.top = '0';
        accessibilityContainer.style.width = '0';
        accessibilityContainer.style.height = '0';
        accessibilityContainer.style.clip = 'rect(0,0,0,0)';
        accessibilityContainer.style.pointerEvents = 'none';
        this.peer = new scenery.AccessiblePeer( this, accessibilityContainer );
      }
      else {
        this.peer = this.node.accessibleContent.createPeer( this );
        var childContainerElement = this.parent.peer.getChildContainerElement();
        childContainerElement.insertBefore( this.peer.domElement, childContainerElement.childNodes[ 0 ] );
      }

      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Initialized ' + this.toString() );

      return this;
    },

    /**
     * Consider the following example:
     *
     * We have a node structure:
     * A
     *  B ( accessible )
     *    C (accessible )
     *      D
     *        E (accessible)
     *         G (accessible)
     *        F
     *          H (accessible)
     *
     *
     * Which has an equivalent accessible instance tree:
     * root
     *  AB
     *    ABC
     *      ABCDE
     *        ABCDEG
     *      ABCDFH
     *
     * Produces the call tree for adding instances to the accessible instance tree:
     * ABC.addSubtree( ABCD ) - not accessible
     *     ABC.addSubtree( ABCDE)
     *       ABCDE.addSubtree( ABCDEG )
     *     ABC.addSubtree( ABCDF )
     *       ABC.addSubtree( ABCDFH )
     */
    addSubtree: function( trail ) {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'addSubtree on ' + this.toString() + ' with trail ' + trail.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();

      var node = trail.lastNode();
      var nextInstance = this;
      if ( node.accessibleContent ) {
        var accessibleInstance = AccessibleInstance.createFromPool( this, this.display, trail.copy() ); // TODO: Pooling
        sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
          'Insert parent: ' + this.toString() + ', (new) child: ' + accessibleInstance.toString() );
        this.children.push( accessibleInstance ); // TODO: Mark us as dirty for performance.
        this.markAsUnsorted();

        nextInstance = accessibleInstance;
      }
      var children = node._children;
      for ( var i = 0; i < children.length; i++ ) {
        trail.addDescendant( children[ i ], i );
        nextInstance.addSubtree( trail );
        trail.removeDescendant();
      }

      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },

    removeSubtree: function( trail ) {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'removeSubtree on ' + this.toString() + ' with trail ' + trail.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();

      for ( var i = this.children.length - 1; i >= 0; i-- ) {
        var childInstance = this.children[ i ];
        if ( childInstance.trail.isExtensionOf( trail, true ) ) {
          sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
            'Remove parent: ' + this.toString() + ', child: ' + childInstance.toString() );
          this.children.splice( i, 1 ); // remove it from the children array

          // Dispose the entire subtree of AccessibleInstances
          childInstance.dispose();
        }
      }

      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },

    markAsUnsorted: function() {
      if ( this.isSorted ) {
        this.isSorted = false;
        this.display.markUnsortedAccessibleInstance( this );
      }
    },

    /**
     * Sort our children accessible instances in the order they should appear in the parallel DOM. We do this by
     * creating a comparison function between two accessible instances, and sorting the array with that.
     */
    sortChildren: function() {
      assert && assert( !this.isSorted, 'No need to sort children if it is already marked as sorted' );
      this.isSorted = true;

      var parentInstance = this;

      // Reindex trails in preparation for sorting
      for ( var m = 0; m < this.children.length; m++ ) {
        this.children[ m ].trail.reindex();
      }

      this.children.sort( function( a, b ) {
        // Sort between a {AccessibleInstance} and b {AccessibleInstance}. This is a process where we start at our
        // "parent" accessible instance's location in the trail, and walk down looking for accessible orders that may
        // determine the order between these two instances.
        // This allows ancestor orders (for instance, an order on this instance) to override descendant orders.
        var aNodes = a.trail.nodes;
        var bNodes = b.trail.nodes;

        // Starting at the Node for this accessible instance, and walking down until the trails diverge. If our loop
        // here reaches a place where they diverge, we can use document order to determine which comes first (since
        // that means we didn't hit any relevant accessible orders). If our parentInstance is the root instance, its
        // trail will have length 0 (nothing shared), so our starting index should be set to 0.
        for ( var i = Math.max( 0, parentInstance.trail.length - 1 ); aNodes[ i ] === bNodes[ i ]; i++ ) {
          var currentNode = aNodes[ i ];
          var order = currentNode.accessibleOrder;

          // If there is no order specified on this node, we want to continue to the next children in the trails.
          if ( !order ) {
            continue;
          }

          // Loop through items in the order, since the first elements in the order are the most significant.
          for ( var j = 0; j < order.length; j++ ) {
            var orderedNode = order[ j ];
            // Find where (if at all) our Node in the order is present in the trails.
            var aIndex = aNodes.indexOf( orderedNode );
            var bIndex = bNodes.indexOf( orderedNode );

            // If the ordered node is present in both trails, we need to first determine whether the trail to those
            // nodes is the same. If they are the same, we will jump ahead to that ordered node (deliberately skipping
            // any orders on nodes in-between), and continuing on from there. If they are different, the document order
            // between the two trails to the ordered node will determine which of our instances comes first.
            if ( aIndex >= 0 && bIndex >= 0 ) {
              // Determine the index at where our two trails diverge.
              var branchIndex = i + 1;
              while ( aNodes[ branchIndex ] === bNodes[ branchIndex ] ) {
                branchIndex++;
              }

              // If the index of our ordered node in one of the trails is before our branch index, it means the trails
              // to the ordered node are the same. We want to jump ahead to the ordered node's location and continue
              // with our outer for loop.
              if ( aIndex < branchIndex ) {
                // We want the next iteration of the outer for loop to start at the index of the ordered node. Since i
                // will be incremented before the next loop begins, we subtract 1 here.
                i = aIndex - 1;

                // Exit the inner for loop
                break;
              }
              // The trails to the ordered node are different. We use the document order between the two trails to
              // determine which instance is first. This can be done by inspecting just the difference at the branch
              // index.
              else {
                // Since branchIndex is the index in the trail of two different children, we want to compare the indices
                // for the parent node of the branch nodes, thus we need to subtract 1 from our branch index.
                var aChildIndex = a.trail.indices[ branchIndex - 1 ];
                var bChildIndex = b.trail.indices[ branchIndex - 1 ];
                if ( aChildIndex < bChildIndex ) {
                  return -1;
                }
                else if ( aChildIndex > bChildIndex ) {
                  return 1;
                }
                else {
                  throw new Error( 'Two different children have the same child index' );
                }
              }
            }
            // If only the first trail is under an ordered node, it is first
            else if ( aIndex >= 0 ) {
              return -1;
            }
            // If only the second trail is under an ordered node, it is first
            else if ( bIndex >= 0 ) {
              return 1;
            }
          }
        }

        // If we reach here and haven't returned, it should be a document order comparison AND the index i determines
        // the current index where the nodes are different (branch index).
        // Since i is the index in the trail of two different children, we want to compare the indices
        // for the parent node of the branch nodes, thus we need to subtract 1 from our branch index.
        var aEndChildIndex = a.trail.indices[ i - 1 ];
        var bEndChildIndex = b.trail.indices[ i - 1 ];
        if ( aEndChildIndex < bEndChildIndex ) {
          return -1;
        }
        else if ( aEndChildIndex > bEndChildIndex ) {
          return 1;
        }
        else {
          throw new Error( 'Two different children have the same child index' );
        }
      } );

      var containerElement = this.peer.getChildContainerElement();
      for ( var n = this.children.length - 1; n >= 0; n-- ) {
        var peerDOMElement = this.children[ n ].peer.domElement;

        if ( peerDOMElement === containerElement.childNodes[ n ] ) {
          continue;
        }
        containerElement.insertBefore( peerDOMElement, containerElement.childNodes[ n + 1 ] );
      }
    },

    // Recursive disposal
    dispose: function() {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Disposing ' + this.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();

      // Disconnect DOM
      if ( !this.isRootInstance ) {
        this.parent.peer.getChildContainerElement().removeChild( this.peer.domElement );
      }

      while ( this.children.length ) {
        this.children.pop().dispose();
      }

      // If we are the root accessible instance, we won't actually have a reference to a node.
      if ( this.node ) {
        this.node.removeAccessibleInstance( this );
      }

      this.display = null;
      this.trail = null;
      this.node = null;
      this.peer = null;
      this.disposed = true;

      this.freeToPool();

      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },

    toString: function() {
      return this.id + '#{' + this.trail.toString() + '}';
    },

    auditRoot: function() {
      assert && assert( this.trail.length === 0,
        'Should only call auditRoot() on the root AccessibleInstance for a display' );

      function audit( nestedOrderArray, accessibleInstance ) {
        assert && assert( nestedOrderArray.length === accessibleInstance.children.length,
          'Different number of children in accessible instance' );

        _.each( nestedOrderArray, function( nestedChild ) {
          var instance = _.find( accessibleInstance.children, function( childInstance ) {
            return childInstance.trail.equals( nestedChild.trail );
          } );
          assert && assert( instance, 'Missing child accessible instance' );

          audit( nestedChild.children, instance );
        } );

        // Exact Order checks
        for ( var i = 0; i < nestedOrderArray.length; i++ ) {
          assert && assert( nestedOrderArray[ i ].trail.lastNode() === accessibleInstance.children[ i ].node,
            'Accessible order mismatch' );
        }
      }

      audit( this.display.rootNode.getNestedAccessibleOrder(), this );
    }
  } );

  Poolable.mixin( AccessibleInstance, {
    constructorDuplicateFactory: function( pool ) {
      return function( parent, display, trail ) {
        if ( pool.length ) {
          return pool.pop().initializeAccessibleInstance( parent, display, trail );
        }
        else {
          return new AccessibleInstance( parent, display, trail );
        }
      };
    }
  } );

  return AccessibleInstance;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Lightweight event & listener abstraction for a single event type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'AXON/Emitter',['require','PHET_CORE/inherit','AXON/axon'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var axon = require( 'AXON/axon' );

  /**
   *
   * @constructor
   */
  function Emitter() {
    this.listeners = [];

    // @private - during emit() keep track of which listeners should receive events
    //            in order to manage removal of listeners during emit()
    this.listenersToEmitTo = [];
  }

  axon.register( 'Emitter', Emitter );

  return inherit( Object, Emitter, {

    /**
     * Adds a listener
     * @param {function} listener
     * @public
     */
    addListener: function( listener ) {

      // If callbacks are in progress, make a copy of the current list of listeners--the newly added listener
      // will be available for the next emit() but not the one in progress.  This is to match behavior with removeListener
      this.defendCallbacks();

      this.listeners.push( listener );
    },

    /**
     * Removes a listener
     * @param {function} listener
     * @public
     */
    removeListener: function( listener ) {

      var index = this.listeners.indexOf( listener );
      assert && assert( index >= 0, 'tried to removeListener on something that wasnt a listener' );

      // If callbacks are in progress, make a copy of the current list of listeners--the removed listener
      // will remain in the list and receive a callback for this emit call, see #72
      this.defendCallbacks();

      this.listeners.splice( index, 1 );
    },

    /**
     * Removes all the listeners
     * @public
     */
    removeAllListeners: function() {
      while ( this.listeners.length > 0 ) {
        this.removeListener( this.listeners[ 0 ] );
      }
    },

    /**
     * If processing callbacks during an emit() call and addListener/removeListener() is called,
     * make a defensive copy of the array of listener before changing the array, and use it for
     * the rest of the callbacks until the emit call has completed.
     * @private
     */
    defendCallbacks: function() {

      for ( var i = this.listenersToEmitTo.length - 1; i >= 0; i-- ) {

        // Once we meet a level that was already defended, we can stop, since all previous levels are also defended
        if ( this.listenersToEmitTo[ i ].defended ) {
          break;
        }
        else {
          var defendedListeners = this.listeners.slice();

          // Mark copies as 'defended' so that it will use the original listeners when emit started and not the modified list.
          defendedListeners.defended = true;
          this.listenersToEmitTo[ i ] = defendedListeners;
        }
      }
    },

    /**
     * Emits a single event.
     * This method is called many times in a simulation and must be well-optimized.
     * @public
     */
    emit: function() {
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;

      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]();
      }

      this.listenersToEmitTo.pop();
    },

    /**
     * Emits a single event with one argument.  This is a copy-paste of emit() for performance reasons.
     * @param {*} arg1
     * @public
     */
    emit1: function( arg1 ) {
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;

      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]( arg1 );
      }

      this.listenersToEmitTo.pop();
    },

    /**
     * Emits a single event with two arguments.  This is a copy-paste of emit() for performance reasons.
     * @param {*} arg1
     * @param {*} arg2
     * @public
     */
    emit2: function( arg1, arg2 ) {
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;

      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]( arg1, arg2 );
      }

      this.listenersToEmitTo.pop();
    },

    /**
     * Checks whether a listener is registered with this Emitter
     * @param {function} listener
     * @returns {boolean}
     * @public
     */
    hasListener: function( listener ) {
      assert && assert( arguments.length === 1, 'Emitter.hasListener should be called with 1 argument' );
      return this.listeners.indexOf( listener ) >= 0;
    },

    /**
     * Returns true if there are any listeners.
     * @returns {boolean}
     * @public
     */
    hasListeners: function() {
      assert && assert( arguments.length === 0, 'Emitter.hasListeners should be called without arguments' );
      return this.listeners.length > 0;
    }
  } );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * A Multilink is an instance that can be used to link to multiple properties.  It is very similar to a DerivedProperty,
 * but has no value and does not conform to the Property API because it is intended for use with callbacks that do not
 * compute a value.  Multilink should not be created through calling its constructor directly, but through the
 * Property.multilink and Property.lazyMultilink functions.
 *
 * @author Sam Reid
 */
define( 'AXON/Multilink',['require','AXON/axon','PHET_CORE/inherit'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );

  /**
   * @param {Property[]} dependencies
   * @param {function} callback function that expects args in the same order as dependencies
   * @param {boolean} [lazy] Optional parameter that can be set to true if this should be a lazy multilink (no immediate callback)
   * @constructor
   */
  function Multilink( dependencies, callback, lazy ) {

    this.dependencies = dependencies; // @private

    // @private Keep track of each dependency and only update the changed value, for speed
    this.dependencyValues = dependencies.map( function( property ) {return property.get();} );

    var multilink = this;

    // @private Keep track of listeners so they can be detached
    this.dependencyListeners = [];

    //When a dependency value changes, update the list of dependencies and call back to the callback
    for ( var i = 0; i < dependencies.length; i++ ) {
      var dependency = dependencies[ i ];
      (function( dependency, i ) {
        var listener = function( newValue ) {
          multilink.dependencyValues[ i ] = newValue;
          callback.apply( null, multilink.dependencyValues );
        };
        multilink.dependencyListeners.push( listener );
        dependency.lazyLink( listener );
      })( dependency, i );
    }

    //Send initial call back but only if we are non-lazy
    if ( !lazy ) {
      callback.apply( null, this.dependencyValues );
    }
  }

  axon.register( 'Multilink', Multilink );

  return inherit( Object, Multilink, {

    // @public
    dispose: function() {
      // Unlink from dependent properties
      for ( var i = 0; i < this.dependencies.length; i++ ) {
        var dependency = this.dependencies[ i ];
        dependency.unlink( this.dependencyListeners[ i ] );
      }
      this.dependencies = null;
      this.dependencyListeners = null;
      this.dependencyValues = null;
    }
  } );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * An observable property which notifies registered observers when the value changes.
 *
 * @author Sam Reid
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'AXON/Property',['require','AXON/axon','PHET_CORE/inherit','AXON/Events','AXON/Emitter','AXON/Multilink'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var Emitter = require( 'AXON/Emitter' );
  var Multilink = require( 'AXON/Multilink' );

  /**
   * @param {*} value - the initial value of the property
   * @param {Object} [options] - options
   * @constructor
   */
  function Property( value, options ) {

    var property = this;

    // Check duck type for incorrect Tandem argument
    if ( options && options.isTandem ) {
      assert && assert( false, 'Options should be an Object, not a Tandem' );
    }

    options = _.extend( { tandem: null }, options );

    // @private Internal Events for sending startedCallbacksForChanged & endedCallbacksForChanged
    this.events = new Events();

    // @private - Store the internal value and the initial value
    this._value = value;

    // @private - Initial value
    this._initialValue = value;

    // @private (unit-tests) - emit1 is called when the value changes (or on link)
    // Also used in ShapePlacementBoard.js at the moment
    this.changedEmitter = new Emitter();

    options.tandem && options.tandem.addInstance( this );

    // @private
    this.disposeProperty = function() {

      // Make sure there were no remaining observers.  If there are observers at disposal time, there may be a latent
      // memory leak, see #77
      assert && assert(
        property.changedEmitter.listeners.length === 0,
        'during disposal, expected 0 observers, actual = ' + property.changedEmitter.listeners.length
      );
      options.tandem && options.tandem.removeInstance( this );
    };
  }

  axon.register( 'Property', Property );

  return inherit( Object, Property, {

      /**
       * Gets the value.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.
       * @return {*}
       * @public
       */
      get: function() {
        return this._value;
      },

      /**
       * Sets the value and notifies registered observers.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.
       * If the value hasn't changed, this is a no-op.
       *
       * @param {*} value
       * @public
       */
      set: function( value ) {
        if ( !this.equalsValue( value ) ) {
          this._setAndNotifyObservers( value );
        }
        return this;
      },

      // @public returns true iff the specified value equals the value of this property
      equalsValue: function( value ) {
        return this.areValuesEqual( value, this._value );
      },

      /**
       * Determines equality semantics for the wrapped type, including whether notifications are sent out when the
       * wrapped value changes, and whether onValue is triggered.  A different implementation can be provided by
       * subclasses or instances to change the equals definition. See #10 and #73
       * @param {Object} a - should have the same type as Property element type
       * @param {Object} b - should have the same type as Property element type
       * @returns {boolean}
       * @public
       */
      areValuesEqual: function( a, b ) {
        return a === b;
      },

      // @public
      get initialValue() {
        return this._initialValue;
      },

      // @private
      _setAndNotifyObservers: function( value ) {
        var oldValue = this.get();
        this._value = value;
        this._notifyObservers( oldValue );
      },

      // @private
      _notifyObservers: function( oldValue ) {

        // Note the current value, since it will be sent to possibly multiple observers.
        var value = this.get();

        // TODO: Should Property extend or compose Events?  Would extending Events broaden its interface too much?
        this.events.trigger2( 'startedCallbacksForChanged', value, oldValue );

        this.changedEmitter.emit2( value, oldValue );

        this.events.trigger0( 'endedCallbacksForChanged' );
      },

      /**
       * Use this method when mutating a value (not replacing with a new instance) and you want to send notifications about the change.
       * This is different from the normal axon strategy, but may be necessary to prevent memory allocations.
       * This method is unsafe for removing observers because it assumes the observer list not modified, to save another allocation
       * Only provides the new reference as a callback (no oldvalue)
       * See https://github.com/phetsims/axon/issues/6
       * @public
       */
      notifyObserversStatic: function() {
        this.changedEmitter.emit1( this.get() );
      },

      /**
       * Resets the value to the initial value.
       * @public
       */
      reset: function() {
        this.set( this._initialValue );
      },

      // @public
      get value() { return this.get(); },

      // @public
      set value( newValue ) { this.set( newValue ); },

      /**
       * Adds an observer and notifies it immediately.
       * If observer is already registered, this is a no-op.
       * The initial notification provides the current value for newValue and null for oldValue.
       *
       * @param {function} observer a function of the form observer(newValue,oldValue)
       * @public
       */
      link: function( observer ) {
        if ( !this.changedEmitter.hasListener( observer ) ) {
          this.changedEmitter.addListener( observer );
          observer( this.get(), null ); // null should be used when an object is expected but unavailable
        }
      },

      /**
       * Add an observer to the Property, without calling it back right away.
       * This is used when you need to register a observer without an immediate callback.
       *
       * @param {function} observer - a function with a single argument, which is the value of the property at the time the function is called.
       * @public
       */
      lazyLink: function( observer ) {
        this.changedEmitter.addListener( observer );
      },

      /**
       * Removes an observer.
       * If observer is not registered, this is a no-op.
       *
       * @param {function} observer
       * @public
       */
      unlink: function( observer ) {
        if ( this.changedEmitter.hasListener( observer ) ) {
          this.changedEmitter.removeListener( observer );
        }
      },

      /**
       * Removes all observers.
       * If no observers are registered, this is a no-op.
       */
      unlinkAll: function() {
        this.changedEmitter.removeAllListeners();
      },

      /**
       * Links an object's named attribute to this property.  Returns a handle so it can be removed using Property.unlink();
       * Example: modelVisibleProperty.linkAttribute(view,'visible');
       *
       * @param object
       * @param attributeName
       * @public
       */
      linkAttribute: function( object, attributeName ) {
        var handle = function( value ) {object[ attributeName ] = value;};
        this.link( handle );
        return handle;
      },

      /**
       * Unlink an observer added with linkAttribute.  Note: the args of linkAttribute do not match the args of
       * unlinkAttribute: here, you must pass the observer handle returned by linkAttribute rather than object and attributeName
       *
       * @param observer
       * @public
       */
      unlinkAttribute: function( observer ) {
        this.unlink( observer );
      },

      // @public Provide toString for console debugging, see http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript
      toString: function() {return 'Property{' + this.get() + '}'; },

      // @public
      valueOf: function() {return this.toString();},

      /**
       * Add an observer so that it will only fire once (and not on registration)
       *
       * I can see two ways to implement this:
       * (a) add a field to the observer so after notifications it can be checked and possibly removed. Disadvantage: will make everything slower even if not using 'once'
       * (b) wrap the observer in a new function which will call the observer and then remove itself.  Disadvantage: cannot remove an observer added using 'once'
       * To avoid possible performance problems, use a wrapper function, and return it as a handle in case the 'once' observer must be removed before it is called once
       *
       * @param observer the observer which should be called back only for one property change (and not on registration)
       * @returns {function} the wrapper handle in case the wrapped function needs to be removed with 'unlink' before it is called once
       * @public
       */
      once: function( observer ) {
        var property = this;
        var wrapper = function( newValue, oldValue ) {
          property.unlink( wrapper );
          observer( newValue, oldValue );
        };
        this.lazyLink( wrapper );
        return wrapper;
      },

      /**
       * Convenience function for debugging a property values.  It prints the new value on registration and when changed.
       * @param name debug name to be printed on the console
       * @returns {function} the handle to the linked observer in case it needs to be removed later
       * @public
       */
      debug: function( name ) {
        var observer = function( value ) { console.log( name, value ); };
        this.link( observer );
        return observer;
      },

      /**
       * Returns a function that can be used to toggle the property (using !)
       * @returns {function}
       * @public
       */
      get toggleFunction() {
        return this.toggle.bind( this );
      },

      /**
       * Modifies the value of this Property with the ! operator.  Works for booleans and non-booleans.
       * @public
       */
      toggle: function() {
        this.value = !this.value;
      },

      /**
       * Adds an observer that is fired when the property takes the specified value.  If the property has the value already,
       * the observer is called back immediately.  A reference to the observer is returned so that it can be removed.
       *
       * @param value the value to match
       * @param observer the observer that is called when this Property
       * @public
       */
      onValue: function( value, observer ) {
        var property = this;
        var onValueObserver = function( v ) {
          if ( property.areValuesEqual( v, value ) ) {
            observer();
          }
        };
        this.link( onValueObserver );
        return onValueObserver;
      },

      // @public Ensures that the Property is eligible for GC
      dispose: function() {
        this.disposeProperty();
      },

      /**
       * Returns true if there are any listeners.
       * @returns {boolean}
       * @public
       */
      hasListeners: function() {
        assert && assert( arguments.length === 0, 'Property.hasListeners should be called without arguments' );
        return this.changedEmitter.hasListeners();
      }
    },

    //statics
    {

      /**
       * Registers an observer with multiple properties, then notifies the observer immediately.
       * @param {Property[]} properties
       * @param {function} observer no params, returns nothing
       * @static
       */
      multilink: function( properties, observer ) {
        return new Multilink( properties, observer, false );
      },

      lazyMultilink: function( properties, observer ) {
        return new Multilink( properties, observer, true );
      },

      /**
       * Removes the multilinked observer from this Property.
       * Same as calling dispose() on the handle (which happens to be a DerivedProperty instance)
       * @param {DerivedProperty} derivedProperty
       */
      unmultilink: function( derivedProperty ) {
        derivedProperty.dispose();
      },

      /**
       * Set up a PropertySet-like property on any object (see https://github.com/phetsims/axon/issues/42).
       *
       * @param {Object} object - The object that the property will be placed on
       * @param {string} propertyName - Name of the property
       * @param {*} initialValue - The initial value of the property
       */
      addProperty: function( object, propertyName, initialValue ) {
        // defines the property
        var property = object[ propertyName + 'Property' ] = new Property( initialValue );

        // defines ES5 getter/setter
        Object.defineProperty( object, propertyName, {
          get: function() { return property.get(); },
          set: function( value ) { property.set( value ); },

          // Make it configurable and enumerable so it's easy to override...
          configurable: true,
          enumerable: true
        } );
      }
    } );
} );

// Copyright 2013-2015, University of Colorado Boulder

define( 'DOT/dot',['require','PHET_CORE/Namespace','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );

  // object allocation tracking
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );

  var dot = new Namespace( 'dot' );

  dot.register( 'v2', function( x, y ) { return new dot.Vector2( x, y ); } );
  dot.register( 'v3', function( x, y, z ) { return new dot.Vector3( x, y, z ); } );
  dot.register( 'v4', function( x, y, z, w ) { return new dot.Vector4( x, y, z, w ); } );

  // TODO: performance: check browser speed to compare how fast this is. We may need to add a 32 option for GL ES.
  dot.register( 'FastArray', window.Float64Array ? window.Float64Array : window.Array );

  // will be filled in by other modules
  return dot;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Utility functions for Dot, placed into the dot.X namespace.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Util',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  // require( 'DOT/Vector2' ); // Require.js doesn't like the circular reference

  // constants
  var EPSILON = Number.MIN_VALUE;
  var TWO_PI = 2 * Math.PI;

  // "static" variables used in boxMullerTransform
  var generate;
  var z0;
  var z1;

  var Util = {
    /**
     * Returns the original value if it is inclusively within the [max,min] range. If it's below the range, min is
     * returned, and if it's above the range, max is returned.
     * @public
     *
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {number}
     */
    clamp: function( value, min, max ) {
      if ( value < min ) {
        return min;
      }
      else if ( value > max ) {
        return max;
      }
      else {
        return value;
      }
    },

    /**
     * Returns a number in the range $n\in[\mathrm{min},\mathrm{max})$ with the same equivalence class as the input
     * value mod (max-min), i.e. for a value $m$, $m\equiv n\ (\mathrm{mod}\ \mathrm{max}-\mathrm{min})$.
     * @public
     *
     * The 'down' indicates that if the value is equal to min or max, the max is returned.
     *
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {number}
     */
    moduloBetweenDown: function( value, min, max ) {
      assert && assert( max > min, 'max > min required for moduloBetween' );

      var divisor = max - min;

      // get a partial result of value-min between [0,divisor)
      var partial = ( value - min ) % divisor;
      if ( partial < 0 ) {
        // since if value-min < 0, the remainder will give us a negative number
        partial += divisor;
      }

      return partial + min; // add back in the minimum value
    },

    /**
     * Returns a number in the range $n\in(\mathrm{min},\mathrm{max}]$ with the same equivalence class as the input
     * value mod (max-min), i.e. for a value $m$, $m\equiv n\ (\mathrm{mod}\ \mathrm{max}-\mathrm{min})$.
     * @public
     *
     * The 'up' indicates that if the value is equal to min or max, the min is returned.
     *
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {number}
     */
    moduloBetweenUp: function( value, min, max ) {
      return -Util.moduloBetweenDown( -value, -max, -min );
    },

    /**
     * Returns an array of integers from A to B (inclusive), e.g. rangeInclusive( 4, 7 ) maps to [ 4, 5, 6, 7 ].
     * @public
     *
     * @param {number} a
     * @param {number} b
     * @returns {Array.<number>}
     */
    rangeInclusive: function( a, b ) {
      if ( b < a ) {
        return [];
      }
      var result = new Array( b - a + 1 );
      for ( var i = a; i <= b; i++ ) {
        result[ i - a ] = i;
      }
      return result;
    },

    /**
     * Returns an array of integers from A to B (exclusive), e.g. rangeExclusive( 4, 7 ) maps to [ 5, 6 ].
     * @public
     *
     * @param {number} a
     * @param {number} b
     * @returns {Array.<number>}
     */
    rangeExclusive: function( a, b ) {
      return Util.rangeInclusive( a + 1, b - 1 );
    },

    /**
     * Converts degrees to radians.
     * @public
     *
     * @param {number} degrees
     * @returns {number}
     */
    toRadians: function( degrees ) {
      return Math.PI * degrees / 180;
    },

    /**
     * Converts radians to degrees.
     * @public
     *
     * @param {number} radians
     * @returns {number}
     */
    toDegrees: function( radians ) {
      return 180 * radians / Math.PI;
    },

    /**
     * Greatest Common Denominator, using https://en.wikipedia.org/wiki/Euclidean_algorithm
     * @public
     *
     * @param {number} a
     * @param {number} b
     */
    gcd: function( a, b ) {
      return b === 0 ? a : this.gcd( b, a % b );
    },

    /**
     * Intersection point between the lines defined by the line segments p1-2 and p3-p4. Currently does not handle
     * parallel lines.
     * @public
     *
     * @param {Vector2} p1
     * @param {Vector2} p2
     * @param {Vector2} p3
     * @param {Vector2} p4
     * @returns {Vector2}
     */
    lineLineIntersection: function( p1, p2, p3, p4 ) {
      // Taken from an answer in http://stackoverflow.com/questions/385305/efficient-maths-algorithm-to-calculate-intersections
      var x12 = p1.x - p2.x;
      var x34 = p3.x - p4.x;
      var y12 = p1.y - p2.y;
      var y34 = p3.y - p4.y;

      var denom = x12 * y34 - y12 * x34;

      var a = p1.x * p2.y - p1.y * p2.x;
      var b = p3.x * p4.y - p3.y * p4.x;

      return new dot.Vector2(
        ( a * x34 - x12 * b ) / denom,
        ( a * y34 - y12 * b ) / denom
      );
    },

    /**
     * Ray-sphere intersection, returning information about the closest intersection. Assumes the sphere is centered
     * at the origin (for ease of computation), transform the ray to compensate if needed.
     * @public
     *
     * If there is no intersection, null is returned. Otherwise an object will be returned like:
     * <pre class="brush: js">
     * {
     *   distance: {number}, // distance from the ray position to the intersection
     *   hitPoint: {Vector3}, // location of the intersection
     *   normal: {Vector3}, // the normal of the sphere's surface at the intersection
     *   fromOutside: {boolean}, // whether the ray intersected the sphere from outside the sphere first
     * }
     * </pre>
     *
     * @param {number} radius
     * @param {Ray3} ray
     * @param {number} epsilon
     * @returns {Object}
     */
    // assumes a sphere with the specified radius, centered at the origin
    sphereRayIntersection: function( radius, ray, epsilon ) {
      epsilon = epsilon === undefined ? 1e-5 : epsilon;

      // center is the origin for now, but leaving in computations so that we can change that in the future. optimize away if needed
      var center = new dot.Vector3();

      var rayDir = ray.direction;
      var pos = ray.position;
      var centerToRay = pos.minus( center );

      // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)
      var tmp = rayDir.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - radius * radius );
      if ( det < epsilon ) {
        // ray misses sphere entirely
        return null;
      }

      var base = rayDir.dot( center ) - rayDir.dot( pos );
      var sqt = Math.sqrt( det ) / 2;

      // the "first" entry point distance into the sphere. if we are inside the sphere, it is behind us
      var ta = base - sqt;

      // the "second" entry point distance
      var tb = base + sqt;

      if ( tb < epsilon ) {
        // sphere is behind ray, so don't return an intersection
        return null;
      }

      var hitPositionB = ray.pointAtDistance( tb );
      var normalB = hitPositionB.minus( center ).normalized();

      if ( ta < epsilon ) {
        // we are inside the sphere
        // in => out
        return {
          distance: tb,
          hitPoint: hitPositionB,
          normal: normalB.negated(),
          fromOutside: false
        };
      }
      else {
        // two possible hits
        var hitPositionA = ray.pointAtDistance( ta );
        var normalA = hitPositionA.minus( center ).normalized();

        // close hit, we have out => in
        return {
          distance: ta,
          hitPoint: hitPositionA,
          normal: normalA,
          fromOutside: true
        };
      }
    },

    /**
     * Returns an array of the real roots of the quadratic equation $ax^2 + bx + c=0$ (there will be between 0 and 2 roots).
     * @public
     *
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @returns {Array.<number>}
     */
    solveQuadraticRootsReal: function( a, b, c ) {
      var epsilon = 1E7;

      //We need to test whether a is several orders of magnitude less than b or c. If so, return the result as a solution to the linear (easy) equation
      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon ) {
        return [ -c / b ];
      }

      var discriminant = b * b - 4 * a * c;
      if ( discriminant < 0 ) {
        return [];
      }
      var sqrt = Math.sqrt( discriminant );
      // TODO: how to handle if discriminant is 0? give unique root or double it?
      // TODO: probably just use Complex for the future
      return [
        ( -b - sqrt ) / ( 2 * a ),
        ( -b + sqrt ) / ( 2 * a )
      ];
    },

    /**
     * Returns an array of the real roots of the quadratic equation $ax^3 + bx^2 + cx + d=0$ (there will be between 0 and 3 roots).
     * @public
     *
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @param {number} d
     * @returns {Array.<number>}
     */
    solveCubicRootsReal: function( a, b, c, d ) {
      // TODO: a Complex type!

      //We need to test whether a is several orders of magnitude less than b, c, d
      var epsilon = 1E7;

      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon || Math.abs( d / a ) > epsilon ) {
        return Util.solveQuadraticRootsReal( b, c, d );
      }
      if ( d === 0 || Math.abs( a / d ) > epsilon || Math.abs( b / d ) > epsilon || Math.abs( c / d ) > epsilon ) {
        return Util.solveQuadraticRootsReal( a, b, c );
      }

      b /= a;
      c /= a;
      d /= a;

      var q = ( 3.0 * c - ( b * b ) ) / 9;
      var r = ( -(27 * d) + b * (9 * c - 2 * (b * b)) ) / 54;
      var discriminant = q * q * q + r * r;
      var b3 = b / 3;

      if ( discriminant > 0 ) {
        // a single real root
        var dsqrt = Math.sqrt( discriminant );
        return [ Util.cubeRoot( r + dsqrt ) + Util.cubeRoot( r - dsqrt ) - b3 ];
      }

      // three real roots
      if ( discriminant === 0 ) {
        // contains a double root
        var rsqrt = Util.cubeRoot( r );
        var doubleRoot = b3 - rsqrt;
        return [ -b3 + 2 * rsqrt, doubleRoot, doubleRoot ];
      }
      else {
        // all unique
        var qX = -q * q * q;
        qX = Math.acos( r / Math.sqrt( qX ) );
        var rr = 2 * Math.sqrt( -q );
        return [
          -b3 + rr * Math.cos( qX / 3 ),
          -b3 + rr * Math.cos( ( qX + 2 * Math.PI ) / 3 ),
          -b3 + rr * Math.cos( ( qX + 4 * Math.PI ) / 3 )
        ];
      }
    },

    /**
     * Returns the unique real cube root of x, such that $y^3=x$.
     * @public
     *
     * @param {number} x
     * @returns {number}
     */
    cubeRoot: function( x ) {
      return x >= 0 ? Math.pow( x, 1 / 3 ) : -Math.pow( -x, 1 / 3 );
    },

    /**
     * Defines and evaluates a linear mapping. The mapping is defined so that $f(a_1)=b_1$ and $f(a_2)=b_2$, and other
     * values are interpolated along the linear equation. The returned value is $f(a_3)$.
     * @public
     *
     * @param {number} a1
     * @param {number} a2
     * @param {number} b1
     * @param {number} b2
     * @param {number} a3
     * @returns {number}
     */
    linear: function( a1, a2, b1, b2, a3 ) {
      return ( b2 - b1 ) / ( a2 - a1 ) * ( a3 - a1 ) + b1;
    },

    /**
     * Rounds using "Round half away from zero" algorithm. See dot#35.
     * @public
     *
     * JavaScript's Math.round is not symmetric for positive and negative numbers, it uses IEEE 754 "Round half up".
     * See https://en.wikipedia.org/wiki/Rounding#Round_half_up.
     * For sims, we want to treat positive and negative values symmetrically, which is IEEE 754 "Round half away from zero",
     * See https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero
     *
     * Note that -0 is rounded to 0, since we typically do not want to display -0 in sims.
     *
     * @param {number} value                               `
     * @returns {number}
     */
    roundSymmetric: function( value ) {
      return ( ( value < 0 ) ? -1 : 1 ) * Math.round( Math.abs( value ) );
    },

    /**
     * A predictable implementation of toFixed.
     * @public
     *
     * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,
     * because the spec doesn't specify whether to round or floor.
     * Rounding is symmetric for positive and negative values, see Util.roundSymmetric.
     *
     * @param {number} value
     * @param {number} decimalPlaces
     * @returns {string}
     */
    toFixed: function( value, decimalPlaces ) {
      var multiplier = Math.pow( 10, decimalPlaces );
      var newValue = Util.roundSymmetric( value * multiplier ) / multiplier;
      return newValue.toFixed( decimalPlaces );
    },

    /**
     * A predictable implementation of toFixed, where the result is returned as a number instead of a string.
     * @public
     *
     * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,
     * because the spec doesn't specify whether to round or floor.
     * Rounding is symmetric for positive and negative values, see Util.roundSymmetric.
     *
     * @param {number} value
     * @param {number} decimalPlaces
     * @returns {number}
     */
    toFixedNumber: function( value, decimalPlaces ) {
      return parseFloat( Util.toFixed( value, decimalPlaces ) );
    },

    /**
     * Returns whether the input is a number that is an integer (no fractional part).
     * @public
     *
     * @param {number} n
     * @returns {boolean}
     */
    isInteger: function( n ) {
      return ( typeof n === 'number' ) && ( n % 1 === 0 );
    },

    /**
     * Computes the intersection of the two line segments $(x_1,y_1)(x_2,y_2)$ and $(x_3,y_3)(x_4,y_4)$. If there is no
     * intersection, null is returned.
     * @public
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {number} x4
     * @param {number} y4
     * @returns {Vector2|null}
     */
    lineSegmentIntersection: function( x1, y1, x2, y2, x3, y3, x4, y4 ) {
      /*
       * Algorithm taken from Paul Bourke, 1989:
       * http://paulbourke.net/geometry/pointlineplane/
       * http://paulbourke.net/geometry/pointlineplane/pdb.c
       * Ported from MathUtil.java on 9/20/2013 by @samreid
       */
      var numA = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );
      var numB = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );
      var denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );

      // If denominator is 0, the lines are parallel or coincident
      if ( denom === 0 ) {
        return null;
      }
      else {
        var ua = numA / denom;
        var ub = numB / denom;

        // ua and ub must both be in the range 0 to 1 for the segments to have an intersection pt.
        if ( !( ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1 ) ) {
          return null;
        }
        else {
          var x = x1 + ua * ( x2 - x1 );
          var y = y1 + ua * ( y2 - y1 );
          return new dot.Vector2( x, y );
        }
      }
    },

    /**
     * Squared distance from a point to a line segment squared.
     * See http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
     * @public
     *
     * @param {Vector2} point - The point
     * @param {Vector2} a - Starting point of the line segment
     * @param {Vector2} b - Ending point of the line segment
     * @returns {number}
     */
    distToSegmentSquared: function( point, a, b ) {
      var segmentLength = a.distanceSquared( b );
      if ( segmentLength === 0 ) { return point.distanceSquared( a ); }
      var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / segmentLength;
      return t < 0 ? point.distanceSquared( a ) :
             t > 1 ? point.distanceSquared( b ) :
             point.distanceSquared( new dot.Vector2( a.x + t * (b.x - a.x), a.y + t * (b.y - a.y) ) );
    },

    /**
     * Squared distance from a point to a line segment squared.
     * @public
     *
     * @param {Vector2} point - The point
     * @param {Vector2} a - Starting point of the line segment
     * @param {Vector2} b - Ending point of the line segment
     * @returns {number}
     */
    distToSegment: function( point, a, b ) { return Math.sqrt( this.distToSegmentSquared( point, a, b ) ); },

    /**
     * Determines whether the three points are approximately collinear.
     * @public
     *
     * @param {Vector2} a
     * @param {Vector2} b
     * @param {Vector2} c
     * @param {number} epsilon
     * @returns {boolean}
     */
    arePointsCollinear: function( a, b, c, epsilon ) {
      if ( epsilon === undefined ) {
        epsilon = 0;
      }
      return Util.triangleArea( a, b, c ) <= epsilon;
    },

    /**
     * The area inside the triangle defined by the three vertices.
     * @public
     *
     * @param {Vector2} a
     * @param {Vector2} b
     * @param {Vector2} c
     * @returns {number}
     */
    triangleArea: function( a, b, c ) {
      return Math.abs( Util.triangleAreaSigned( a, b, c ) );
    },

    /**
     * The area inside the triangle defined by the three vertices, but with the sign determined by whether the vertices
     * provided are clockwise or counter-clockwise.
     * @public
     *
     * @param {Vector2} a
     * @param {Vector2} b
     * @param {Vector2} c
     * @returns {number}
     */
    triangleAreaSigned: function( a, b, c ) {
      // TODO: investigate which way we want the sign (Canvas or WebGL style)
      return a.x * ( b.y - c.y ) + b.x * ( c.y - a.y ) + c.x * ( a.y - b.y );
    },

    /**
     * Log base-10, since it wasn't included in every supported browser.
     * @public
     *
     * @param {number} val
     * @returns {number}
     */
    log10: function( val ) {
      return Math.log( val ) / Math.LN10;
    },

    /**
     * Generates a random Gaussian sample with the given mean and standard deviation.
     * This method relies on the "static" variables generate, z0, and z1 defined above.
     * Random.js is the primary client of this function, but it is defined here so it can be
     * used other places more easily if need be.
     * Code inspired by example here: https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform.
     * @public
     *
     * @param {number} mu - The mean of the Gaussian
     * @param {number} sigma - The standard deviation of the Gaussian
     * @returns {number}
     */
    boxMullerTransform: function( mu, sigma ) {
      generate = !generate;

      if ( !generate ) {
        return z1 * sigma + mu;
      }

      var u1;
      var u2;
      do {
        u1 = Math.random();
        u2 = Math.random();
      }
      while ( u1 <= EPSILON );

      z0 = Math.sqrt( -2.0 * Math.log( u1 ) ) * Math.cos( TWO_PI * u2 );
      z1 = Math.sqrt( -2.0 * Math.log( u1 ) ) * Math.sin( TWO_PI * u2 );
      return z0 * sigma + mu;
    }
  };
  dot.register( 'Util', Util );

  // make these available in the main namespace directly (for now)
  dot.clamp = Util.clamp;
  dot.moduloBetweenDown = Util.moduloBetweenDown;
  dot.moduloBetweenUp = Util.moduloBetweenUp;
  dot.rangeInclusive = Util.rangeInclusive;
  dot.rangeExclusive = Util.rangeExclusive;
  dot.toRadians = Util.toRadians;
  dot.toDegrees = Util.toDegrees;
  dot.lineLineIntersection = Util.lineLineIntersection;
  dot.sphereRayIntersection = Util.sphereRayIntersection;
  dot.solveQuadraticRootsReal = Util.solveQuadraticRootsReal;
  dot.solveCubicRootsReal = Util.solveCubicRootsReal;
  dot.cubeRoot = Util.cubeRoot;
  dot.linear = Util.linear;
  dot.boxMullerTransform = Util.boxMullerTransform;

  return Util;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Basic 2-dimensional vector, represented as (x,y).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Vector2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  require( 'DOT/Util' );
  // require( 'DOT/Vector3' ); // commented out since Require.js complains about the circular dependency

  /**
   * Creates a 2-dimensional vector with the specified X and Y values.
   * @constructor
   * @public
   *
   * @param {number} [x] - X coordinate, defaults to 0 if not provided
   * @param {number} [y] - Y coordinate, defaults to 0 if not provided
   */
  function Vector2( x, y ) {
    // @public {number} - The X coordinate of the vector.
    this.x = x !== undefined ? x : 0;

    // @public {number} - The Y coordinate of the vector.
    this.y = y !== undefined ? y : 0;

    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );

    phetAllocation && phetAllocation( 'Vector2' );
  }

  dot.register( 'Vector2', Vector2 );

  inherit( Object, Vector2, {
    // @public (read-only) - Helps to identify the dimension of the vector
    isVector2: true,
    dimension: 2,

    /**
     * The magnitude (Euclidean/L2 Norm) of this vector, i.e. $\sqrt{x^2+y^2}$.
     * @public
     *
     * @returns {number}
     */
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    /**
     * The squared magnitude (square of the Euclidean/L2 Norm) of this vector, i.e. $x^2+y^2$.
     * @public
     *
     * @returns {number}
     */
    magnitudeSquared: function() {
      return this.x * this.x + this.y * this.y;
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    distance: function( point ) {
      return Math.sqrt( this.distanceSquared( point ) );
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point (x,y).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @returns {number}
     */
    distanceXY: function( x, y ) {
      var dx = this.x - x;
      var dy = this.y - y;
      return Math.sqrt( dx * dx + dy * dy );
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    distanceSquared: function( point ) {
      var dx = this.x - point.x;
      var dy = this.y - point.y;
      return dx * dx + dy * dy;
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point (x,y).
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    distanceSquaredXY: function( x, y ) {
      var dx = this.x - x;
      var dy = this.y - y;
      return dx * dx + dy * dy;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector v.
     * @public
     *
     * @param {Vector2} v
     * @returns {number}
     */
    dot: function( v ) {
      return this.x * v.x + this.y * v.y;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector (x,y).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @returns {number}
     */
    dotXY: function( x, y ) {
      return this.x * x + this.y * y;
    },

    /**
     * The angle $\theta$ of this vector, such that this vector is equal to
     * $$ u = \begin{bmatrix} r\cos\theta \\ r\sin\theta \end{bmatrix} $$
     * for the magnitude $r \ge 0$ of the vector, with $\theta\in(-\pi,\pi]$
     * @public
     *
     * @returns {number}
     */
    angle: function() {
      return Math.atan2( this.y, this.x );
    },

    /**
     * The angle between this vector and another vector, in the range $\theta\in[0, \pi]$.
     * @public
     *
     * Equal to $\theta = \cos^{-1}( \hat{u} \cdot \hat{v} )$ where $\hat{u}$ is this vector (normalized) and $\hat{v}$
     * is the input vector (normalized).
     *
     * @param {Vector2} v
     * @returns {number}
     */
    angleBetween: function( v ) {
      var thisMagnitude = this.magnitude();
      var vMagnitude = v.magnitude();
      return Math.acos( dot.clamp( ( this.x * v.x + this.y * v.y ) / ( thisMagnitude * vMagnitude ), -1, 1 ) );
    },

    /**
     * Exact equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector2} other
     * @returns {boolean} - Whether the two vectors have equal components
     */
    equals: function( other ) {
      return this.x === other.x && this.y === other.y;
    },

    /**
     * Approximate equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector2} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two vectors has no component with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.max( Math.abs( this.x - other.x ), Math.abs( this.y - other.y ) ) <= epsilon;
    },

    /**
     * Whether all of the components are numbers (not NaN) that are not infinity or -infinity.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y );
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this vector, or if a vector is passed in, set that vector's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a vector is provided. This will return a new vector, and
     * will not modify this vector.
     *
     * @param {Vector2} [vector] - If not provided, creates a new Vector2 with filled in values. Otherwise, fills in the
     *                             values of the provided vector so that it equals this vector.
     * @returns {Vector2}
     */
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector2( this.x, this.y );
      }
    },

    /**
     * The scalar value of the z-component of the equivalent 3-dimensional cross product:
     * $$ f( u, v ) = \left( \begin{bmatrix} u_x \\ u_y \\ 0 \end{bmatrix} \times \begin{bmatrix} v_x \\ v_y \\ 0 \end{bmatrix} \right)_z = u_x v_y - u_y v_x $$
     * @public
     *
     * @param {Vector2} v
     * @returns {number}
     */
    crossScalar: function( v ) {
      return this.x * v.y - this.y * v.x;
    },

    /**
     * Normalized (re-scaled) copy of this vector such that its magnitude is 1. If its initial magnitude is zero, an
     * error is thrown.
     * @public
     *
     * This is the immutable form of the function normalize(). This will return a new vector, and will not modify this
     * vector.
     *
     * @returns {Vector2}
     */
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return new Vector2( this.x / mag, this.y / mag );
      }
    },

    /**
     * Re-scaled copy of this vector such that it has the desired magnitude. If its initial magnitude is zero, an error
     * is thrown. If the passed-in magnitude is negative, the direction of the resulting vector will be reversed.
     * @public
     *
     * This is the immutable form of the function setMagnitude(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} magnitude
     * @returns {Vector2}
     */
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },

    /**
     * Copy of this vector, scaled by the desired scalar value.
     * @public
     *
     * This is the immutable form of the function multiplyScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    timesScalar: function( scalar ) {
      return new Vector2( this.x * scalar, this.y * scalar );
    },

    /**
     * Same as timesScalar.
     * @public
     *
     * This is the immutable form of the function multiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },

    /**
     * Copy of this vector, multiplied component-wise by the passed-in vector v.
     * @public
     *
     * This is the immutable form of the function componentMultiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    componentTimes: function( v ) {
      return new Vector2( this.x * v.x, this.y * v.y );
    },

    /**
     * Addition of this vector and another vector, returning a copy.
     * @public
     *
     * This is the immutable form of the function add(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    plus: function( v ) {
      return new Vector2( this.x + v.x, this.y + v.y );
    },

    /**
     * Addition of this vector and another vector (x,y), returning a copy.
     * @public
     *
     * This is the immutable form of the function addXY(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    plusXY: function( x, y ) {
      return new Vector2( this.x + x, this.y + y );
    },

    /**
     * Addition of this vector with a scalar (adds the scalar to every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function addScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    plusScalar: function( scalar ) {
      return new Vector2( this.x + scalar, this.y + scalar );
    },

    /**
     * Subtraction of this vector by another vector v, returning a copy.
     * @public
     *
     * This is the immutable form of the function subtract(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    minus: function( v ) {
      return new Vector2( this.x - v.x, this.y - v.y );
    },

    /**
     * Subtraction of this vector by another vector (x,y), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractXY(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    minusXY: function( x, y ) {
      return new Vector2( this.x - x, this.y - y );
    },

    /**
     * Subtraction of this vector by a scalar (subtracts the scalar from every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    minusScalar: function( scalar ) {
      return new Vector2( this.x - scalar, this.y - scalar );
    },

    /**
     * Division of this vector by a scalar (divides every component by the scalar), returning a copy.
     * @public
     *
     * This is the immutable form of the function divideScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    dividedScalar: function( scalar ) {
      return new Vector2( this.x / scalar, this.y / scalar );
    },

    /**
     * Negated copy of this vector (multiplies every component by -1).
     * @public
     *
     * This is the immutable form of the function negate(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector2}
     */
    negated: function() {
      return new Vector2( -this.x, -this.y );
    },

    /**
     * Rotated by -pi/2 (perpendicular to this vector), returned as a copy.
     * @public
     *
     * @returns {Vector2}
     */
    perpendicular: function() {
      return new Vector2( this.y, -this.x );
    },

    /**
     * Rotated by an arbitrary angle, in radians. Returned as a copy.
     * @public
     *
     * This is the immutable form of the function rotate(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} angle - In radians
     * @returns {Vector2}
     */
    rotated: function( angle ) {
      var newAngle = this.angle() + angle;
      var mag = this.magnitude();
      return new Vector2( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
    },

    /**
     * A linear interpolation between this vector (ratio=0) and another vector (ratio=1).
     * @public
     *
     * @param {Vector2} vector
     * @param {number} ratio - Not necessarily constrained in [0, 1]
     * @returns {Vector2}
     */
    blend: function( vector, ratio ) {
      return new Vector2( this.x + (vector.x - this.x) * ratio, this.y + (vector.y - this.y) * ratio );
    },

    /**
     * The average (midpoint) between this vector and another vector.
     * @public
     *
     * @param {Vector2} vector
     * @returns {Vector2}
     */
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },

    /**
     * Debugging string for the vector.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return 'Vector2(' + this.x + ', ' + this.y + ')';
    },

    /**
     * Converts this to a 3-dimensional vector, with the z-component equal to 0.
     * @public
     *
     * @returns {Vector3}
     */
    toVector3: function() {
      return new dot.Vector3( this.x, this.y, 0 );
    },

    /*---------------------------------------------------------------------------*
     * Mutables
     * - all mutation should go through setXY / setX / setY
     *---------------------------------------------------------------------------*/

    /**
     * Sets all of the components of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    setXY: function( x, y ) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * Sets the x-component of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @returns {Vector2}
     */
    setX: function( x ) {
      this.x = x;
      return this;
    },

    /**
     * Sets the y-component of this vector, returning this.
     * @public
     *
     * @param {number} y
     * @returns {Vector2}
     */
    setY: function( y ) {
      this.y = y;
      return this;
    },

    /**
     * Sets this vector to be a copy of another vector.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this vector, in addition to returning
     * this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    set: function( v ) {
      return this.setXY( v.x, v.y );
    },

    /**
     * Sets the magnitude of this vector. If the passed-in magnitude is negative, this flips the vector and sets its
     * magnitude to abs( magnitude ).
     * @public
     *
     * This is the mutable form of the function withMagnitude(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} magnitude
     * @returns {Vector2}
     */
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },

    /**
     * Adds another vector to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    add: function( v ) {
      return this.setXY( this.x + v.x, this.y + v.y );
    },

    /**
     * Adds another vector (x,y) to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plusXY(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    addXY: function( x, y ) {
      return this.setXY( this.x + x, this.y + y );
    },

    /**
     * Adds a scalar to this vector (added to every component), changing this vector.
     * @public
     *
     * This is the mutable form of the function plusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    addScalar: function( scalar ) {
      return this.setXY( this.x + scalar, this.y + scalar );
    },

    /**
     * Subtracts this vector by another vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function minus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    subtract: function( v ) {
      return this.setXY( this.x - v.x, this.y - v.y );
    },

    /**
     * Subtracts this vector by another vector (x,y), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusXY(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    subtractXY: function( x, y ) {
      return this.setXY( this.x - x, this.y - y );
    },

    /**
     * Subtracts this vector by a scalar (subtracts each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    subtractScalar: function( scalar ) {
      return this.setXY( this.x - scalar, this.y - scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function timesScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    multiplyScalar: function( scalar ) {
      return this.setXY( this.x * scalar, this.y * scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * Same as multiplyScalar.
     * @public
     *
     * This is the mutable form of the function times(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },

    /**
     * Multiplies this vector by another vector component-wise, changing this vector.
     * @public
     *
     * This is the mutable form of the function componentTimes(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    componentMultiply: function( v ) {
      return this.setXY( this.x * v.x, this.y * v.y );
    },

    /**
     * Divides this vector by a scalar (divides each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function dividedScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    divideScalar: function( scalar ) {
      return this.setXY( this.x / scalar, this.y / scalar );
    },

    /**
     * Negates this vector (multiplies each component by -1), changing this vector.
     * @public
     *
     * This is the mutable form of the function negated(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector2}
     */
    negate: function() {
      return this.setXY( -this.x, -this.y );
    },

    /**
     * Normalizes this vector (rescales to where the magnitude is 1), changing this vector.
     * @public
     *
     * This is the mutable form of the function normalized(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector2}
     */
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return this.divideScalar( mag );
      }
    },

    /**
     * Rotates this vector by the angle (in radians), changing this vector.
     * @public
     *
     * This is the mutable form of the function rotated(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} angle - In radians
     * @returns {Vector2}
     */
    rotate: function( angle ) {
      var newAngle = this.angle() + angle;
      var mag = this.magnitude();
      return this.setXY( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
    },

    /**
     * Sets this vector's value to be the x,y values matching the given magnitude and angle (in radians), changing
     * this vector, and returning itself.
     * @public
     *
     * @param {number} magnitude
     * @param {number} angle - In radians
     * @returns {Vector2}
     */
    setPolar: function( magnitude, angle ) {
      return this.setXY( magnitude * Math.cos( angle ), magnitude * Math.sin( angle ) );
    },

    /**
     * Returns a duck-typed object meant for use with tandem/phet-io serialization.
     *
     * @returns {Object}
     */
    toStateObject: function() {
      return { x: this.x, y: this.y };
    }
  }, { // static functions on Vector2 itself
    /**
     * Returns a Vector2 with the specified magnitude $r$ and angle $\theta$ (in radians), with the formula:
     * $$ f( r, \theta ) = \begin{bmatrix} r\cos\theta \\ r\sin\theta \end{bmatrix} $$
     * @public
     *
     * @param {number} magnitude
     * @param {number} angle
     * @returns {Vector2}
     */
    createPolar: function( magnitude, angle ) {
      return new Vector2().setPolar( magnitude, angle );
    },

    /**
     * Constructs a Vector2 from a duck-typed { x: {number}, y: {number} } object, meant for use with
     * tandem/phet-io deserialization.
     * @public
     *
     * @param {Object} stateObject - Like { x: {number}, y: {number} }
     * @returns {Vector2}
     */
    fromStateObject: function( stateObject ) {
      return new Vector2( stateObject.x, stateObject.y );
    }
  } );

  // Sets up pooling on Vector2
  Poolable.mixin( Vector2, {
    defaultFactory: function() { return new Vector2(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y );
        }
        else {
          return new Vector2( x, y );
        }
      };
    }
  } );

  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *---------------------------------------------------------------------------*/

  // @private
  Vector2.Immutable = function ImmutableVector2( x, y ) {
    Vector2.call( this, x, y );
  };
  var Immutable = Vector2.Immutable;

  inherit( Vector2, Immutable );

  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector2' );
    };
  };

  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXY' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );

  /**
   * Immutable zero vector: $\begin{bmatrix} 0\\0 \end{bmatrix}$
   * @public
   *
   * @constant {Vector2} ZERO
   */
  Vector2.ZERO = assert ? new Immutable( 0, 0 ) : new Vector2( 0, 0 );

  /**
   * Immutable vector: $\begin{bmatrix} 1\\0 \end{bmatrix}$
   * @public
   *
   * @constant {Vector2} X_UNIT
   */
  Vector2.X_UNIT = assert ? new Immutable( 1, 0 ) : new Vector2( 1, 0 );

  /**
   * Immutable vector: $\begin{bmatrix} 0\\1 \end{bmatrix}$
   * @public
   *
   * @constant {Vector2} Y_UNIT
   */
  Vector2.Y_UNIT = assert ? new Immutable( 0, 1 ) : new Vector2( 0, 1 );

  return Vector2;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A 2D rectangle-shaped bounded area (bounding box).
 *
 * There are a number of convenience functions to get locations and points on the Bounds. Currently we do not
 * store these with the Bounds2 instance, since we want to lower the memory footprint.
 *
 * minX, minY, maxX, and maxY are actually stored. We don't do x,y,width,height because this can't properly express
 * semi-infinite bounds (like a half-plane), or easily handle what Bounds2.NOTHING and Bounds2.EVERYTHING do with
 * the constructive solid areas.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Bounds2',['require','DOT/dot','DOT/Vector2','PHET_CORE/inherit','PHET_CORE/Poolable'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var Vector2 = require( 'DOT/Vector2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  // Temporary instances to be used in the transform method.
  var scratchVector2 = new dot.Vector2();

  /**
   * Creates a 2-dimensional bounds (bounding box).
   * @constructor
   * @public
   *
   * @param {number} minX - The intial minimum X coordinate of the bounds.
   * @param {number} minY - The intial minimum Y coordinate of the bounds.
   * @param {number} maxX - The intial maximum X coordinate of the bounds.
   * @param {number} maxY - The intial maximum Y coordinate of the bounds.
   */
  function Bounds2( minX, minY, maxX, maxY ) {
    assert && assert( maxY !== undefined, 'Bounds2 requires 4 parameters' );

    // @public {number} - The minimum X coordinate of the bounds.
    this.minX = minX;

    // @public {number} - The minimum Y coordinate of the bounds.
    this.minY = minY;

    // @public {number} - The maximum X coordinate of the bounds.
    this.maxX = maxX;

    // @public {number} - The maximum Y coordinate of the bounds.
    this.maxY = maxY;

    phetAllocation && phetAllocation( 'Bounds2' );
  }

  dot.register( 'Bounds2', Bounds2 );

  inherit( Object, Bounds2, {
    // @public (read-only) - Helps to identify the dimension of the bounds
    isBounds: true,
    dimension: 2,

    /*---------------------------------------------------------------------------*
     * Properties
     *---------------------------------------------------------------------------*/

    /**
     * The width of the bounds, defined as maxX - minX.
     * @public
     *
     * @returns {number}
     */
    getWidth: function() { return this.maxX - this.minX; },
    get width() { return this.getWidth(); },

    /**
     * The height of the bounds, defined as maxY - minY.
     * @public
     *
     * @returns {number}
     */
    getHeight: function() { return this.maxY - this.minY; },
    get height() { return this.getHeight(); },

    /*
     * Convenience locations
     * upper is in terms of the visual layout in Scenery and other programs, so the minY is the "upper", and minY is the "lower"
     *
     *             minX (x)     centerX        maxX
     *          ---------------------------------------
     * minY (y) | leftTop     centerTop     rightTop
     * centerY  | leftCenter  center        rightCenter
     * maxY     | leftBottom  centerBottom  rightBottom
     */

    /**
     * Alias for minX, when thinking of the bounds as an (x,y,width,height) rectangle.
     * @public
     *
     * @returns {number}
     */
    getX: function() { return this.minX; },
    get x() { return this.getX(); },

    /**
     * Alias for minY, when thinking of the bounds as an (x,y,width,height) rectangle.
     * @public
     *
     * @returns {number}
     */
    getY: function() { return this.minY; },
    get y() { return this.getY(); },

    /**
     * Alias for minX, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMinX: function() { return this.minX; },

    /**
     * Alias for minY, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMinY: function() { return this.minY; },

    /**
     * Alias for maxX, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMaxX: function() { return this.maxX; },

    /**
     * Alias for maxY, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMaxY: function() { return this.maxY; },

    /**
     * Alias for minX, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getLeft: function() { return this.minX; },
    get left() { return this.minX; },

    /**
     * Alias for minY, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getTop: function() { return this.minY; },
    get top() { return this.minY; },

    /**
     * Alias for maxX, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getRight: function() { return this.maxX; },
    get right() { return this.maxX; },

    /**
     * Alias for maxY, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getBottom: function() { return this.maxY; },
    get bottom() { return this.maxY; },

    /**
     * The horizontal (X-coordinate) center of the bounds, averaging the minX and maxX.
     * @public
     *
     * @returns {number}
     */
    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },
    get centerX() { return this.getCenterX(); },

    /**
     * The vertical (Y-coordinate) center of the bounds, averaging the minY and maxY.
     * @public
     *
     * @returns {number}
     */
    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },
    get centerY() { return this.getCenterY(); },

    /**
     * The point (minX, minY), in the UI-coordinate upper-left.
     * @public
     *
     * @returns {Vector2}
     */
    getLeftTop: function() { return new dot.Vector2( this.minX, this.minY ); },
    get leftTop() { return this.getLeftTop(); },

    /**
     * The point (centerX, minY), in the UI-coordinate upper-center.
     * @public
     *
     * @returns {Vector2}
     */
    getCenterTop: function() { return new dot.Vector2( this.getCenterX(), this.minY ); },
    get centerTop() { return this.getCenterTop(); },

    /**
     * The point (right, minY), in the UI-coordinate upper-right.
     * @public
     *
     * @returns {Vector2}
     */
    getRightTop: function() { return new dot.Vector2( this.maxX, this.minY ); },
    get rightTop() { return this.getRightTop(); },

    /**
     * The point (left, centerY), in the UI-coordinate center-left.
     * @public
     *
     * @returns {Vector2}
     */
    getLeftCenter: function() { return new dot.Vector2( this.minX, this.getCenterY() ); },
    get leftCenter() { return this.getLeftCenter(); },

    /**
     * The point (centerX, centerY), in the center of the bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getCenter: function() { return new dot.Vector2( this.getCenterX(), this.getCenterY() ); },
    get center() { return this.getCenter(); },

    /**
     * The point (maxX, centerY), in the UI-coordinate center-right
     * @public
     *
     * @returns {Vector2}
     */
    getRightCenter: function() { return new dot.Vector2( this.maxX, this.getCenterY() ); },
    get rightCenter() { return this.getRightCenter(); },

    /**
     * The point (minX, maxY), in the UI-coordinate lower-left
     * @public
     *
     * @returns {Vector2}
     */
    getLeftBottom: function() { return new dot.Vector2( this.minX, this.maxY ); },
    get leftBottom() { return this.getLeftBottom(); },

    /**
     * The point (centerX, maxY), in the UI-coordinate lower-center
     * @public
     *
     * @returns {Vector2}
     */
    getCenterBottom: function() { return new dot.Vector2( this.getCenterX(), this.maxY ); },
    get centerBottom() { return this.getCenterBottom(); },

    /**
     * The point (maxX, maxY), in the UI-coordinate lower-right
     * @public
     *
     * @returns {Vector2}
     */
    getRightBottom: function() { return new dot.Vector2( this.maxX, this.maxY ); },
    get rightBottom() { return this.getRightBottom(); },

    /**
     * Whether we have negative width or height. Bounds2.NOTHING is a prime example of an empty Bounds2.
     * Bounds with width = height = 0 are considered not empty, since they include the single (0,0) point.
     * @public
     *
     * @returns {boolean}
     */
    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0; },

    /**
     * Whether our minimums and maximums are all finite numbers. This will exclude Bounds2.NOTHING and Bounds2.EVERYTHING.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.maxX ) && isFinite( this.maxY );
    },

    /**
     * Whether this bounds has a non-zero area (non-zero positive width and height).
     * @public
     *
     * @returns {boolean}
     */
    hasNonzeroArea: function() {
      return this.getWidth() > 0 && this.getHeight() > 0;
    },

    /**
     * Whether this bounds has a finite and non-negative width and height.
     * @public
     *
     * @returns {boolean}
     */
    isValid: function() {
      return !this.isEmpty() && this.isFinite();
    },

    /**
     * If the location is inside the bounds, the location will be returned. Otherwise, this will return a new location
     * on the edge of the bounds that is the closest to the provided location.
     * @public
     *
     * @param {Vector2} location
     * @returns {Vector2}
     */
    closestPointTo: function( location ) {
      if ( this.containsCoordinates( location.x, location.y ) ) {
        return location;
      }
      else {
        var xConstrained = Math.max( Math.min( location.x, this.maxX ), this.x );
        var yConstrained = Math.max( Math.min( location.y, this.maxY ), this.y );
        return new Vector2( xConstrained, yConstrained );
      }
    },

    /**
     * Whether the coordinates are contained inside the bounding box, or are on the boundary.
     * @public
     *
     * @param {number} x - X coordinate of the point to check
     * @param {number} y - Y coordinate of the point to check
     * @returns {boolean}
     */
    containsCoordinates: function( x, y ) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    },

    /**
     * Whether the point is contained inside the bounding box, or is on the boundary.
     * @public
     *
     * @param {Vector2} point
     * @returns {boolean}
     */
    containsPoint: function( point ) {
      return this.containsCoordinates( point.x, point.y );
    },

    /**
     * Whether this bounding box completely contains the bounding box passed as a parameter. The boundary of a box is
     * considered to be "contained".
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {boolean}
     */
    containsBounds: function( bounds ) {
      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY;
    },

    /**
     * Whether this and another bounding box have any points of intersection (including touching boundaries).
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {boolean}
     */
    intersectsBounds: function( bounds ) {
      var minX = Math.max( this.minX, bounds.minX );
      var minY = Math.max( this.minY, bounds.minY );
      var maxX = Math.min( this.maxX, bounds.maxX );
      var maxY = Math.min( this.maxY, bounds.maxY );
      return ( maxX - minX ) >= 0 && ( maxY - minY >= 0 );
    },

    /**
     * The squared distance from the input point to the point closest to it inside the bounding box.
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    minimumDistanceToPointSquared: function( point ) {
      var closeX = point.x < this.minX ? this.minX : ( point.x > this.maxX ? this.maxX : null );
      var closeY = point.y < this.minY ? this.minY : ( point.y > this.maxY ? this.maxY : null );
      var d;
      if ( closeX === null && closeY === null ) {
        // inside, or on the boundary
        return 0;
      }
      else if ( closeX === null ) {
        // vertically directly above/below
        d = closeY - point.y;
        return d * d;
      }
      else if ( closeY === null ) {
        // horizontally directly to the left/right
        d = closeX - point.x;
        return d * d;
      }
      else {
        // corner case
        var dx = closeX - point.x;
        var dy = closeY - point.y;
        return dx * dx + dy * dy;
      }
    },

    /**
     * The squared distance from the input point to the point furthest from it inside the bounding box.
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    maximumDistanceToPointSquared: function( point ) {
      var x = point.x > this.getCenterX() ? this.minX : this.maxX;
      var y = point.y > this.getCenterY() ? this.minY : this.maxY;
      x -= point.x;
      y -= point.y;
      return x * x + y * y;
    },

    /**
     * Debugging string for the bounds.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + ')]';
    },

    /**
     * Exact equality comparison between this bounds and another bounds.
     * @public
     *
     * @param {Bounds2} other
     * @returns {boolean} - Whether the two bounds are equal
     */
    equals: function( other ) {
      return this.minX === other.minX && this.minY === other.minY && this.maxX === other.maxX && this.maxY === other.maxY;
    },

    /**
     * Approximate equality comparison between this bounds and another bounds.
     * @public
     *
     * @param {Bounds2} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two bounds has no min/max with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      epsilon = epsilon !== undefined ? epsilon : 0;
      var thisFinite = this.isFinite();
      var otherFinite = other.isFinite();
      if ( thisFinite && otherFinite ) {
        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity
        return Math.abs( this.minX - other.minX ) < epsilon &&
               Math.abs( this.minY - other.minY ) < epsilon &&
               Math.abs( this.maxX - other.maxX ) < epsilon &&
               Math.abs( this.maxY - other.maxY ) < epsilon;
      }
      else if ( thisFinite !== otherFinite ) {
        return false; // one is finite, the other is not. definitely not equal
      }
      else if ( this === other ) {
        return true; // exact same instance, must be equal
      }
      else {
        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both
        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&
               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&
               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&
               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) );
      }
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this bounds, or if a bounds is passed in, set that bounds's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a bounds is provided. This will return a new bounds, and
     * will not modify this bounds.
     *
     * @param {Bounds2} [bounds] - If not provided, creates a new Bounds2 with filled in values. Otherwise, fills in the
     *                             values of the provided bounds so that it equals this bounds.
     * @returns {Bounds2}
     */
    copy: function( bounds ) {
      if ( bounds ) {
        return bounds.set( this );
      }
      else {
        return new Bounds2( this.minX, this.minY, this.maxX, this.maxY );
      }
    },

    /**
     * The smallest bounds that contains both this bounds and the input bounds, returned as a copy.
     * @public
     *
     * This is the immutable form of the function includeBounds(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    union: function( bounds ) {
      return new Bounds2(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY )
      );
    },

    /**
     * The smallest bounds that is contained by both this bounds and the input bounds, returned as a copy.
     * @public
     *
     * This is the immutable form of the function constrainBounds(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    intersection: function( bounds ) {
      return new Bounds2(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY )
      );
    },
    // TODO: difference should be well-defined, but more logic is needed to compute

    /**
     * The smallest bounds that contains this bounds and the point (x,y), returned as a copy.
     * @public
     *
     * This is the immutable form of the function addCoordinates(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    withCoordinates: function( x, y ) {
      return new Bounds2(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y )
      );
    },

    /**
     * The smallest bounds that contains this bounds and the input point, returned as a copy.
     * @public
     *
     * This is the immutable form of the function addPoint(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Vector2} point
     * @returns {Bounds2}
     */
    withPoint: function( point ) {
      return this.withCoordinates( point.x, point.y );
    },

    /**
     * A copy of this bounds, with minX replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMinX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} minX
     * @returns {Bounds2}
     */
    withMinX: function( minX ) {
      return new Bounds2( minX, this.minY, this.maxX, this.maxY );
    },

    /**
     * A copy of this bounds, with minY replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMinY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} minY
     * @returns {Bounds2}
     */
    withMinY: function( minY ) {
      return new Bounds2( this.minX, minY, this.maxX, this.maxY );
    },

    /**
     * A copy of this bounds, with maxX replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMaxX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} maxX
     * @returns {Bounds2}
     */
    withMaxX: function( maxX ) {
      return new Bounds2( this.minX, this.minY, maxX, this.maxY );
    },

    /**
     * A copy of this bounds, with maxY replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMaxY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} maxY
     * @returns {Bounds2}
     */
    withMaxY: function( maxY ) {
      return new Bounds2( this.minX, this.minY, this.maxX, maxY );
    },

    /**
     * A copy of this bounds, with the minimum values rounded down to the nearest integer, and the maximum values
     * rounded up to the nearest integer. This causes the bounds to expand as necessary so that its boundaries
     * are integer-aligned.
     * @public
     *
     * This is the immutable form of the function roundOut(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @returns {Bounds2}
     */
    roundedOut: function() {
      return new Bounds2(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY )
      );
    },

    /**
     * A copy of this bounds, with the minimum values rounded up to the nearest integer, and the maximum values
     * rounded down to the nearest integer. This causes the bounds to contract as necessary so that its boundaries
     * are integer-aligned.
     * @public
     *
     * This is the immutable form of the function roundIn(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @returns {Bounds2}
     */
    roundedIn: function() {
      return new Bounds2(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY )
      );
    },

    /**
     * A bounding box (still axis-aligned) that contains the transformed shape of this bounds, applying the matrix as
     * an affine transformation.
     * @pubic
     *
     * NOTE: bounds.transformed( matrix ).transformed( inverse ) may be larger than the original box, if it includes
     * a rotation that isn't a multiple of $\pi/2$. This is because the returned bounds may expand in area to cover
     * ALL of the corners of the transformed bounding box.
     *
     * This is the immutable form of the function transform(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    transformed: function( matrix ) {
      return this.copy().transform( matrix );
    },

    /**
     * A bounding box that is expanded on all sides by the specified amount.)
     * @public
     *
     * This is the immutable form of the function dilate(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} d
     * @returns {Bounds2}
     */
    dilated: function( d ) {
      return new Bounds2( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
    },

    /**
     * A bounding box that is expanded horizontally (on the left and right) by the specified amount.
     * @public
     *
     * This is the immutable form of the function dilateX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    dilatedX: function( x ) {
      return new Bounds2( this.minX - x, this.minY, this.maxX + x, this.maxY );
    },

    /**
     * A bounding box that is expanded vertically (on the top and bottom) by the specified amount.
     * @public
     *
     * This is the immutable form of the function dilateY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    dilatedY: function( y ) {
      return new Bounds2( this.minX, this.minY - y, this.maxX, this.maxY + y );
    },

    /**
     * A bounding box that is expanded on all sides, with different amounts of expansion horizontally and vertically.
     * Will be identical to the bounds returned by calling bounds.dilatedX( x ).dilatedY( y ).
     * @public
     *
     * This is the immutable form of the function dilateXY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x - Amount to dilate horizontally (for each side)
     * @param {number} y - Amount to dilate vertically (for each side)
     * @returns {Bounds2}
     */
    dilatedXY: function( x, y ) {
      return new Bounds2( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
    },

    /**
     * A bounding box that is contracted on all sides by the specified amount.
     * @public
     *
     * This is the immutable form of the function erode(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} amount
     * @returns {Bounds2}
     */
    eroded: function( d ) { return this.dilated( -d ); },

    /**
     * A bounding box that is contracted horizontally (on the left and right) by the specified amount.
     * @public
     *
     * This is the immutable form of the function erodeX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    erodedX: function( x ) { return this.dilatedX( -x ); },

    /**
     * A bounding box that is contracted vertically (on the top and bottom) by the specified amount.
     * @public
     *
     * This is the immutable form of the function erodeY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    erodedY: function( y ) { return this.dilatedY( -y ); },

    /**
     * A bounding box that is contracted on all sides, with different amounts of contraction horizontally and vertically.
     * @public
     *
     * This is the immutable form of the function erodeXY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x - Amount to erode horizontally (for each side)
     * @param {number} y - Amount to erode vertically (for each side)
     * @returns {Bounds2}
     */
    erodedXY: function( x, y ) { return this.dilatedXY( -x, -y ); },

    /**
     * A bounding box that is expanded by a specific amount on all sides (or if some offsets are negative, will contract
     * those sides).
     * @public
     *
     * This is the immutable form of the function offset(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} left - Amount to expand to the left (subtracts from minX)
     * @param {number} top - Amount to expand to the top (subtracts from minY)
     * @param {number} right - Amount to expand to the right (adds to maxX)
     * @param {number} bottom - Amount to expand to the bottom (adds to maxY)
     * @returns {Bounds2}
     */
    withOffsets: function( left, top, right, bottom ) {
      return new Bounds2( this.minX - left, this.minY - top, this.maxX + right, this.maxY + bottom );
    },

    /**
     * Our bounds, translated horizontally by x, returned as a copy.
     * @public
     *
     * This is the immutable form of the function shiftX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    shiftedX: function( x ) {
      return new Bounds2( this.minX + x, this.minY, this.maxX + x, this.maxY );
    },

    /**
     * Our bounds, translated vertically by y, returned as a copy.
     * @public
     *
     * This is the immutable form of the function shiftY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    shiftedY: function( y ) {
      return new Bounds2( this.minX, this.minY + y, this.maxX, this.maxY + y );
    },

    /**
     * Our bounds, translated by (x,y), returned as a copy.
     * @public
     *
     * This is the immutable form of the function shift(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    shifted: function( x, y ) {
      return new Bounds2( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
    },

    /*---------------------------------------------------------------------------*
     * Mutable operations
     *
     * All mutable operations should call one of the following:
     *   setMinMax, setMinX, setMinY, setMaxX, setMaxY
     *---------------------------------------------------------------------------*/

    /**
     * Sets each value for this bounds, and returns itself.
     * @public
     *
     * @param {number} minX
     * @param {number} minY
     * @param {number} maxX
     * @param {number} maxY
     * @returns {Bounds2}
     */
    setMinMax: function( minX, minY, maxX, maxY ) {
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
      return this;
    },

    /**
     * Sets the value of minX.
     * @public
     *
     * This is the mutable form of the function withMinX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} minX
     * @returns {Bounds2}
     */
    setMinX: function( minX ) {
      this.minX = minX;
      return this;
    },

    /**
     * Sets the value of minY.
     * @public
     *
     * This is the mutable form of the function withMinY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} minY
     * @returns {Bounds2}
     */
    setMinY: function( minY ) {
      this.minY = minY;
      return this;
    },

    /**
     * Sets the value of maxX.
     * @public
     *
     * This is the mutable form of the function withMaxX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} maxX
     * @returns {Bounds2}
     */
    setMaxX: function( maxX ) {
      this.maxX = maxX;
      return this;
    },

    /**
     * Sets the value of maxY.
     * @public
     *
     * This is the mutable form of the function withMaxY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} maxY
     * @returns {Bounds2}
     */
    setMaxY: function( maxY ) {
      this.maxY = maxY;
      return this;
    },

    /**
     * Sets the values of this bounds to be equal to the input bounds.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    set: function( bounds ) {
      return this.setMinMax( bounds.minX, bounds.minY, bounds.maxX, bounds.maxY );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input bounds.
     * @public
     *
     * This is the mutable form of the function union(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    includeBounds: function( bounds ) {
      return this.setMinMax(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY )
      );
    },

    /**
     * Modifies this bounds so that it is the largest bounds contained both in its original bounds and in the input bounds.
     * @public
     *
     * This is the mutable form of the function intersection(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    constrainBounds: function( bounds ) {
      return this.setMinMax(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY )
      );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input point (x,y).
     * @public
     *
     * This is the mutable form of the function withCoordinates(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    addCoordinates: function( x, y ) {
      return this.setMinMax(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y )
      );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input point.
     * @public
     *
     * This is the mutable form of the function withPoint(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Vector2} point
     * @returns {Bounds2}
     */
    addPoint: function( point ) {
      return this.addCoordinates( point.x, point.y );
    },

    /**
     * Modifies this bounds so that its boundaries are integer-aligned, rounding the minimum boundaries down and the
     * maximum boundaries up (expanding as necessary).
     * @public
     *
     * This is the mutable form of the function roundedOut(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @returns {Bounds2}
     */
    roundOut: function() {
      return this.setMinMax(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY )
      );
    },

    /**
     * Modifies this bounds so that its boundaries are integer-aligned, rounding the minimum boundaries up and the
     * maximum boundaries down (contracting as necessary).
     * @public
     *
     * This is the mutable form of the function roundedIn(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @returns {Bounds2}
     */
    roundIn: function() {
      return this.setMinMax(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY )
      );
    },

    /**
     * Modifies this bounds so that it would fully contain a transformed version if its previous value, applying the
     * matrix as an affine transformation.
     * @pubic
     *
     * NOTE: bounds.transform( matrix ).transform( inverse ) may be larger than the original box, if it includes
     * a rotation that isn't a multiple of $\pi/2$. This is because the bounds may expand in area to cover
     * ALL of the corners of the transformed bounding box.
     *
     * This is the mutable form of the function transformed(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    transform: function( matrix ) {
      // if we contain no area, no change is needed
      if ( this.isEmpty() ) {
        return this;
      }

      // optimization to bail for identity matrices
      if ( matrix.isIdentity() ) {
        return this;
      }

      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.set( dot.Bounds2.NOTHING );

      // using mutable vector so we don't create excessive instances of Vector2 during this
      // make sure all 4 corners are inside this transformed bounding box

      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, minY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, maxY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, minY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, maxY ) ) );
      return this;
    },

    /**
     * Expands this bounds on all sides by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilated(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} d
     * @returns {Bounds2}
     */
    dilate: function( d ) {
      return this.setMinMax( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
    },

    /**
     * Expands this bounds horizontally (left and right) by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilatedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    dilateX: function( x ) {
      return this.setMinMax( this.minX - x, this.minY, this.maxX + x, this.maxY );
    },

    /**
     * Expands this bounds vertically (top and bottom) by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilatedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    dilateY: function( y ) {
      return this.setMinMax( this.minX, this.minY - y, this.maxX, this.maxY + y );
    },

    /**
     * Expands this bounds independently in the horizontal and vertical directions. Will be equal to calling
     * bounds.dilateX( x ).dilateY( y ).
     * @public
     *
     * This is the mutable form of the function dilatedXY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    dilateXY: function( x, y ) {
      return this.setMinMax( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
    },

    /**
     * Contracts this bounds on all sides by the specified amount.
     * @public
     *
     * This is the mutable form of the function eroded(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} d
     * @returns {Bounds2}
     */
    erode: function( d ) { return this.dilate( -d ); },

    /**
     * Contracts this bounds horizontally (left and right) by the specified amount.
     * @public
     *
     * This is the mutable form of the function erodedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    erodeX: function( x ) { return this.dilateX( -x ); },

    /**
     * Contracts this bounds vertically (top and bottom) by the specified amount.
     * @public
     *
     * This is the mutable form of the function erodedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    erodeY: function( y ) { return this.dilateY( -y ); },

    /**
     * Contracts this bounds independently in the horizontal and vertical directions. Will be equal to calling
     * bounds.erodeX( x ).erodeY( y ).
     * @public
     *
     * This is the mutable form of the function erodedXY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    erodeXY: function( x, y ) { return this.dilateXY( -x, -y ); },

    /**
     * Expands this bounds independently for each side (or if some offsets are negative, will contract those sides).
     * @public
     *
     * This is the mutable form of the function withOffsets(). This will mutate (change) this bounds, in addition to
     * returning this bounds itself.
     *
     * @param {number} left - Amount to expand to the left (subtracts from minX)
     * @param {number} top - Amount to expand to the top (subtracts from minY)
     * @param {number} right - Amount to expand to the right (adds to maxX)
     * @param {number} bottom - Amount to expand to the bottom (adds to maxY)
     * @returns {Bounds2}
     */
    offset: function( left, top, right, bottom ) {
      return new Bounds2( this.minX - left, this.minY - top, this.maxX + right, this.maxY + bottom );
    },

    /**
     * Translates our bounds horizontally by x.
     * @public
     *
     * This is the mutable form of the function shiftedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    shiftX: function( x ) {
      return this.setMinMax( this.minX + x, this.minY, this.maxX + x, this.maxY );
    },

    /**
     * Translates our bounds vertically by y.
     * @public
     *
     * This is the mutable form of the function shiftedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    shiftY: function( y ) {
      return this.setMinMax( this.minX, this.minY + y, this.maxX, this.maxY + y );
    },

    /**
     * Translates our bounds by (x,y).
     * @public
     *
     * This is the mutable form of the function shifted(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    shift: function( x, y ) {
      return this.setMinMax( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
    },

    /**
     * Find a point in the bounds closest to the specified point.
     * @public
     *
     * @param {number} x - X coordinate of the point to test.
     * @param {number} y - Y coordinate of the point to test.
     * @param {Vector2} [result] - Vector2 that can store the return value to avoid allocations.
     * @returns {Vector2}
     */
    getClosestPoint: function( x, y, result ) {
      if ( result ) {
        result.setXY( x, y );
      }
      else {
        result = new dot.Vector2( x, y );
      }
      if ( result.x < this.minX ) { result.x = this.minX; }
      if ( result.x > this.maxX ) { result.x = this.maxX; }
      if ( result.y < this.minY ) { result.y = this.minY; }
      if ( result.y > this.maxY ) { result.y = this.maxY; }
      return result;
    }
  }, {
    /**
     * Returns a new Bounds2 object, with the familiar rectangle construction with x, y, width, and height.
     * @public
     *
     * @param {number} x - The minimum value of X for the bounds.
     * @param {number} y - The minimum value of Y for the bounds.
     * @param {number} width - The width (maxX - minX) of the bounds.
     * @param {number} height - The height (maxY - minY) of the bounds.
     * @returns {Bounds2}
     */
    rect: function( x, y, width, height ) {
      return new Bounds2( x, y, x + width, y + height );
    },

    /**
     * Returns a new Bounds2 object that only contains the specified point (x,y). Useful for being dilated to form a
     * bounding box around a point. Note that the bounds will not be "empty" as it contains (x,y), but it will have
     * zero area.
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    point: function( x, y ) {
      if ( x instanceof dot.Vector2 ) {
        var p = x;
        return new Bounds2( p.x, p.y, p.x, p.y );
      }
      else {
        return new Bounds2( x, y, x, y );
      }
    }
  } );

  Poolable.mixin( Bounds2, {
    defaultFactory: function() { return Bounds2.NOTHING.copy(); },
    constructorDuplicateFactory: function( pool ) {
      return function( minX, minY, maxX, maxY ) {
        if ( pool.length ) {
          return pool.pop().setMinMax( minX, minY, maxX, maxY );
        }
        else {
          return new Bounds2( minX, minY, maxX, maxY );
        }
      };
    }
  } );

  /**
   * A contant Bounds2 with minimums = $\infty$, maximums = $-\infty$, so that it represents "no bounds whatsoever".
   * @public
   *
   * This allows us to take the union (union/includeBounds) of this and any other Bounds2 to get the other bounds back,
   * e.g. Bounds2.NOTHING.union( bounds ).equals( bounds ). This object naturally serves as the base case as a union of
   * zero bounds objects.
   *
   * Additionally, intersections with NOTHING will always return a Bounds2 equivalent to NOTHING.
   *
   * @constant {Bounds2} NOTHING
   */
  Bounds2.NOTHING = new Bounds2( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );

  /**
   * A contant Bounds2 with minimums = $-\infty$, maximums = $\infty$, so that it represents "all bounds".
   * @public
   *
   * This allows us to take the intersection (intersection/constrainBounds) of this and any other Bounds2 to get the
   * other bounds back, e.g. Bounds2.EVERYTHING.intersection( bounds ).equals( bounds ). This object naturally serves as
   * the base case as an intersection of zero bounds objects.
   *
   * Additionally, unions with EVERYTHING will always return a Bounds2 equivalent to EVERYTHING.
   *
   * @constant {Bounds2} EVERYTHING
   */
  Bounds2.EVERYTHING = new Bounds2( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );

  function catchImmutableSetterLowHangingFruit( bounds ) {
    bounds.setMinMax = function() { throw new Error( 'Attempt to set \"setMinMax\" of an immutable Bounds2 object' ); };
    bounds.set = function() { throw new Error( 'Attempt to set \"set\" of an immutable Bounds2 object' ); };
    bounds.includeBounds = function() { throw new Error( 'Attempt to set \"includeBounds\" of an immutable Bounds2 object' ); };
    bounds.constrainBounds = function() { throw new Error( 'Attempt to set \"constrainBounds\" of an immutable Bounds2 object' ); };
    bounds.addCoordinates = function() { throw new Error( 'Attempt to set \"addCoordinates\" of an immutable Bounds2 object' ); };
    bounds.transform = function() { throw new Error( 'Attempt to set \"transform\" of an immutable Bounds2 object' ); };
  }

  if ( assert ) {
    catchImmutableSetterLowHangingFruit( Bounds2.EVERYTHING );
    catchImmutableSetterLowHangingFruit( Bounds2.NOTHING );
  }

  return Bounds2;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Basic width and height, like a Bounds2 but without the location defined.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Dimension2',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  require( 'DOT/Bounds2' );

  /**
   * Creates a 2-dimensional size with a width and height
   * @constructor
   * @public
   *
   * @param {number} width
   * @param {number} height
   */
  function Dimension2( width, height ) {
    // @public {number} - Width of the dimension
    this.width = width;

    // @public {number} - Height of the dimension
    this.height = height;
  }

  dot.register( 'Dimension2', Dimension2 );

  inherit( Object, Dimension2, {
    /**
     * Debugging string for the dimension.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return '[' + this.width + 'w, ' + this.height + 'h]';
    },

    /**
     * Sets this dimension to be a copy of another dimension.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this dimension, in addition to returning
     * this dimension itself.
     *
     * @param {Dimension2} dimension
     * @returns {Dimension2}
     */
    set: function( dimension ) {
      this.width = dimension.width;
      this.height = dimension.height;
      return this;
    },

    /**
     * Sets the width of the dimension, returning this.
     * @public
     *
     * @param {number} width
     * @returns {Dimension2}
     */
    setWidth: function( width ) {
      this.width = width;
      return this;
    },

    /**
     * Sets the height of the dimension, returning this.
     * @public
     *
     * @param {number} height
     * @returns {Dimension2}
     */
    setHeight: function( height ) {
      this.height = height;
      return this;
    },

    /**
     * Creates a copy of this dimension, or if a dimension is passed in, set that dimension's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a dimension is provided. This will return a new dimension,
     * and will not modify this dimension.
     *
     * @param {Dimension2} [dimension] - If not provided, creates a new Vector2 with filled in values. Otherwise, fills
     *                                   in the values of the provided dimension so that it equals this dimension.
     * @returns {Dimension2}
     */
    copy: function( dimension ) {
      if ( dimension ) {
        return dimension.set( this );
      }
      else {
        return new Dimension2( this.width, this.height );
      }
    },

    /**
     * Creates a Bounds2 from this dimension based on passing in the minimum (top-left) corner as (x,y).
     * @public
     *
     * @param {number} [x] - Minimum x coordinate of the bounds, or 0 if not provided.
     * @param {number} [y] - Minimum y coordinate of the bounds, or 0 if not provided.
     * @returns {Bounds2}
     */
    toBounds: function( x, y ) {
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      return new dot.Bounds2( x, y, this.width + x, this.height + y );
    },

    /**
     * Exact equality comparison between this dimension and another dimension.
     * @public
     *
     * @param {Dimension2} other
     * @returns {boolean} - Whether the two dimensions have equal width and height
     */
    equals: function( other ) {
      return this.width === other.width && this.height === other.height;
    }
  } );

  return Dimension2;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Basic 4-dimensional vector, represented as (x,y).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Vector4',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  require( 'DOT/Util' );
  // require( 'DOT/Vector3' ); // commented out so Require.js doesn't complain about the circular dependency

  /**
   * Creates a 4-dimensional vector with the specified X, Y, Z and W values.
   * @constructor
   * @public
   *
   * @param {number} [x] - X coordinate, defaults to 0 if not provided
   * @param {number} [y] - Y coordinate, defaults to 0 if not provided
   * @param {number} [z] - Z coordinate, defaults to 0 if not provided
   * @param {number} [w] - W coordinate, defaults to 1 if not provided (convenience for homogeneous coordinates)
   */
  function Vector4( x, y, z, w ) {
    // @public {number} - The X coordinate of the vector.
    this.x = x !== undefined ? x : 0;

    // @public {number} - The Y coordinate of the vector.
    this.y = y !== undefined ? y : 0;

    // @public {number} - The Z coordinate of the vector.
    this.z = z !== undefined ? z : 0;

    // @public {number} - The W coordinate of the vector. Default is 1, for ease with homogeneous coordinates.
    this.w = w !== undefined ? w : 1;

    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );
    assert && assert( typeof this.z === 'number', 'z needs to be a number' );
    assert && assert( typeof this.w === 'number', 'w needs to be a number' );

    phetAllocation && phetAllocation( 'Vector4' );
  }

  dot.register( 'Vector4', Vector4 );

  inherit( Object, Vector4, {
    // @public (read-only) - Helps to identify the dimension of the vector
    isVector4: true,
    dimension: 4,

    /**
     * The magnitude (Euclidean/L2 Norm) of this vector, i.e. $\sqrt{x^2+y^2+z^2+w^2}$.
     * @public
     *
     * @returns {number}
     */
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    /**
     * The squared magnitude (square of the Euclidean/L2 Norm) of this vector, i.e. $x^2+y^2+z^2+w^2$.
     * @public
     *
     * @returns {number}
     */
    magnitudeSquared: function() {
      this.dot( this );
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector4} point
     * @returns {number}
     */
    distance: function( point ) {
      return this.minus( point ).magnitude();
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point (x,y,z,w).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {number}
     */
    distanceXYZW: function( x, y, z, w ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      var dw = this.w - w;
      return Math.sqrt( dx * dx + dy * dy + dz * dz + dw * dw );
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector4} point
     * @returns {number}
     */
    distanceSquared: function( point ) {
      return this.minus( point ).magnitudeSquared();
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point (x,y,z,w).
     * @public
     *
     * @param {Vector4} point
     * @returns {number}
     */
    distanceSquaredXYZW: function( x, y, z, w ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      var dw = this.w - w;
      return dx * dx + dy * dy + dz * dz + dw * dw;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector v.
     * @public
     *
     * @param {Vector4} v
     * @returns {number}
     */
    dot: function( v ) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector (x,y,z,w).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {number}
     */
    dotXYZW: function( x, y, z, w ) {
      return this.x * x + this.y * y + this.z * z + this.w * w;
    },

    /**
     * The angle between this vector and another vector, in the range $\theta\in[0, \pi]$.
     * @public
     *
     * Equal to $\theta = \cos^{-1}( \hat{u} \cdot \hat{v} )$ where $\hat{u}$ is this vector (normalized) and $\hat{v}$
     * is the input vector (normalized).
     *
     * @param {Vector4} v
     * @returns {number}
     */
    angleBetween: function( v ) {
      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
    },

    /**
     * Exact equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector4} other
     * @returns {boolean} - Whether the two vectors have equal components
     */
    equals: function( other ) {
      return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
    },

    /**
     * Approximate equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector4} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two vectors has no component with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) + Math.abs( this.w - other.w ) <= epsilon;
    },

    /**
     * Whether all of the components are numbers (not NaN) that are not infinity or -infinity.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z ) && isFinite( this.w );
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this vector, or if a vector is passed in, set that vector's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a vector is provided. This will return a new vector, and
     * will not modify this vector.
     *
     * @param {Vector4} [vector] - If not provided, creates a new Vector4 with filled in values. Otherwise, fills in the
     *                             values of the provided vector so that it equals this vector.
     * @returns {Vector4}
     */
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector4( this.x, this.y, this.z, this.w );
      }
    },

    /**
     * Normalized (re-scaled) copy of this vector such that its magnitude is 1. If its initial magnitude is zero, an
     * error is thrown.
     * @public
     *
     * This is the immutable form of the function normalize(). This will return a new vector, and will not modify this
     * vector.
     *
     * @returns {Vector4}
     */
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return new Vector4( this.x / mag, this.y / mag, this.z / mag, this.w / mag );
      }
    },

    /**
     * Re-scaled copy of this vector such that it has the desired magnitude. If its initial magnitude is zero, an error
     * is thrown. If the passed-in magnitude is negative, the direction of the resulting vector will be reversed.
     * @public
     *
     * This is the immutable form of the function setMagnitude(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} magnitude
     * @returns {Vector4}
     */
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },

    /**
     * Copy of this vector, scaled by the desired scalar value.
     * @public
     *
     * This is the immutable form of the function multiplyScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    timesScalar: function( scalar ) {
      return new Vector4( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
    },

    /**
     * Same as timesScalar.
     * @public
     *
     * This is the immutable form of the function multiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },

    /**
     * Copy of this vector, multiplied component-wise by the passed-in vector v.
     * @public
     *
     * This is the immutable form of the function componentMultiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    componentTimes: function( v ) {
      return new Vector4( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
    },

    /**
     * Addition of this vector and another vector, returning a copy.
     * @public
     *
     * This is the immutable form of the function add(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    plus: function( v ) {
      return new Vector4( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
    },

    /**
     * Addition of this vector and another vector (x,y,z,w), returning a copy.
     * @public
     *
     * This is the immutable form of the function addXYZW(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    plusXYZW: function( x, y, z, w ) {
      return new Vector4( this.x + x, this.y + y, this.z + z, this.w + w );
    },

    /**
     * Addition of this vector with a scalar (adds the scalar to every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function addScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    plusScalar: function( scalar ) {
      return new Vector4( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
    },

    /**
     * Subtraction of this vector by another vector v, returning a copy.
     * @public
     *
     * This is the immutable form of the function subtract(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    minus: function( v ) {
      return new Vector4( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
    },

    /**
     * Subtraction of this vector by another vector (x,y,z,w), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractXYZW(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    minusXYZW: function( x, y, z, w ) {
      return new Vector4( this.x - x, this.y - y, this.z - z, this.w - w );
    },

    /**
     * Subtraction of this vector by a scalar (subtracts the scalar from every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    minusScalar: function( scalar ) {
      return new Vector4( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
    },

    /**
     * Division of this vector by a scalar (divides every component by the scalar), returning a copy.
     * @public
     *
     * This is the immutable form of the function divideScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    dividedScalar: function( scalar ) {
      return new Vector4( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
    },

    /**
     * Negated copy of this vector (multiplies every component by -1).
     * @public
     *
     * This is the immutable form of the function negate(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector4}
     */
    negated: function() {
      return new Vector4( -this.x, -this.y, -this.z, -this.w );
    },

    /**
     * A linear interpolation between this vector (ratio=0) and another vector (ratio=1).
     * @public
     *
     * @param {Vector4} vector
     * @param {number} ratio - Not necessarily constrained in [0, 1]
     * @returns {Vector4}
     */
    blend: function( vector, ratio ) {
      return this.plus( vector.minus( this ).times( ratio ) );
    },

    /**
     * The average (midpoint) between this vector and another vector.
     * @public
     *
     * @param {Vector4} vector
     * @returns {Vector4}
     */
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },

    /**
     * Debugging string for the vector.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return 'Vector4(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
    },

    /**
     * Converts this to a 3-dimensional vector, discarding the w-component.
     * @public
     *
     * @returns {Vector3}
     */
    toVector3: function() {
      return new dot.Vector3( this.x, this.y, this.z );
    },

    /*---------------------------------------------------------------------------*
     * Mutables
     * - all mutation should go through setXYZW / setX / setY / setZ / setW
     *---------------------------------------------------------------------------*/

    /**
     * Sets all of the components of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    setXYZW: function( x, y, z, w ) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    },

    /**
     * Sets the x-component of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @returns {Vector4}
     */
    setX: function( x ) {
      this.x = x;
      return this;
    },

    /**
     * Sets the y-component of this vector, returning this.
     * @public
     *
     * @param {number} y
     * @returns {Vector4}
     */
    setY: function( y ) {
      this.y = y;
      return this;
    },

    /**
     * Sets the z-component of this vector, returning this.
     * @public
     *
     * @param {number} z
     * @returns {Vector4}
     */
    setZ: function( z ) {
      this.z = z;
      return this;
    },

    /**
     * Sets the w-component of this vector, returning this.
     * @public
     *
     * @param {number} w
     * @returns {Vector4}
     */
    setW: function( w ) {
      this.w = w;
      return this;
    },

    /**
     * Sets this vector to be a copy of another vector.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this vector, in addition to returning
     * this vector itself.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    set: function( v ) {
      return this.setXYZW( v.x, v.y, v.z, v.w );
    },

    /**
     * Sets the magnitude of this vector. If the passed-in magnitude is negative, this flips the vector and sets its
     * magnitude to abs( magnitude ).
     * @public
     *
     * This is the mutable form of the function withMagnitude(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} magnitude
     * @returns {Vector4}
     */
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },

    /**
     * Adds another vector to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    add: function( v ) {
      return this.setXYZW( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
    },

    /**
     * Adds another vector (x,y,z,w) to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plusXYZW(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    addXYZW: function( x, y, z, w ) {
      return this.setXYZW( this.x + x, this.y + y, this.z + z, this.w + w );
    },

    /**
     * Adds a scalar to this vector (added to every component), changing this vector.
     * @public
     *
     * This is the mutable form of the function plusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    addScalar: function( scalar ) {
      return this.setXYZW( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
    },

    /**
     * Subtracts this vector by another vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function minus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    subtract: function( v ) {
      return this.setXYZW( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
    },

    /**
     * Subtracts this vector by another vector (x,y,z,w), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusXYZW(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    subtractXYZW: function( x, y, z, w ) {
      return this.setXYZW( this.x - x, this.y - y, this.z - z, this.w - w );
    },

    /**
     * Subtracts this vector by a scalar (subtracts each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    subtractScalar: function( scalar ) {
      return this.setXYZW( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function timesScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    multiplyScalar: function( scalar ) {
      return this.setXYZW( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * Same as multiplyScalar.
     * @public
     *
     * This is the mutable form of the function times(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },

    /**
     * Multiplies this vector by another vector component-wise, changing this vector.
     * @public
     *
     * This is the mutable form of the function componentTimes(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    componentMultiply: function( v ) {
      return this.setXYZW( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
    },

    /**
     * Divides this vector by a scalar (divides each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function dividedScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    divideScalar: function( scalar ) {
      return this.setXYZW( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
    },

    /**
     * Negates this vector (multiplies each component by -1), changing this vector.
     * @public
     *
     * This is the mutable form of the function negated(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector4}
     */
    negate: function() {
      return this.setXYZW( -this.x, -this.y, -this.z, -this.w );
    },

    /**
     * Normalizes this vector (rescales to where the magnitude is 1), changing this vector.
     * @public
     *
     * This is the mutable form of the function normalized(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector4}
     */
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return this.divideScalar( mag );
      }
      return this;
    }
  } );

  // Sets up pooling on Vector4
  Poolable.mixin( Vector4, {
    defaultFactory: function() { return new Vector4(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y, z, w ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y, z, w );
        }
        else {
          return new Vector4( x, y, z, w );
        }
      };
    }
  } );

  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *---------------------------------------------------------------------------*/

  // @private
  Vector4.Immutable = function( x, y, z, w ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
    this.w = w !== undefined ? w : 1;
  };
  var Immutable = Vector4.Immutable;

  inherit( Vector4, Immutable );

  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector4' );
    };
  };

  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXYZW' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Immutable.mutableOverrideHelper( 'setZ' );
  Immutable.mutableOverrideHelper( 'setW' );

  // @public {Vector4} - helpful immutable constants
  Vector4.ZERO = assert ? new Immutable( 0, 0, 0, 0 ) : new Vector4( 0, 0, 0, 0 );
  Vector4.X_UNIT = assert ? new Immutable( 1, 0, 0, 0 ) : new Vector4( 1, 0, 0, 0 );
  Vector4.Y_UNIT = assert ? new Immutable( 0, 1, 0, 0 ) : new Vector4( 0, 1, 0, 0 );
  Vector4.Z_UNIT = assert ? new Immutable( 0, 0, 1, 0 ) : new Vector4( 0, 0, 1, 0 );
  Vector4.W_UNIT = assert ? new Immutable( 0, 0, 0, 1 ) : new Vector4( 0, 0, 0, 1 );

  return Vector4;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Basic 3-dimensional vector, represented as (x,y).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Vector3',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util','DOT/Vector2','DOT/Vector4'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  require( 'DOT/Util' );
  require( 'DOT/Vector2' );
  require( 'DOT/Vector4' );

  /**
   * Creates a 3-dimensional vector with the specified X, Y and Z values.
   * @constructor
   * @public
   *
   * @param {number} [x] - X coordinate, defaults to 0 if not provided
   * @param {number} [y] - Y coordinate, defaults to 0 if not provided
   * @param {number} [z] - Z coordinate, defaults to 0 if not provided
   */
  function Vector3( x, y, z ) {
    // @public {number} - The X coordinate of the vector.
    this.x = x !== undefined ? x : 0;

    // @public {number} - The Y coordinate of the vector.
    this.y = y !== undefined ? y : 0;

    // @public {number} - The Z coordinate of the vector.
    this.z = z !== undefined ? z : 0;

    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );
    assert && assert( typeof this.z === 'number', 'z needs to be a number' );

    phetAllocation && phetAllocation( 'Vector3' );
  }

  dot.register( 'Vector3', Vector3 );

  inherit( Object, Vector3, {
    // @public (read-only) - Helps to identify the dimension of the vector
    isVector3: true,
    dimension: 3,

    /**
     * The magnitude (Euclidean/L2 Norm) of this vector, i.e. $\sqrt{x^2+y^2+z^2}$.
     * @public
     *
     * @returns {number}
     */
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    /**
     * T squared magnitude (square of the Euclidean/L2 Norm) of this vector, i.e. $x^2+y^2+z^2$.
     * @public
     *
     * @returns {number}
     */
    magnitudeSquared: function() {
      return this.dot( this );
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector3} point
     * @returns {number}
     */
    distance: function( point ) {
      return Math.sqrt( this.distanceSquared( point ) );
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point (x,y,z).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {number}
     */
    distanceXYZ: function( x, y, z ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      return Math.sqrt( dx * dx + dy * dy + dz * dz );
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector3} point
     * @returns {number}
     */
    distanceSquared: function( point ) {
      var dx = this.x - point.x;
      var dy = this.y - point.y;
      var dz = this.z - point.z;
      return dx * dx + dy * dy + dz * dz;
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point (x,y,z).
     * @public
     *
     * @param {Vector3} point
     * @returns {number}
     */
    distanceSquaredXYZ: function( x, y, z ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      return dx * dx + dy * dy + dz * dz;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector v.
     * @public
     *
     * @param {Vector3} v
     * @returns {number}
     */
    dot: function( v ) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector (x,y,z).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {number}
     */
    dotXYZ: function( x, y, z ) {
      return this.x * x + this.y * y + this.z * z;
    },

    /**
     * The angle between this vector and another vector, in the range $\theta\in[0, \pi]$.
     * @public
     *
     * Equal to $\theta = \cos^{-1}( \hat{u} \cdot \hat{v} )$ where $\hat{u}$ is this vector (normalized) and $\hat{v}$
     * is the input vector (normalized).
     *
     * @param {Vector3} v
     * @returns {number}
     */
    angleBetween: function( v ) {
      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
    },

    /**
     * Exact equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector3} other
     * @returns {boolean} - Whether the two vectors have equal components
     */
    equals: function( other ) {
      return this.x === other.x && this.y === other.y && this.z === other.z;
    },

    /**
     * Approximate equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector3} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two vectors has no component with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) <= epsilon;
    },

    /**
     * Whether all of the components are numbers (not NaN) that are not infinity or -infinity.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z );
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this vector, or if a vector is passed in, set that vector's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a vector is provided. This will return a new vector, and
     * will not modify this vector.
     *
     * @param {Vector3} [vector] - If not provided, creates a new Vector3 with filled in values. Otherwise, fills in the
     *                             values of the provided vector so that it equals this vector.
     * @returns {Vector3}
     */
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector3( this.x, this.y, this.z );
      }
    },

    /**
     * The Euclidean 3-dimensional cross-product of this vector by the passed-in vector.
     * @public
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    cross: function( v ) {
      return new Vector3(
        this.y * v.z - this.z * v.y,
        this.z * v.x - this.x * v.z,
        this.x * v.y - this.y * v.x
      );
    },

    /**
     * Normalized (re-scaled) copy of this vector such that its magnitude is 1. If its initial magnitude is zero, an
     * error is thrown.
     * @public
     *
     * This is the immutable form of the function normalize(). This will return a new vector, and will not modify this
     * vector.
     *
     * @returns {Vector3}
     */
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return new Vector3( this.x / mag, this.y / mag, this.z / mag );
      }
    },

    /**
     * Re-scaled copy of this vector such that it has the desired magnitude. If its initial magnitude is zero, an error
     * is thrown. If the passed-in magnitude is negative, the direction of the resulting vector will be reversed.
     * @public
     *
     * This is the immutable form of the function setMagnitude(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} magnitude
     * @returns {Vector3}
     */
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },

    /**
     * Copy of this vector, scaled by the desired scalar value.
     * @public
     *
     * This is the immutable form of the function multiplyScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    timesScalar: function( scalar ) {
      return new Vector3( this.x * scalar, this.y * scalar, this.z * scalar );
    },

    /**
     * Same as timesScalar.
     * @public
     *
     * This is the immutable form of the function multiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },

    /**
     * Copy of this vector, multiplied component-wise by the passed-in vector v.
     * @public
     *
     * This is the immutable form of the function componentMultiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    componentTimes: function( v ) {
      return new Vector3( this.x * v.x, this.y * v.y, this.z * v.z );
    },

    /**
     * Addition of this vector and another vector, returning a copy.
     * @public
     *
     * This is the immutable form of the function add(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    plus: function( v ) {
      return new Vector3( this.x + v.x, this.y + v.y, this.z + v.z );
    },

    /**
     * Addition of this vector and another vector (x,y,z), returning a copy.
     * @public
     *
     * This is the immutable form of the function addXYZ(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    plusXYZ: function( x, y, z ) {
      return new Vector3( this.x + x, this.y + y, this.z + z );
    },

    /**
     * Addition of this vector with a scalar (adds the scalar to every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function addScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    plusScalar: function( scalar ) {
      return new Vector3( this.x + scalar, this.y + scalar, this.z + scalar );
    },

    /**
     * Subtraction of this vector by another vector v, returning a copy.
     * @public
     *
     * This is the immutable form of the function subtract(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    minus: function( v ) {
      return new Vector3( this.x - v.x, this.y - v.y, this.z - v.z );
    },

    /**
     * Subtraction of this vector by another vector (x,y,z), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractXYZ(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    minusXYZ: function( x, y, z ) {
      return new Vector3( this.x - x, this.y - y, this.z - z );
    },

    /**
     * Subtraction of this vector by a scalar (subtracts the scalar from every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    minusScalar: function( scalar ) {
      return new Vector3( this.x - scalar, this.y - scalar, this.z - scalar );
    },

    /**
     * Division of this vector by a scalar (divides every component by the scalar), returning a copy.
     * @public
     *
     * This is the immutable form of the function divideScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    dividedScalar: function( scalar ) {
      return new Vector3( this.x / scalar, this.y / scalar, this.z / scalar );
    },

    /**
     * Negated copy of this vector (multiplies every component by -1).
     * @public
     *
     * This is the immutable form of the function negate(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector3}
     */
    negated: function() {
      return new Vector3( -this.x, -this.y, -this.z );
    },

    /**
     * A linear interpolation between this vector (ratio=0) and another vector (ratio=1).
     * @public
     *
     * @param {Vector3} vector
     * @param {number} ratio - Not necessarily constrained in [0, 1]
     * @returns {Vector3}
     */
    blend: function( vector, ratio ) {
      return this.plus( vector.minus( this ).times( ratio ) );
    },

    /**
     * The average (midpoint) between this vector and another vector.
     * @public
     *
     * @param {Vector3} vector
     * @returns {Vector3}
     */
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },

    /**
     * Debugging string for the vector.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return 'Vector3(' + this.x + ', ' + this.y + ', ' + this.z + ')';
    },

    /**
     * Converts this to a 2-dimensional vector, discarding the z-component.
     * @public
     *
     * @returns {Vector2}
     */
    toVector2: function() {
      return new dot.Vector2( this.x, this.y );
    },

    /**
     * Converts this to a 4-dimensional vector, with the z-component equal to 1 (useful for homogeneous coordinates).
     * @public
     *
     * @returns {Vector4}
     */
    toVector4: function() {
      return new dot.Vector4( this.x, this.y, this.z, 1 );
    },

    /*---------------------------------------------------------------------------*
     * Mutables
     * - all mutation should go through setXYZ / setX / setY / setZ
     *---------------------------------------------------------------------------*/

    /**
     * Sets all of the components of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    setXYZ: function( x, y, z ) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    },

    /**
     * Sets the x-component of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @returns {Vector3}
     */
    setX: function( x ) {
      this.x = x;
      return this;
    },

    /**
     * Sets the y-component of this vector, returning this.
     * @public
     *
     * @param {number} y
     * @returns {Vector3}
     */
    setY: function( y ) {
      this.y = y;
      return this;
    },

    /**
     * Sets the z-component of this vector, returning this.
     * @public
     *
     * @param {number} z
     * @returns {Vector3}
     */
    setZ: function( z ) {
      this.z = z;
      return this;
    },

    /**
     * Sets this vector to be a copy of another vector.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this vector, in addition to returning
     * this vector itself.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    set: function( v ) {
      return this.setXYZ( v.x, v.y, v.z );
    },

    /**
     * Sets the magnitude of this vector. If the passed-in magnitude is negative, this flips the vector and sets its
     * magnitude to abs( magnitude ).
     * @public
     *
     * This is the mutable form of the function withMagnitude(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} magnitude
     * @returns {Vector3}
     */
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },

    /**
     * Adds another vector to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    add: function( v ) {
      return this.setXYZ( this.x + v.x, this.y + v.y, this.z + v.z );
    },

    /**
     * Adds another vector (x,y,z) to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plusXYZ(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    addXYZ: function( x, y, z ) {
      return this.setXYZ( this.x + x, this.y + y, this.z + z );
    },

    /**
     * Adds a scalar to this vector (added to every component), changing this vector.
     * @public
     *
     * This is the mutable form of the function plusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    addScalar: function( scalar ) {
      return this.setXYZ( this.x + scalar, this.y + scalar, this.z + scalar );
    },

    /**
     * Subtracts this vector by another vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function minus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    subtract: function( v ) {
      return this.setXYZ( this.x - v.x, this.y - v.y, this.z - v.z );
    },

    /**
     * Subtracts this vector by another vector (x,y,z), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusXYZ(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    subtractXYZ: function( x, y, z ) {
      return this.setXYZ( this.x - x, this.y - y, this.z - z );
    },

    /**
     * Subtracts this vector by a scalar (subtracts each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    subtractScalar: function( scalar ) {
      return this.setXYZ( this.x - scalar, this.y - scalar, this.z - scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function timesScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    multiplyScalar: function( scalar ) {
      return this.setXYZ( this.x * scalar, this.y * scalar, this.z * scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * Same as multiplyScalar.
     * @public
     *
     * This is the mutable form of the function times(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },

    /**
     * Multiplies this vector by another vector component-wise, changing this vector.
     * @public
     *
     * This is the mutable form of the function componentTimes(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    componentMultiply: function( v ) {
      return this.setXYZ( this.x * v.x, this.y * v.y, this.z * v.z );
    },

    /**
     * Divides this vector by a scalar (divides each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function dividedScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    divideScalar: function( scalar ) {
      return this.setXYZ( this.x / scalar, this.y / scalar, this.z / scalar );
    },

    /**
     * Negates this vector (multiplies each component by -1), changing this vector.
     * @public
     *
     * This is the mutable form of the function negated(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector3}
     */
    negate: function() {
      return this.setXYZ( -this.x, -this.y, -this.z );
    },

    /**
     * Normalizes this vector (rescales to where the magnitude is 1), changing this vector.
     * @public
     *
     * This is the mutable form of the function normalized(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector3}
     */
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return this.divideScalar( mag );
      }
    }
  }, {
    /**
     * Spherical linear interpolation between two unit vectors.
     * @public
     *
     * @param {Vector3} start - Start unit vector
     * @param {Vector3} end - End unit vector
     * @param {number} ratio  - Between 0 (at start vector) and 1 (at end vector)
     * @return Spherical linear interpolation between the start and end
     */
    slerp: function( start, end, ratio ) {
      // NOTE: we can't create a require() loop here
      return dot.Quaternion.slerp( new dot.Quaternion(), dot.Quaternion.getRotationQuaternion( start, end ), ratio ).timesVector3( start );
    }
  } );

  // Sets up pooling on Vector3
  Poolable.mixin( Vector3, {
    defaultFactory: function() { return new Vector3(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y, z ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y, z );
        }
        else {
          return new Vector3( x, y, z );
        }
      };
    }
  } );

  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *---------------------------------------------------------------------------*/

  // @private
  Vector3.Immutable = function( x, y, z ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
  };
  var Immutable = Vector3.Immutable;

  inherit( Vector3, Immutable );

  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector3' );
    };
  };

  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXYZ' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Immutable.mutableOverrideHelper( 'setZ' );

  // @public {Vector3} - helpful immutable constants
  Vector3.ZERO = assert ? new Immutable( 0, 0, 0 ) : new Vector3( 0, 0, 0 );
  Vector3.X_UNIT = assert ? new Immutable( 1, 0, 0 ) : new Vector3( 1, 0, 0 );
  Vector3.Y_UNIT = assert ? new Immutable( 0, 1, 0 ) : new Vector3( 0, 1, 0 );
  Vector3.Z_UNIT = assert ? new Immutable( 0, 0, 1 ) : new Vector3( 0, 0, 1 );

  return Vector3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * 4-dimensional Matrix
 *
 * TODO: consider adding affine flag if it will help performance (a la Matrix3)
 * TODO: get rotation angles
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Matrix4',['require','DOT/dot','DOT/Vector3','DOT/Vector4'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  require( 'DOT/Vector3' );
  require( 'DOT/Vector4' );

  var Float32Array = window.Float32Array || Array;

  function Matrix4( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {

    // entries stored in column-major format
    this.entries = new Float32Array( 16 );

    this.rowMajor(
      v00 !== undefined ? v00 : 1, v01 !== undefined ? v01 : 0, v02 !== undefined ? v02 : 0, v03 !== undefined ? v03 : 0,
      v10 !== undefined ? v10 : 0, v11 !== undefined ? v11 : 1, v12 !== undefined ? v12 : 0, v13 !== undefined ? v13 : 0,
      v20 !== undefined ? v20 : 0, v21 !== undefined ? v21 : 0, v22 !== undefined ? v22 : 1, v23 !== undefined ? v23 : 0,
      v30 !== undefined ? v30 : 0, v31 !== undefined ? v31 : 0, v32 !== undefined ? v32 : 0, v33 !== undefined ? v33 : 1,
      type );
  }

  dot.register( 'Matrix4', Matrix4 );

  Matrix4.Types = {
    OTHER: 0, // default
    IDENTITY: 1,
    TRANSLATION_3D: 2,
    SCALING: 3,
    AFFINE: 4

    // TODO: possibly add rotations
  };

  var Types = Matrix4.Types;

  Matrix4.identity = function() {
    return new Matrix4(
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1,
      Types.IDENTITY );
  };

  Matrix4.translation = function( x, y, z ) {
    return new Matrix4(
      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1,
      Types.TRANSLATION_3D );
  };

  Matrix4.translationFromVector = function( v ) { return Matrix4.translation( v.x, v.y, v.z ); };

  Matrix4.scaling = function( x, y, z ) {
    // allow using one parameter to scale everything
    y = y === undefined ? x : y;
    z = z === undefined ? x : z;

    return new Matrix4(
      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1,
      Types.SCALING );
  };

  // axis is a normalized Vector3, angle in radians.
  Matrix4.rotationAxisAngle = function( axis, angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var C = 1 - c;

    return new Matrix4(
      axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s, 0,
      axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s, 0,
      axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };

  // TODO: add in rotation from quaternion, and from quat + translation

  Matrix4.rotationX = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4(
      1, 0, 0, 0,
      0, c, -s, 0,
      0, s, c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };

  Matrix4.rotationY = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4(
      c, 0, s, 0,
      0, 1, 0, 0,
      -s, 0, c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };

  Matrix4.rotationZ = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4(
      c, -s, 0, 0,
      s, c, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };

  // aspect === width / height
  Matrix4.gluPerspective = function( fovYRadians, aspect, zNear, zFar ) {
    var cotangent = Math.cos( fovYRadians ) / Math.sin( fovYRadians );

    return new Matrix4(
      cotangent / aspect, 0, 0, 0,
      0, cotangent, 0, 0,
      0, 0, ( zFar + zNear ) / ( zNear - zFar ), ( 2 * zFar * zNear ) / ( zNear - zFar ),
      0, 0, -1, 0 );
  };

  Matrix4.prototype = {
    constructor: Matrix4,

    rowMajor: function( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {
      this.entries[ 0 ] = v00;
      this.entries[ 1 ] = v10;
      this.entries[ 2 ] = v20;
      this.entries[ 3 ] = v30;
      this.entries[ 4 ] = v01;
      this.entries[ 5 ] = v11;
      this.entries[ 6 ] = v21;
      this.entries[ 7 ] = v31;
      this.entries[ 8 ] = v02;
      this.entries[ 9 ] = v12;
      this.entries[ 10 ] = v22;
      this.entries[ 11 ] = v32;
      this.entries[ 12 ] = v03;
      this.entries[ 13 ] = v13;
      this.entries[ 14 ] = v23;
      this.entries[ 15 ] = v33;

      // TODO: consider performance of the affine check here
      this.type = type === undefined ? ( ( v30 === 0 && v31 === 0 && v32 === 0 && v33 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
      return this;
    },

    columnMajor: function( v00, v10, v20, v30, v01, v11, v21, v31, v02, v12, v22, v32, v03, v13, v23, v33, type ) {
      return this.rowMajor( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type );
    },

    set: function( matrix ) {
      return this.rowMajor(
        matrix.m00(), matrix.m01(), matrix.m02(), matrix.m03(),
        matrix.m10(), matrix.m11(), matrix.m12(), matrix.m13(),
        matrix.m20(), matrix.m21(), matrix.m22(), matrix.m23(),
        matrix.m30(), matrix.m31(), matrix.m32(), matrix.m33(),
        matrix.type );
    },

    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler
    m00: function() { return this.entries[ 0 ]; },
    m01: function() { return this.entries[ 4 ]; },
    m02: function() { return this.entries[ 8 ]; },
    m03: function() { return this.entries[ 12 ]; },
    m10: function() { return this.entries[ 1 ]; },
    m11: function() { return this.entries[ 5 ]; },
    m12: function() { return this.entries[ 9 ]; },
    m13: function() { return this.entries[ 13 ]; },
    m20: function() { return this.entries[ 2 ]; },
    m21: function() { return this.entries[ 6 ]; },
    m22: function() { return this.entries[ 10 ]; },
    m23: function() { return this.entries[ 14 ]; },
    m30: function() { return this.entries[ 3 ]; },
    m31: function() { return this.entries[ 7 ]; },
    m32: function() { return this.entries[ 11 ]; },
    m33: function() { return this.entries[ 15 ]; },

    isFinite: function() {
      return isFinite( this.m00() ) &&
             isFinite( this.m01() ) &&
             isFinite( this.m02() ) &&
             isFinite( this.m03() ) &&
             isFinite( this.m10() ) &&
             isFinite( this.m11() ) &&
             isFinite( this.m12() ) &&
             isFinite( this.m13() ) &&
             isFinite( this.m20() ) &&
             isFinite( this.m21() ) &&
             isFinite( this.m22() ) &&
             isFinite( this.m23() ) &&
             isFinite( this.m30() ) &&
             isFinite( this.m31() ) &&
             isFinite( this.m32() ) &&
             isFinite( this.m33() );
    },

    // the 3D translation, assuming multiplication with a homogeneous vector
    getTranslation: function() {
      return new dot.Vector3( this.m03(), this.m13(), this.m23() );
    },
    get translation() { return this.getTranslation(); },

    // returns a vector that is equivalent to ( T(1,0,0).magnitude(), T(0,1,0).magnitude(), T(0,0,1).magnitude() )
    // where T is a relative transform
    getScaleVector: function() {
      var m0003 = this.m00() + this.m03();
      var m1013 = this.m10() + this.m13();
      var m2023 = this.m20() + this.m23();
      var m3033 = this.m30() + this.m33();
      var m0103 = this.m01() + this.m03();
      var m1113 = this.m11() + this.m13();
      var m2123 = this.m21() + this.m23();
      var m3133 = this.m31() + this.m33();
      var m0203 = this.m02() + this.m03();
      var m1213 = this.m12() + this.m13();
      var m2223 = this.m22() + this.m23();
      var m3233 = this.m32() + this.m33();
      return new dot.Vector3(
        Math.sqrt( m0003 * m0003 + m1013 * m1013 + m2023 * m2023 + m3033 * m3033 ),
        Math.sqrt( m0103 * m0103 + m1113 * m1113 + m2123 * m2123 + m3133 * m3133 ),
        Math.sqrt( m0203 * m0203 + m1213 * m1213 + m2223 * m2223 + m3233 * m3233 ) );
    },
    get scaleVector() { return this.getScaleVector(); },

    getCSSTransform: function() {
      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility

      // We need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
      // See https://github.com/phetsims/dot/issues/36

      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!
      // NOTE: the toFixed calls are inlined for performance reasons
      return 'matrix3d(' +
             this.entries[ 0 ].toFixed( 20 ) + ',' +
             this.entries[ 1 ].toFixed( 20 ) + ',' +
             this.entries[ 2 ].toFixed( 20 ) + ',' +
             this.entries[ 3 ].toFixed( 20 ) + ',' +
             this.entries[ 4 ].toFixed( 20 ) + ',' +
             this.entries[ 5 ].toFixed( 20 ) + ',' +
             this.entries[ 6 ].toFixed( 20 ) + ',' +
             this.entries[ 7 ].toFixed( 20 ) + ',' +
             this.entries[ 8 ].toFixed( 20 ) + ',' +
             this.entries[ 9 ].toFixed( 20 ) + ',' +
             this.entries[ 10 ].toFixed( 20 ) + ',' +
             this.entries[ 11 ].toFixed( 20 ) + ',' +
             this.entries[ 12 ].toFixed( 20 ) + ',' +
             this.entries[ 13 ].toFixed( 20 ) + ',' +
             this.entries[ 14 ].toFixed( 20 ) + ',' +
             this.entries[ 15 ].toFixed( 20 ) + ')';
    },
    get cssTransform() { return this.getCSSTransform(); },

    // exact equality
    equals: function( m ) {
      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() && this.m03() === m.m03() &&
             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() && this.m13() === m.m13() &&
             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22() && this.m23() === m.m23() &&
             this.m30() === m.m30() && this.m31() === m.m31() && this.m32() === m.m32() && this.m33() === m.m33();
    },

    // equality within a margin of error
    equalsEpsilon: function( m, epsilon ) {
      return Math.abs( this.m00() - m.m00() ) < epsilon &&
             Math.abs( this.m01() - m.m01() ) < epsilon &&
             Math.abs( this.m02() - m.m02() ) < epsilon &&
             Math.abs( this.m03() - m.m03() ) < epsilon &&
             Math.abs( this.m10() - m.m10() ) < epsilon &&
             Math.abs( this.m11() - m.m11() ) < epsilon &&
             Math.abs( this.m12() - m.m12() ) < epsilon &&
             Math.abs( this.m13() - m.m13() ) < epsilon &&
             Math.abs( this.m20() - m.m20() ) < epsilon &&
             Math.abs( this.m21() - m.m21() ) < epsilon &&
             Math.abs( this.m22() - m.m22() ) < epsilon &&
             Math.abs( this.m23() - m.m23() ) < epsilon &&
             Math.abs( this.m30() - m.m30() ) < epsilon &&
             Math.abs( this.m31() - m.m31() ) < epsilon &&
             Math.abs( this.m32() - m.m32() ) < epsilon &&
             Math.abs( this.m33() - m.m33() ) < epsilon;
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations (returning a new matrix)
     *----------------------------------------------------------------------------*/

    copy: function() {
      return new Matrix4(
        this.m00(), this.m01(), this.m02(), this.m03(),
        this.m10(), this.m11(), this.m12(), this.m13(),
        this.m20(), this.m21(), this.m22(), this.m23(),
        this.m30(), this.m31(), this.m32(), this.m33(),
        this.type
      );
    },

    plus: function( m ) {
      return new Matrix4(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(), this.m03() + m.m03(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(), this.m13() + m.m13(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22(), this.m23() + m.m23(),
        this.m30() + m.m30(), this.m31() + m.m31(), this.m32() + m.m32(), this.m33() + m.m33()
      );
    },

    minus: function( m ) {
      return new Matrix4(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(), this.m03() - m.m03(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(), this.m13() - m.m13(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22(), this.m23() - m.m23(),
        this.m30() - m.m30(), this.m31() - m.m31(), this.m32() - m.m32(), this.m33() - m.m33()
      );
    },

    transposed: function() {
      return new Matrix4(
        this.m00(), this.m10(), this.m20(), this.m30(),
        this.m01(), this.m11(), this.m21(), this.m31(),
        this.m02(), this.m12(), this.m22(), this.m32(),
        this.m03(), this.m13(), this.m23(), this.m33() );
    },

    negated: function() {
      return new Matrix4(
        -this.m00(), -this.m01(), -this.m02(), -this.m03(),
        -this.m10(), -this.m11(), -this.m12(), -this.m13(),
        -this.m20(), -this.m21(), -this.m22(), -this.m23(),
        -this.m30(), -this.m31(), -this.m32(), -this.m33() );
    },

    inverted: function() {
      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_3D:
          return new Matrix4(
            1, 0, 0, -this.m03(),
            0, 1, 0, -this.m13(),
            0, 0, 1, -this.m23(),
            0, 0, 0, 1, Types.TRANSLATION_3D );
        case Types.SCALING:
          return new Matrix4(
            1 / this.m00(), 0, 0, 0,
            0, 1 / this.m11(), 0, 0,
            0, 0, 1 / this.m22(), 0,
            0, 0, 0, 1 / this.m33(), Types.SCALING );
        case Types.AFFINE:
        case Types.OTHER:
          var det = this.getDeterminant();
          if ( det !== 0 ) {
            return new Matrix4(
              ( -this.m31() * this.m22() * this.m13() + this.m21() * this.m32() * this.m13() + this.m31() * this.m12() * this.m23() - this.m11() * this.m32() * this.m23() - this.m21() * this.m12() * this.m33() + this.m11() * this.m22() * this.m33() ) / det,
              ( this.m31() * this.m22() * this.m03() - this.m21() * this.m32() * this.m03() - this.m31() * this.m02() * this.m23() + this.m01() * this.m32() * this.m23() + this.m21() * this.m02() * this.m33() - this.m01() * this.m22() * this.m33() ) / det,
              ( -this.m31() * this.m12() * this.m03() + this.m11() * this.m32() * this.m03() + this.m31() * this.m02() * this.m13() - this.m01() * this.m32() * this.m13() - this.m11() * this.m02() * this.m33() + this.m01() * this.m12() * this.m33() ) / det,
              ( this.m21() * this.m12() * this.m03() - this.m11() * this.m22() * this.m03() - this.m21() * this.m02() * this.m13() + this.m01() * this.m22() * this.m13() + this.m11() * this.m02() * this.m23() - this.m01() * this.m12() * this.m23() ) / det,
              ( this.m30() * this.m22() * this.m13() - this.m20() * this.m32() * this.m13() - this.m30() * this.m12() * this.m23() + this.m10() * this.m32() * this.m23() + this.m20() * this.m12() * this.m33() - this.m10() * this.m22() * this.m33() ) / det,
              ( -this.m30() * this.m22() * this.m03() + this.m20() * this.m32() * this.m03() + this.m30() * this.m02() * this.m23() - this.m00() * this.m32() * this.m23() - this.m20() * this.m02() * this.m33() + this.m00() * this.m22() * this.m33() ) / det,
              ( this.m30() * this.m12() * this.m03() - this.m10() * this.m32() * this.m03() - this.m30() * this.m02() * this.m13() + this.m00() * this.m32() * this.m13() + this.m10() * this.m02() * this.m33() - this.m00() * this.m12() * this.m33() ) / det,
              ( -this.m20() * this.m12() * this.m03() + this.m10() * this.m22() * this.m03() + this.m20() * this.m02() * this.m13() - this.m00() * this.m22() * this.m13() - this.m10() * this.m02() * this.m23() + this.m00() * this.m12() * this.m23() ) / det,
              ( -this.m30() * this.m21() * this.m13() + this.m20() * this.m31() * this.m13() + this.m30() * this.m11() * this.m23() - this.m10() * this.m31() * this.m23() - this.m20() * this.m11() * this.m33() + this.m10() * this.m21() * this.m33() ) / det,
              ( this.m30() * this.m21() * this.m03() - this.m20() * this.m31() * this.m03() - this.m30() * this.m01() * this.m23() + this.m00() * this.m31() * this.m23() + this.m20() * this.m01() * this.m33() - this.m00() * this.m21() * this.m33() ) / det,
              ( -this.m30() * this.m11() * this.m03() + this.m10() * this.m31() * this.m03() + this.m30() * this.m01() * this.m13() - this.m00() * this.m31() * this.m13() - this.m10() * this.m01() * this.m33() + this.m00() * this.m11() * this.m33() ) / det,
              ( this.m20() * this.m11() * this.m03() - this.m10() * this.m21() * this.m03() - this.m20() * this.m01() * this.m13() + this.m00() * this.m21() * this.m13() + this.m10() * this.m01() * this.m23() - this.m00() * this.m11() * this.m23() ) / det,
              ( this.m30() * this.m21() * this.m12() - this.m20() * this.m31() * this.m12() - this.m30() * this.m11() * this.m22() + this.m10() * this.m31() * this.m22() + this.m20() * this.m11() * this.m32() - this.m10() * this.m21() * this.m32() ) / det,
              ( -this.m30() * this.m21() * this.m02() + this.m20() * this.m31() * this.m02() + this.m30() * this.m01() * this.m22() - this.m00() * this.m31() * this.m22() - this.m20() * this.m01() * this.m32() + this.m00() * this.m21() * this.m32() ) / det,
              ( this.m30() * this.m11() * this.m02() - this.m10() * this.m31() * this.m02() - this.m30() * this.m01() * this.m12() + this.m00() * this.m31() * this.m12() + this.m10() * this.m01() * this.m32() - this.m00() * this.m11() * this.m32() ) / det,
              ( -this.m20() * this.m11() * this.m02() + this.m10() * this.m21() * this.m02() + this.m20() * this.m01() * this.m12() - this.m00() * this.m21() * this.m12() - this.m10() * this.m01() * this.m22() + this.m00() * this.m11() * this.m22() ) / det
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break;
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },

    timesMatrix: function( m ) {
      // I * M === M * I === I (the identity)
      if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
        return this.type === Types.IDENTITY ? m : this;
      }

      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_3D ) {
          // faster combination of translations
          return new Matrix4(
            1, 0, 0, this.m03() + m.m02(),
            0, 1, 0, this.m13() + m.m12(),
            0, 0, 1, this.m23() + m.m23(),
            0, 0, 0, 1, Types.TRANSLATION_3D );
        }
        else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return new Matrix4(
            this.m00() * m.m00(), 0, 0, 0,
            0, this.m11() * m.m11(), 0, 0,
            0, 0, this.m22() * m.m22(), 0,
            0, 0, 0, 1, Types.SCALING );
        }
      }

      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine

        // affine case
        return new Matrix4(
          this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
          this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
          this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03(),
          this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
          this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
          this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13(),
          this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
          this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
          this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22(),
          this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23(),
          0, 0, 0, 1, Types.AFFINE );
      }

      // general case
      return new Matrix4(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20() + this.m03() * m.m30(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21() + this.m03() * m.m31(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22() + this.m03() * m.m32(),
        this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03() * m.m33(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20() + this.m13() * m.m30(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21() + this.m13() * m.m31(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22() + this.m13() * m.m32(),
        this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13() * m.m33(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20() + this.m23() * m.m30(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21() + this.m23() * m.m31(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() + this.m23() * m.m32(),
        this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23() * m.m33(),
        this.m30() * m.m00() + this.m31() * m.m10() + this.m32() * m.m20() + this.m33() * m.m30(),
        this.m30() * m.m01() + this.m31() * m.m11() + this.m32() * m.m21() + this.m33() * m.m31(),
        this.m30() * m.m02() + this.m31() * m.m12() + this.m32() * m.m22() + this.m33() * m.m32(),
        this.m30() * m.m03() + this.m31() * m.m13() + this.m32() * m.m23() + this.m33() * m.m33() );
    },

    timesVector4: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z + this.m03() * v.w;
      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z + this.m13() * v.w;
      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z + this.m23() * v.w;
      var w = this.m30() * v.x + this.m31() * v.y + this.m32() * v.z + this.m33() * v.w;
      return new dot.Vector4( x, y, z, w );
    },

    timesVector3: function( v ) {
      return this.timesVector4( v.toVector4() ).toVector3();
    },

    timesTransposeVector4: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z + this.m30() * v.w;
      var y = this.m01() * v.x + this.m11() * v.y + this.m21() * v.z + this.m31() * v.w;
      var z = this.m02() * v.x + this.m12() * v.y + this.m22() * v.z + this.m32() * v.w;
      var w = this.m03() * v.x + this.m13() * v.y + this.m23() * v.z + this.m33() * v.w;
      return new dot.Vector4( x, y, z, w );
    },

    timesTransposeVector3: function( v ) {
      return this.timesTransposeVector4( v.toVector4() ).toVector3();
    },

    timesRelativeVector3: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z;
      var y = this.m01() * v.y + this.m11() * v.y + this.m21() * v.z;
      var z = this.m02() * v.z + this.m12() * v.y + this.m22() * v.z;
      return new dot.Vector3( x, y, z );
    },

    getDeterminant: function() {
      return this.m03() * this.m12() * this.m21() * this.m30() -
             this.m02() * this.m13() * this.m21() * this.m30() -
             this.m03() * this.m11() * this.m22() * this.m30() +
             this.m01() * this.m13() * this.m22() * this.m30() +
             this.m02() * this.m11() * this.m23() * this.m30() -
             this.m01() * this.m12() * this.m23() * this.m30() -
             this.m03() * this.m12() * this.m20() * this.m31() +
             this.m02() * this.m13() * this.m20() * this.m31() +
             this.m03() * this.m10() * this.m22() * this.m31() -
             this.m00() * this.m13() * this.m22() * this.m31() -
             this.m02() * this.m10() * this.m23() * this.m31() +
             this.m00() * this.m12() * this.m23() * this.m31() +
             this.m03() * this.m11() * this.m20() * this.m32() -
             this.m01() * this.m13() * this.m20() * this.m32() -
             this.m03() * this.m10() * this.m21() * this.m32() +
             this.m00() * this.m13() * this.m21() * this.m32() +
             this.m01() * this.m10() * this.m23() * this.m32() -
             this.m00() * this.m11() * this.m23() * this.m32() -
             this.m02() * this.m11() * this.m20() * this.m33() +
             this.m01() * this.m12() * this.m20() * this.m33() +
             this.m02() * this.m10() * this.m21() * this.m33() -
             this.m00() * this.m12() * this.m21() * this.m33() -
             this.m01() * this.m10() * this.m22() * this.m33() +
             this.m00() * this.m11() * this.m22() * this.m33();
    },
    get determinant() { return this.getDeterminant(); },

    toString: function() {
      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + ' ' + this.m03() + '\n' +
             this.m10() + ' ' + this.m11() + ' ' + this.m12() + ' ' + this.m13() + '\n' +
             this.m20() + ' ' + this.m21() + ' ' + this.m22() + ' ' + this.m23() + '\n' +
             this.m30() + ' ' + this.m31() + ' ' + this.m32() + ' ' + this.m33();
    },

    makeImmutable: function() {
      this.rowMajor = function() {
        throw new Error( 'Cannot modify immutable matrix' );
      };
    }
  };

  // create an immutable
  Matrix4.IDENTITY = new Matrix4();
  Matrix4.IDENTITY.makeImmutable();

  return Matrix4;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * 3-dimensional Matrix
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Matrix3',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2','DOT/Vector3','DOT/Matrix4'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  var FastArray = dot.FastArray;

  require( 'DOT/Vector2' );
  require( 'DOT/Vector3' );
  require( 'DOT/Matrix4' );

  var identityFastArray = new FastArray( 9 );
  identityFastArray[ 0 ] = 1;
  identityFastArray[ 4 ] = 1;
  identityFastArray[ 8 ] = 1;

  var createIdentityArray = FastArray === Array ?
                            function() {
                              return [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
                            } :
                            function() {
                              return new FastArray( identityFastArray );
                            };

  // Create an identity matrix
  function Matrix3( argumentsShouldNotExist ) {

    //Make sure no clients are expecting to create a matrix with non-identity values
    assert && assert( !argumentsShouldNotExist, 'Matrix3 constructor should not be called with any arguments.  Use Matrix3.createFromPool()/Matrix3.identity()/etc.' );

    // entries stored in column-major format
    this.entries = createIdentityArray();

    phetAllocation && phetAllocation( 'Matrix3' );
    this.type = Types.IDENTITY;
  }

  dot.register( 'Matrix3', Matrix3 );

  Matrix3.Types = {
    // NOTE: if an inverted matrix of a type is not that type, change inverted()!
    // NOTE: if two matrices with identical types are multiplied, the result should have the same type. if not, changed timesMatrix()!
    // NOTE: on adding a type, exaustively check all type usage
    OTHER: 0, // default
    IDENTITY: 1,
    TRANSLATION_2D: 2,
    SCALING: 3,
    AFFINE: 4

    // TODO: possibly add rotations
  };

  var Types = Matrix3.Types;

  Matrix3.identity = function() { return Matrix3.dirtyFromPool().setToIdentity(); };
  Matrix3.translation = function( x, y ) { return Matrix3.dirtyFromPool().setToTranslation( x, y ); };
  Matrix3.translationFromVector = function( v ) { return Matrix3.translation( v.x, v.y ); };
  Matrix3.scaling = function( x, y ) { return Matrix3.dirtyFromPool().setToScale( x, y ); };
  Matrix3.scale = Matrix3.scaling;
  Matrix3.affine = function( m00, m10, m01, m11, m02, m12 ) { return Matrix3.dirtyFromPool().setToAffine( m00, m01, m02, m10, m11, m12 ); };
  Matrix3.rowMajor = function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) { return Matrix3.dirtyFromPool().rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ); };

  // axis is a normalized Vector3, angle in radians.
  Matrix3.rotationAxisAngle = function( axis, angle ) { return Matrix3.dirtyFromPool().setToRotationAxisAngle( axis, angle ); };

  Matrix3.rotationX = function( angle ) { return Matrix3.dirtyFromPool().setToRotationX( angle ); };
  Matrix3.rotationY = function( angle ) { return Matrix3.dirtyFromPool().setToRotationY( angle ); };
  Matrix3.rotationZ = function( angle ) { return Matrix3.dirtyFromPool().setToRotationZ( angle ); };

  // standard 2d rotation
  Matrix3.rotation2 = Matrix3.rotationZ;

  Matrix3.rotationAround = function( angle, x, y ) {
    return Matrix3.translation( x, y ).timesMatrix( Matrix3.rotation2( angle ) ).timesMatrix( Matrix3.translation( -x, -y ) );
  };

  Matrix3.rotationAroundPoint = function( angle, point ) {
    return Matrix3.rotationAround( angle, point.x, point.y );
  };

  Matrix3.fromSVGMatrix = function( svgMatrix ) { return Matrix3.dirtyFromPool().setToSVGMatrix( svgMatrix ); };

  // a rotation matrix that rotates A to B, by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors
  Matrix3.rotateAToB = function( a, b ) { return Matrix3.dirtyFromPool().setRotationAToB( a, b ); };

  Matrix3.prototype = {
    constructor: Matrix3,

    /*---------------------------------------------------------------------------*
     * "Properties"
     *----------------------------------------------------------------------------*/

    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler
    m00: function() { return this.entries[ 0 ]; },
    m01: function() { return this.entries[ 3 ]; },
    m02: function() { return this.entries[ 6 ]; },
    m10: function() { return this.entries[ 1 ]; },
    m11: function() { return this.entries[ 4 ]; },
    m12: function() { return this.entries[ 7 ]; },
    m20: function() { return this.entries[ 2 ]; },
    m21: function() { return this.entries[ 5 ]; },
    m22: function() { return this.entries[ 8 ]; },

    isIdentity: function() {
      return this.type === Types.IDENTITY || this.equals( Matrix3.IDENTITY );
    },

    // returning false means "inconclusive, may be identity or not"
    isFastIdentity: function() {
      return this.type === Types.IDENTITY;
    },

    isAffine: function() {
      return this.type === Types.AFFINE || ( this.m20() === 0 && this.m21() === 0 && this.m22() === 1 );
    },

    // if it's an affine matrix where the components of transforms are independent
    // i.e. constructed from arbitrary component scaling and translation.
    isAligned: function() {
      // non-diagonal non-translation entries should all be zero.
      return this.isAffine() && this.m01() === 0 && this.m10() === 0;
    },

    // if it's an affine matrix where the components of transforms are independent, but may be switched (unlike isAligned)
    // i.e. the 2x2 rotational sub-matrix is of one of the two forms:
    // A 0  or  0  A
    // 0 B      B  0
    // This means that moving a transformed point by (x,0) or (0,y) will result in a motion along one of the axes.
    isAxisAligned: function() {
      return this.isAffine() && ( ( this.m01() === 0 && this.m10() === 0 ) || ( this.m00() === 0 && this.m11() === 0 ) );
    },

    isFinite: function() {
      return isFinite( this.m00() ) &&
             isFinite( this.m01() ) &&
             isFinite( this.m02() ) &&
             isFinite( this.m10() ) &&
             isFinite( this.m11() ) &&
             isFinite( this.m12() ) &&
             isFinite( this.m20() ) &&
             isFinite( this.m21() ) &&
             isFinite( this.m22() );
    },

    getDeterminant: function() {
      return this.m00() * this.m11() * this.m22() + this.m01() * this.m12() * this.m20() + this.m02() * this.m10() * this.m21() - this.m02() * this.m11() * this.m20() - this.m01() * this.m10() * this.m22() - this.m00() * this.m12() * this.m21();
    },
    get determinant() { return this.getDeterminant(); },

    // the 2D translation, assuming multiplication with a homogeneous vector
    getTranslation: function() {
      return new dot.Vector2( this.m02(), this.m12() );
    },
    get translation() { return this.getTranslation(); },

    // returns a vector that is equivalent to ( T(1,0).magnitude(), T(0,1).magnitude() ) where T is a relative transform
    getScaleVector: function() {
      return new dot.Vector2(
        Math.sqrt( this.m00() * this.m00() + this.m10() * this.m10() ),
        Math.sqrt( this.m01() * this.m01() + this.m11() * this.m11() ) );
    },
    get scaleVector() { return this.getScaleVector(); },

    // angle in radians for the 2d rotation from this matrix, between pi, -pi
    getRotation: function() {
      return Math.atan2( this.m10(), this.m00() );
    },
    get rotation() { return this.getRotation(); },

    toMatrix4: function() {
      return new dot.Matrix4(
        this.m00(), this.m01(), this.m02(), 0,
        this.m10(), this.m11(), this.m12(), 0,
        this.m20(), this.m21(), this.m22(), 0,
        0, 0, 0, 1 );
    },

    toAffineMatrix4: function() {
      return new dot.Matrix4(
        this.m00(), this.m01(), 0, this.m02(),
        this.m10(), this.m11(), 0, this.m12(),
        0, 0, 1, 0,
        0, 0, 0, 1 );
    },

    toString: function() {
      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + '\n' +
             this.m10() + ' ' + this.m11() + ' ' + this.m12() + '\n' +
             this.m20() + ' ' + this.m21() + ' ' + this.m22();
    },

    toSVGMatrix: function() {
      var result = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ).createSVGMatrix();

      // top two rows
      result.a = this.m00();
      result.b = this.m10();
      result.c = this.m01();
      result.d = this.m11();
      result.e = this.m02();
      result.f = this.m12();

      return result;
    },

    getCSSTransform: function() {
      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility

      // We need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
      // See https://github.com/phetsims/dot/issues/36

      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!
      // NOTE: the toFixed calls are inlined for performance reasons
      return 'matrix(' + this.entries[ 0 ].toFixed( 20 ) + ',' + this.entries[ 1 ].toFixed( 20 ) + ',' + this.entries[ 3 ].toFixed( 20 ) + ',' + this.entries[ 4 ].toFixed( 20 ) + ',' + this.entries[ 6 ].toFixed( 20 ) + ',' + this.entries[ 7 ].toFixed( 20 ) + ')';
    },
    get cssTransform() { return this.getCSSTransform(); },

    getSVGTransform: function() {
      // SVG transform presentation attribute. See http://www.w3.org/TR/SVG/coords.html#TransformAttribute

      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      function svgNumber( number ) {
        // Largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
        // See https://github.com/phetsims/dot/issues/36
        return number.toFixed( 20 );
      }

      switch( this.type ) {
        case Types.IDENTITY:
          return '';
        case Types.TRANSLATION_2D:
          return 'translate(' + svgNumber( this.entries[ 6 ] ) + ',' + svgNumber( this.entries[ 7 ] ) + ')';
        case Types.SCALING:
          return 'scale(' + svgNumber( this.entries[ 0 ] ) + ( this.entries[ 0 ] === this.entries[ 4 ] ? '' : ',' + svgNumber( this.entries[ 4 ] ) ) + ')';
        default:
          return 'matrix(' + svgNumber( this.entries[ 0 ] ) + ',' + svgNumber( this.entries[ 1 ] ) + ',' + svgNumber( this.entries[ 3 ] ) + ',' + svgNumber( this.entries[ 4 ] ) + ',' + svgNumber( this.entries[ 6 ] ) + ',' + svgNumber( this.entries[ 7 ] ) + ')';
      }
    },
    get svgTransform() { return this.getSVGTransform(); },

    // returns a parameter object suitable for use with jQuery's .css()
    getCSSTransformStyles: function() {
      var transformCSS = this.getCSSTransform();

      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/
      return {
        // force iOS hardware acceleration
        '-webkit-perspective': 1000,
        '-webkit-backface-visibility': 'hidden',

        '-webkit-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
        '-moz-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
        '-ms-transform': transformCSS,
        '-o-transform': transformCSS,
        'transform': transformCSS,
        'transform-origin': 'top left', // at the origin of the component. consider 0px 0px instead. Critical, since otherwise this defaults to 50% 50%!!! see https://developer.mozilla.org/en-US/docs/CSS/transform-origin
        '-ms-transform-origin': 'top left' // TODO: do we need other platform-specific transform-origin styles?
      };
    },
    get cssTransformStyles() { return this.getCSSTransformStyles(); },

    // exact equality
    equals: function( m ) {
      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() &&
             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() &&
             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22();
    },

    // equality within a margin of error
    equalsEpsilon: function( m, epsilon ) {
      return Math.abs( this.m00() - m.m00() ) < epsilon && Math.abs( this.m01() - m.m01() ) < epsilon && Math.abs( this.m02() - m.m02() ) < epsilon &&
             Math.abs( this.m10() - m.m10() ) < epsilon && Math.abs( this.m11() - m.m11() ) < epsilon && Math.abs( this.m12() - m.m12() ) < epsilon &&
             Math.abs( this.m20() - m.m20() ) < epsilon && Math.abs( this.m21() - m.m21() ) < epsilon && Math.abs( this.m22() - m.m22() ) < epsilon;
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations (returns a new matrix)
     *----------------------------------------------------------------------------*/

    copy: function() {
      return Matrix3.createFromPool(
        this.m00(), this.m01(), this.m02(),
        this.m10(), this.m11(), this.m12(),
        this.m20(), this.m21(), this.m22(),
        this.type
      );
    },

    plus: function( m ) {
      return Matrix3.createFromPool(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
      );
    },

    minus: function( m ) {
      return Matrix3.createFromPool(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
      );
    },

    transposed: function() {
      return Matrix3.createFromPool(
        this.m00(), this.m10(), this.m20(),
        this.m01(), this.m11(), this.m21(),
        this.m02(), this.m12(), this.m22(), ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
      );
    },

    negated: function() {
      return Matrix3.createFromPool(
        -this.m00(), -this.m01(), -this.m02(),
        -this.m10(), -this.m11(), -this.m12(),
        -this.m20(), -this.m21(), -this.m22()
      );
    },

    inverted: function() {
      var det;

      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_2D:
          return Matrix3.createFromPool(
            1, 0, -this.m02(),
            0, 1, -this.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        case Types.SCALING:
          return Matrix3.createFromPool(
            1 / this.m00(), 0, 0,
            0, 1 / this.m11(), 0,
            0, 0, 1 / this.m22(), Types.SCALING );
        case Types.AFFINE:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return Matrix3.createFromPool(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              0, 0, 1, Types.AFFINE
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break;
        case Types.OTHER:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return Matrix3.createFromPool(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
              Types.OTHER
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break;
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },

    timesMatrix: function( m ) {
      // I * M === M * I === M (the identity)
      if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
        return this.type === Types.IDENTITY ? m : this;
      }

      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_2D ) {
          // faster combination of translations
          return Matrix3.createFromPool(
            1, 0, this.m02() + m.m02(),
            0, 1, this.m12() + m.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        }
        else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return Matrix3.createFromPool(
            this.m00() * m.m00(), 0, 0,
            0, this.m11() * m.m11(), 0,
            0, 0, 1, Types.SCALING );
        }
      }

      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine

        // affine case
        return Matrix3.createFromPool(
          this.m00() * m.m00() + this.m01() * m.m10(),
          this.m00() * m.m01() + this.m01() * m.m11(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
          this.m10() * m.m00() + this.m11() * m.m10(),
          this.m10() * m.m01() + this.m11() * m.m11(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
          0, 0, 1, Types.AFFINE );
      }

      // general case
      return Matrix3.createFromPool(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations (returns new form of a parameter)
     *----------------------------------------------------------------------------*/

    timesVector2: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02();
      var y = this.m10() * v.x + this.m11() * v.y + this.m12();
      return new dot.Vector2( x, y );
    },

    timesVector3: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;
      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;
      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;
      return new dot.Vector3( x, y, z );
    },

    timesTransposeVector2: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y;
      var y = this.m01() * v.x + this.m11() * v.y;
      return new dot.Vector2( x, y );
    },

    // TODO: this operation seems to not work for transformDelta2, should be vetted
    timesRelativeVector2: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y;
      var y = this.m10() * v.y + this.m11() * v.y;
      return new dot.Vector2( x, y );
    },

    /*---------------------------------------------------------------------------*
     * Mutable operations (changes this matrix)
     *----------------------------------------------------------------------------*/

    // every mutable method goes through rowMajor
    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
      this.entries[ 0 ] = v00;
      this.entries[ 1 ] = v10;
      this.entries[ 2 ] = v20;
      this.entries[ 3 ] = v01;
      this.entries[ 4 ] = v11;
      this.entries[ 5 ] = v21;
      this.entries[ 6 ] = v02;
      this.entries[ 7 ] = v12;
      this.entries[ 8 ] = v22;

      // TODO: consider performance of the affine check here
      this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
      return this;
    },

    set: function( matrix ) {
      return this.rowMajor(
        matrix.m00(), matrix.m01(), matrix.m02(),
        matrix.m10(), matrix.m11(), matrix.m12(),
        matrix.m20(), matrix.m21(), matrix.m22(),
        matrix.type );
    },

    setArray: function( array ) {
      return this.rowMajor(
        array[ 0 ], array[ 3 ], array[ 6 ],
        array[ 1 ], array[ 4 ], array[ 7 ],
        array[ 2 ], array[ 5 ], array[ 8 ] );
    },

    // component setters
    set00: function( value ) {
      this.entries[ 0 ] = value;
      return this;
    },
    set01: function( value ) {
      this.entries[ 3 ] = value;
      return this;
    },
    set02: function( value ) {
      this.entries[ 6 ] = value;
      return this;
    },
    set10: function( value ) {
      this.entries[ 1 ] = value;
      return this;
    },
    set11: function( value ) {
      this.entries[ 4 ] = value;
      return this;
    },
    set12: function( value ) {
      this.entries[ 7 ] = value;
      return this;
    },
    set20: function( value ) {
      this.entries[ 2 ] = value;
      return this;
    },
    set21: function( value ) {
      this.entries[ 5 ] = value;
      return this;
    },
    set22: function( value ) {
      this.entries[ 8 ] = value;
      return this;
    },

    makeImmutable: function() {
      this.rowMajor = function() {
        throw new Error( 'Cannot modify immutable matrix' );
      };
      return this;
    },

    columnMajor: function( v00, v10, v20, v01, v11, v21, v02, v12, v22, type ) {
      return this.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
    },

    add: function( m ) {
      return this.rowMajor(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
      );
    },

    subtract: function( m ) {
      return this.rowMajor(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
      );
    },

    transpose: function() {
      return this.rowMajor(
        this.m00(), this.m10(), this.m20(),
        this.m01(), this.m11(), this.m21(),
        this.m02(), this.m12(), this.m22(),
        ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
      );
    },

    negate: function() {
      return this.rowMajor(
        -this.m00(), -this.m01(), -this.m02(),
        -this.m10(), -this.m11(), -this.m12(),
        -this.m20(), -this.m21(), -this.m22()
      );
    },

    invert: function() {
      var det;

      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_2D:
          return this.rowMajor(
            1, 0, -this.m02(),
            0, 1, -this.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        case Types.SCALING:
          return this.rowMajor(
            1 / this.m00(), 0, 0,
            0, 1 / this.m11(), 0,
            0, 0, 1 / this.m22(), Types.SCALING );
        case Types.AFFINE:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return this.rowMajor(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              0, 0, 1, Types.AFFINE
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break;
        case Types.OTHER:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return this.rowMajor(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
              Types.OTHER
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break;
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },

    multiplyMatrix: function( m ) {
      // M * I === M (the identity)
      if ( m.type === Types.IDENTITY ) {
        // no change needed
        return this;
      }

      // I * M === M (the identity)
      if ( this.type === Types.IDENTITY ) {
        // copy the other matrix to us
        return this.set( m );
      }

      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_2D ) {
          // faster combination of translations
          return this.rowMajor(
            1, 0, this.m02() + m.m02(),
            0, 1, this.m12() + m.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        }
        else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return this.rowMajor(
            this.m00() * m.m00(), 0, 0,
            0, this.m11() * m.m11(), 0,
            0, 0, 1, Types.SCALING );
        }
      }

      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine

        // affine case
        return this.rowMajor(
          this.m00() * m.m00() + this.m01() * m.m10(),
          this.m00() * m.m01() + this.m01() * m.m11(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
          this.m10() * m.m00() + this.m11() * m.m10(),
          this.m10() * m.m01() + this.m11() * m.m11(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
          0, 0, 1, Types.AFFINE );
      }

      // general case
      return this.rowMajor(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
    },

    prependTranslation: function( x, y ) {
      this.set02( this.m02() + x );
      this.set12( this.m12() + y );

      if ( this.type === Types.IDENTITY || this.type === Types.TRANSLATION_2D ) {
        this.type = Types.TRANSLATION_2D;
      }
      else if ( this.type === Types.OTHER ) {
        this.type = Types.OTHER;
      }
      else {
        this.type = Types.AFFINE;
      }
      return this; // for chaining
    },

    setToIdentity: function() {
      return this.rowMajor(
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
        Types.IDENTITY );
    },

    setToTranslation: function( x, y ) {
      return this.rowMajor(
        1, 0, x,
        0, 1, y,
        0, 0, 1,
        Types.TRANSLATION_2D );
    },

    setToScale: function( x, y ) {
      // allow using one parameter to scale everything
      y = y === undefined ? x : y;

      return this.rowMajor(
        x, 0, 0,
        0, y, 0,
        0, 0, 1,
        Types.SCALING );
    },

    // row major
    setToAffine: function( m00, m01, m02, m10, m11, m12 ) {
      return this.rowMajor( m00, m01, m02, m10, m11, m12, 0, 0, 1, Types.AFFINE );
    },

    // axis is a normalized Vector3, angle in radians.
    setToRotationAxisAngle: function( axis, angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );
      var C = 1 - c;

      return this.rowMajor(
        axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s,
        axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s,
        axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c,
        Types.OTHER );
    },

    setToRotationX: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor(
        1, 0, 0,
        0, c, -s,
        0, s, c,
        Types.OTHER );
    },

    setToRotationY: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor(
        c, 0, s,
        0, 1, 0,
        -s, 0, c,
        Types.OTHER );
    },

    setToRotationZ: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor(
        c, -s, 0,
        s, c, 0,
        0, 0, 1,
        Types.AFFINE );
    },

    setToSVGMatrix: function( svgMatrix ) {
      return this.rowMajor(
        svgMatrix.a, svgMatrix.c, svgMatrix.e,
        svgMatrix.b, svgMatrix.d, svgMatrix.f,
        0, 0, 1,
        Types.AFFINE );
    },

    // a rotation matrix that rotates A to B (Vector3 instances), by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors
    setRotationAToB: function( a, b ) {
      // see http://graphics.cs.brown.edu/~jfh/papers/Moller-EBA-1999/paper.pdf for information on this implementation
      var start = a;
      var end = b;

      var epsilon = 0.0001;

      var e;
      var h;
      var f;

      var v = start.cross( end );
      e = start.dot( end );
      f = ( e < 0 ) ? -e : e;

      // if "from" and "to" vectors are nearly parallel
      if ( f > 1.0 - epsilon ) {
        var c1;
        var c2;
        var c3;

        var x = new dot.Vector3(
          ( start.x > 0.0 ) ? start.x : -start.x,
          ( start.y > 0.0 ) ? start.y : -start.y,
          ( start.z > 0.0 ) ? start.z : -start.z
        );

        if ( x.x < x.y ) {
          if ( x.x < x.z ) {
            x = dot.Vector3.X_UNIT;
          }
          else {
            x = dot.Vector3.Z_UNIT;
          }
        }
        else {
          if ( x.y < x.z ) {
            x = dot.Vector3.Y_UNIT;
          }
          else {
            x = dot.Vector3.Z_UNIT;
          }
        }

        var u = x.minus( start );
        v = x.minus( end );

        c1 = 2.0 / u.dot( u );
        c2 = 2.0 / v.dot( v );
        c3 = c1 * c2 * u.dot( v );

        return this.rowMajor(
          -c1 * u.x * u.x - c2 * v.x * v.x + c3 * v.x * u.x + 1,
          -c1 * u.x * u.y - c2 * v.x * v.y + c3 * v.x * u.y,
          -c1 * u.x * u.z - c2 * v.x * v.z + c3 * v.x * u.z,
          -c1 * u.y * u.x - c2 * v.y * v.x + c3 * v.y * u.x,
          -c1 * u.y * u.y - c2 * v.y * v.y + c3 * v.y * u.y + 1,
          -c1 * u.y * u.z - c2 * v.y * v.z + c3 * v.y * u.z,
          -c1 * u.z * u.x - c2 * v.z * v.x + c3 * v.z * u.x,
          -c1 * u.z * u.y - c2 * v.z * v.y + c3 * v.z * u.y,
          -c1 * u.z * u.z - c2 * v.z * v.z + c3 * v.z * u.z + 1
        );
      }
      else {
        // the most common case, unless "start"="end", or "start"=-"end"
        var hvx;
        var hvz;
        var hvxy;
        var hvxz;
        var hvyz;
        h = 1.0 / ( 1.0 + e );
        hvx = h * v.x;
        hvz = h * v.z;
        hvxy = hvx * v.y;
        hvxz = hvx * v.z;
        hvyz = hvz * v.y;

        return this.rowMajor(
          e + hvx * v.x, hvxy - v.z, hvxz + v.y,
          hvxy + v.z, e + h * v.y * v.y, hvyz - v.x,
          hvxz - v.y, hvyz + v.x, e + hvz * v.z
        );
      }
    },

    setTo32Bit: function() {
      if ( window.Float32Array ) {
        this.entries = new window.Float32Array( this.entries );
      }
      return this;
    },

    setTo64Bit: function() {
      if ( window.Float64Array ) {
        this.entries = new window.Float64Array( this.entries );
      }
      return this;
    },

    /*---------------------------------------------------------------------------*
     * Mutable operations (changes the parameter)
     *----------------------------------------------------------------------------*/

    multiplyVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m01() * v.y + this.m02(),
        this.m10() * v.x + this.m11() * v.y + this.m12() );
    },

    multiplyVector3: function( v ) {
      return v.setXYZ(
        this.m00() * v.x + this.m01() * v.y + this.m02() * v.z,
        this.m10() * v.x + this.m11() * v.y + this.m12() * v.z,
        this.m20() * v.x + this.m21() * v.y + this.m22() * v.z );
    },

    multiplyTransposeVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m10() * v.y,
        this.m01() * v.x + this.m11() * v.y );
    },

    multiplyRelativeVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m01() * v.y,
        this.m10() * v.y + this.m11() * v.y );
    },

    // sets the transform of a Canvas 2D rendering context to the affine part of this matrix
    canvasSetTransform: function( context ) {
      context.setTransform(
        // inlined array entries
        this.entries[ 0 ],
        this.entries[ 1 ],
        this.entries[ 3 ],
        this.entries[ 4 ],
        this.entries[ 6 ],
        this.entries[ 7 ]
      );
    },

    // appends the affine part of this matrix to the Canvas 2D rendering context
    canvasAppendTransform: function( context ) {
      if ( this.type !== Types.IDENTITY ) {
        context.transform(
          // inlined array entries
          this.entries[ 0 ],
          this.entries[ 1 ],
          this.entries[ 3 ],
          this.entries[ 4 ],
          this.entries[ 6 ],
          this.entries[ 7 ]
        );
      }
    }
  };

  Poolable.mixin( Matrix3, {

    //The default factory creates an identity matrix
    defaultFactory: function() { return new Matrix3(); },

    constructorDuplicateFactory: function( pool ) {
      return function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
        var instance = pool.length ? pool.pop() : new Matrix3();
        return instance.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
      };
    }
  } );

  // create an immutable
  Matrix3.IDENTITY = Matrix3.identity();
  Matrix3.IDENTITY.makeImmutable();

  Matrix3.X_REFLECTION = Matrix3.createFromPool(
    -1, 0, 0,
    0, 1, 0,
    0, 0, 1,
    Types.AFFINE );
  Matrix3.X_REFLECTION.makeImmutable();

  Matrix3.Y_REFLECTION = Matrix3.createFromPool(
    1, 0, 0,
    0, -1, 0,
    0, 0, 1,
    Types.AFFINE );
  Matrix3.Y_REFLECTION.makeImmutable();

  //Shortcut for translation times a matrix (without allocating a translation matrix), see scenery#119
  Matrix3.translationTimesMatrix = function( x, y, m ) {
    var type;
    if ( m.type === Types.IDENTITY || m.type === Types.TRANSLATION_2D ) {
      return Matrix3.createFromPool(
        1, 0, m.m02() + x,
        0, 1, m.m12() + y,
        0, 0, 1,
        Types.TRANSLATION_2D );
    }
    else if ( m.type === Types.OTHER ) {
      type = Types.OTHER;
    }
    else {
      type = Types.AFFINE;
    }
    return Matrix3.createFromPool(
      m.m00(), m.m01(), m.m02() + x,
      m.m10(), m.m11(), m.m12() + y,
      m.m20(), m.m21(), m.m22(),
      type );
  };

  Matrix3.printer = {
    print: function( matrix ) {
      console.log( matrix.toString() );
    }
  };

  return Matrix3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * 2-dimensional ray
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Ray2',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  function Ray2( position, direction ) {
    this.position = position;
    this.direction = direction;

    assert && assert( Math.abs( direction.magnitude() - 1 ) < 0.01 );

    phetAllocation && phetAllocation( 'Ray2' );
  }

  dot.register( 'Ray2', Ray2 );

  Ray2.prototype = {
    constructor: Ray2,

    shifted: function( distance ) {
      return new Ray2( this.pointAtDistance( distance ), this.direction );
    },

    pointAtDistance: function( distance ) {
      return this.position.plus( this.direction.timesScalar( distance ) );
    },

    toString: function() {
      return this.position.toString() + ' => ' + this.direction.toString();
    }
  };

  return Ray2;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Forward and inverse transforms with 3x3 matrices. Methods starting with 'transform' will apply the transform from our
 * primary matrix, while methods starting with 'inverse' will apply the transform from the inverse of our matrix.
 *
 * Generally, this means transform.inverseThing( transform.transformThing( thing ) ).equals( thing ).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Transform3',['require','PHET_CORE/inherit','AXON/Events','DOT/dot','DOT/Matrix3','DOT/Vector2','DOT/Ray2'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var dot = require( 'DOT/dot' );

  require( 'DOT/Matrix3' );
  require( 'DOT/Vector2' );
  require( 'DOT/Ray2' );

  var scratchMatrix = new dot.Matrix3();

  function checkMatrix( matrix ) {
    return ( matrix instanceof dot.Matrix3 ) && matrix.isFinite();
  }

  /**
   * Creates a transform based around an initial matrix.
   * @constructor
   * @public
   *
   * @param {Matrix3} matrix
   */
  function Transform3( matrix ) {
    Events.call( this );

    // @private {Matrix3} - The primary matrix used for the transform
    this.matrix = dot.Matrix3.IDENTITY.copy();

    // @private {Matrix3} - The inverse of the primary matrix, computed lazily
    this.inverse = dot.Matrix3.IDENTITY.copy();

    // @private {Matrix3} - The transpose of the primary matrix, computed lazily
    this.matrixTransposed = dot.Matrix3.IDENTITY.copy();

    // @private {Matrix3} - The inverse of the transposed primary matrix, computed lazily
    this.inverseTransposed = dot.Matrix3.IDENTITY.copy();


    // @private {boolean} - Whether this.inverse has been computed based on the latest primary matrix
    this.inverseValid = true;

    // @private {boolean} - Whether this.matrixTransposed has been computed based on the latest primary matrix
    this.transposeValid = true;

    // @private {boolean} - Whether this.inverseTransposed has been computed based on the latest primary matrix
    this.inverseTransposeValid = true;

    if ( matrix ) {
      this.setMatrix( matrix );
    }

    phetAllocation && phetAllocation( 'Transform3' );
  }

  dot.register( 'Transform3', Transform3 );

  inherit( Events, Transform3, {
    /*---------------------------------------------------------------------------*
     * mutators
     *---------------------------------------------------------------------------*/

    /**
     * Sets the value of the primary matrix directly from a Matrix3. Does not change the Matrix3 instance of this
     * Transform3.
     * @public
     *
     * @param {Matrix3} matrix
     */
    setMatrix: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      // copy the matrix over to our matrix
      this.matrix.set( matrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * This should be called after our internal matrix is changed. It marks the other dependent matrices as invalid,
     * and sends out notifications of the change.
     * @private
     */
    invalidate: function() {
      // sanity check
      assert && assert( this.matrix.isFinite() );

      // dependent matrices now invalid
      this.inverseValid = false;
      this.transposeValid = false;
      this.inverseTransposeValid = false;

      this.trigger0( 'change' );
    },

    /**
     * Modifies the primary matrix such that: this.matrix = matrix * this.matrix.
     * @public
     *
     * @param {Matrix3} matrix
     */
    prepend: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      // In the absence of a prepend-multiply function in Matrix3, copy over to a scratch matrix instead
      // TODO: implement a prepend-multiply directly in Matrix3 for a performance increase
      scratchMatrix.set( this.matrix );
      this.matrix.set( matrix );
      this.matrix.multiplyMatrix( scratchMatrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * Optimized prepended translation such that: this.matrix = translation( x, y ) * this.matrix.
     * @public
     *
     * @param {Matrix3} matrix
     */
    prependTranslation: function( x, y ) {
      // See scenery#119 for more details on the need.

      assert && assert( typeof x === 'number' && typeof y === 'number' && isFinite( x ) && isFinite( y ),
        'Attempted to prepend non-finite or non-number (x,y) to the transform' );

      this.matrix.prependTranslation( x, y );

      // set flags and notify
      this.invalidate();
    },

    /**
     * Modifies the primary matrix such that: this.matrix = this.matrix * matrix
     * @public
     *
     * @param {Matrix3} matrix
     */
    append: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      this.matrix.multiplyMatrix( matrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * Like prepend(), but prepends the other transform's matrix.
     * @public
     *
     * @param {Transform3} transform
     */
    prependTransform: function( transform ) {
      this.prepend( transform.matrix );
    },

    /**
     * Like append(), but appends the other transform's matrix.
     * @public
     *
     * @param {Transform3} transform
     */
    appendTransform: function( transform ) {
      this.append( transform.matrix );
    },

    /**
     * Sets the transform of a Canvas context to be equivalent to this transform.
     * @public
     *
     * @param {CanvasRenderingContext2D} context
     */
    applyToCanvasContext: function( context ) {
      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m02(), this.matrix.m12() );
    },

    /*---------------------------------------------------------------------------*
     * getters
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this transform.
     * @public
     *
     * @returns {Transform3}
     */
    copy: function() {
      var transform = new Transform3( this.matrix );

      transform.inverse = this.inverse;
      transform.matrixTransposed = this.matrixTransposed;
      transform.inverseTransposed = this.inverseTransposed;

      transform.inverseValid = this.inverseValid;
      transform.transposeValid = this.transposeValid;
      transform.inverseTransposeValid = this.inverseTransposeValid;
    },

    /**
     * Returns the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix3}
     */
    getMatrix: function() {
      return this.matrix;
    },

    /**
     * Returns the inverse of the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix3}
     */
    getInverse: function() {
      if ( !this.inverseValid ) {
        this.inverseValid = true;

        this.inverse.set( this.matrix );
        this.inverse.invert();
      }
      return this.inverse;
    },

    /**
     * Returns the transpose of the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix3}
     */
    getMatrixTransposed: function() {
      if ( !this.transposeValid ) {
        this.transposeValid = true;

        this.matrixTransposed.set( this.matrix );
        this.matrixTransposed.transpose();
      }
      return this.matrixTransposed;
    },

    /**
     * Returns the inverse of the transpose of matrix of this transform.
     * @public
     *
     * @returns {Matrix3}
     */
    getInverseTransposed: function() {
      if ( !this.inverseTransposeValid ) {
        this.inverseTransposeValid = true;

        this.inverseTransposed.set( this.getInverse() ); // triggers inverse to be valid
        this.inverseTransposed.transpose();
      }
      return this.inverseTransposed;
    },

    /**
     * Returns whether our primary matrix is known to be an identity matrix. If false is returned, it doesn't necessarily
     * mean our matrix isn't an identity matrix, just that it is unlikely in normal usage.
     * @public
     *
     * @returns {boolean}
     */
    isIdentity: function() {
      return this.matrix.type === dot.Matrix3.Types.IDENTITY;
    },

    /**
     * Returns whether any components of our primary matrix are either infinite or NaN.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return this.matrix.isFinite();
    },

    /*---------------------------------------------------------------------------*
     * forward transforms (for Vector2 or scalar)
     *---------------------------------------------------------------------------*/

    /**
     * Transforms a 2-dimensional vector like it is a point with a position (translation is applied).
     * @public
     *
     * For an affine matrix $M$, the result is the homogeneous multiplication $M\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    transformPosition2: function( v ) {
      return this.matrix.timesVector2( v );
    },

    /**
     * Transforms a 2-dimensional vector like position is irrelevant (translation is not applied).
     * @public
     *
     * For an affine matrix $\begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix}$,
     * the result is $\begin{bmatrix} a & b & 0 \\ d & e & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    transformDelta2: function( v ) {
      var m = this.getMatrix();
      // m . v - m . Vector2.ZERO
      return new dot.Vector2( m.m00() * v.x + m.m01() * v.y, m.m10() * v.x + m.m11() * v.y );
    },

    /**
     * Transforms a 2-dimensional vector like it is a normal to a curve (so that the curve is transformed, and the new
     * normal to the curve at the transformed point is returned).
     * @public
     *
     * For an affine matrix $\begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix}$,
     * the result is $\begin{bmatrix} a & e & 0 \\ d & b & 0 \\ 0 & 0 & 1 \end{bmatrix}^{-1} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     * This is essentially the transposed inverse with translation removed.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    transformNormal2: function( v ) {
      return this.getInverse().timesTransposeVector2( v ).normalize();
    },

    /**
     * Returns the resulting x-coordinate of the transformation of all vectors with the initial input x-coordinate. If
     * this is not well-defined (the x value depends on y), an assertion is thrown (and y is assumed to be 0).
     * @public
     *
     * @param {number} x
     * @returns {number}
     */
    transformX: function( x ) {
      var m = this.getMatrix();
      assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );
      return m.m00() * x + m.m02();
    },

    /**
     * Returns the resulting y-coordinate of the transformation of all vectors with the initial input y-coordinate. If
     * this is not well-defined (the y value depends on x), an assertion is thrown (and x is assumed to be 0).
     * @public
     *
     * @param {number} y
     * @returns {number}
     */
    transformY: function( y ) {
      var m = this.getMatrix();
      assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y + m.m12();
    },

    /**
     * Returns the x-coordinate difference for two transformed vectors, which add the x-coordinate difference of the input
     * x (and same y values) beforehand.
     * @public
     *
     * @param {number} x
     * @returns {number}
     */
    transformDeltaX: function( x ) {
      var m = this.getMatrix();
      // same as this.transformDelta2( new dot.Vector2( x, 0 ) ).x;
      return m.m00() * x;
    },

    /**
     * Returns the y-coordinate difference for two transformed vectors, which add the y-coordinate difference of the input
     * y (and same x values) beforehand.
     * @public
     *
     * @param {number} y
     * @returns {number}
     */
    transformDeltaY: function( y ) {
      var m = this.getMatrix();
      // same as this.transformDelta2( new dot.Vector2( 0, y ) ).y;
      return m.m11() * y;
    },

    /**
     * Returns bounds (axis-aligned) that contains the transformed bounds rectangle.
     * @pubic
     *
     * NOTE: transform.inverseBounds2( transform.transformBounds2( bounds ) ) may be larger than the original box,
     * if it includes a rotation that isn't a multiple of $\pi/2$. This is because the returned bounds may expand in
     * area to cover ALL of the corners of the transformed bounding box.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    transformBounds2: function( bounds ) {
      return bounds.transformed( this.matrix );
    },

    /**
     * Returns a transformed kite.Shape.
     * @pubic
     *
     * @param {Shape} shape
     * @returns {Shape}
     */
    transformShape: function( shape ) {
      return shape.transformed( this.matrix );
    },

    /**
     * Returns a transformed ray.
     * @pubic
     *
     * @param {Ray2} ray
     * @returns {Ray2}
     */
    transformRay2: function( ray ) {
      return new dot.Ray2( this.transformPosition2( ray.position ), this.transformDelta2( ray.direction ).normalized() );
    },

    /*---------------------------------------------------------------------------*
     * inverse transforms (for Vector2 or scalar)
     *---------------------------------------------------------------------------*/

    /**
     * Transforms a 2-dimensional vector by the inverse of our transform like it is a point with a position (translation is applied).
     * @public
     *
     * For an affine matrix $M$, the result is the homogeneous multiplication $M^{-1}\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     *
     * This is the inverse of transformPosition2().
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    inversePosition2: function( v ) {
      return this.getInverse().timesVector2( v );
    },

    /**
     * Transforms a 2-dimensional vector by the inverse of our transform like position is irrelevant (translation is not applied).
     * @public
     *
     * For an affine matrix $\begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix}$,
     * the result is $\begin{bmatrix} a & b & 0 \\ d & e & 0 \\ 0 & 0 & 1 \end{bmatrix}^{-1} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     *
     * This is the inverse of transformDelta2().
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    inverseDelta2: function( v ) {
      var m = this.getInverse();
      // m . v - m . Vector2.ZERO
      return new dot.Vector2( m.m00() * v.x + m.m01() * v.y, m.m10() * v.x + m.m11() * v.y );
    },

    /**
     * Transforms a 2-dimensional vector by the inverse of our transform like it is a normal to a curve (so that the
     * curve is transformed, and the new normal to the curve at the transformed point is returned).
     * @public
     *
     * For an affine matrix $\begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix}$,
     * the result is $\begin{bmatrix} a & e & 0 \\ d & b & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     * This is essentially the transposed transform with translation removed.
     *
     * This is the inverse of transformNormal2().
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    inverseNormal2: function( v ) {
      return this.matrix.timesTransposeVector2( v ).normalize();
    },

    /**
     * Returns the resulting x-coordinate of the inverse transformation of all vectors with the initial input x-coordinate. If
     * this is not well-defined (the x value depends on y), an assertion is thrown (and y is assumed to be 0).
     * @public
     *
     * This is the inverse of transformX().
     *
     * @param {number} x
     * @returns {number}
     */
    inverseX: function( x ) {
      var m = this.getInverse();
      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
      return m.m00() * x + m.m02();
    },

    /**
     * Returns the resulting y-coordinate of the inverse transformation of all vectors with the initial input y-coordinate. If
     * this is not well-defined (the y value depends on x), an assertion is thrown (and x is assumed to be 0).
     * @public
     *
     * This is the inverse of transformY().
     *
     * @param {number} y
     * @returns {number}
     */
    inverseY: function( y ) {
      var m = this.getInverse();
      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y + m.m12();
    },

    /**
     * Returns the x-coordinate difference for two inverse-transformed vectors, which add the x-coordinate difference of the input
     * x (and same y values) beforehand.
     * @public
     *
     * This is the inverse of transformDeltaX().
     *
     * @param {number} x
     * @returns {number}
     */
    inverseDeltaX: function( x ) {
      var m = this.getInverse();
      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
      // same as this.inverseDelta2( new dot.Vector2( x, 0 ) ).x;
      return m.m00() * x;
    },

    /**
     * Returns the y-coordinate difference for two inverse-transformed vectors, which add the y-coordinate difference of the input
     * y (and same x values) beforehand.
     * @public
     *
     * This is the inverse of transformDeltaY().
     *
     * @param {number} y
     * @returns {number}
     */
    inverseDeltaY: function( y ) {
      var m = this.getInverse();
      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
      // same as this.inverseDelta2( new dot.Vector2( 0, y ) ).y;
      return m.m11() * y;
    },

    /**
     * Returns bounds (axis-aligned) that contains the inverse-transformed bounds rectangle.
     * @pubic
     *
     * NOTE: transform.inverseBounds2( transform.transformBounds2( bounds ) ) may be larger than the original box,
     * if it includes a rotation that isn't a multiple of $\pi/2$. This is because the returned bounds may expand in
     * area to cover ALL of the corners of the transformed bounding box.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    inverseBounds2: function( bounds2 ) {
      return bounds2.transformed( this.getInverse() );
    },

    /**
     * Returns an inverse-transformed kite.Shape.
     * @pubic
     *
     * This is the inverse of transformShape()
     *
     * @param {Shape} shape
     * @returns {Shape}
     */
    inverseShape: function( shape ) {
      return shape.transformed( this.getInverse() );
    },

    /**
     * Returns an inverse-transformed ray.
     * @pubic
     *
     * This is the inverse of transformRay2()
     *
     * @param {Ray2} ray
     * @returns {Ray2}
     */
    inverseRay2: function( ray ) {
      return new dot.Ray2( this.inversePosition2( ray.position ), this.inverseDelta2( ray.direction ).normalized() );
    }
  } );

  return Transform3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * The main 'kite' namespace object for the exported (non-Require.js) API. Used internally
 * since it prevents Require.js issues with circular dependencies.
 *
 * The returned kite object namespace may be incomplete if not all modules are listed as
 * dependencies. Please use the 'main' module for that purpose if all of Kite is desired.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/kite',['require','PHET_CORE/Namespace','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );

  // object allocation tracking
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );

  var kite = new Namespace( 'kite' );

  // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
  // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
  // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
  // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
  kite.register( 'svgNumber', function( n ) {
    return n.toFixed( 20 );
  } );

  // will be filled in by other modules
  return kite;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A segment represents a specific curve with a start and end.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Segment',['require','KITE/kite','PHET_CORE/inherit','AXON/Events','DOT/Util','DOT/Bounds2'],function( require ) {
  'use strict';

  var kite = require( 'KITE/kite' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var DotUtil = require( 'DOT/Util' ); // eslint-disable-line require-statement-match
  var Bounds2 = require( 'DOT/Bounds2' );

  /*
   * Will contain (for segments):
   * properties (backed by ES5 getters, created usually lazily):
   * start        - start point of this segment
   * end          - end point of this segment
   * startTangent - the tangent vector (normalized) to the segment at the start, pointing in the direction of motion (from start to end)
   * endTangent   - the tangent vector (normalized) to the segment at the end, pointing in the direction of motion (from start to end)
   * bounds       - the bounding box for the segment
   *
   * methods:
   * positionAt( t )          - returns the position parametrically, with 0 <= t <= 1. this does NOT guarantee a constant magnitude tangent... don't feel like adding elliptical functions yet!
   * tangentAt( t )           - returns the non-normalized tangent (dx/dt, dy/dt) parametrically, with 0 <= t <= 1.
   * curvatureAt( t )         - returns the signed curvature (positive for visual clockwise - mathematical counterclockwise)
   * subdivided( t )          - returns an array with 2 sub-segments, split at the parametric t value.
   * getSVGPathFragment()     - returns a string containing the SVG path. assumes that the start point is already provided, so anything that calls this needs to put the M calls first
   * strokeLeft( lineWidth )  - returns an array of segments that will draw an offset curve on the logical left side
   * strokeRight( lineWidth ) - returns an array of segments that will draw an offset curve on the logical right side
   * windingIntersection      - returns the winding number for intersection with a ray
   * getInteriorExtremaTs     - returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on these will result in monotonic segments
   *
   * writeToContext( context ) - draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point
   * transformed( matrix )     - returns a new segment that represents this segment after transformation by the matrix
   */
  function Segment() {
    Events.call( this );
  }

  kite.register( 'Segment', Segment );

  var identityFunction = function identityFunction( x ) { return x; };

  inherit( Events, Segment, {
    /**
     * Will return true if the start/end tangents are purely vertical or horizontal. If all of the segments of a shape
     * have this property, then the only line joins will be a multiple of pi/2 (90 degrees), and so all of the types of
     * line joins will have the same bounds. This means that the stroked bounds will just be a pure dilation of the
     * regular bounds, by lineWidth / 2.
     * @public
     *
     * @returns {boolean}
     */
    areStrokedBoundsDilated: function() {
      var epsilon = 0.0000001;

      // If the derivative at the start/end are pointing in a cardinal direction (north/south/east/west), then the
      // endpoints won't trigger non-dilated bounds, and the interior of the curve will not contribute.
      return Math.abs( this.startTangent.x * this.startTangent.y ) < epsilon && Math.abs( this.endTangent.x * this.endTangent.y ) < epsilon;
    },

    // TODO: override everywhere so this isn't necessary (it's not particularly efficient!)
    getBoundsWithTransform: function( matrix ) {
      var transformedSegment = this.transformed( matrix );
      return transformedSegment.getBounds();
    },

    // tList should be a list of sorted t values from 0 <= t <= 1
    subdivisions: function( tList ) {
      // this could be solved by recursion, but we don't plan on the JS engine doing tail-call optimization
      var right = this;
      var result = [];
      for ( var i = 0; i < tList.length; i++ ) {
        // assume binary subdivision
        var t = tList[ i ];
        var arr = right.subdivided( t );
        assert && assert( arr.length === 2 );
        result.push( arr[ 0 ] );
        right = arr[ 1 ];

        // scale up the remaining t values
        for ( var j = i + 1; j < tList.length; j++ ) {
          tList[ j ] = DotUtil.linear( t, 1, 0, 1, tList[ j ] );
        }
      }
      result.push( right );
      return result;
    },

    // return an array of segments from breaking this segment into monotone pieces
    subdividedIntoMonotone: function() {
      return this.subdivisions( this.getInteriorExtremaTs() );
    },

    /*
     * toPiecewiseLinearSegments( options ), with the following options provided:
     * - minLevels:                       how many levels to force subdivisions
     * - maxLevels:                       prevent subdivision past this level
     * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve
     * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments
     * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
     * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
     *                                    instead of using our brute-force logic
     */
    toPiecewiseLinearSegments: function( options, minLevels, maxLevels, segments, start, end ) {
      // for the first call, initialize min/max levels from our options
      minLevels = minLevels === undefined ? options.minLevels : minLevels;
      maxLevels = maxLevels === undefined ? options.maxLevels : maxLevels;
      segments = segments || [];
      var pointMap = options.pointMap || identityFunction;

      // points mapped by the (possibly-nonlinear) pointMap.
      start = start || pointMap( this.start );
      end = end || pointMap( this.end );
      var middle = pointMap( this.positionAt( 0.5 ) );

      assert && assert( minLevels <= maxLevels );
      assert && assert( options.distanceEpsilon === null || typeof options.distanceEpsilon === 'number' );
      assert && assert( options.curveEpsilon === null || typeof options.curveEpsilon === 'number' );
      assert && assert( !pointMap || typeof pointMap === 'function' );

      // i.e. we will have finished = maxLevels === 0 || ( minLevels <= 0 && epsilonConstraints ), just didn't want to one-line it
      var finished = maxLevels === 0; // bail out once we reach our maximum number of subdivision levels
      if ( !finished && minLevels <= 0 ) { // force subdivision if minLevels hasn't been reached
        // flatness criterion: A=start, B=end, C=midpoint, d0=distance from AB, d1=||B-A||, subdivide if d0/d1 > sqrt(epsilon)
        finished = ( options.curveEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) / start.distanceSquared( end ) < options.curveEpsilon ) ) &&
                   // deviation criterion
                   ( options.distanceEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) < options.distanceEpsilon ) );
      }

      if ( finished ) {
        segments.push( new kite.Line( start, end ) );
      }
      else {
        var subdividedSegments = this.subdivided( 0.5 );
        subdividedSegments[ 0 ].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, start, middle );
        subdividedSegments[ 1 ].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, middle, end );
      }
      return segments;
    }
  } );

  /**
   * Adds getter/setter function pairs and ES5 pairs, e.g. addInvalidatingGetterSetter( Arc, 'radius' ) would add:
   * - segment.getRadius()
   * - segment.setRadius( value )
   * - segment.radius // getter and setter
   *
   * It assumes the following is the internal name: '_' + name
   *
   * @param {Function} type - Should be the constructor of the type. We will modify its prototype
   * @param {string} name - Name of the
   */
  Segment.addInvalidatingGetterSetter = function( type, name ) {
    var internalName = '_' + name;
    var capitalizedName = name.charAt( 0 ).toUpperCase() + name.slice( 1 );
    var getterName = 'get' + capitalizedName;
    var setterName = 'set' + capitalizedName;

    // e.g. getRadius()
    type.prototype[ getterName ] = function() {
      return this[ internalName ];
    };

    // e.g. setRadius( value )
    type.prototype[ setterName ] = function( value ) {
      if ( this[ internalName ] !== value ) {
        this[ internalName ] = value;
        this.invalidate();
      }
      return this; // allow chaining
    };

    Object.defineProperty( type.prototype, name, {
      set: type.prototype[ setterName ],
      get: type.prototype[ getterName ]
    } );
  };

  // list of { segment: ..., t: ..., closestPoint: ..., distanceSquared: ... } (since there can be duplicates), threshold is used for subdivision,
  // where it will exit if all of the segments are shorter than the threshold
  // TODO: solve segments to determine this analytically!
  Segment.closestToPoint = function( segments, point, threshold ) {
    var thresholdSquared = threshold * threshold;
    var items = [];
    var bestList = [];
    var bestDistanceSquared = Number.POSITIVE_INFINITY;
    var thresholdOk = false;

    _.each( segments, function( segment ) {
      // if we have an explicit computation for this segment, use it
      if ( segment.explicitClosestToPoint ) {
        var infos = segment.explicitClosestToPoint( point );
        _.each( infos, function( info ) {
          if ( info.distanceSquared < bestDistanceSquared ) {
            bestList = [ info ];
            bestDistanceSquared = info.distanceSquared;
          }
          else if ( info.distanceSquared === bestDistanceSquared ) {
            bestList.push( info );
          }
        } );
      }
      else {
        // otherwise, we will split based on monotonicity, so we can subdivide
        // separate, so we can map the subdivided segments
        var ts = [ 0 ].concat( segment.getInteriorExtremaTs() ).concat( [ 1 ] );
        for ( var i = 0; i < ts.length - 1; i++ ) {
          var ta = ts[ i ];
          var tb = ts[ i + 1 ];
          var pa = segment.positionAt( ta );
          var pb = segment.positionAt( tb );
          var bounds = Bounds2.point( pa ).addPoint( pb );
          var minDistanceSquared = bounds.minimumDistanceToPointSquared( point );
          if ( minDistanceSquared <= bestDistanceSquared ) {
            var maxDistanceSquared = bounds.maximumDistanceToPointSquared( point );
            if ( maxDistanceSquared < bestDistanceSquared ) {
              bestDistanceSquared = maxDistanceSquared;
              bestList = []; // clear it
            }
            items.push( {
              ta: ta,
              tb: tb,
              pa: pa,
              pb: pb,
              segment: segment,
              bounds: bounds,
              min: minDistanceSquared,
              max: maxDistanceSquared
            } );
          }
        }
      }
    } );

    while ( items.length && !thresholdOk ) {
      var curItems = items;
      items = [];

      // whether all of the segments processed are shorter than the threshold
      thresholdOk = true;

      _.each( curItems, function( item ) {
        if ( item.minDistanceSquared > bestDistanceSquared ) {
          return; // drop this item
        }
        if ( thresholdOk && item.pa.distanceSquared( item.pb ) > thresholdSquared ) {
          thresholdOk = false;
        }
        var tmid = ( item.ta + item.tb ) / 2;
        var pmid = item.segment.positionAt( tmid );
        var boundsA = Bounds2.point( item.pa ).addPoint( pmid );
        var boundsB = Bounds2.point( item.pb ).addPoint( pmid );
        var minA = boundsA.minimumDistanceToPointSquared( point );
        var minB = boundsB.minimumDistanceToPointSquared( point );
        if ( minA <= bestDistanceSquared ) {
          var maxA = boundsA.maximumDistanceToPointSquared( point );
          if ( maxA < bestDistanceSquared ) {
            bestDistanceSquared = maxA;
            bestList = []; // clear it
          }
          items.push( {
            ta: item.ta,
            tb: tmid,
            pa: item.pa,
            pb: pmid,
            segment: item.segment,
            bounds: boundsA,
            min: minA,
            max: maxA
          } );
        }
        if ( minB <= bestDistanceSquared ) {
          var maxB = boundsB.maximumDistanceToPointSquared( point );
          if ( maxB < bestDistanceSquared ) {
            bestDistanceSquared = maxB;
            bestList = []; // clear it
          }
          items.push( {
            ta: tmid,
            tb: item.tb,
            pa: pmid,
            pb: item.pb,
            segment: item.segment,
            bounds: boundsB,
            min: minB,
            max: maxB
          } );
        }
      } );
    }

    // if there are any closest regions, they are within the threshold, so we will add them all
    _.each( items, function( item ) {
      var t = ( item.ta + item.tb ) / 2;
      var closestPoint = item.segment.positionAt( t );
      bestList.push( {
        segment: item.segment,
        t: t,
        closestPoint: closestPoint,
        distanceSquared: point.distanceSquared( closestPoint )
      } );
    } );

    return bestList;
  };

  return Segment;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Linear segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Line',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Util = require( 'DOT/Util' );

  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );

  var scratchVector2 = new Vector2();

  function Line( start, end ) {
    Segment.call( this );

    this._start = start;
    this._end = end;

    this.invalidate();
  }

  kite.register( 'Line', Line );

  inherit( Segment, Line, {

    // @public - Clears cached information, should be called when any of the 'constructor arguments' are mutated.
    invalidate: function() {
      // Lazily-computed derived information
      this._tangent = null; // {Vector2 | null}
      this._bounds = null; // {Bounds2 | null}

      this.trigger0( 'invalidated' );
    },

    getStartTangent: function() {
      if ( this._tangent === null ) {
        // TODO: allocation reduction
        this._tangent = this._end.minus( this._start ).normalized();
      }
      return this._tangent;
    },
    get startTangent() { return this.getStartTangent(); },

    getEndTangent: function() {
      return this.getStartTangent();
    },
    get endTangent() { return this.getEndTangent(); },

    getBounds: function() {
      // TODO: allocation reduction
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING.copy().addPoint( this._start ).addPoint( this._end );
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    getBoundsWithTransform: function( matrix ) {
      // uses mutable calls
      var bounds = Bounds2.NOTHING.copy();
      bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._start ) ) );
      bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._end ) ) );
      return bounds;
    },

    getNondegenerateSegments: function() {
      // if it is degenerate (0-length), just ignore it
      if ( this._start.equals( this._end ) ) {
        return [];
      }
      else {
        return [ this ];
      }
    },

    positionAt: function( t ) {
      return this._start.plus( this._end.minus( this._start ).times( t ) );
    },

    tangentAt: function( t ) {
      // tangent always the same, just use the start tanget
      return this.getStartTangent();
    },

    curvatureAt: function( t ) {
      return 0; // no curvature on a straight line segment
    },

    getSVGPathFragment: function() {
      return 'L ' + kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
    },

    strokeLeft: function( lineWidth ) {
      var offset = this.getEndTangent().perpendicular().negated().times( lineWidth / 2 );
      return [ new kite.Line( this._start.plus( offset ), this._end.plus( offset ) ) ];
    },

    strokeRight: function( lineWidth ) {
      var offset = this.getStartTangent().perpendicular().times( lineWidth / 2 );
      return [ new kite.Line( this._end.plus( offset ), this._start.plus( offset ) ) ];
    },

    // lines are already monotone
    getInteriorExtremaTs: function() { return []; },

    subdivided: function( t ) {
      var pt = this.positionAt( t );
      return [
        new kite.Line( this._start, pt ),
        new kite.Line( pt, this._end )
      ];
    },

    intersection: function( ray ) {
      // We solve for the parametric line-line intersection, and then ensure the parameters are within both
      // the line segment and forwards from the ray.

      var result = [];

      var start = this._start;
      var end = this._end;

      var diff = end.minus( start );

      if ( diff.magnitudeSquared() === 0 ) {
        return result;
      }

      var denom = ray.direction.y * diff.x - ray.direction.x * diff.y;

      // If denominator is 0, the lines are parallel or coincident
      if ( denom === 0 ) {
        return result;
      }

      // linear parameter where start (0) to end (1)
      var t = ( ray.direction.x * ( start.y - ray.position.y ) - ray.direction.y * ( start.x - ray.position.x ) ) / denom;

      // check that the intersection point is between the line segment's endpoints
      if ( t < 0 || t >= 1 ) {
        return result;
      }

      // linear parameter where ray.position (0) to ray.position+ray.direction (1)
      var s = ( diff.x * ( start.y - ray.position.y ) - diff.y * ( start.x - ray.position.x ) ) / denom;

      // bail if it is behind our ray
      if ( s < 0.00000001 ) {
        return result;
      }

      // return the proper winding direction depending on what way our line intersection is "pointed"
      var perp = diff.perpendicular();
      result.push( {
        distance: s,
        point: start.plus( diff.times( t ) ),
        normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
        wind: ray.direction.perpendicular().dot( diff ) < 0 ? 1 : -1,
        segment: this
      } );
      return result;
    },

    // returns the resultant winding number of this ray intersecting this segment.
    windingIntersection: function( ray ) {
      var hits = this.intersection( ray );
      if ( hits.length ) {
        return hits[ 0 ].wind;
      }
      else {
        return 0;
      }
    },

    // assumes the current position is at start
    writeToContext: function( context ) {
      context.lineTo( this._end.x, this._end.y );
    },

    transformed: function( matrix ) {
      return new kite.Line( matrix.timesVector2( this._start ), matrix.timesVector2( this._end ) );
    },

    explicitClosestToPoint: function( point ) {
      var diff = this._end.minus( this._start );
      var t = point.minus( this._start ).dot( diff ) / diff.magnitudeSquared();
      t = Util.clamp( t, 0, 1 );
      var closestPoint = this.positionAt( t );
      return [
        {
          segment: this,
          t: t,
          closestPoint: closestPoint,
          distanceSquared: point.distanceSquared( closestPoint )
        }
      ];
    },

    // given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b
    reparameterized: function( a, b ) {
      return new kite.Line( this.positionAt( b ), this.positionAt( a + b ) );
    },

    polarToCartesian: function( options ) {
      if ( this._start.x === this._end.x ) {
        // angle is the same, we are still a line segment!
        return [ new kite.Line( Vector2.createPolar( this._start.y, this._start.x ), Vector2.createPolar( this._end.y, this._end.x ) ) ];
      }
      else if ( this._start.y === this._end.y ) {
        // we have a constant radius, so we are a circular arc
        return [ new kite.Arc( Vector2.ZERO, this._start.y, this._start.x, this._end.x, this._start.x > this._end.x ) ];
      }
      else {
        return this.toPiecewiseLinearSegments( options );
      }
    }
  } );

  Segment.addInvalidatingGetterSetter( Line, 'start' );
  Segment.addInvalidatingGetterSetter( Line, 'end' );

  return Line;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Arc segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Arc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var DotUtil = require( 'DOT/Util' ); // eslint-disable-line require-statement-match

  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );

  /**
   * Creates a circular arc (or circle if the startAngle/endAngle difference is ~2pi).
   * See http://www.w3.org/TR/2dcontext/#dom-context-2d-arc for detailed information on the parameters.
   *
   * @param {Vector2} center - Center of the arc (every point on the arc is equally far from the center)
   * @param {number} radius - How far from the center the arc will be
   * @param {number} startAngle - Angle (radians) of the start of the arc
   * @param {number} endAngle - Angle (radians) of the end of the arc
   * @param {boolean} anticlockwise - Decides which direction the arc takes around the center
   * @constructor
   */
  function Arc( center, radius, startAngle, endAngle, anticlockwise ) {
    Segment.call( this );

    this._center = center;
    this._radius = radius;
    this._startAngle = startAngle;
    this._endAngle = endAngle;
    this._anticlockwise = anticlockwise;

    this.invalidate();
  }

  kite.register( 'Arc', Arc );

  inherit( Segment, Arc, {
    // @public - Clears cached information, should be called when any of the 'constructor arguments' are mutated.
    invalidate: function() {
      // Lazily-computed derived information
      this._start = null; // {Vector2 | null}
      this._end = null; // {Vector2 | null}
      this._startTangent = null; // {Vector2 | null}
      this._endTangent = null; // {Vector2 | null}
      this._actualEndAngle = null; // {number | null} - End angle in relation to our start angle (can get remapped)
      this._isFullPerimeter = null; // {boolean | null} - Whether it's a full circle (and not just an arc)
      this._angleDifference = null; // {number | null}
      this._bounds = null; // {Bounds2 | null}

      // Remap negative radius to a positive radius
      if ( this._radius < 0 ) {
        // support this case since we might actually need to handle it inside of strokes?
        this._radius = -this._radius;
        this._startAngle += Math.PI;
        this._endAngle += Math.PI;
      }

      // Constraints that should always be satisfied
      assert && assert( !( ( !this.anticlockwise && this.endAngle - this.startAngle <= -Math.PI * 2 ) ||
                           ( this.anticlockwise && this.startAngle - this.endAngle <= -Math.PI * 2 ) ),
        'Not handling arcs with start/end angles that show differences in-between browser handling' );
      assert && assert( !( ( !this.anticlockwise && this.endAngle - this.startAngle > Math.PI * 2 ) ||
                           ( this.anticlockwise && this.startAngle - this.endAngle > Math.PI * 2 ) ),
        'Not handling arcs with start/end angles that show differences in-between browser handling' );

      this.trigger0( 'invalidated' );
    },

    getStart: function() {
      if ( this._start === null ) {
        this._start = this.positionAtAngle( this._startAngle );
      }
      return this._start;
    },
    get start() { return this.getStart(); },

    getEnd: function() {
      if ( this._end === null ) {
        this._end = this.positionAtAngle( this._endAngle );
      }
      return this._end;
    },
    get end() { return this.getEnd(); },

    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAtAngle( this._startAngle );
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },

    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAtAngle( this._endAngle );
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },

    getActualEndAngle: function() {
      if ( this._actualEndAngle === null ) {
        // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle
        if ( this._anticlockwise ) {
          // angle is 'decreasing'
          // -2pi <= end - start < 2pi
          if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle - 2 * Math.PI;
          }
          else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
        else {
          // angle is 'increasing'
          // -2pi < end - start <= 2pi
          if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle + Math.PI * 2;
          }
          else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
      }
      return this._actualEndAngle;
    },
    get actualEndAngle() { return this.getActualEndAngle(); },

    getIsFullPerimeter: function() {
      if ( this._isFullPerimeter === null ) {
        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
      }
      return this._isFullPerimeter;
    },
    get isFullPerimeter() { return this.getIsFullPerimeter(); },

    getAngleDifference: function() {
      if ( this._angleDifference === null ) {
        // compute an angle difference that represents how "much" of the circle our arc covers
        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
        if ( this._angleDifference < 0 ) {
          this._angleDifference += Math.PI * 2;
        }
        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
      }
      return this._angleDifference;
    },
    get angleDifference() { return this.getAngleDifference(); },

    getBounds: function() {
      if ( this._bounds === null ) {
        // acceleration for intersection
        this._bounds = Bounds2.NOTHING.copy().withPoint( this.getStart() )
          .withPoint( this.getEnd() );

        // if the angles are different, check extrema points
        if ( this._startAngle !== this._endAngle ) {
          // check all of the extrema points
          this.includeBoundsAtAngle( 0 );
          this.includeBoundsAtAngle( Math.PI / 2 );
          this.includeBoundsAtAngle( Math.PI );
          this.includeBoundsAtAngle( 3 * Math.PI / 2 );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    getNondegenerateSegments: function() {
      if ( this._radius <= 0 || this._startAngle === this._endAngle ) {
        return [];
      }
      else {
        return [ this ]; // basically, Arcs aren't really degenerate that easily
      }
    },

    includeBoundsAtAngle: function( angle ) {
      if ( this.containsAngle( angle ) ) {
        // the boundary point is in the arc
        this._bounds = this._bounds.withPoint( this._center.plus( Vector2.createPolar( this._radius, angle ) ) );
      }
    },

    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.
    mapAngle: function( angle ) {
      // consider an assert that we contain that angle?
      return ( this._startAngle > this.getActualEndAngle() ) ?
             DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
             DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
    },

    tAtAngle: function( angle ) {
      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
    },

    angleAt: function( t ) {
      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
    },

    positionAt: function( t ) {
      return this.positionAtAngle( this.angleAt( t ) );
    },

    tangentAt: function( t ) {
      return this.tangentAtAngle( this.angleAt( t ) );
    },

    curvatureAt: function( t ) {
      return ( this._anticlockwise ? -1 : 1 ) / this._radius;
    },

    positionAtAngle: function( angle ) {
      return this._center.plus( Vector2.createPolar( this._radius, angle ) );
    },

    tangentAtAngle: function( angle ) {
      var normal = Vector2.createPolar( 1, angle );

      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
    },

    // TODO: refactor? shared with EllipticalArc (use this improved version)
    containsAngle: function( angle ) {
      // transform the angle into the appropriate coordinate form
      // TODO: check anticlockwise version!
      var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;

      // get the angle between 0 and 2pi
      var positiveMinAngle = DotUtil.moduloBetweenDown( normalizedAngle, 0, Math.PI * 2 );

      return positiveMinAngle <= this.angleDifference;
    },

    getSVGPathFragment: function() {
      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info
      // rx ry x-axis-rotation large-arc-flag sweep-flag x y

      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
      var sweepFlag = this._anticlockwise ? '0' : '1';
      var largeArcFlag;
      if ( this.angleDifference < Math.PI * 2 - epsilon ) {
        largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';
        return 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' + largeArcFlag +
               ' ' + sweepFlag + ' ' + kite.svgNumber( this.end.x ) + ' ' + kite.svgNumber( this.end.y );
      }
      else {
        // circle (or almost-circle) case needs to be handled differently
        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs

        // get the angle that is between and opposite of both of the points
        var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
        var splitPoint = this._center.plus( Vector2.createPolar( this._radius, splitOppositeAngle ) );

        largeArcFlag = '0'; // since we split it in 2, it's always the small arc

        var firstArc = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' +
                       largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( splitPoint.x ) + ' ' + kite.svgNumber( splitPoint.y );
        var secondArc = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' +
                        largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( this.end.x ) + ' ' + kite.svgNumber( this.end.y );

        return firstArc + ' ' + secondArc;
      }
    },

    strokeLeft: function( lineWidth ) {
      return [ new kite.Arc( this._center, this._radius + ( this._anticlockwise ? 1 : -1 ) * lineWidth / 2, this._startAngle, this._endAngle, this._anticlockwise ) ];
    },

    strokeRight: function( lineWidth ) {
      return [ new kite.Arc( this._center, this._radius + ( this._anticlockwise ? -1 : 1 ) * lineWidth / 2, this._endAngle, this._startAngle, !this._anticlockwise ) ];
    },

    // not including 0 and 1
    getInteriorExtremaTs: function() {
      var that = this;
      var result = [];
      _.each( [ 0, Math.PI / 2, Math.PI, 3 * Math.PI / 2 ], function( angle ) {
        if ( that.containsAngle( angle ) ) {
          var t = that.tAtAngle( angle );
          var epsilon = 0.0000000001; // TODO: general kite epsilon?
          if ( t > epsilon && t < 1 - epsilon ) {
            result.push( t );
          }
        }
      } );
      return result.sort(); // modifies original, which is OK
    },

    subdivided: function( t ) {
      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles
      var angle0 = this.angleAt( 0 );
      var angleT = this.angleAt( t );
      var angle1 = this.angleAt( 1 );
      return [
        new kite.Arc( this._center, this._radius, angle0, angleT, this._anticlockwise ),
        new kite.Arc( this._center, this._radius, angleT, angle1, this._anticlockwise )
      ];
    },

    intersection: function( ray ) {
      var result = []; // hits in order

      // left here, if in the future we want to better-handle boundary points
      var epsilon = 0;

      // Run a general circle-intersection routine, then we can test the angles later.
      // Solves for the two solutions t such that ray.position + ray.direction * t is on the circle.
      // Then we check whether the angle at each possible hit point is in our arc.
      var centerToRay = ray.position.minus( this._center );
      var tmp = ray.direction.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var discriminant = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this._radius * this._radius );
      if ( discriminant < epsilon ) {
        // ray misses circle entirely
        return result;
      }
      var base = ray.direction.dot( this._center ) - ray.direction.dot( ray.position );
      var sqt = Math.sqrt( discriminant ) / 2;
      var ta = base - sqt;
      var tb = base + sqt;

      if ( tb < epsilon ) {
        // circle is behind ray
        return result;
      }

      var pointB = ray.pointAtDistance( tb );
      var normalB = pointB.minus( this._center ).normalized();

      if ( ta < epsilon ) {
        // we are inside the circle, so only one intersection is possible
        if ( this.containsAngle( normalB.angle() ) ) {
          result.push( {
            distance: tb,
            point: pointB,
            normal: normalB.negated(), // normal is towards the ray
            wind: this._anticlockwise ? -1 : 1 // since we are inside, wind this way
          } );
        }
      }
      else {
        // two possible hits (outside circle)
        var pointA = ray.pointAtDistance( ta );
        var normalA = pointA.minus( this._center ).normalized();

        if ( this.containsAngle( normalA.angle() ) ) {
          result.push( {
            distance: ta,
            point: pointA,
            normal: normalA,
            wind: this._anticlockwise ? 1 : -1 // hit from outside
          } );
        }
        if ( this.containsAngle( normalB.angle() ) ) {
          result.push( {
            distance: tb,
            point: pointB,
            normal: normalB.negated(),
            wind: this._anticlockwise ? -1 : 1 // this is the far hit, which winds the opposite way
          } );
        }
      }

      return result;
    },

    // returns the resultant winding number of this ray intersecting this segment.
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },

    writeToContext: function( context ) {
      context.arc( this._center.x, this._center.y, this._radius, this._startAngle, this._endAngle, this._anticlockwise );
    },

    // TODO: test various transform types, especially rotations, scaling, shears, etc.
    transformed: function( matrix ) {
      // so we can handle reflections in the transform, we do the general case handling for start/end angles
      var startAngle = matrix.timesVector2( Vector2.createPolar( 1, this._startAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();
      var endAngle = matrix.timesVector2( Vector2.createPolar( 1, this._endAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();

      // reverse the 'clockwiseness' if our transform includes a reflection
      var anticlockwise = matrix.getDeterminant() >= 0 ? this._anticlockwise : !this._anticlockwise;

      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
      }

      var scaleVector = matrix.getScaleVector();
      if ( scaleVector.x !== scaleVector.y ) {
        var radiusX = scaleVector.x * this._radius;
        var radiusY = scaleVector.y * this._radius;
        return new kite.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, 0, startAngle, endAngle, anticlockwise );
      }
      else {
        var radius = scaleVector.x * this._radius;
        return new kite.Arc( matrix.timesVector2( this._center ), radius, startAngle, endAngle, anticlockwise );
      }
    }
  } );

  Segment.addInvalidatingGetterSetter( Arc, 'center' );
  Segment.addInvalidatingGetterSetter( Arc, 'radius' );
  Segment.addInvalidatingGetterSetter( Arc, 'startAngle' );
  Segment.addInvalidatingGetterSetter( Arc, 'endAngle' );
  Segment.addInvalidatingGetterSetter( Arc, 'anticlockwise' );

  return Arc;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Styles needed to determine a stroked line shape.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/util/LineStyles',['require','KITE/kite','DOT/Util','PHET_CORE/inherit','KITE/segments/Arc','KITE/segments/Line'],function( require ) {
  'use strict';

  var kite = require( 'KITE/kite' );
  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;
  var inherit = require( 'PHET_CORE/inherit' );

  var Arc = require( 'KITE/segments/Arc' );
  var Line = require( 'KITE/segments/Line' );

  function LineStyles( args ) {
    if ( args === undefined ) {
      args = {};
    }
    this.lineWidth = args.lineWidth !== undefined ? args.lineWidth : 1;
    this.lineCap = args.lineCap !== undefined ? args.lineCap : 'butt'; // butt, round, square
    this.lineJoin = args.lineJoin !== undefined ? args.lineJoin : 'miter'; // miter, round, bevel
    this.lineDash = args.lineDash ? args.lineDash : []; // [] is default, otherwise an array of numbers
    this.lineDashOffset = args.lineDashOffset !== undefined ? args.lineDashOffset : 0; // 0 default, any number
    this.miterLimit = args.miterLimit !== undefined ? args.miterLimit : 10; // see https://svgwg.org/svg2-draft/painting.html for miterLimit computations

    assert && assert( Array.isArray( this.lineDash ) );
  }

  kite.register( 'LineStyles', LineStyles );

  inherit( Object, LineStyles, {

    equals: function( other ) {
      var typical = this.lineWidth === other.lineWidth &&
                    this.lineCap === other.lineCap &&
                    this.lineJoin === other.lineJoin &&
                    this.miterLimit === other.miterLimit &&
                    this.lineDashOffset === other.lineDashOffset;
      if ( !typical ) {
        return false;
      }

      if ( this.lineDash.length === other.lineDash.length ) {
        for ( var i = 0; i < this.lineDash.length; i++ ) {
          if ( this.lineDash[ i ] !== other.lineDash[ i ] ) {
            return false;
          }
        }
      }
      else {
        // line dashes must be different
        return false;
      }

      return true;
    },

    /*
     * Creates an array of Segments that make up a line join, to the left side.
     *
     * Joins two segments together on the logical "left" side, at 'center' (where they meet), and un-normalized tangent
     * vectors in the direction of the stroking. To join on the "right" side, switch the tangent order and negate them.
     */
    leftJoin: function( center, fromTangent, toTangent ) {
      fromTangent = fromTangent.normalized();
      toTangent = toTangent.normalized();

      // where our join path starts and ends
      var fromPoint = center.plus( fromTangent.perpendicular().negated().times( this.lineWidth / 2 ) );
      var toPoint = center.plus( toTangent.perpendicular().negated().times( this.lineWidth / 2 ) );

      var bevel = ( fromPoint.equals( toPoint ) ? [] : [ new Line( fromPoint, toPoint ) ] );

      // only insert a join on the non-acute-angle side
      if ( fromTangent.perpendicular().dot( toTangent ) > 0 ) {
        switch( this.lineJoin ) {
          case 'round':
            var fromAngle = fromTangent.angle() + Math.PI / 2;
            var toAngle = toTangent.angle() + Math.PI / 2;
            return [ new Arc( center, this.lineWidth / 2, fromAngle, toAngle, true ) ];
          case 'miter':
            var theta = fromTangent.angleBetween( toTangent.negated() );
            if ( 1 / Math.sin( theta / 2 ) <= this.miterLimit && theta < Math.PI - 0.00001 ) {
              // draw the miter
              var miterPoint = lineLineIntersection( fromPoint, fromPoint.plus( fromTangent ), toPoint, toPoint.plus( toTangent ) );
              return [
                new Line( fromPoint, miterPoint ),
                new Line( miterPoint, toPoint )
              ];
            }
            else {
              // angle too steep, use bevel instead. same as below, but copied for linter
              return bevel;
            }
            break;
          case 'bevel':
            return bevel;
        }
      }
      else {
        // no join necessary here since we have the acute angle. just simple lineTo for now so that the next segment starts from the right place
        // TODO: can we prevent self-intersection here?
        return bevel;
      }
    },

    /*
     * Creates an array of Segments that make up a line join, to the right side.
     *
     * Joins two segments together on the logical "right" side, at 'center' (where they meet), and normalized tangent
     * vectors in the direction of the stroking. To join on the "left" side, switch the tangent order and negate them.
     */
    rightJoin: function( center, fromTangent, toTangent ) {
      return this.leftJoin( center, toTangent.negated(), fromTangent.negated() );
    },

    /*
     * Creates an array of Segments that make up a line cap from the endpoint 'center' in the direction of the tangent
     */
    cap: function( center, tangent ) {
      tangent = tangent.normalized();

      var fromPoint = center.plus( tangent.perpendicular().times( -this.lineWidth / 2 ) );
      var toPoint = center.plus( tangent.perpendicular().times( this.lineWidth / 2 ) );

      switch( this.lineCap ) {
        case 'butt':
          return [ new Line( fromPoint, toPoint ) ];
        case 'round':
          var tangentAngle = tangent.angle();
          return [ new Arc( center, this.lineWidth / 2, tangentAngle + Math.PI / 2, tangentAngle - Math.PI / 2, true ) ];
        case 'square':
          var toLeft = tangent.perpendicular().negated().times( this.lineWidth / 2 );
          var toRight = tangent.perpendicular().times( this.lineWidth / 2 );
          var toFront = tangent.times( this.lineWidth / 2 );

          var left = center.plus( toLeft ).plus( toFront );
          var right = center.plus( toRight ).plus( toFront );
          return [
            new Line( fromPoint, left ),
            new Line( left, right ),
            new Line( right, toPoint )
          ];
      }
    }
  } );

  return kite.LineStyles;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A Canvas-style stateful (mutable) subpath, which tracks segments in addition to the points.
 *
 * See http://www.w3.org/TR/2dcontext/#concept-path
 * for the path / subpath Canvas concept.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/util/Subpath',['require','DOT/Bounds2','PHET_CORE/inherit','AXON/Events','KITE/kite','KITE/segments/Line','KITE/segments/Arc','KITE/util/LineStyles'],function( require ) {
  'use strict';

  var Bounds2 = require( 'DOT/Bounds2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );

  var kite = require( 'KITE/kite' );

  var Line = require( 'KITE/segments/Line' );
  var Arc = require( 'KITE/segments/Arc' );
  var LineStyles = require( 'KITE/util/LineStyles' );

  // all arguments optional (they are for the copy() method)
  function Subpath( segments, points, closed ) {
    Events.call( this );

    var self = this;

    this.segments = [];

    // recombine points if necessary, based off of start points of segments + the end point of the last segment
    this.points = points || ( ( segments && segments.length ) ? _.map( segments, function( segment ) { return segment.start; } ).concat( segments[ segments.length - 1 ].end ) : [] );
    this.closed = !!closed;

    // cached stroked shape (so hit testing can be done quickly on stroked shapes)
    this._strokedSubpaths = null;
    this._strokedSubpathsComputed = false;
    this._strokedStyles = null;

    this._bounds = null; // {Bounds2 | null} - If non-null, the bounds of the subpath

    this._invalidateListener = this.invalidate.bind( this );
    this._invalidatingPoints = false; // So we can invalidate all of the points without firing invalidation tons of times

    // Add all segments directly (hooks up invalidation listeners properly)
    if ( segments ) {
      for ( var i = 0; i < segments.length; i++ ) {
        _.each( segments[ i ].getNondegenerateSegments(), function( segment ) {
          self.addSegmentDirectly( segment );
        } );
      }
    }
  }

  kite.register( 'Subpath', Subpath );

  inherit( Events, Subpath, {
    getBounds: function() {
      if ( this._bounds === null ) {
        var bounds = Bounds2.NOTHING.copy();
        _.each( this.segments, function( segment ) {
          bounds.includeBounds( segment.getBounds() );
        } );
        this._bounds = bounds;
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    copy: function() {
      return new Subpath( this.segments.slice( 0 ), this.points.slice( 0 ), this.closed );
    },

    invalidatePoints: function() {
      this._invalidatingPoints = true;

      var numSegments = this.segments.length;
      for ( var i = 0; i < numSegments; i++ ) {
        this.segments[ i ].invalidate();
      }

      this._invalidatingPoints = false;
      this.invalidate();
    },

    invalidate: function() {
      if ( !this._invalidatingPoints ) {
        this._bounds = null;
        this._strokedSubpathsComputed = false;
        this.trigger0( 'invalidated' );
      }
    },

    addPoint: function( point ) {
      this.points.push( point );

      return this; // allow chaining
    },

    // @private - REALLY! Make sure we invalidate() after this is called
    addSegmentDirectly: function( segment ) {
      assert && assert( segment.start.isFinite(), 'Segment start is infinite' );
      assert && assert( segment.end.isFinite(), 'Segment end is infinite' );
      assert && assert( segment.startTangent.isFinite(), 'Segment startTangent is infinite' );
      assert && assert( segment.endTangent.isFinite(), 'Segment endTangent is infinite' );
      assert && assert( segment.bounds.isEmpty() || segment.bounds.isFinite(), 'Segment bounds is infinite and non-empty' );
      this.segments.push( segment );

      // Hook up an invalidation listener, so if this segment is invalidated, it will invalidate our subpath!
      // NOTE: if we add removal of segments, we'll need to remove these listeners, or we'll leak!
      segment.onStatic( 'invalidated', this._invalidateListener );

      return this; // allow chaining
    },

    addSegment: function( segment ) {
      var nondegenerateSegments = segment.getNondegenerateSegments();
      var numNondegenerateSegments = nondegenerateSegments.length;
      for ( var i = 0; i < numNondegenerateSegments; i++ ) {
        this.addSegmentDirectly( segment );
      }
      this.invalidate(); // need to invalidate after addSegmentDirectly

      return this; // allow chaining
    },

    // Adds a line segment from the start to end (if non-zero length) and marks the subpath as closed.
    // NOTE: normally you just want to mark the subpath as closed, and not generate the closing segment this way?
    addClosingSegment: function() {
      if ( this.hasClosingSegment() ) {
        var closingSegment = this.getClosingSegment();
        this.addSegmentDirectly( closingSegment );
        this.invalidate(); // need to invalidate after addSegmentDirectly
        this.addPoint( this.getFirstPoint() );
        this.closed = true;
      }
    },

    // TODO: consider always adding a closing segment into our segments list for easier processing!! see addClosingSegment()
    close: function() {
      this.closed = true;
    },

    getLength: function() {
      return this.points.length;
    },

    getFirstPoint: function() {
      return _.first( this.points );
    },

    getLastPoint: function() {
      return _.last( this.points );
    },

    getFirstSegment: function() {
      return _.first( this.segments );
    },

    getLastSegment: function() {
      return _.last( this.segments );
    },

    isDrawable: function() {
      return this.segments.length > 0;
    },

    isClosed: function() {
      return this.closed;
    },

    hasClosingSegment: function() {
      return !this.getFirstPoint().equalsEpsilon( this.getLastPoint(), 0.000000001 );
    },

    getClosingSegment: function() {
      assert && assert( this.hasClosingSegment(), 'Implicit closing segment unnecessary on a fully closed path' );
      return new Line( this.getLastPoint(), this.getFirstPoint() );
    },

    writeToContext: function( context ) {
      if ( this.isDrawable() ) {
        var startPoint = this.getFirstSegment().start;
        context.moveTo( startPoint.x, startPoint.y ); // the segments assume the current context position is at their start

        var len = this.segments.length;
        for ( var i = 0; i < len; i++ ) {
          this.segments[ i ].writeToContext( context );
        }

        if ( this.closed ) {
          context.closePath();
        }
      }
    },

    // see Segment.toPiecewiseLinearSegments for documentation
    toPiecewiseLinear: function( options ) {
      assert && assert( !options.pointMap, 'For use with pointMap, please use nonlinearTransformed' );
      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
        return segment.toPiecewiseLinearSegments( options );
      } ) ), null, this.closed );
    },

    transformed: function( matrix ) {
      return new Subpath(
        _.map( this.segments, function( segment ) { return segment.transformed( matrix ); } ),
        _.map( this.points, function( point ) { return matrix.timesVector2( point ); } ),
        this.closed
      );
    },

    // see Segment.toPiecewiseLinearSegments for documentation
    nonlinearTransformed: function( options ) {
      // specify an actual closing segment, so it can be mapped properly by any non-linear transforms
      // TODO: always create and add the closing segments when the subpath is closed!!!
      if ( this.closed && this.hasClosingSegment() ) {
        this.addClosingSegment();
      }

      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
        // check for this segment's support for the specific transform or discretization being applied
        if ( options.methodName && segment[ options.methodName ] ) {
          return segment[ options.methodName ]( options );
        }
        else {
          return segment.toPiecewiseLinearSegments( options );
        }
      } ) ), null, this.closed );
    },

    getBoundsWithTransform: function( matrix ) {
      var bounds = Bounds2.NOTHING.copy();
      var numSegments = this.segments.length;
      for ( var i = 0; i < numSegments; i++ ) {
        bounds.includeBounds( this.segments[ i ].getBoundsWithTransform( matrix ) );
      }
      return bounds;
    },

    // {experimental} returns a subpath
    offset: function( distance ) {
      if ( !this.isDrawable() ) {
        return new Subpath( [], null, this.closed );
      }
      if ( distance === 0 ) {
        return new Subpath( this.segments.slice(), null, this.closed );
      }

      var i;

      var regularSegments = this.segments.slice();
      if ( this.closed && this.hasClosingSegment() ) {
        regularSegments.push( this.getClosingSegment() );
      }
      var offsets = [];

      for ( i = 0; i < regularSegments.length; i++ ) {
        offsets.push( regularSegments[ i ].strokeLeft( 2 * distance ) );
      }

      var segments = [];
      for ( i = 0; i < regularSegments.length; i++ ) {
        if ( this.closed || i > 0 ) {
          var previousI = ( i > 0 ? i : regularSegments.length ) - 1;
          var center = regularSegments[ i ].start;
          var fromTangent = regularSegments[ previousI ].endTangent;
          var toTangent = regularSegments[ i ].startTangent;

          var startAngle = fromTangent.perpendicular().negated().times( distance ).angle();
          var endAngle = toTangent.perpendicular().negated().times( distance ).angle();
          var anticlockwise = fromTangent.perpendicular().dot( toTangent ) > 0;
          segments.push( new Arc( center, Math.abs( distance ), startAngle, endAngle, anticlockwise ) );
        }
        segments = segments.concat( offsets[ i ] );
      }

      return new Subpath( segments, null, this.closed );
    },

    // returns an array of subpaths (one if open, two if closed) that represent a stroked copy of this subpath.
    stroked: function( lineStyles ) {
      // non-drawable subpaths convert to empty subpaths
      if ( !this.isDrawable() ) {
        return [];
      }

      if ( lineStyles === undefined ) {
        lineStyles = new LineStyles();
      }

      // return a cached version if possible
      if ( this._strokedSubpathsComputed && this._strokedStyles.equals( lineStyles ) ) {
        return this._strokedSubpaths;
      }

      var lineWidth = lineStyles.lineWidth;

      var i;
      var leftSegments = [];
      var rightSegments = [];
      var firstSegment = this.getFirstSegment();
      var lastSegment = this.getLastSegment();

      function appendLeftSegments( segments ) {
        leftSegments = leftSegments.concat( segments );
      }

      function appendRightSegments( segments ) {
        rightSegments = rightSegments.concat( segments );
      }

      // we don't need to insert an implicit closing segment if the start and end points are the same
      var alreadyClosed = lastSegment.end.equals( firstSegment.start );
      // if there is an implicit closing segment
      var closingSegment = alreadyClosed ? null : new Line( this.segments[ this.segments.length - 1 ].end, this.segments[ 0 ].start );

      // stroke the logical "left" side of our path
      for ( i = 0; i < this.segments.length; i++ ) {
        if ( i > 0 ) {
          appendLeftSegments( lineStyles.leftJoin( this.segments[ i ].start, this.segments[ i - 1 ].endTangent, this.segments[ i ].startTangent ) );
        }
        appendLeftSegments( this.segments[ i ].strokeLeft( lineWidth ) );
      }

      // stroke the logical "right" side of our path
      for ( i = this.segments.length - 1; i >= 0; i-- ) {
        if ( i < this.segments.length - 1 ) {
          appendRightSegments( lineStyles.rightJoin( this.segments[ i ].end, this.segments[ i ].endTangent, this.segments[ i + 1 ].startTangent ) );
        }
        appendRightSegments( this.segments[ i ].strokeRight( lineWidth ) );
      }

      var subpaths;
      if ( this.closed ) {
        if ( alreadyClosed ) {
          // add the joins between the start and end
          appendLeftSegments( lineStyles.leftJoin( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );
          appendRightSegments( lineStyles.rightJoin( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );
        }
        else {
          // logical "left" stroke on the implicit closing segment
          appendLeftSegments( lineStyles.leftJoin( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );
          appendLeftSegments( closingSegment.strokeLeft( lineWidth ) );
          appendLeftSegments( lineStyles.leftJoin( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );

          // logical "right" stroke on the implicit closing segment
          appendRightSegments( lineStyles.rightJoin( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );
          appendRightSegments( closingSegment.strokeRight( lineWidth ) );
          appendRightSegments( lineStyles.rightJoin( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );
        }
        subpaths = [
          new Subpath( leftSegments, null, true ),
          new Subpath( rightSegments, null, true )
        ];
      }
      else {
        subpaths = [
          new Subpath( leftSegments.concat( lineStyles.cap( lastSegment.end, lastSegment.endTangent ) )
            .concat( rightSegments )
            .concat( lineStyles.cap( firstSegment.start, firstSegment.startTangent.negated() ) ),
            null, true )
        ];
      }

      this._strokedSubpaths = subpaths;
      this._strokedSubpathsComputed = true;
      this._strokedStyles = new LineStyles( lineStyles ); // shallow copy, since we consider linestyles to be mutable

      return subpaths;
    }
  } );

  return kite.Subpath;
} );

// NOTE: Generated from svgPath.pegjs using PEG.js, with added kite namespace and require.js compatibility.
// See svgPath.pegjs for more documentation, or run "grunt generate-svgPath-parser" to regenerate.

define( 'KITE/parser/svgPath',['require','KITE/kite'],function( require ) {
  var kite = require( 'KITE/kite' );

  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */

  function quote( s ) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
    return '"' + s
        .replace( /\\/g, '\\\\' )  // backslash
        .replace( /"/g, '\\"' )    // closing quote character
        .replace( /\x08/g, '\\b' ) // backspace
        .replace( /\t/g, '\\t' )   // horizontal tab
        .replace( /\n/g, '\\n' )   // line feed
        .replace( /\f/g, '\\f' )   // form feed
        .replace( /\r/g, '\\r' )   // carriage return
        .replace( /[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape )
           + '"';
  }

  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function( input, startRule ) {
      var parseFunctions = {
        "svgPath": parse_svgPath,
        "movetoDrawtoCommandGroups": parse_movetoDrawtoCommandGroups,
        "movetoDrawtoCommandGroup": parse_movetoDrawtoCommandGroup,
        "drawtoCommands": parse_drawtoCommands,
        "drawtoCommand": parse_drawtoCommand,
        "moveto": parse_moveto,
        "movetoArgumentSequence": parse_movetoArgumentSequence,
        "closepath": parse_closepath,
        "lineto": parse_lineto,
        "linetoArgumentSequence": parse_linetoArgumentSequence,
        "horizontalLineto": parse_horizontalLineto,
        "horizontalLinetoArgumentSequence": parse_horizontalLinetoArgumentSequence,
        "verticalLineto": parse_verticalLineto,
        "verticalLinetoArgumentSequence": parse_verticalLinetoArgumentSequence,
        "curveto": parse_curveto,
        "curvetoArgumentSequence": parse_curvetoArgumentSequence,
        "curvetoArgument": parse_curvetoArgument,
        "smoothCurveto": parse_smoothCurveto,
        "smoothCurvetoArgumentSequence": parse_smoothCurvetoArgumentSequence,
        "smoothCurvetoArgument": parse_smoothCurvetoArgument,
        "quadraticBezierCurveto": parse_quadraticBezierCurveto,
        "quadraticBezierCurvetoArgumentSequence": parse_quadraticBezierCurvetoArgumentSequence,
        "quadraticBezierCurvetoArgument": parse_quadraticBezierCurvetoArgument,
        "smoothQuadraticBezierCurveto": parse_smoothQuadraticBezierCurveto,
        "smoothQuadraticBezierCurvetoArgumentSequence": parse_smoothQuadraticBezierCurvetoArgumentSequence,
        "ellipticalArc": parse_ellipticalArc,
        "ellipticalArcArgumentSequence": parse_ellipticalArcArgumentSequence,
        "ellipticalArcArgument": parse_ellipticalArcArgument,
        "coordinatePair": parse_coordinatePair,
        "nonnegativeNumber": parse_nonnegativeNumber,
        "number": parse_number,
        "flag": parse_flag,
        "commaWsp": parse_commaWsp,
        "comma": parse_comma,
        "floatingPointConstant": parse_floatingPointConstant,
        "fractionalConstant": parse_fractionalConstant,
        "exponent": parse_exponent,
        "sign": parse_sign,
        "digitSequence": parse_digitSequence,
        "digit": parse_digit,
        "wsp": parse_wsp
      };

      if ( startRule !== undefined ) {
        if ( parseFunctions[ startRule ] === undefined ) {
          throw new Error( "Invalid rule name: " + quote( startRule ) + "." );
        }
      }
      else {
        startRule = "svgPath";
      }

      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];

      function padLeft( input, padding, length ) {
        var result = input;

        var padLength = length - input.length;
        for ( var i = 0; i < padLength; i++ ) {
          result = padding + result;
        }

        return result;
      }

      function escape( ch ) {
        var charCode = ch.charCodeAt( 0 );
        var escapeChar;
        var length;

        if ( charCode <= 0xFF ) {
          escapeChar = 'x';
          length = 2;
        }
        else {
          escapeChar = 'u';
          length = 4;
        }

        return '\\' + escapeChar + padLeft( charCode.toString( 16 ).toUpperCase(), '0', length );
      }

      function matchFailed( failure ) {
        if ( pos < rightmostFailuresPos ) {
          return;
        }

        if ( pos > rightmostFailuresPos ) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }

        rightmostFailuresExpected.push( failure );
      }

      function parse_svgPath() {
        var result0, result1, result2, result3;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_wsp();
        while ( result1 !== null ) {
          result0.push( result1 );
          result1 = parse_wsp();
        }
        if ( result0 !== null ) {
          result1 = parse_movetoDrawtoCommandGroups();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = [];
            result3 = parse_wsp();
            while ( result3 !== null ) {
              result2.push( result3 );
              result3 = parse_wsp();
            }
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, path ) { return path ? path : []; })( pos0, result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_movetoDrawtoCommandGroups() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_movetoDrawtoCommandGroup();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_movetoDrawtoCommandGroups();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a.concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_movetoDrawtoCommandGroup();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return a; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_movetoDrawtoCommandGroup() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_moveto();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_drawtoCommands();
            result2 = result2 !== null ? result2 : "";
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, m, c ) { return c.length ? m.concat( c ) : m; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_drawtoCommands() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_drawtoCommand();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_drawtoCommands();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, cmd, cmds ) { return cmd.concat( cmds ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_drawtoCommand();
          if ( result0 !== null ) {
            result0 = (function( offset, cmd ) { return cmd; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_drawtoCommand() {
        var result0;

        result0 = parse_closepath();
        if ( result0 === null ) {
          result0 = parse_lineto();
          if ( result0 === null ) {
            result0 = parse_horizontalLineto();
            if ( result0 === null ) {
              result0 = parse_verticalLineto();
              if ( result0 === null ) {
                result0 = parse_curveto();
                if ( result0 === null ) {
                  result0 = parse_smoothCurveto();
                  if ( result0 === null ) {
                    result0 = parse_quadraticBezierCurveto();
                    if ( result0 === null ) {
                      result0 = parse_smoothQuadraticBezierCurveto();
                      if ( result0 === null ) {
                        result0 = parse_ellipticalArc();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }

      function parse_moveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 77 ) {
          result0 = "M";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"M\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_movetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) { return createMoveTo( args, false ); })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 109 ) {
            result0 = "m";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"m\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_movetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) { return createMoveTo( args, true ); })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_movetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, pair, list ) { return [ pair ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, pair ) { return [ pair ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_closepath() {
        var result0;
        var pos0;

        pos0 = pos;
        if ( input.charCodeAt( pos ) === 90 ) {
          result0 = "Z";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"Z\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 122 ) {
            result0 = "z";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"z\"" );
            }
          }
        }
        if ( result0 !== null ) {
          result0 = (function( offset, command ) { return { cmd: 'close' }; })( pos0, result0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_lineto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 76 ) {
          result0 = "L";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"L\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'lineTo',
                args: [ arg.x, arg.y ]
              };
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 108 ) {
            result0 = "l";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"l\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_linetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'lineToRelative',
                  args: [ arg.x, arg.y ]
                };
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_linetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_horizontalLineto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 72 ) {
          result0 = "H";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"H\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_horizontalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'horizontalLineTo',
                args: [ arg ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 104 ) {
            result0 = "h";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"h\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_horizontalLinetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'horizontalLineToRelative',
                  args: [ arg ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_horizontalLinetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_horizontalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_number();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_verticalLineto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 86 ) {
          result0 = "V";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"V\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_verticalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'verticalLineTo',
                args: [ arg ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 118 ) {
            result0 = "v";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"v\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_verticalLinetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'verticalLineToRelative',
                  args: [ arg ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_verticalLinetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_verticalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_number();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_curveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 67 ) {
          result0 = "C";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"C\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_curvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'cubicCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 99 ) {
            result0 = "c";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"c\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_curvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'cubicCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_curvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_curvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_curvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_curvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_curvetoArgument() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result3 = parse_commaWsp();
              result3 = result3 !== null ? result3 : "";
              if ( result3 !== null ) {
                result4 = parse_coordinatePair();
                if ( result4 !== null ) {
                  result0 = [ result0, result1, result2, result3, result4 ];
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b, c ) { return [ a.x, a.y, b.x, b.y, c.x, c.y ]; })( pos0, result0[ 0 ], result0[ 2 ], result0[ 4 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_smoothCurveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 83 ) {
          result0 = "S";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"S\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_smoothCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'smoothCubicCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 115 ) {
            result0 = "s";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"s\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_smoothCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'smoothCubicCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_smoothCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_smoothCurvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_smoothCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_smoothCurvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_smoothCurvetoArgument() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_quadraticBezierCurveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 81 ) {
          result0 = "Q";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"Q\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_quadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'quadraticCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 113 ) {
            result0 = "q";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"q\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_quadraticBezierCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'quadraticCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_quadraticBezierCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_quadraticBezierCurvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_quadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_quadraticBezierCurvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_quadraticBezierCurvetoArgument() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_smoothQuadraticBezierCurveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 84 ) {
          result0 = "T";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"T\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'smoothQuadraticCurveTo',
                args: [ arg.x, arg.y ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 116 ) {
            result0 = "t";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"t\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'smoothQuadraticCurveToRelative',
                  args: [ arg.x, arg.y ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_smoothQuadraticBezierCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_ellipticalArc() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 65 ) {
          result0 = "A";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"A\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_ellipticalArcArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'ellipticalArcTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 97 ) {
            result0 = "a";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"a\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_ellipticalArcArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'ellipticalArcToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_ellipticalArcArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_ellipticalArcArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_ellipticalArcArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_ellipticalArcArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_ellipticalArcArgument() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_nonnegativeNumber();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_nonnegativeNumber();
            if ( result2 !== null ) {
              result3 = parse_commaWsp();
              result3 = result3 !== null ? result3 : "";
              if ( result3 !== null ) {
                result4 = parse_number();
                if ( result4 !== null ) {
                  result5 = parse_commaWsp();
                  if ( result5 !== null ) {
                    result6 = parse_flag();
                    if ( result6 !== null ) {
                      result7 = parse_commaWsp();
                      result7 = result7 !== null ? result7 : "";
                      if ( result7 !== null ) {
                        result8 = parse_flag();
                        if ( result8 !== null ) {
                          result9 = parse_commaWsp();
                          result9 = result9 !== null ? result9 : "";
                          if ( result9 !== null ) {
                            result10 = parse_coordinatePair();
                            if ( result10 !== null ) {
                              result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10 ];
                            }
                            else {
                              result0 = null;
                              pos = pos1;
                            }
                          }
                          else {
                            result0 = null;
                            pos = pos1;
                          }
                        }
                        else {
                          result0 = null;
                          pos = pos1;
                        }
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, rx, ry, rot, largeArc, sweep, to ) { return [ rx, ry, rot, largeArc, sweep, to.x, to.y ] })( pos0, result0[ 0 ], result0[ 2 ], result0[ 4 ], result0[ 6 ], result0[ 8 ], result0[ 10 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_coordinatePair() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_number();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return { x: a, y: b }; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_nonnegativeNumber() {
        var result0;
        var pos0;

        pos0 = pos;
        result0 = parse_floatingPointConstant();
        if ( result0 !== null ) {
          result0 = (function( offset, number ) { return parseFloat( number, 10 ); })( pos0, result0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            result0 = (function( offset, number ) { return parseInt( number, 10 ); })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_number() {
        var result0, result1;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_sign();
        result0 = result0 !== null ? result0 : "";
        if ( result0 !== null ) {
          result1 = parse_floatingPointConstant();
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, sign, number ) { return parseFloat( sign + number, 10 ); })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_sign();
          result0 = result0 !== null ? result0 : "";
          if ( result0 !== null ) {
            result1 = parse_digitSequence();
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, sign, number ) { return parseInt( sign + number, 10 ); })( pos0, result0[ 0 ], result0[ 1 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_flag() {
        var result0;
        var pos0;

        pos0 = pos;
        if ( input.charCodeAt( pos ) === 48 ) {
          result0 = "0";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"0\"" );
          }
        }
        if ( result0 !== null ) {
          result0 = (function( offset ) { return false; })( pos0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          if ( input.charCodeAt( pos ) === 49 ) {
            result0 = "1";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"1\"" );
            }
          }
          if ( result0 !== null ) {
            result0 = (function( offset ) { return true; })( pos0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_commaWsp() {
        var result0, result1, result2, result3;
        var pos0;

        pos0 = pos;
        result1 = parse_wsp();
        if ( result1 !== null ) {
          result0 = [];
          while ( result1 !== null ) {
            result0.push( result1 );
            result1 = parse_wsp();
          }
        }
        else {
          result0 = null;
        }
        if ( result0 !== null ) {
          result1 = parse_comma();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = [];
            result3 = parse_wsp();
            while ( result3 !== null ) {
              result2.push( result3 );
              result3 = parse_wsp();
            }
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos0;
            }
          }
          else {
            result0 = null;
            pos = pos0;
          }
        }
        else {
          result0 = null;
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_comma();
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos0;
            }
          }
          else {
            result0 = null;
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_comma() {
        var result0;

        if ( input.charCodeAt( pos ) === 44 ) {
          result0 = ",";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\",\"" );
          }
        }
        return result0;
      }

      function parse_floatingPointConstant() {
        var result0, result1;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_fractionalConstant();
        if ( result0 !== null ) {
          result1 = parse_exponent();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            result1 = parse_exponent();
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_fractionalConstant() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_digitSequence();
        result0 = result0 !== null ? result0 : "";
        if ( result0 !== null ) {
          if ( input.charCodeAt( pos ) === 46 ) {
            result1 = ".";
            pos++;
          }
          else {
            result1 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\".\"" );
            }
          }
          if ( result1 !== null ) {
            result2 = parse_digitSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + '.' + b; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            if ( input.charCodeAt( pos ) === 46 ) {
              result1 = ".";
              pos++;
            }
            else {
              result1 = null;
              if ( reportFailures === 0 ) {
                matchFailed( "\".\"" );
              }
            }
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return a })( pos0, result0[ 0 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_exponent() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 101 ) {
          result0 = "e";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"e\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 69 ) {
            result0 = "E";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"E\"" );
            }
          }
        }
        if ( result0 !== null ) {
          result1 = parse_sign();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_digitSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b, c ) { return a + b + c; })( pos0, result0[ 0 ], result0[ 1 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_sign() {
        var result0;

        if ( input.charCodeAt( pos ) === 43 ) {
          result0 = "+";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"+\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 45 ) {
            result0 = "-";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"-\"" );
            }
          }
        }
        return result0;
      }

      function parse_digitSequence() {
        var result0, result1;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_digit();
        if ( result0 !== null ) {
          result1 = parse_digitSequence();
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          result0 = parse_digit();
        }
        return result0;
      }

      function parse_digit() {
        var result0;

        if ( /^[0-9]/.test( input.charAt( pos ) ) ) {
          result0 = input.charAt( pos );
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "[0-9]" );
          }
        }
        return result0;
      }

      function parse_wsp() {
        var result0;

        if ( input.charCodeAt( pos ) === 32 ) {
          result0 = " ";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\" \"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 9 ) {
            result0 = "\t";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"\\t\"" );
            }
          }
          if ( result0 === null ) {
            if ( input.charCodeAt( pos ) === 13 ) {
              result0 = "\r";
              pos++;
            }
            else {
              result0 = null;
              if ( reportFailures === 0 ) {
                matchFailed( "\"\\r\"" );
              }
            }
            if ( result0 === null ) {
              if ( input.charCodeAt( pos ) === 10 ) {
                result0 = "\n";
                pos++;
              }
              else {
                result0 = null;
                if ( reportFailures === 0 ) {
                  matchFailed( "\"\\n\"" );
                }
              }
            }
          }
        }
        return result0;
      }


      function cleanupExpected( expected ) {
        expected.sort();

        var lastExpected = null;
        var cleanExpected = [];
        for ( var i = 0; i < expected.length; i++ ) {
          if ( expected[ i ] !== lastExpected ) {
            cleanExpected.push( expected[ i ] );
            lastExpected = expected[ i ];
          }
        }
        return cleanExpected;
      }

      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */

        var line = 1;
        var column = 1;
        var seenCR = false;

        for ( var i = 0; i < Math.max( pos, rightmostFailuresPos ); i++ ) {
          var ch = input.charAt( i );
          if ( ch === "\n" ) {
            if ( !seenCR ) { line++; }
            column = 1;
            seenCR = false;
          }
          else if ( ch === "\r" || ch === "\u2028" || ch === "\u2029" ) {
            line++;
            column = 1;
            seenCR = true;
          }
          else {
            column++;
            seenCR = false;
          }
        }

        return { line: line, column: column };
      }


      function createMoveTo( args, isRelative ) {
        var result = [ {
          cmd: isRelative ? 'moveToRelative' : 'moveTo',
          args: [ args[ 0 ].x, args[ 0 ].y ]
        } ];

        // any other coordinate pairs are implicit lineTos
        if ( args.length > 1 ) {
          for ( var i = 1; i < args.length; i++ ) {
            result.push( {
              cmd: isRelative ? 'lineToRelative' : 'lineTo',
              args: [ args[ i ].x, args[ i ].y ]
            } );
          }
        }
        return result;
      }


      var result = parseFunctions[ startRule ]();

      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if ( result === null || pos !== input.length ) {
        var offset = Math.max( pos, rightmostFailuresPos );
        var found = offset < input.length ? input.charAt( offset ) : null;
        var errorPosition = computeErrorPosition();

        throw new this.SyntaxError(
          cleanupExpected( rightmostFailuresExpected ),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }

      return result;
    },

    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };

  /* Thrown when a parser encounters a syntax error. */

  result.SyntaxError = function( expected, found, offset, line, column ) {
    function buildMessage( expected, found ) {
      var expectedHumanized, foundHumanized;

      switch( expected.length ) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[ 0 ];
          break;
        default:
          expectedHumanized = expected.slice( 0, expected.length - 1 ).join( ", " )
                              + " or "
                              + expected[ expected.length - 1 ];
      }

      foundHumanized = found ? quote( found ) : "end of input";

      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }

    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage( expected, found );
    this.offset = offset;
    this.line = line;
    this.column = column;
  };

  result.SyntaxError.prototype = Error.prototype;

  kite.register( 'svgPath', result );
  return kite.svgPath;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Quadratic Bezier segment
 *
 * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Quadratic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Matrix3','DOT/Util','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;
  var arePointsCollinear = require( 'DOT/Util' ).arePointsCollinear;

  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );

  function Quadratic( start, control, end ) {
    Segment.call( this );

    this._start = start;
    this._control = control;
    this._end = end;

    this.invalidate();
  }

  kite.register( 'Quadratic', Quadratic );

  inherit( Segment, Quadratic, {

    degree: 2,

    // @public - Clears cached information, should be called when any of the 'constructor arguments' are mutated.
    invalidate: function() {
      // Lazily-computed derived information
      this._startTangent = null; // {Vector2 | null}
      this._endTangent = null; // {Vector2 | null}
      this._tCriticalX = null; // {number | null} T where x-derivative is 0 (replaced with NaN if not in range)
      this._tCriticalY = null; // {number | null} T where y-derivative is 0 (replaced with NaN if not in range)

      this._bounds = null; // {Bounds2 | null}

      this.trigger0( 'invalidated' );
    },

    getStartTangent: function() {
      if ( this._startTangent === null ) {
        var controlIsStart = this._start.equals( this._control );
        // TODO: allocation reduction
        this._startTangent = controlIsStart ?
                             this._end.minus( this._start ).normalized() :
                             this._control.minus( this._start ).normalized();
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },

    getEndTangent: function() {
      if ( this._endTangent === null ) {
        var controlIsEnd = this._end.equals( this._control );
        // TODO: allocation reduction
        this._endTangent = controlIsEnd ?
                           this._end.minus( this._start ).normalized() :
                           this._end.minus( this._control ).normalized();
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },

    getTCriticalX: function() {
      // compute x where the derivative is 0 (used for bounds and other things)
      if ( this._tCriticalX === null ) {
        this._tCriticalX = Quadratic.extremaT( this._start.x, this._control.x, this._end.x );
      }
      return this._tCriticalX;
    },
    get tCriticalX() { return this.getTCriticalX(); },

    getTCriticalY: function() {
      // compute y where the derivative is 0 (used for bounds and other things)
      if ( this._tCriticalY === null ) {
        this._tCriticalY = Quadratic.extremaT( this._start.y, this._control.y, this._end.y );
      }
      return this._tCriticalY;
    },
    get tCriticalY() { return this.getTCriticalY(); },

    getNondegenerateSegments: function() {
      var start = this._start;
      var control = this._control;
      var end = this._end;

      var startIsEnd = start.equals( end );
      var startIsControl = start.equals( control );
      var endIsControl = start.equals( control );

      if ( startIsEnd && startIsControl ) {
        // all same points
        return [];
      }
      else if ( startIsEnd ) {
        // this is a special collinear case, we basically line out to the farthest point and back
        var halfPoint = this.positionAt( 0.5 );
        return [
          new kite.Line( start, halfPoint ),
          new kite.Line( halfPoint, end )
        ];
      }
      else if ( arePointsCollinear( start, control, end ) ) {
        // if they are collinear, we can reduce to start->control and control->end, or if control is between, just one line segment
        // also, start !== end (handled earlier)
        if ( startIsControl || endIsControl ) {
          // just a line segment!
          return [ new kite.Line( start, end ) ]; // no extra nondegenerate check since start !== end
        }
        // now control point must be unique. we check to see if our rendered path will be outside of the start->end line segment
        var delta = end.minus( start );
        var p1d = control.minus( start ).dot( delta.normalized ) / delta.magnitude();
        var t = Quadratic.extremaT( 0, p1d, 1 );
        if ( !isNaN( t ) && t > 0 && t < 1 ) {
          // we have a local max inside the range, indicating that our extrema point is outside of start->end
          // we'll line to and from it
          var pt = this.positionAt( t );
          return _.flatten( [
            new kite.Line( start, pt ).getNondegenerateSegments(),
            new kite.Line( pt, end ).getNondegenerateSegments()
          ] );
        }
        else {
          // just provide a line segment, our rendered path doesn't go outside of this
          return [ new kite.Line( start, end ) ]; // no extra nondegenerate check since start !== end
        }
      }
      else {
        return [ this ];
      }
    },

    getBounds: function() {
      // calculate our temporary guaranteed lower bounds based on the end points
      if ( this._bounds === null ) {
        this._bounds = new Bounds2( Math.min( this._start.x, this._end.x ), Math.min( this._start.y, this._end.y ), Math.max( this._start.x, this._end.x ), Math.max( this._start.y, this._end.y ) );

        // compute x and y where the derivative is 0, so we can include this in the bounds
        var tCriticalX = this.getTCriticalX();
        var tCriticalY = this.getTCriticalY();

        if ( !isNaN( tCriticalX ) && tCriticalX > 0 && tCriticalX < 1 ) {
          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalX ) );
        }
        if ( !isNaN( tCriticalY ) && tCriticalY > 0 && tCriticalY < 1 ) {
          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalY ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    // can be described from t=[0,1] as: (1-t)^2 start + 2(1-t)t control + t^2 end
    positionAt: function( t ) {
      var mt = 1 - t;
      // TODO: allocation reduction
      return this._start.times( mt * mt ).plus( this._control.times( 2 * mt * t ) ).plus( this._end.times( t * t ) );
    },

    // derivative: 2(1-t)( control - start ) + 2t( end - control )
    tangentAt: function( t ) {
      // TODO: allocation reduction
      return this._control.minus( this._start ).times( 2 * ( 1 - t ) ).plus( this._end.minus( this._control ).times( 2 * t ) );
    },

    curvatureAt: function( t ) {
      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31
      // TODO: remove code duplication with Cubic
      var epsilon = 0.0000001;
      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
        var isZero = t < 0.5;
        var p0 = isZero ? this._start : this._end;
        var p1 = this._control;
        var p2 = isZero ? this._end : this._start;
        var d10 = p1.minus( p0 );
        var a = d10.magnitude();
        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
      }
      else {
        return this.subdivided( t, true )[ 0 ].curvatureAt( 1 );
      }
    },

    // see http://www.visgraf.impa.br/sibgrapi96/trabs/pdf/a14.pdf
    // and http://math.stackexchange.com/questions/12186/arc-length-of-bezier-curves for curvature / arc length

    offsetTo: function( r, reverse ) {
      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html
      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      var curves = [ this ];

      // subdivide this curve
      var depth = 5; // generates 2^depth curves
      for ( var i = 0; i < depth; i++ ) {
        curves = _.flatten( _.map( curves, function( curve ) {
          return curve.subdivided( 0.5, true );
        } ) );
      }

      var offsetCurves = _.map( curves, function( curve ) { return curve.approximateOffset( r ); } );

      if ( reverse ) {
        offsetCurves.reverse();
        offsetCurves = _.map( offsetCurves, function( curve ) { return curve.reversed( true ); } );
      }

      return offsetCurves;
    },

    subdivided: function( t ) {
      // de Casteljau method
      var leftMid = this._start.blend( this._control, t );
      var rightMid = this._control.blend( this._end, t );
      var mid = leftMid.blend( rightMid, t );
      return [
        new kite.Quadratic( this._start, leftMid, mid ),
        new kite.Quadratic( mid, rightMid, this._end )
      ];
    },

    // elevation of this quadratic Bezier curve to a cubic Bezier curve
    degreeElevated: function() {
      // TODO: allocation reduction
      return new kite.Cubic(
        this._start,
        this._start.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
        this._end.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
        this._end
      );
    },

    reversed: function() {
      return new kite.Quadratic( this._end, this._control, this._start );
    },

    approximateOffset: function( r ) {
      return new kite.Quadratic(
        this._start.plus( ( this._start.equals( this._control ) ? this._end.minus( this._start ) : this._control.minus( this._start ) ).perpendicular().normalized().times( r ) ),
        this._control.plus( this._end.minus( this._start ).perpendicular().normalized().times( r ) ),
        this._end.plus( ( this._end.equals( this._control ) ? this._end.minus( this._start ) : this._end.minus( this._control ) ).perpendicular().normalized().times( r ) )
      );
    },

    getSVGPathFragment: function() {
      return 'Q ' + kite.svgNumber( this._control.x ) + ' ' + kite.svgNumber( this._control.y ) + ' ' +
             kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
    },

    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },

    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },

    getInteriorExtremaTs: function() {
      // TODO: we assume here we are reduce, so that a criticalX doesn't equal a criticalY?
      var result = [];
      var epsilon = 0.0000000001; // TODO: general kite epsilon?

      var criticalX = this.getTCriticalX();
      var criticalY = this.getTCriticalY();

      if ( !isNaN( criticalX ) && criticalX > epsilon && criticalX < 1 - epsilon ) {
        result.push( this.tCriticalX );
      }
      if ( !isNaN( criticalY ) && criticalY > epsilon && criticalY < 1 - epsilon ) {
        result.push( this.tCriticalY );
      }
      return result.sort();
    },

    // returns the resultant winding number of this ray intersecting this segment.
    intersection: function( ray ) {
      var self = this;
      var result = [];

      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
      var inverseMatrix = Matrix3.rotation2( -ray.direction.angle() ).timesMatrix( Matrix3.translation( -ray.position.x, -ray.position.y ) );

      var p0 = inverseMatrix.timesVector2( this._start );
      var p1 = inverseMatrix.timesVector2( this._control );
      var p2 = inverseMatrix.timesVector2( this._end );

      //(1-t)^2 start + 2(1-t)t control + t^2 end
      var a = p0.y - 2 * p1.y + p2.y;
      var b = -2 * p0.y + 2 * p1.y;
      var c = p0.y;

      var ts = solveQuadraticRootsReal( a, b, c );

      _.each( ts, function( t ) {
        if ( t >= 0 && t <= 1 ) {
          var hitPoint = self.positionAt( t );
          var unitTangent = self.tangentAt( t ).normalized();
          var perp = unitTangent.perpendicular();
          var toHit = hitPoint.minus( ray.position );

          // make sure it's not behind the ray
          if ( toHit.dot( ray.direction ) > 0 ) {
            result.push( {
              distance: toHit.magnitude(),
              point: hitPoint,
              normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
              wind: ray.direction.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
            } );
          }
        }
      } );
      return result;
    },

    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },

    // assumes the current position is at start
    writeToContext: function( context ) {
      context.quadraticCurveTo( this._control.x, this._control.y, this._end.x, this._end.y );
    },

    transformed: function( matrix ) {
      return new kite.Quadratic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control ), matrix.timesVector2( this._end ) );
    },

    // given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b
    reparameterized: function( a, b ) {
      // to the polynomial pt^2 + qt + r:
      var p = this._start.plus( this._end.plus( this._control.timesScalar( -2 ) ) );
      var q = this._control.minus( this._start ).timesScalar( 2 );
      var r = this._start;

      // to the polynomial alpha*x^2 + beta*x + gamma:
      var alpha = p.timesScalar( a * a );
      var beta = p.timesScalar( a * b ).timesScalar( 2 ).plus( q.timesScalar( a ) );
      var gamma = p.timesScalar( b * b ).plus( q.timesScalar( b ) ).plus( r );

      // back to the form start,control,end
      return new kite.Quadratic( gamma, beta.timesScalar( 0.5 ).plus( gamma ), alpha.plus( beta ).plus( gamma ) );
    }
  } );

  Segment.addInvalidatingGetterSetter( Quadratic, 'start' );
  Segment.addInvalidatingGetterSetter( Quadratic, 'control' );
  Segment.addInvalidatingGetterSetter( Quadratic, 'end' );

  // one-dimensional solution to extrema
  Quadratic.extremaT = function( start, control, end ) {
    // compute t where the derivative is 0 (used for bounds and other things)
    var divisorX = 2 * ( end - 2 * control + start );
    if ( divisorX !== 0 ) {
      return -2 * ( control - start ) / divisorX;
    }
    else {
      return NaN;
    }
  };

  return Quadratic;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Cubic Bezier segment.
 *
 * See http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf for info
 *
 * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Cubic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','DOT/Util','DOT/Util','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/segments/Quadratic'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;
  var solveCubicRootsReal = require( 'DOT/Util' ).solveCubicRootsReal;
  var arePointsCollinear = require( 'DOT/Util' ).arePointsCollinear;

  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  require( 'KITE/segments/Quadratic' );

  var scratchVector1 = new Vector2();
  var scratchVector2 = new Vector2();
  var scratchVector3 = new Vector2();

  /**
   * @param {Vector2} start - Start point of the cubic bezier
   * @param {Vector2} control1 - First control point
   * @param {Vector2} control2 - Second control point
   * @param {Vector2} end - End point of the cubic bezier
   * @constructor
   */
  function Cubic( start, control1, control2, end ) {
    Segment.call( this );

    this._start = start;
    this._control1 = control1;
    this._control2 = control2;
    this._end = end;

    this.invalidate();
  }

  kite.register( 'Cubic', Cubic );

  inherit( Segment, Cubic, {

    degree: 3,

    // @public - Clears cached information, should be called when any of the 'constructor arguments' are mutated.
    invalidate: function() {
      // Lazily-computed derived information
      this._startTangent = null; // {Vector2 | null}
      this._endTangent = null; // {Vector2 | null}
      this._r = null; // {number | null}
      this._s = null; // {number | null}

      // Cusp-specific information
      this._tCusp = null; // {number | null} - T value for a potential cusp
      this._tDeterminant = null; // {number | null}
      this._tInflection1 = null; // {number | null} - NaN if not applicable
      this._tInflection2 = null; // {number | null} - NaN if not applicable
      this._startQuadratic = null; // {Quadratic | null}
      this._endQuadratic = null; // {Quadratic | null}

      // T-values where X and Y (respectively) reach an extrema (not necessarily including 0 and 1)
      this._xExtremaT = null; // {Array.<number> | null}
      this._yExtremaT = null; // {Array.<number> | null}

      this._bounds = null; // {Bounds2 | null}

      this.trigger0( 'invalidated' );
    },

    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAt( 0 ).normalized();
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },

    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAt( 1 ).normalized();
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },

    getR: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      if ( this._r === null ) {
        this._r = this._control1.minus( this._start ).normalized();
      }
      return this._r;
    },
    get r() { return this.getR(); },

    getS: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      if ( this._s === null ) {
        this._s = this.getR().perpendicular();
      }
      return this._s;
    },
    get s() { return this.getS(); },

    getTCusp: function() {
      if ( this._tCusp === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tCusp !== null );
      return this._tCusp;
    },
    get tCusp() { return this.getTCusp(); },

    getTDeterminant: function() {
      if ( this._tDeterminant === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tDeterminant !== null );
      return this._tDeterminant;
    },
    get tDeterminant() { return this.getTDeterminant(); },

    getTInflection1: function() {
      if ( this._tInflection1 === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tInflection1 !== null );
      return this._tInflection1;
    },
    get tInflection1() { return this.getTInflection1(); },

    getTInflection2: function() {
      if ( this._tInflection2 === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tInflection2 !== null );
      return this._tInflection2;
    },
    get tInflection2() { return this.getTInflection2(); },

    getStartQuadratic: function() {
      if ( this._startQuadratic === null ) {
        this.computeCuspSegments();
      }
      assert && assert( this._startQuadratic !== null );
      return this._startQuadratic;
    },
    get startQuadratic() { return this.getStartQuadratic(); },

    getEndQuadratic: function() {
      if ( this._endQuadratic === null ) {
        this.computeCuspSegments();
      }
      assert && assert( this._endQuadratic !== null );
      return this._endQuadratic;
    },
    get endQuadratic() { return this.getEndQuadratic(); },

    getXExtremaT: function() {
      if ( this._xExtremaT === null ) {
        this._xExtremaT = Cubic.extremaT( this._start.x, this._control1.x, this._control2.x, this._end.x );
      }
      return this._xExtremaT;
    },
    get xExtremaT() { return this.getXExtremaT(); },

    getYExtremaT: function() {
      if ( this._yExtremaT === null ) {
        this._yExtremaT = Cubic.extremaT( this._start.y, this._control1.y, this._control2.y, this._end.y );
      }
      return this._yExtremaT;
    },
    get yExtremaT() { return this.getYExtremaT(); },

    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING;
        this._bounds = this._bounds.withPoint( this._start );
        this._bounds = this._bounds.withPoint( this._end );

        var cubic = this;
        _.each( this.getXExtremaT(), function( t ) {
          if ( t >= 0 && t <= 1 ) {
            cubic._bounds = cubic._bounds.withPoint( cubic.positionAt( t ) );
          }
        } );
        _.each( this.getYExtremaT(), function( t ) {
          if ( t >= 0 && t <= 1 ) {
            cubic._bounds = cubic._bounds.withPoint( cubic.positionAt( t ) );
          }
        } );

        if ( this.hasCusp() ) {
          this._bounds = this._bounds.withPoint( this.positionAt( this.getTCusp() ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    // t value for the cusp, and the related determinant and inflection points
    computeCuspInfo: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      // TODO: allocation reduction
      var a = this._start.times( -1 ).plus( this._control1.times( 3 ) ).plus( this._control2.times( -3 ) ).plus( this._end );
      var b = this._start.times( 3 ).plus( this._control1.times( -6 ) ).plus( this._control2.times( 3 ) );
      var c = this._start.times( -3 ).plus( this._control1.times( 3 ) );

      var aPerp = a.perpendicular();
      var bPerp = b.perpendicular();
      var aPerpDotB = aPerp.dot( b );

      this._tCusp = -0.5 * ( aPerp.dot( c ) / aPerpDotB );
      this._tDeterminant = this._tCusp * this._tCusp - ( 1 / 3 ) * ( bPerp.dot( c ) / aPerpDotB );
      if ( this._tDeterminant >= 0 ) {
        var sqrtDet = Math.sqrt( this._tDeterminant );
        this._tInflection1 = this._tCusp - sqrtDet;
        this._tInflection2 = this._tCusp + sqrtDet;
      }
      else {
        this._tInflection1 = NaN;
        this._tInflection2 = NaN;
      }
    },

    // the cusp allows us to split into 2 quadratic Bezier curves
    computeCuspSegments: function() {
      if ( this.hasCusp() ) {
        // if there is a cusp, we'll split at the cusp into two quadratic bezier curves.
        // see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8088&rep=rep1&type=pdf (Singularities of rational Bezier curves - J Monterde, 2001)
        var subdividedAtCusp = this.subdivided( this.getTCusp );
        this._startQuadratic = new kite.Quadratic( subdividedAtCusp[ 0 ].start, subdividedAtCusp[ 0 ].control1, subdividedAtCusp[ 0 ].end, false );
        this._endQuadratic = new kite.Quadratic( subdividedAtCusp[ 1 ].start, subdividedAtCusp[ 1 ].control2, subdividedAtCusp[ 1 ].end, false );
      }
      else {
        this._startQuadratic = null;
        this._endQuadratic = null;
      }
    },

    getNondegenerateSegments: function() {
      var self = this;

      var start = this._start;
      var control1 = this._control1;
      var control2 = this._control2;
      var end = this._end;

      var reduced = this.degreeReduced( 1e-9 );

      if ( start.equals( end ) && start.equals( control1 ) && start.equals( control2 ) ) {
        // degenerate point
        return [];
      }
      else if ( this.hasCusp() ) {
        return _.flatten( [
          this._startQuadratic.getNondegenerateSegments(),
          this._endQuadratic.getNondegenerateSegments()
        ] );
      }
      else if ( reduced ) {
        // if we can reduce to a quadratic Bezier, always do this (and make sure it is non-degenerate)
        return reduced.getNondegenerateSegments();
      }
      else if ( arePointsCollinear( start, control1, end ) && arePointsCollinear( start, control2, end ) ) {
        var extremaPoints = this.getXExtremaT().concat( this.getYExtremaT() ).sort().map( function( t ) {
          return self.positionAt( t );
        } );

        var segments = [];
        var lastPoint = start;
        if ( extremaPoints.length ) {
          segments.push( new kite.Line( start, extremaPoints[ 0 ] ) );
          lastPoint = extremaPoints[ 0 ];
        }
        for ( var i = 1; i < extremaPoints.length; i++ ) {
          segments.push( new kite.Line( extremaPoints[ i - 1 ], extremaPoints[ i ] ) );
          lastPoint = extremaPoints[ i ];
        }
        segments.push( new kite.Line( lastPoint, end ) );

        return _.flatten( segments.map( function( segment ) { return segment.getNondegenerateSegments(); } ), true );
      }
      else {
        return [ this ];
      }
    },

    hasCusp: function() {
      var tCusp = this.getTCusp();

      var epsilon = 1e-7; // TODO: make this available to change?
      return this.tangentAt( tCusp ).magnitude() < epsilon && tCusp >= 0 && tCusp <= 1;
    },

    // position: (1 - t)^3*start + 3*(1 - t)^2*t*control1 + 3*(1 - t) t^2*control2 + t^3*end
    positionAt: function( t ) {
      var mt = 1 - t;
      return this._start.times( mt * mt * mt ).plus( this._control1.times( 3 * mt * mt * t ) ).plus( this._control2.times( 3 * mt * t * t ) ).plus( this._end.times( t * t * t ) );
    },

    // derivative: -3 p0 (1 - t)^2 + 3 p1 (1 - t)^2 - 6 p1 (1 - t) t + 6 p2 (1 - t) t - 3 p2 t^2 + 3 p3 t^2
    tangentAt: function( t ) {
      var mt = 1 - t;
      var result = new Vector2();
      return result.set( this._start ).multiplyScalar( -3 * mt * mt )
        .add( scratchVector1.set( this._control1 ).multiplyScalar( 3 * mt * mt - 6 * mt * t ) )
        .add( scratchVector1.set( this._control2 ).multiplyScalar( 6 * mt * t - 3 * t * t ) )
        .add( scratchVector1.set( this._end ).multiplyScalar( 3 * t * t ) );
    },

    curvatureAt: function( t ) {
      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31
      // TODO: remove code duplication with Quadratic
      var epsilon = 0.0000001;
      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
        var isZero = t < 0.5;
        var p0 = isZero ? this._start : this._end;
        var p1 = isZero ? this._control1 : this._control2;
        var p2 = isZero ? this._control2 : this._control1;
        var d10 = p1.minus( p0 );
        var a = d10.magnitude();
        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
      }
      else {
        return this.subdivided( t )[ 0 ].curvatureAt( 1 );
      }
    },

    toRS: function( point ) {
      var firstVector = point.minus( this._start );
      return new Vector2( firstVector.dot( this.getR() ), firstVector.dot( this.getS() ) );
    },

    subdivided: function( t ) {
      // de Casteljau method
      // TODO: add a 'bisect' or 'between' method for vectors?
      var left = this._start.blend( this._control1, t );
      var right = this._control2.blend( this._end, t );
      var middle = this._control1.blend( this._control2, t );
      var leftMid = left.blend( middle, t );
      var rightMid = middle.blend( right, t );
      var mid = leftMid.blend( rightMid, t );
      return [
        new kite.Cubic( this._start, left, leftMid, mid ),
        new kite.Cubic( mid, rightMid, right, this._end )
      ];
    },

    offsetTo: function( r, reverse ) {
      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html
      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf

      // how many segments to create (possibly make this more adaptive?)
      var quantity = 32;

      var points = [];
      var result = [];
      for ( var i = 0; i < quantity; i++ ) {
        var t = i / ( quantity - 1 );
        if ( reverse ) {
          t = 1 - t;
        }

        points.push( this.positionAt( t ).plus( this.tangentAt( t ).perpendicular().normalized().times( r ) ) );
        if ( i > 0 ) {
          result.push( new kite.Line( points[ i - 1 ], points[ i ] ) );
        }
      }

      return result;
    },

    getSVGPathFragment: function() {
      return 'C ' + kite.svgNumber( this._control1.x ) + ' ' + kite.svgNumber( this._control1.y ) + ' ' +
             kite.svgNumber( this._control2.x ) + ' ' + kite.svgNumber( this._control2.y ) + ' ' +
             kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
    },

    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },

    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },

    getInteriorExtremaTs: function() {
      var ts = this.getXExtremaT().concat( this.getYExtremaT() );
      var result = [];
      _.each( ts, function( t ) {
        var epsilon = 0.0000000001; // TODO: general kite epsilon?
        if ( t > epsilon && t < 1 - epsilon ) {
          // don't add duplicate t values
          if ( _.every( result, function( otherT ) { return Math.abs( t - otherT ) > epsilon; } ) ) {
            result.push( t );
          }
        }
      } );
      return result.sort();
    },

    // returns the resultant winding number of this ray intersecting this segment.
    intersection: function( ray ) {
      var self = this;
      var result = [];

      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
      var inverseMatrix = Matrix3.rotation2( -ray.direction.angle() ).timesMatrix( Matrix3.translation( -ray.position.x, -ray.position.y ) );

      var p0 = inverseMatrix.timesVector2( this._start );
      var p1 = inverseMatrix.timesVector2( this._control1 );
      var p2 = inverseMatrix.timesVector2( this._control2 );
      var p3 = inverseMatrix.timesVector2( this._end );

      // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3
      var a = -p0.y + 3 * p1.y - 3 * p2.y + p3.y;
      var b = 3 * p0.y - 6 * p1.y + 3 * p2.y;
      var c = -3 * p0.y + 3 * p1.y;
      var d = p0.y;

      var ts = solveCubicRootsReal( a, b, c, d );

      _.each( ts, function( t ) {
        if ( t >= 0 && t <= 1 ) {
          var hitPoint = self.positionAt( t );
          var unitTangent = self.tangentAt( t ).normalized();
          var perp = unitTangent.perpendicular();
          var toHit = hitPoint.minus( ray.position );

          // make sure it's not behind the ray
          if ( toHit.dot( ray.direction ) > 0 ) {
            result.push( {
              distance: toHit.magnitude(),
              point: hitPoint,
              normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
              wind: ray.direction.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
            } );
          }
        }
      } );
      return result;
    },

    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },

    // assumes the current position is at start
    writeToContext: function( context ) {
      context.bezierCurveTo( this._control1.x, this._control1.y, this._control2.x, this._control2.y, this._end.x, this._end.y );
    },

    transformed: function( matrix ) {
      return new kite.Cubic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control1 ), matrix.timesVector2( this._control2 ), matrix.timesVector2( this._end ) );
    },

    // returns a degree-reduced quadratic Bezier if possible, otherwise it returns null
    degreeReduced: function( epsilon ) {
      epsilon = epsilon || 0; // if not provided, use an exact version
      var controlA = scratchVector1.set( this._control1 ).multiplyScalar( 3 ).subtract( this._start ).divideScalar( 2 );
      var controlB = scratchVector2.set( this._control2 ).multiplyScalar( 3 ).subtract( this._end ).divideScalar( 2 );
      var difference = scratchVector3.set( controlA ).subtract( controlB );
      if ( difference.magnitude() <= epsilon ) {
        return new kite.Quadratic(
          this._start,
          controlA.average( controlB ), // average the control points for stability. they should be almost identical
          this._end
        );
      }
      else {
        // the two options for control points are too far away, this curve isn't easily reducible.
        return null;
      }
    }

    // returns the resultant winding number of this ray intersecting this segment.
    // windingIntersection: function( ray ) {
    //   // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
    //   var inverseMatrix = Matrix3.rotation2( -ray.direction.angle() );
    //   assert && assert( inverseMatrix.timesVector2( ray.direction ).x > 0.99 ); // verify that we transform the unit vector to the x-unit

    //   var y0 = inverseMatrix.timesVector2( this._start ).y;
    //   var y1 = inverseMatrix.timesVector2( this._control1 ).y;
    //   var y2 = inverseMatrix.timesVector2( this._control2 ).y;
    //   var y3 = inverseMatrix.timesVector2( this._end ).y;

    //   // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3
    //   var a = -y0 + 3 * y1 - 3 * y2 + y3;
    //   var b = 3 * y0 - 6 * y1 + 3 * y2;
    //   var c = -3 * y0 + 3 * y1;
    //   var d = y0;

    //   // solve cubic roots
    //   var ts = solveCubicRootsReal( a, b, c, d );

    //   var result = 0;

    //   // for each hit
    //   _.each( ts, function( t ) {
    //     if ( t >= 0 && t <= 1 ) {
    //       result += ray.direction.perpendicular().dot( this.tangentAt( t ) ) < 0 ? 1 : -1;
    //     }
    //   } );

    //   return result;
    // }
  } );

  Segment.addInvalidatingGetterSetter( Cubic, 'start' );
  Segment.addInvalidatingGetterSetter( Cubic, 'control1' );
  Segment.addInvalidatingGetterSetter( Cubic, 'control2' );
  Segment.addInvalidatingGetterSetter( Cubic, 'end' );

  // finds what t values the cubic extrema are at (if any). This is just the 1-dimensional case, used for multiple purposes
  Cubic.extremaT = function( v0, v1, v2, v3 ) {
    if ( v0 === v1 && v0 === v2 && v0 === v3 ) {
      return [];
    }

    // coefficients of derivative
    var a = -3 * v0 + 9 * v1 - 9 * v2 + 3 * v3;
    var b = 6 * v0 - 12 * v1 + 6 * v2;
    var c = -3 * v0 + 3 * v1;

    return solveQuadraticRootsReal( a, b, c );
  };

  return Cubic;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Elliptical arc segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/EllipticalArc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var toDegrees = require( 'DOT/Util' ).toDegrees;
  var DotUtil = require( 'DOT/Util' ); // eslint-disable-line require-statement-match

  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );

  // TODO: notes at http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
  // Canvas notes were at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-ellipse
  // context.ellipse was removed from the Canvas spec
  function EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
    Segment.call( this );

    this._center = center;
    this._radiusX = radiusX;
    this._radiusY = radiusY;
    this._rotation = rotation;
    this._startAngle = startAngle;
    this._endAngle = endAngle;
    this._anticlockwise = anticlockwise;

    this.invalidate();
  }

  kite.register( 'EllipticalArc', EllipticalArc );

  inherit( Segment, EllipticalArc, {

    // @public - Clears cached information, should be called when any of the 'constructor arguments' are mutated.
    invalidate: function() {
      // Lazily-computed derived information
      this._unitTransform = null; // {Transform3 | null} - Mapping between our ellipse and a unit circle
      this._start = null; // {Vector2 | null}
      this._end = null; // {Vector2 | null}
      this._startTangent = null; // {Vector2 | null}
      this._endTangent = null; // {Vector2 | null}
      this._actualEndAngle = null; // {number | null} - End angle in relation to our start angle (can get remapped)
      this._isFullPerimeter = null; // {boolean | null} - Whether it's a full ellipse (and not just an arc)
      this._angleDifference = null; // {number | null}
      this._unitArcSegment = null; // {Arc | null} - Corresponding circular arc for our unit transform.
      this._bounds = null; // {Bounds2 | null}

      // remapping of negative radii
      if ( this._radiusX < 0 ) {
        // support this case since we might actually need to handle it inside of strokes?
        this._radiusX = -this._radiusX;
        this._startAngle = Math.PI - this._startAngle;
        this._endAngle = Math.PI - this._endAngle;
        this._anticlockwise = !this._anticlockwise;
      }
      if ( this._radiusY < 0 ) {
        // support this case since we might actually need to handle it inside of strokes?
        this._radiusY = -this._radiusY;
        this._startAngle = -this._startAngle;
        this._endAngle = -this._endAngle;
        this._anticlockwise = !this._anticlockwise;
      }
      if ( this._radiusX < this._radiusY ) {
        // swap radiusX and radiusY internally for consistent Canvas / SVG output
        this._rotation += Math.PI / 2;
        this._startAngle -= Math.PI / 2;
        this._endAngle -= Math.PI / 2;

        // swap radiusX and radiusY
        var tmpR = this._radiusX;
        this._radiusX = this._radiusY;
        this._radiusY = tmpR;
      }

      if ( this._radiusX < this._radiusY ) {
        // TODO: check this
        throw new Error( 'Not verified to work if radiusX < radiusY' );
      }

      // constraints shared with Arc
      assert && assert( !( ( !this.anticlockwise && this.endAngle - this.startAngle <= -Math.PI * 2 ) ||
                           ( this.anticlockwise && this.startAngle - this.endAngle <= -Math.PI * 2 ) ),
        'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
      assert && assert( !( ( !this.anticlockwise && this.endAngle - this.startAngle > Math.PI * 2 ) ||
                           ( this.anticlockwise && this.startAngle - this.endAngle > Math.PI * 2 ) ),
        'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
    },

    getUnitTransform: function() {
      if ( this._unitTransform === null ) {
        this._unitTransform = EllipticalArc.computeUnitTransform( this._center, this._radiusX, this._radiusY, this._rotation );
      }
      return this._unitTransform;
    },
    get unitTransform() { return this.getUnitTransform(); },

    getStart: function() {
      if ( this._start === null ) {
        this._start = this.positionAtAngle( this._startAngle );
      }
      return this._start;
    },
    get start() { return this.getStart(); },

    getEnd: function() {
      if ( this._end === null ) {
        this._end = this.positionAtAngle( this._endAngle );
      }
      return this._end;
    },
    get end() { return this.getEnd(); },

    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAtAngle( this._startAngle );
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },

    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAtAngle( this._endAngle );
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },

    getActualEndAngle: function() {
      if ( this._actualEndAngle === null ) {
        // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle
        if ( this._anticlockwise ) {
          // angle is 'decreasing'
          // -2pi <= end - start < 2pi
          if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle - 2 * Math.PI;
          }
          else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
        else {
          // angle is 'increasing'
          // -2pi < end - start <= 2pi
          if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle + Math.PI * 2;
          }
          else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
      }
      return this._actualEndAngle;
    },
    get actualEndAngle() { return this.getActualEndAngle(); },

    getIsFullPerimeter: function() {
      if ( this._isFullPerimeter === null ) {
        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
      }
      return this._isFullPerimeter;
    },
    get isFullPerimeter() { return this.getIsFullPerimeter(); },

    getAngleDifference: function() {
      if ( this._angleDifference === null ) {
        // compute an angle difference that represents how "much" of the circle our arc covers
        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
        if ( this._angleDifference < 0 ) {
          this._angleDifference += Math.PI * 2;
        }
        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
      }
      return this._angleDifference;
    },
    get angleDifference() { return this.getAngleDifference(); },

    // a unit arg segment that we can map to our ellipse. useful for hit testing and such.
    getUnitArcSegment: function() {
      if ( this._unitArcSegment === null ) {
        this._unitArcSegment = new kite.Arc( Vector2.ZERO, 1, this._startAngle, this._endAngle, this._anticlockwise );
      }
      return this._unitArcSegment;
    },

    // temporary shims
    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING.withPoint( this.getStart() )
          .withPoint( this.getEnd() );

        // if the angles are different, check extrema points
        if ( this._startAngle !== this._endAngle ) {
          // solve the mapping from the unit circle, find locations where a coordinate of the gradient is zero.
          // we find one extrema point for both x and y, since the other two are just rotated by pi from them.
          var xAngle = Math.atan( -( this._radiusY / this._radiusX ) * Math.tan( this._rotation ) );
          var yAngle = Math.atan( ( this._radiusY / this._radiusX ) / Math.tan( this._rotation ) );

          // check all of the extrema points
          this.possibleExtremaAngles = [
            xAngle,
            xAngle + Math.PI,
            yAngle,
            yAngle + Math.PI
          ];

          _.each( this.possibleExtremaAngles, this.includeBoundsAtAngle.bind( this ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    getNondegenerateSegments: function() {
      if ( this._radiusX <= 0 || this._radiusY <= 0 || this._startAngle === this._endAngle ) {
        return [];
      }
      else if ( this._radiusX === this._radiusY ) {
        // reduce to an Arc
        var startAngle = this._startAngle - this._rotation;
        var endAngle = this._endAngle - this._rotation;

        // preserve full circles
        if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
          endAngle = this._anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
        }
        return [ new kite.Arc( this._center, this._radiusX, startAngle, endAngle, this._anticlockwise ) ];
      }
      else {
        return [ this ];
      }
    },

    includeBoundsAtAngle: function( angle ) {
      if ( this.containsAngle( angle ) ) {
        // the boundary point is in the arc
        this._bounds = this._bounds.withPoint( this.positionAtAngle( angle ) );
      }
    },

    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.
    mapAngle: function( angle ) {
      // consider an assert that we contain that angle?
      return ( this._startAngle > this.getActualEndAngle() ) ?
             DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
             DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
    },

    tAtAngle: function( angle ) {
      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
    },

    angleAt: function( t ) {
      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
    },

    positionAt: function( t ) {
      return this.positionAtAngle( this.angleAt( t ) );
    },

    tangentAt: function( t ) {
      return this.tangentAtAngle( this.angleAt( t ) );
    },

    curvatureAt: function( t ) {
      // see http://mathworld.wolfram.com/Ellipse.html (59)
      var angle = this.angleAt( t );
      var aq = this._radiusX * Math.sin( angle );
      var bq = this._radiusY * Math.cos( angle );
      var denominator = Math.pow( bq * bq + aq * aq, 3 / 2 );
      return ( this._anticlockwise ? -1 : 1 ) * this._radiusX * this._radiusY / denominator;
    },

    positionAtAngle: function( angle ) {
      return this.getUnitTransform().transformPosition2( Vector2.createPolar( 1, angle ) );
    },

    tangentAtAngle: function( angle ) {
      var normal = this.getUnitTransform().transformNormal2( Vector2.createPolar( 1, angle ) );

      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
    },

    // TODO: refactor? exact same as Arc
    containsAngle: function( angle ) {
      // transform the angle into the appropriate coordinate form
      // TODO: check anticlockwise version!
      var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;

      // get the angle between 0 and 2pi
      var positiveMinAngle = normalizedAngle % ( Math.PI * 2 );
      // check this because modular arithmetic with negative numbers reveal a negative number
      if ( positiveMinAngle < 0 ) {
        positiveMinAngle += Math.PI * 2;
      }

      return positiveMinAngle <= this.getAngleDifference();
    },

    // discretizes the elliptical arc and returns an offset curve as a list of lineTos
    offsetTo: function( r, reverse ) {
      // how many segments to create (possibly make this more adaptive?)
      var quantity = 32;

      var points = [];
      var result = [];
      for ( var i = 0; i < quantity; i++ ) {
        var ratio = i / ( quantity - 1 );
        if ( reverse ) {
          ratio = 1 - ratio;
        }
        var angle = this.angleAt( ratio );

        points.push( this.positionAtAngle( angle ).plus( this.tangentAtAngle( angle ).perpendicular().normalized().times( r ) ) );
        if ( i > 0 ) {
          result.push( new kite.Line( points[ i - 1 ], points[ i ] ) );
        }
      }

      return result;
    },

    getSVGPathFragment: function() {
      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info
      // rx ry x-axis-rotation large-arc-flag sweep-flag x y
      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
      var sweepFlag = this._anticlockwise ? '0' : '1';
      var largeArcFlag;
      var degreesRotation = toDegrees( this._rotation ); // bleh, degrees?
      if ( this.getAngleDifference() < Math.PI * 2 - epsilon ) {
        largeArcFlag = this.getAngleDifference() < Math.PI ? '0' : '1';
        return 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' + degreesRotation +
               ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( this.getEnd().x ) + ' ' + kite.svgNumber( this.getEnd().y );
      }
      else {
        // ellipse (or almost-ellipse) case needs to be handled differently
        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs

        // get the angle that is between and opposite of both of the points
        var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
        var splitPoint = this.positionAtAngle( splitOppositeAngle );

        largeArcFlag = '0'; // since we split it in 2, it's always the small arc

        var firstArc = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' +
                       degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' +
                       kite.svgNumber( splitPoint.x ) + ' ' + kite.svgNumber( splitPoint.y );
        var secondArc = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' +
                        degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' +
                        kite.svgNumber( this.getEnd().x ) + ' ' + kite.svgNumber( this.getEnd().y );

        return firstArc + ' ' + secondArc;
      }
    },

    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },

    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },

    // not including 0 and 1
    getInteriorExtremaTs: function() {
      var that = this;
      var result = [];
      _.each( this.possibleExtremaAngles, function( angle ) {
        if ( that.containsAngle( angle ) ) {
          var t = that.tAtAngle( angle );
          var epsilon = 0.0000000001; // TODO: general kite epsilon?
          if ( t > epsilon && t < 1 - epsilon ) {
            result.push( t );
          }
        }
      } );
      return result.sort(); // modifies original, which is OK
    },

    subdivided: function( t ) {
      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles
      var angle0 = this.angleAt( 0 );
      var angleT = this.angleAt( t );
      var angle1 = this.angleAt( 1 );
      return [
        new kite.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angle0, angleT, this._anticlockwise ),
        new kite.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angleT, angle1, this._anticlockwise )
      ];
    },

    intersection: function( ray ) {
      // be lazy. transform it into the space of a non-elliptical arc.
      var unitTransform = this.getUnitTransform();
      var rayInUnitCircleSpace = unitTransform.inverseRay2( ray );
      var hits = this.getUnitArcSegment().intersection( rayInUnitCircleSpace );

      return _.map( hits, function( hit ) {
        var transformedPoint = unitTransform.transformPosition2( hit.point );
        return {
          distance: ray.position.distance( transformedPoint ),
          point: transformedPoint,
          normal: unitTransform.inverseNormal2( hit.normal ),
          wind: hit.wind
        };
      } );
    },

    // returns the resultant winding number of this ray intersecting this segment.
    windingIntersection: function( ray ) {
      // be lazy. transform it into the space of a non-elliptical arc.
      var rayInUnitCircleSpace = this.getUnitTransform().inverseRay2( ray );
      return this.getUnitArcSegment().windingIntersection( rayInUnitCircleSpace );
    },

    // assumes the current position is at start
    writeToContext: function( context ) {
      if ( context.ellipse ) {
        context.ellipse( this._center.x, this._center.y, this._radiusX, this._radiusY, this._rotation, this._startAngle, this._endAngle, this._anticlockwise );
      }
      else {
        // fake the ellipse call by using transforms
        this.getUnitTransform().getMatrix().canvasAppendTransform( context );
        context.arc( 0, 0, 1, this._startAngle, this._endAngle, this._anticlockwise );
        this.getUnitTransform().getInverse().canvasAppendTransform( context );
      }
    },

    transformed: function( matrix ) {
      var transformedSemiMajorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusX, this._rotation ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
      var transformedSemiMinorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusY, this._rotation + Math.PI / 2 ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
      var rotation = transformedSemiMajorAxis.angle();
      var radiusX = transformedSemiMajorAxis.magnitude();
      var radiusY = transformedSemiMinorAxis.magnitude();

      var reflected = matrix.getDeterminant() < 0;

      // reverse the 'clockwiseness' if our transform includes a reflection
      // TODO: check reflections. swapping angle signs should fix clockwiseness
      var anticlockwise = reflected ? !this._anticlockwise : this._anticlockwise;
      var startAngle = reflected ? -this._startAngle : this._startAngle;
      var endAngle = reflected ? -this._endAngle : this._endAngle;

      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
      }

      return new kite.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
    }
  } );

  Segment.addInvalidatingGetterSetter( EllipticalArc, 'center' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'radiusX' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'radiusY' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'rotation' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'startAngle' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'endAngle' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'anticlockwise' );

  // adapted from http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
  // transforms the unit circle onto our ellipse
  EllipticalArc.computeUnitTransform = function( center, radiusX, radiusY, rotation ) {
    return new Transform3( Matrix3.translation( center.x, center.y ) // TODO: convert to Matrix3.translation( this._center) when available
      .timesMatrix( Matrix3.rotation2( rotation ) )
      .timesMatrix( Matrix3.scaling( radiusX, radiusY ) ) );
  };

  return EllipticalArc;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Shape handling
 *
 * Shapes are internally made up of Subpaths, which contain a series of segments, and are optionally closed.
 * Familiarity with how Canvas handles subpaths is helpful for understanding this code.
 *
 * Canvas spec: http://www.w3.org/TR/2dcontext/
 * SVG spec: http://www.w3.org/TR/SVG/expanded-toc.html
 *           http://www.w3.org/TR/SVG/paths.html#PathData (for paths)
 * Notes for elliptical arcs: http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
 * Notes for painting strokes: https://svgwg.org/svg2-draft/painting.html
 *
 * TODO: add nonzero / evenodd support when browsers support it
 * TODO: docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/Shape',['require','KITE/kite','PHET_CORE/inherit','AXON/Events','DOT/Vector2','DOT/Bounds2','DOT/Ray2','KITE/util/Subpath','KITE/parser/svgPath','KITE/segments/Arc','KITE/segments/Cubic','KITE/segments/EllipticalArc','KITE/segments/Line','KITE/segments/Quadratic'],function( require ) {
  'use strict';

  var kite = require( 'KITE/kite' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );

  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Ray2 = require( 'DOT/Ray2' );

  var Subpath = require( 'KITE/util/Subpath' );
  var svgPath = require( 'KITE/parser/svgPath' );
  var Arc = require( 'KITE/segments/Arc' );
  var Cubic = require( 'KITE/segments/Cubic' );
  var EllipticalArc = require( 'KITE/segments/EllipticalArc' );
  var Line = require( 'KITE/segments/Line' );
  var Quadratic = require( 'KITE/segments/Quadratic' );

  // for brevity
  function p( x, y ) { return new Vector2( x, y ); }

  function v( x, y ) { return new Vector2( x, y ); } // TODO: use this version in general, it makes more sense and is easier to type

  // The tension parameter controls how smoothly the curve turns through its control points. For a Catmull-Rom
  // curve, the tension is zero. The tension should range from -1 to 1.
  function weightedSplineVector( beforeVector, currentVector, afterVector, tension ) {
    return afterVector.copy()
      .subtract( beforeVector )
      .multiplyScalar( ( 1 - tension ) / 6 )
      .add( currentVector );
  }

  // a normalized vector for non-zero winding checks
  // var weirdDir = p( Math.PI, 22 / 7 );

  // all arguments optional, they are for the copy() method. if used, ensure that 'bounds' is consistent with 'subpaths'
  function Shape( subpaths, bounds ) {
    var self = this;

    Events.call( this );

    // @public Lower-level piecewise mathematical description using segments, also individually immutable
    this.subpaths = [];

    // If non-null, computed bounds for all pieces added so far. Lazily computed with getBounds/bounds ES5 getter
    this._bounds = bounds ? bounds.copy() : null; // {Bounds2 | null}

    this.resetControlPoints();

    this._invalidateListener = this.invalidate.bind( this );
    this._invalidatingPoints = false; // So we can invalidate all of the points without firing invalidation tons of times

    // Add in subpaths from the constructor (if applicable)
    if ( typeof subpaths === 'object' ) {
      // assume it's an array
      for ( var i = 0; i < subpaths.length; i++ ) {
        this.addSubpath( subpaths[ i ] );
      }
    }

    if ( subpaths && typeof subpaths !== 'object' ) {
      assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' );
      // parse the SVG path
      _.each( svgPath.parse( subpaths ), function( item ) {
        assert && assert( Shape.prototype[ item.cmd ] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );
        self[ item.cmd ].apply( self, item.args );
      } );
    }

    // defines _bounds if not already defined (among other things)
    this.invalidate();

    phetAllocation && phetAllocation( 'Shape' );
  }

  kite.register( 'Shape', Shape );

  inherit( Events, Shape, {

    // for tracking the last quadratic/cubic control point for smooth* functions
    // see https://github.com/phetsims/kite/issues/38
    resetControlPoints: function() {
      this.lastQuadraticControlPoint = null;
      this.lastCubicControlPoint = null;
    },
    setQuadraticControlPoint: function( point ) {
      this.lastQuadraticControlPoint = point;
      this.lastCubicControlPoint = null;
    },
    setCubicControlPoint: function( point ) {
      this.lastQuadraticControlPoint = null;
      this.lastCubicControlPoint = point;
    },

    // Adds a new subpath if there have already been draw calls made. Will prevent any line or connection from the last
    // draw call to future draw calls.
    subpath: function() {
      if ( this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }

      return this; // for chaining
    },

    moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },
    moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },
    moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },
    moveToPoint: function( point ) {
      this.addSubpath( new Subpath().addPoint( point ) );
      this.resetControlPoints();

      return this;
    },

    lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },
    lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },
    lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },
    lineToPoint: function( point ) {
      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-lineto
      if ( this.hasSubpaths() ) {
        var start = this.getLastSubpath().getLastPoint();
        var end = point;
        var line = new Line( start, end );
        this.getLastSubpath().addPoint( end );
        this.addSegmentAndBounds( line );
      }
      else {
        this.ensure( point );
      }
      this.resetControlPoints();

      return this;
    },

    horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },
    horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },

    verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },
    verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },

    quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },
    quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },
    quadraticCurveToPointRelative: function( controlPoint, point ) {
      var relativePoint = this.getRelativePoint();
      return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );
    },
    // TODO: consider a rename to put 'smooth' farther back?
    smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },
    smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },
    quadraticCurveToPoint: function( controlPoint, point ) {
      var shape = this;

      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-quadraticcurveto
      this.ensure( controlPoint );
      var start = this.getLastSubpath().getLastPoint();
      var quadratic = new Quadratic( start, controlPoint, point );
      this.getLastSubpath().addPoint( point );
      var nondegenerateSegments = quadratic.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        // TODO: optimization
        shape.addSegmentAndBounds( segment );
      } );
      this.setQuadraticControlPoint( controlPoint );

      return this;
    },

    cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },
    cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },
    cubicCurveToPointRelative: function( control1, control2, point ) {
      var relativePoint = this.getRelativePoint();
      return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );
    },
    smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },
    smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },
    cubicCurveToPoint: function( control1, control2, point ) {
      var shape = this;
      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-quadraticcurveto
      this.ensure( control1 );
      var start = this.getLastSubpath().getLastPoint();
      var cubic = new Cubic( start, control1, control2, point );

      var nondegenerateSegments = cubic.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        shape.addSegmentAndBounds( segment );
      } );
      this.getLastSubpath().addPoint( point );

      this.setCubicControlPoint( control2 );

      return this;
    },

    arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },
    arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {
      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-arc

      var arc = new Arc( center, radius, startAngle, endAngle, anticlockwise );

      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas
      var startPoint = arc.getStart();
      var endPoint = arc.getEnd();

      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them
      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
        this.addSegmentAndBounds( new Line( this.getLastSubpath().getLastPoint(), startPoint ) );
      }

      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }

      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)
      this.getLastSubpath().addPoint( startPoint );
      this.getLastSubpath().addPoint( endPoint );

      this.addSegmentAndBounds( arc );
      this.resetControlPoints();

      return this;
    },

    ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) { return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ); },
    ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-arc

      var ellipticalArc = new EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );

      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas
      var startPoint = ellipticalArc.start;
      var endPoint = ellipticalArc.end;

      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them
      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
        this.addSegmentAndBounds( new Line( this.getLastSubpath().getLastPoint(), startPoint ) );
      }

      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }

      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)
      this.getLastSubpath().addPoint( startPoint );
      this.getLastSubpath().addPoint( endPoint );

      this.addSegmentAndBounds( ellipticalArc );
      this.resetControlPoints();

      return this;
    },

    close: function() {
      if ( this.hasSubpaths() ) {
        var previousPath = this.getLastSubpath();
        var nextPath = new Subpath();

        previousPath.close();
        this.addSubpath( nextPath );
        nextPath.addPoint( previousPath.getFirstPoint() );
      }
      this.resetControlPoints();
      return this;
    },

    // matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html
    ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
      var relativePoint = this.getRelativePoint();
      return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );
    },
    ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
      throw new Error( 'ellipticalArcTo unimplemented' );
    },

    /*
     * Draws a circle using the arc() call with the following parameters:
     * circle( center, radius ) // center is a Vector2
     * circle( centerX, centerY, radius )
     */
    circle: function( centerX, centerY, radius ) {
      if ( typeof centerX === 'object' ) {
        // circle( center, radius )
        var center = centerX;
        radius = centerY;
        return this.arcPoint( center, radius, 0, Math.PI * 2, false );
      }
      else {
        // circle( centerX, centerY, radius )
        return this.arcPoint( p( centerX, centerY ), radius, 0, Math.PI * 2, false );
      }
    },

    /*
     * Draws an ellipse using the ellipticalArc() call with the following parameters:
     * ellipse( center, radiusX, radiusY, rotation ) // center is a Vector2
     * ellipse( centerX, centerY, radiusX, radiusY, rotation )
     *
     * The rotation is about the centerX, centerY.
     */
    ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {
      // TODO: separate into ellipse() and ellipsePoint()?
      // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling
      if ( typeof centerX === 'object' ) {
        // ellipse( center, radiusX, radiusY, rotation )
        var center = centerX;
        rotation = radiusY;
        radiusY = radiusX;
        radiusX = centerY;
        return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );
      }
      else {
        // ellipse( centerX, centerY, radiusX, radiusY, rotation )
        return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );
      }
    },

    rect: function( x, y, width, height ) {
      var subpath = new Subpath();
      this.addSubpath( subpath );
      subpath.addPoint( v( x, y ) );
      subpath.addPoint( v( x + width, y ) );
      subpath.addPoint( v( x + width, y + height ) );
      subpath.addPoint( v( x, y + height ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 0 ], subpath.points[ 1 ] ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 1 ], subpath.points[ 2 ] ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 2 ], subpath.points[ 3 ] ) );
      subpath.close();
      this.addSubpath( new Subpath() );
      this.getLastSubpath().addPoint( v( x, y ) );
      assert && assert( !isNaN( this.bounds.getX() ) );
      this.resetControlPoints();

      return this;
    },

    //Create a round rectangle. All arguments are number.
    roundRect: function( x, y, width, height, arcw, arch ) {
      var lowX = x + arcw;
      var highX = x + width - arcw;
      var lowY = y + arch;
      var highY = y + height - arch;
      // if ( true ) {
      if ( arcw === arch ) {
        // we can use circular arcs, which have well defined stroked offsets
        this
          .arc( highX, lowY, arcw, -Math.PI / 2, 0, false )
          .arc( highX, highY, arcw, 0, Math.PI / 2, false )
          .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )
          .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )
          .close();
      }
      else {
        // we have to resort to elliptical arcs
        this
          .ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )
          .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )
          .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )
          .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )
          .close();
      }
      return this;
    },

    polygon: function( vertices ) {
      var length = vertices.length;
      if ( length > 0 ) {
        this.moveToPoint( vertices[ 0 ] );
        for ( var i = 1; i < length; i++ ) {
          this.lineToPoint( vertices[ i ] );
        }
      }
      return this.close();
    },

    /**
     * This is a convenience function that allows to generate Cardinal splines
     * from a position array. Cardinal spline differs from Bezier curves in that all
     * defined points on a Cardinal spline are on the path itself.
     *
     * It includes a tension parameter to allow the client to specify how tightly
     * the path interpolates between points. One can think of the tension as the tension in
     * a rubber band around pegs. however unlike a rubber band the tension can be negative.
     * the tension ranges from -1 to 1
     *
     * @param {Array.<Vector2>} positions
     * @param {Object} [options] - see documentation below
     * @returns {Shape}
     */
    cardinalSpline: function( positions, options ) {
      options = _.extend( {
        // the tension parameter controls how smoothly the curve turns through its
        // control points. For a Catmull-Rom curve the tension is zero.
        // the tension should range from  -1 to 1
        tension: 0,

        // is the resulting shape forming a closed line?
        isClosedLineSegments: false
      }, options );

      assert && assert( options.tension < 1 && options.tension > -1, ' the tension goes from -1 to 1 ' );

      var pointNumber = positions.length; // number of points in the array

      // if the line is open, there is one less segments than point vectors
      var segmentNumber = ( options.isClosedLineSegments ) ? pointNumber : pointNumber - 1;

      for ( var i = 0; i < segmentNumber; i++ ) {
        var cardinalPoints; // {Array.<Vector2>} cardinal points Array
        if ( i === 0 && !options.isClosedLineSegments ) {
          cardinalPoints = [
            positions[ 0 ],
            positions[ 0 ],
            positions[ 1 ],
            positions[ 2 ] ];
        }
        else if ( (i === segmentNumber - 1) && !options.isClosedLineSegments ) {
          cardinalPoints = [
            positions[ i - 1 ],
            positions[ i ],
            positions[ i + 1 ],
            positions[ i + 1 ] ];
        }
        else {
          cardinalPoints = [
            positions[ ( i - 1 + pointNumber ) % pointNumber ],
            positions[ i % pointNumber ],
            positions[ ( i + 1 ) % pointNumber ],
            positions[ ( i + 2 ) % pointNumber ] ];
        }

        // Cardinal Spline to Cubic Bezier conversion matrix
        //    0                 1             0            0
        //  (-1+tension)/6      1      (1-tension)/6       0
        //    0            (1-tension)/6      1       (-1+tension)/6
        //    0                 0             1           0

        // {Array.<Vector2>} bezier points Array
        var bezierPoints = [
          cardinalPoints[ 1 ],
          weightedSplineVector( cardinalPoints[ 0 ], cardinalPoints[ 1 ], cardinalPoints[ 2 ], options.tension ),
          weightedSplineVector( cardinalPoints[ 3 ], cardinalPoints[ 2 ], cardinalPoints[ 1 ], options.tension ),
          cardinalPoints[ 2 ]
        ];

        // special operations on the first point
        if ( i === 0 ) {
          this.ensure( bezierPoints[ 0 ] );
          this.getLastSubpath().addPoint( bezierPoints[ 0 ] );
        }

        this.cubicCurveToPoint( bezierPoints[ 1 ], bezierPoints[ 2 ], bezierPoints[ 3 ] );
      }

      return this;
    },

    copy: function() {
      // copy each individual subpath, so future modifications to either Shape doesn't affect the other one
      return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );
    },

    // write out this shape's path to a canvas 2d context. does NOT include the beginPath()!
    writeToContext: function( context ) {
      var len = this.subpaths.length;
      for ( var i = 0; i < len; i++ ) {
        this.subpaths[ i ].writeToContext( context );
      }
    },

    // returns something like "M150 0 L75 200 L225 200 Z" for a triangle
    getSVGPath: function() {
      var string = '';
      var len = this.subpaths.length;
      for ( var i = 0; i < len; i++ ) {
        var subpath = this.subpaths[ i ];
        if ( subpath.isDrawable() ) {
          // since the commands after this are relative to the previous 'point', we need to specify a move to the initial point
          var startPoint = subpath.segments[ 0 ].start;
          assert && assert( startPoint.equalsEpsilon( subpath.getFirstPoint(), 0.00001 ) ); // sanity check
          string += 'M ' + kite.svgNumber( startPoint.x ) + ' ' + kite.svgNumber( startPoint.y ) + ' ';

          for ( var k = 0; k < subpath.segments.length; k++ ) {
            string += subpath.segments[ k ].getSVGPathFragment() + ' ';
          }

          if ( subpath.isClosed() ) {
            string += 'Z ';
          }
        }
      }
      return string;
    },

    // return a new Shape that is transformed by the associated matrix
    transformed: function( matrix ) {
      // TODO: allocation reduction
      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );
      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
      return new Shape( subpaths, bounds );
    },

    /*
     * Provided options (see Segment.nonlinearTransformed)
     * - minLevels:                       how many levels to force subdivisions
     * - maxLevels:                       prevent subdivision past this level
     * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve. smaller => more subdivision
     * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments. smaller => more subdivision
     * -   OR includeCurvature:           {Boolean}, whether to include a default curveEpsilon (usually off by default)
     * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
     * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
     *                                    instead of using our brute-force logic. Supports optimizations for custom non-linear transforms (like polar coordinates)
     */
    nonlinearTransformed: function( options ) {
      // defaults
      options = _.extend( {
        minLevels: 0,
        maxLevels: 7,
        distanceEpsilon: 0.16, // NOTE: this will change when the Shape is scaled, since this is a threshold for the square of a distance value
        curveEpsilon: ( options && options.includeCurvature ) ? 0.002 : null
      }, options );

      // TODO: allocation reduction
      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.nonlinearTransformed( options ); } );
      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
      return new Shape( subpaths, bounds );
    },

    /*
     * Maps points by treating their x coordinate as polar angle, and y coordinate as polar magnitude.
     * See http://en.wikipedia.org/wiki/Polar_coordinate_system
     *
     * Please see Shape.nonlinearTransformed for more documentation on adaptive discretization options (minLevels, maxLevels, distanceEpsilon, curveEpsilon)
     *
     * Example: A line from (0,10) to (pi,10) will be transformed to a circular arc from (10,0) to (-10,0) passing through (0,10).
     */
    polarToCartesian: function( options ) {
      return this.nonlinearTransformed( _.extend( {
        pointMap: function( p ) {
          return Vector2.createPolar( p.y, p.x );
          // return new Vector2( p.y * Math.cos( p.x ), p.y * Math.sin( p.x ) );
        },
        methodName: 'polarToCartesian' // this will be called on Segments if it exists to do more optimized conversion (see Line)
      }, options ) );
    },

    /*
     * Converts each segment into lines, using an adaptive (midpoint distance subdivision) method.
     *
     * NOTE: uses nonlinearTransformed method internally, but since we don't provide a pointMap or methodName, it won't create anything but line segments.
     * See nonlinearTransformed for documentation of options
     */
    toPiecewiseLinear: function( options ) {
      assert && assert( !options.pointMap, 'No pointMap for toPiecewiseLinear allowed, since it could create non-linear segments' );
      assert && assert( !options.methodName, 'No methodName for toPiecewiseLinear allowed, since it could create non-linear segments' );
      return this.nonlinearTransformed( options );
    },

    containsPoint: function( point ) {
      // we pick a ray, and determine the winding number over that ray. if the number of segments crossing it CCW == number of segments crossing it CW, then the point is contained in the shape
      var ray = new Ray2( point, Vector2.X_UNIT );

      return this.windingIntersection( ray ) !== 0;
    },

    intersection: function( ray ) {
      var hits = [];
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];

        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            var segment = subpath.segments[ k ];
            hits = hits.concat( segment.intersection( ray ) );
          }

          if ( subpath.hasClosingSegment() ) {
            hits = hits.concat( subpath.getClosingSegment().intersection( ray ) );
          }
        }
      }
      return _.sortBy( hits, function( hit ) { return hit.distance; } );
    },

    windingIntersection: function( ray ) {
      var wind = 0;

      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];

        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            wind += subpath.segments[ k ].windingIntersection( ray );
          }

          // handle the implicit closing line segment
          if ( subpath.hasClosingSegment() ) {
            wind += subpath.getClosingSegment().windingIntersection( ray );
          }
        }
      }

      return wind;
    },

    /**
     * Whether the path of the Shape intersects (or is contained in) the provided bounding box.
     * Computed by checking intersections with all four edges of the bounding box, or whether the Shape is totally
     * contained within the bounding box.
     *
     * @param {Bounds2} bounds
     */
    intersectsBounds: function( bounds ) {
      // If the bounding box completely surrounds our shape, it intersects the bounds
      if ( this.bounds.intersection( bounds ).equals( this.bounds ) ) {
        return true;
      }

      // rays for hit testing along the bounding box edges
      var minHorizontalRay = new Ray2( new Vector2( bounds.minX, bounds.minY ), new Vector2( 1, 0 ) );
      var minVerticalRay = new Ray2( new Vector2( bounds.minX, bounds.minY ), new Vector2( 0, 1 ) );
      var maxHorizontalRay = new Ray2( new Vector2( bounds.maxX, bounds.maxY ), new Vector2( -1, 0 ) );
      var maxVerticalRay = new Ray2( new Vector2( bounds.maxX, bounds.maxY ), new Vector2( 0, -1 ) );

      var hitPoint;
      var i;
      // TODO: could optimize to intersect differently so we bail sooner
      var horizontalRayIntersections = this.intersection( minHorizontalRay ).concat( this.intersection( maxHorizontalRay ) );
      for ( i = 0; i < horizontalRayIntersections.length; i++ ) {
        hitPoint = horizontalRayIntersections[ i ].point;
        if ( hitPoint.x >= bounds.minX && hitPoint.x <= bounds.maxX ) {
          return true;
        }
      }

      var verticalRayIntersections = this.intersection( minVerticalRay ).concat( this.intersection( maxVerticalRay ) );
      for ( i = 0; i < verticalRayIntersections.length; i++ ) {
        hitPoint = verticalRayIntersections[ i ].point;
        if ( hitPoint.y >= bounds.minY && hitPoint.y <= bounds.maxY ) {
          return true;
        }
      }

      // not contained, and no intersections with the sides of the bounding box
      return false;
    },

    // returns a new Shape that is an outline of the stroked path of this current Shape. currently not intended to be nested (doesn't do intersection computations yet)
    // TODO: rename stroked( lineStyles )
    getStrokedShape: function( lineStyles ) {
      var subpaths = [];
      var bounds = Bounds2.NOTHING.copy();
      var subLen = this.subpaths.length;
      for ( var i = 0; i < subLen; i++ ) {
        var subpath = this.subpaths[ i ];
        var strokedSubpath = subpath.stroked( lineStyles );
        subpaths = subpaths.concat( strokedSubpath );
      }
      subLen = subpaths.length;
      for ( i = 0; i < subLen; i++ ) {
        bounds.includeBounds( subpaths[ i ].bounds );
      }
      return new Shape( subpaths, bounds );
    },

    // {experimental!}
    getOffsetShape: function( distance ) {
      // TODO: abstract away this type of behavior
      var subpaths = [];
      var bounds = Bounds2.NOTHING.copy();
      var subLen = this.subpaths.length;
      for ( var i = 0; i < subLen; i++ ) {
        subpaths.push( this.subpaths[ i ].offset( distance ) );
      }
      subLen = subpaths.length;
      for ( i = 0; i < subLen; i++ ) {
        bounds.includeBounds( subpaths[ i ].bounds );
      }
      return new Shape( subpaths, bounds );
    },

    getBounds: function() {
      if ( this._bounds === null ) {
        var bounds = Bounds2.NOTHING.copy();
        _.each( this.subpaths, function( subpath ) {
          bounds.includeBounds( subpath.getBounds() );
        } );
        this._bounds = bounds;
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    getStrokedBounds: function( lineStyles ) {
      // Check if all of our segments end vertically or horizontally AND our drawable subpaths are all closed. If so,
      // we can apply a bounds dilation.
      var areStrokedBoundsDilated = true;
      for ( var i = 0; i < this.subpaths.length; i++ ) {
        var subpath = this.subpaths[ i ];

        // If a subpath with any segments is NOT closed, line-caps will apply. We can't make the simplification in this
        // case.
        if ( subpath.isDrawable() && !subpath.isClosed() ) {
          areStrokedBoundsDilated = false;
          break;
        }
        for ( var j = 0; j < subpath.segments.length; j++ ) {
          var segment = subpath.segments[ j ];
          if ( !segment.areStrokedBoundsDilated() ) {
            areStrokedBoundsDilated = false;
            break;
          }
        }
      }

      if ( areStrokedBoundsDilated ) {
        return this.bounds.dilated( lineStyles.lineWidth / 2 );
      }
      else {
        return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );
      }
    },

    getBoundsWithTransform: function( matrix, lineStyles ) {
      // if we don't need to handle rotation/shear, don't use the extra effort!
      if ( matrix.isAxisAligned() ) {
        return this.getStrokedBounds( lineStyles );
      }

      var bounds = Bounds2.NOTHING.copy();

      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];
        bounds.includeBounds( subpath.getBoundsWithTransform( matrix ) );
      }

      if ( lineStyles ) {
        bounds.includeBounds( this.getStrokedShape( lineStyles ).getBoundsWithTransform( matrix ) );
      }

      return bounds;
    },

    /**
     * Should be called after mutating the x/y of Vector2 points that were passed in to various Shape calls, so that
     * derived information computed (bounds, etc.) will be correct, and any clients (e.g. Scenery Paths) will be
     * notified of the updates.
     */
    invalidatePoints: function() {
      this._invalidatingPoints = true;

      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        this.subpaths[ i ].invalidatePoints();
      }

      this._invalidatingPoints = false;
      this.invalidate();
    },

    toString: function() {
      // TODO: consider a more verbose but safer way?
      return 'new kite.Shape( \'' + this.getSVGPath() + '\' )';
    },

    /*---------------------------------------------------------------------------*
     * Internal subpath computations
     *----------------------------------------------------------------------------*/

    // @private
    invalidate: function() {
      if ( !this._invalidatingPoints ) {
        this._bounds = null;

        this.trigger0( 'invalidated' );
      }
    },

    // @private
    addSegmentAndBounds: function( segment ) {
      this.getLastSubpath().addSegment( segment );
      this.invalidate();
    },

    // @private
    ensure: function( point ) {
      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
        this.getLastSubpath().addPoint( point );
      }
    },

    // @private
    addSubpath: function( subpath ) {
      this.subpaths.push( subpath );

      // listen to when the subpath is invalidated (will cause bounds recomputation here)
      subpath.onStatic( 'invalidated', this._invalidateListener );

      this.invalidate();

      return this; // allow chaining
    },

    // @private
    hasSubpaths: function() {
      return this.subpaths.length > 0;
    },

    // @private
    getLastSubpath: function() {
      return _.last( this.subpaths );
    },

    // @private - gets the last point in the last subpath, or null if it doesn't exist
    getLastPoint: function() {
      return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;
    },

    // @private
    getLastSegment: function() {
      if ( !this.hasSubpaths() ) { return null; }

      var subpath = this.getLastSubpath();
      if ( !subpath.isDrawable() ) { return null; }

      return subpath.getLastSegment();
    },

    // @private - returns the point to be used for smooth quadratic segments
    getSmoothQuadraticControlPoint: function() {
      var lastPoint = this.getLastPoint();

      if ( this.lastQuadraticControlPoint ) {
        return lastPoint.plus( lastPoint.minus( this.lastQuadraticControlPoint ) );
      }
      else {
        return lastPoint;
      }
    },

    // @private - returns the point to be used for smooth cubic segments
    getSmoothCubicControlPoint: function() {
      var lastPoint = this.getLastPoint();

      if ( this.lastCubicControlPoint ) {
        return lastPoint.plus( lastPoint.minus( this.lastCubicControlPoint ) );
      }
      else {
        return lastPoint;
      }
    },

    // @private
    getRelativePoint: function() {
      var lastPoint = this.getLastPoint();
      return lastPoint ? lastPoint : Vector2.ZERO;
    }
  } );

  /*---------------------------------------------------------------------------*
   * Shape shortcuts
   *----------------------------------------------------------------------------*/

  Shape.rectangle = function( x, y, width, height ) {
    return new Shape().rect( x, y, width, height );
  };
  Shape.rect = Shape.rectangle;

  // Create a round rectangle {Shape}, with {Number} arguments. Uses circular or elliptical arcs if given.
  Shape.roundRect = function( x, y, width, height, arcw, arch ) {
    return new Shape().roundRect( x, y, width, height, arcw, arch );
  };
  Shape.roundRectangle = Shape.roundRect;

  /**
   * Creates a rounded rectangle, where each corner can have a different radius. The radii default to 0, and may be set
   * using topLeft, topRight, bottomLeft and bottomRight in the options.
   * @public

   * E.g.:
   *
   * var cornerRadius = 20;
   * var rect = Shape.roundedRectangleWithRadii( 0, 0, 200, 100, {
   *   topLeft: cornerRadius,
   *   topRight: cornerRadius
   * } );
   *
   * @param {number} x - Left edge location
   * @param {number} y - Top edge location
   * @param {number} width - Width of rectangle
   * @param {number} height - Height of rectangle
   * @param {Object] [cornerRadii] - Optional object with potential radii for each corner.
   */
  Shape.roundedRectangleWithRadii = function( x, y, width, height, cornerRadii ) {
    // defaults to 0 (not using _.extends, since we reference each multiple times)
    var topLeftRadius = cornerRadii && cornerRadii.topLeft || 0;
    var topRightRadius = cornerRadii && cornerRadii.topRight || 0;
    var bottomLeftRadius = cornerRadii && cornerRadii.bottomLeft || 0;
    var bottomRightRadius = cornerRadii && cornerRadii.bottomRight || 0;

    // type and constraint assertions
    assert && assert( typeof x === 'number' && isFinite( x ), 'Non-finite x' );
    assert && assert( typeof y === 'number' && isFinite( y ), 'Non-finite y' );
    assert && assert( typeof width === 'number' && width >= 0 && isFinite( width ), 'Negative or non-finite width' );
    assert && assert( typeof height === 'number' && height >= 0 && isFinite( height ), 'Negative or non-finite height' );
    assert && assert( typeof topLeftRadius === 'number' && topLeftRadius >= 0 && isFinite( topLeftRadius ),
      'Invalid topLeft' );
    assert && assert( typeof topRightRadius === 'number' && topRightRadius >= 0 && isFinite( topRightRadius ),
      'Invalid topRight' );
    assert && assert( typeof bottomLeftRadius === 'number' && bottomLeftRadius >= 0 && isFinite( bottomLeftRadius ),
      'Invalid bottomLeft' );
    assert && assert( typeof bottomRightRadius === 'number' && bottomRightRadius >= 0 && isFinite( bottomRightRadius ),
      'Invalid bottomRight' );

    // verify there is no overlap between corners
    assert && assert( topLeftRadius + topRightRadius <= width, 'Corner overlap on top edge' );
    assert && assert( bottomLeftRadius + bottomRightRadius <= width, 'Corner overlap on bottom edge' );
    assert && assert( topLeftRadius + bottomLeftRadius <= height, 'Corner overlap on left edge' );
    assert && assert( topRightRadius + bottomRightRadius <= height, 'Corner overlap on right edge' );

    var shape = new kite.Shape();
    var right = x + width;
    var bottom = y + height;

    // To draw the rounded rectangle, we use the implicit "line from last segment to next segment" and the close() for
    // all of the straight line edges between arcs, or lineTo the corner.

    if ( bottomRightRadius > 0 ) {
      shape.arc( right - bottomRightRadius, bottom - bottomRightRadius, bottomRightRadius, 0, Math.PI / 2, false );
    }
    else {
      shape.moveTo( right, bottom );
    }

    if ( bottomLeftRadius > 0 ) {
      shape.arc( x + bottomLeftRadius, bottom - bottomLeftRadius, bottomLeftRadius, Math.PI / 2, Math.PI, false );
    }
    else {
      shape.lineTo( x, bottom );
    }

    if ( topLeftRadius > 0 ) {
      shape.arc( x + topLeftRadius, y + topLeftRadius, topLeftRadius, Math.PI, 3 * Math.PI / 2, false );
    }
    else {
      shape.lineTo( x, y );
    }

    if ( topRightRadius > 0 ) {
      shape.arc( right - topRightRadius, y + topRightRadius, topRightRadius, 3 * Math.PI / 2, 2 * Math.PI, false );
    }
    else {
      shape.lineTo( right, y );
    }

    shape.close();

    return shape;
  };

  Shape.polygon = function( vertices ) {
    return new Shape().polygon( vertices );
  };

  Shape.bounds = function( bounds ) {
    return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );
  };

  //Create a line segment, using either (x1,y1,x2,y2) or ({x1,y1},{x2,y2}) arguments
  Shape.lineSegment = function( a, b, c, d ) {
    // TODO: add type assertions?
    if ( typeof a === 'number' ) {
      return new Shape().moveTo( a, b ).lineTo( c, d );
    }
    else {
      return new Shape().moveToPoint( a ).lineToPoint( b );
    }
  };

  Shape.regularPolygon = function( sides, radius ) {
    var shape = new Shape();
    _.each( _.range( sides ), function( k ) {
      var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );
      ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );
    } );
    return shape.close();
  };

  // supports both circle( centerX, centerY, radius ), circle( center, radius ), and circle( radius ) with the center default to 0,0
  Shape.circle = function( centerX, centerY, radius ) {
    if ( centerY === undefined ) {
      // circle( radius ), center = 0,0
      return new Shape().circle( 0, 0, centerX );
    }
    return new Shape().circle( centerX, centerY, radius ).close();
  };

  /*
   * Supports ellipse( centerX, centerY, radiusX, radiusY, rotation ), ellipse( center, radiusX, radiusY, rotation ), and ellipse( radiusX, radiusY, rotation )
   * with the center default to 0,0 and rotation of 0.  The rotation is about the centerX, centerY.
   */
  Shape.ellipse = function( centerX, centerY, radiusX, radiusY, rotation ) {
    // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling
    if ( radiusY === undefined ) {
      // ellipse( radiusX, radiusY ), center = 0,0
      return new Shape().ellipse( 0, 0, centerX, centerY, radiusX );
    }
    return new Shape().ellipse( centerX, centerY, radiusX, radiusY, rotation ).close();
  };

  // supports both arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) and arc( center, radius, startAngle, endAngle, anticlockwise )
  Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {
    return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );
  };

  return Shape;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * An enumeration of different back-end technologies used for rendering. It also essentially represents the API that
 * nodes need to implement to be used with this specified back-end.
 *
 * We use a bitmask to represent renderers currently, in a way that can be logically-ANDed in order to obtain
 * information about "what renderer can support all of these Nodes?"
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Renderer',['require','SCENERY/scenery'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  // now it's a namespace
  var Renderer = {};
  scenery.register( 'Renderer', Renderer );

  //OHTWO TODO: rename to take advantage of lack of deprecated names? (remove bitmask prefix)

  /*---------------------------------------------------------------------------*
   * Renderer bitmask flags
   *---------------------------------------------------------------------------*/

  Renderer.numActiveRenderers = 4;
  Renderer.bitsPerRenderer = 5;
  Renderer.bitmaskRendererArea = 0x00000FF;
  Renderer.bitmaskCurrentRendererArea = 0x000000F;
  Renderer.bitmaskLacksOffset = 0x10000;
  Renderer.bitmaskLacksShift = 16; // number of bits between the main renderer bitmask and the "lacks" variety
  Renderer.bitmaskNodeDefault = Renderer.bitmaskRendererArea;

  Renderer.bitmaskCanvas = 0x0000001;
  Renderer.bitmaskSVG = 0x0000002;
  Renderer.bitmaskDOM = 0x0000004;
  Renderer.bitmaskWebGL = 0x0000008;
  // 10, 20, 40, 80 reserved for future renderers NOTE: update bitmaskCurrentRendererArea/numActiveRenderers if they are added/removed

  // summary bits (for RendererSummary):
  Renderer.bitmaskSingleCanvas = 0x100;
  Renderer.bitmaskSingleSVG = 0x200;
  // reserved gap 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000 for future renderer-specific single information
  Renderer.bitmaskNotPainted = 0x1000;
  Renderer.bitmaskBoundsValid = 0x2000;
  Renderer.bitmaskNotAccessible = 0x4000;
  // summary bits for whether a renderer could be potentially used to display a Node.
  Renderer.bitmaskLacksCanvas = Renderer.bitmaskCanvas << Renderer.bitmaskLacksShift; // 0x10000
  Renderer.bitmaskLacksSVG = Renderer.bitmaskSVG << Renderer.bitmaskLacksShift; // 0x20000
  Renderer.bitmaskLacksDOM = Renderer.bitmaskDOM << Renderer.bitmaskLacksShift; // 0x40000
  Renderer.bitmaskLacksWebGL = Renderer.bitmaskWebGL << Renderer.bitmaskLacksShift; // 0x80000
  // reserved gap 0x10000, 0x20000, 0x40000, 0x80000 for future renderers

  Renderer.isCanvas = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskCanvas ) !== 0;
  };
  Renderer.isSVG = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskSVG ) !== 0;
  };
  Renderer.isDOM = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskDOM ) !== 0;
  };
  Renderer.isWebGL = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskWebGL ) !== 0;
  };

  var rendererMap = {
    canvas: Renderer.bitmaskCanvas,
    svg: Renderer.bitmaskSVG,
    dom: Renderer.bitmaskDOM,
    webgl: Renderer.bitmaskWebGL
  };
  Renderer.fromName = function( name ) {
    return rendererMap[ name ];
  };

  // returns the part of the bitmask that should contain only Canvas/SVG/DOM/WebGL flags
  //OHTWO TODO: use this instead of direct access to bitmaskRendererArea
  Renderer.stripBitmask = function( bitmask ) {
    return bitmask & Renderer.bitmaskRendererArea;
  };

  Renderer.createOrderBitmask = function( firstRenderer, secondRenderer, thirdRenderer, fourthRenderer ) {
    firstRenderer = firstRenderer || 0;
    secondRenderer = secondRenderer || 0;
    thirdRenderer = thirdRenderer || 0;
    fourthRenderer = fourthRenderer || 0;

    // uses 20 bits now with 4 renderers
    return firstRenderer |
           ( secondRenderer << 5 ) |
           ( thirdRenderer << 10 ) |
           ( fourthRenderer << 15 );
  };
  // bitmaskOrderN with n=0 is bitmaskOrderFirst, n=1 is bitmaskOrderSecond, etc.
  Renderer.bitmaskOrder = function( bitmask, n ) {
    // Normally the condition here shouldn't be needed, but Safari seemed to cause a logic error when this function
    // gets inlined elsewhere if n=0. See https://github.com/phetsims/scenery/issues/481 and
    // https://github.com/phetsims/bending-light/issues/259.
    if ( n > 0 ) {
      bitmask = bitmask >> ( 5 * n );
    }
    return bitmask & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderFirst = function( bitmask ) {
    return bitmask & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderSecond = function( bitmask ) {
    return ( bitmask >> 5 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderThird = function( bitmask ) {
    return ( bitmask >> 10 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderFourth = function( bitmask ) {
    return ( bitmask >> 15 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.pushOrderBitmask = function( bitmask, renderer ) {
    assert && assert( typeof bitmask === 'number' );
    assert && assert( typeof renderer === 'number' );
    var rendererToInsert = renderer;
    var totalBits = Renderer.bitsPerRenderer * Renderer.numActiveRenderers;
    for ( var i = 0; i <= totalBits; i += Renderer.bitsPerRenderer ) {
      var currentRenderer = ( bitmask >> i ) & Renderer.bitmaskCurrentRendererArea;
      if ( currentRenderer === rendererToInsert ) {
        return bitmask;
      }
      else if ( currentRenderer === 0 ) {
        // place the renderer and exit
        bitmask = bitmask | ( rendererToInsert << i );
        return bitmask;
      }
      else {
        // clear out that slot
        bitmask = ( bitmask & ~( Renderer.bitmaskCurrentRendererArea << i ) );

        // place in the renderer to insert
        bitmask = bitmask | ( rendererToInsert << i );

        rendererToInsert = currentRenderer;
      }

      // don't walk over and re-place our initial renderer
      if ( rendererToInsert === renderer ) {
        return bitmask;
      }
    }

    throw new Error( 'pushOrderBitmask overflow' );
  };

  Renderer.createSelfDrawable = function( instance, node, selfRenderer, fittable ) {
    var drawable;

    if ( Renderer.isCanvas( selfRenderer ) ) {
      drawable = node.createCanvasDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isSVG( selfRenderer ) ) {
      drawable = node.createSVGDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isDOM( selfRenderer ) ) {
      drawable = node.createDOMDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isWebGL( selfRenderer ) ) {
      drawable = node.createWebGLDrawable( selfRenderer, instance );
    }
    else {
      throw new Error( 'Unrecognized renderer: ' + selfRenderer );
    }

    // Initialize its fittable flag
    drawable.setFittable( fittable );

    return drawable;
  };

  /*---------------------------------------------------------------------------*
   * WebGL Renderer type enumeration
   *----------------------------------------------------------------------------*/
  Renderer.webglCustom = 0x1;
  Renderer.webglTexturedTriangles = 0x2;
  Renderer.webglVertexColorPolygons = 0x3;

  return Renderer;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Contains information about what renderers (and a few other flags) are supported for an entire subtree.
 *
 * We effectively do this by tracking bitmask changes from scenery.js (used for rendering properties in general). In particular, we count
 * how many zeros in the bitmask we have in key places.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/RendererSummary',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Renderer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );

  var summaryBits = [
    // renderer bits ("Is renderer X supported by the entire sub-tree?")
    Renderer.bitmaskCanvas,
    Renderer.bitmaskSVG,
    Renderer.bitmaskDOM,
    Renderer.bitmaskWebGL,

    // summary bits (added to the renderer bitmask to handle special flags for the summary)
    Renderer.bitmaskSingleCanvas,
    Renderer.bitmaskSingleSVG,
    Renderer.bitmaskNotPainted,
    Renderer.bitmaskBoundsValid,
    Renderer.bitmaskNotAccessible,

    // inverse renderer bits ("Do all painted nodes NOT support renderer X in this sub-tree?")
    Renderer.bitmaskLacksCanvas,
    Renderer.bitmaskLacksSVG,
    Renderer.bitmaskLacksDOM,
    Renderer.bitmaskLacksWebGL
  ];
  var numSummaryBits = summaryBits.length;

  // A bitmask with all of the bits set that we record
  var bitmaskAll = 0;
  for ( var l = 0; l < numSummaryBits; l++ ) {
    bitmaskAll |= summaryBits[ l ];
  }

  function RendererSummary( node ) {
    // NOTE: assumes that we are created in the Node constructor
    assert && assert( node._rendererBitmask === Renderer.bitmaskNodeDefault, 'Node must have a default bitmask when creating a RendererSummary' );
    assert && assert( node._children.length === 0, 'Node cannot have children when creating a RendererSummary' );

    this.node = node;

    // Maps stringified bitmask bit (e.g. "1" for Canvas, since Renderer.bitmaskCanvas is 0x01) to
    // a count of how many children (or self) have that property (e.g. can't renderer all of their contents with Canvas)
    this._counts = {};
    for ( var i = 0; i < numSummaryBits; i++ ) {
      this._counts[ summaryBits[ i ] ] = 0; // set everything to 0 at first
    }

    // @public
    this.bitmask = bitmaskAll;

    this.selfBitmask = RendererSummary.summaryBitmaskForNodeSelf( node );

    this.summaryChange( this.bitmask, this.selfBitmask );

    // required listeners to update our summary based on painted/non-painted information
    var listener = this.selfChange.bind( this );
    this.node.onStatic( 'opacity', listener );
    this.node.onStatic( 'hint', listener ); // should fire on things like node.renderer being changed
    this.node.onStatic( 'clip', listener );
    this.node.onStatic( 'selfBoundsValid', listener ); // e.g. Text, may change based on boundsMethod
    this.node.onStatic( 'accessibleContent', listener );
  }

  scenery.register( 'RendererSummary', RendererSummary );

  inherit( Object, RendererSummary, {
    /*
     * @public
     * Use a bitmask of all 1s to represent 'does not exist' since we count zeros
     */
    summaryChange: function( oldBitmask, newBitmask ) {
      assert && this.audit();

      var changeBitmask = oldBitmask ^ newBitmask; // bit set only if it changed

      var ancestorOldMask = 0;
      var ancestorNewMask = 0;
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];

        // If the bit for the renderer has changed
        if ( bit & changeBitmask ) {

          // If it is now set (wasn't before), gained support for the renderer
          if ( bit & newBitmask ) {
            this._counts[ bit ]--; // reduce count, since we count the number of 0s (unsupported)
            if ( this._counts[ bit ] === 0 ) {
              ancestorNewMask |= bit; // add our bit to the "new" mask we will send to ancestors
            }
          }
          // It was set before (now isn't), lost support for the renderer
          else {
            this._counts[ bit ]++; // increment the count, since we count the number of 0s (unsupported)
            if ( this._counts[ bit ] === 1 ) {
              ancestorOldMask |= bit; // add our bit to the "old" mask we will send to ancestors
            }
          }
        }
      }

      if ( ancestorOldMask || ancestorNewMask ) {
        for ( var j = 0; j < numSummaryBits; j++ ) {
          var ancestorBit = summaryBits[ j ];
          // Check for added bits
          if ( ancestorNewMask & ancestorBit ) {
            this.bitmask |= ancestorBit;
          }

          // Check for removed bits
          if ( ancestorOldMask & ancestorBit ) {
            this.bitmask ^= ancestorBit;
            assert && assert( !( this.bitmask & ancestorBit ),
              'Should be cleared, doing cheaper XOR assuming it already was set' );
          }
        }

        this.node.trigger0( 'rendererSummary' ); // please don't change children when listening to this!

        var len = this.node._parents.length;
        for ( var k = 0; k < len; k++ ) {
          this.node._parents[ k ]._rendererSummary.summaryChange( ancestorOldMask, ancestorNewMask );
        }

        assert && assert( this.bitmask === this.computeBitmask(), 'Sanity check' );
      }

      assert && this.audit();
    },

    // @public
    selfChange: function() {
      var oldBitmask = this.selfBitmask;
      var newBitmask = RendererSummary.summaryBitmaskForNodeSelf( this.node );
      if ( oldBitmask !== newBitmask ) {
        this.summaryChange( oldBitmask, newBitmask );
        this.selfBitmask = newBitmask;
      }
    },

    // @private
    computeBitmask: function() {
      var bitmask = 0;
      for ( var i = 0; i < numSummaryBits; i++ ) {
        if ( this._counts[ summaryBits[ i ] ] === 0 ) {
          bitmask |= summaryBits[ i ];
        }
      }
      return bitmask;
    },

    /**
     * @public
     * Is the renderer compatible with every single painted node under this subtree?
     * (Can this entire sub-tree be rendered with just this renderer)
     *
     * @param {number} renderer - Single bit preferred. If multiple bits set, requires ALL painted nodes are compatible
     *                            with ALL of the bits.
     */
    isSubtreeFullyCompatible: function( renderer ) {
      return !!( renderer & this.bitmask );
    },

    /**
     * @public
     * Is the renderer compatible with at least one painted node under this subtree?
     *
     * @param {number} renderer - Single bit preferred. If multiple bits set, will return if a single painted node is
     *                            compatible with at least one of the bits.
     */
    isSubtreeContainingCompatible: function( renderer ) {
      return !( ( renderer << Renderer.bitmaskLacksShift ) & this.bitmask );
    },

    isSingleCanvasSupported: function() {
      return !!( Renderer.bitmaskSingleCanvas & this.bitmask );
    },

    isSingleSVGSupported: function() {
      return !!( Renderer.bitmaskSingleSVG & this.bitmask );
    },

    isNotPainted: function() {
      return !!( Renderer.bitmaskNotPainted & this.bitmask );
    },

    isNotAccessible: function() {
      return !!( Renderer.bitmaskNotAccessible & this.bitmask );
    },

    areBoundsValid: function() {
      return !!( Renderer.bitmaskBoundsValid & this.bitmask );
    },

    /**
     * Given a bitmask representing a list of ordered preferred renderers, we check to see if all of our nodes can be
     * displayed in a single SVG block, AND that given the preferred renderers, that it will actually happen in our
     * rendering process.
     */
    isSubtreeRenderedExclusivelySVG: function( preferredRenderers ) {
      // Check if we have anything that would PREVENT us from having a single SVG block
      if ( !this.isSingleSVGSupported() ) {
        return false;
      }

      // Check for any renderer preferences that would CAUSE us to choose not to display with a single SVG block
      for ( var i = 0; i < Renderer.numActiveRenderers; i++ ) {
        // Grab the next-most preferred renderer
        var renderer = Renderer.bitmaskOrder( preferredRenderers, i );

        // If it's SVG, congrats! Everything will render in SVG (since SVG is supported, as noted above)
        if ( Renderer.bitmaskSVG & renderer ) {
          return true;
        }

        // Since it's not SVG, if there's a single painted node that supports this renderer (which is preferred over SVG),
        // then it will be rendered with this renderer, NOT SVG.
        if ( this.isSubtreeContainingCompatible( renderer ) ) {
          return false;
        }
      }

      return false; // sanity check
    },

    // for debugging purposes
    audit: function() {
      if ( assert ) {
        for ( var i = 0; i < numSummaryBits; i++ ) {
          var bit = summaryBits[ i ];
          var countIsZero = this._counts[ bit ] === 0;
          var bitmaskContainsBit = !!( this.bitmask & bit );
          assert( countIsZero === bitmaskContainsBit, 'Bits should be set if count is zero' );
        }
      }
    },

    // for debugging purposes
    toString: function() {
      var result = RendererSummary.bitmaskToString( this.bitmask );
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];
        var countForBit = this._counts[ bit ];
        if ( countForBit !== 0 ) {
          result += ' ' + RendererSummary.bitToString( bit ) + ':' + countForBit;
        }
      }
      return result;
    }
  }, {
    bitmaskAll: bitmaskAll,

    /**
     * Determines which of the summary bits can be set for a specific Node (ignoring children/ancestors).
     * For instance, for bitmaskSingleSVG, we only don't include the flag if THIS node prevents its usage
     * (even though child nodes may prevent it in the renderer summary itself).
     *
     * @param {Node} node
     */
    summaryBitmaskForNodeSelf: function( node ) {
      var bitmask = node._rendererBitmask;

      if ( node.isPainted() ) {
        bitmask |= ( ( node._rendererBitmask & Renderer.bitmaskCurrentRendererArea ) ^ Renderer.bitmaskCurrentRendererArea ) << Renderer.bitmaskLacksShift;
      }
      else {
        bitmask |= Renderer.bitmaskCurrentRendererArea << Renderer.bitmaskLacksShift;
      }

      // NOTE: If changing, see Instance.updateRenderingState
      var requiresSplit = node._hints.requireElement || node._hints.cssTransform || node._hints.layerSplit;
      var mightUseOpacity = node.opacity !== 1 || node._hints.usesOpacity;
      var mightUseClip = node.clipArea !== null;
      var rendererHint = node._hints.renderer;

      // Whether this subtree will be able to support a single SVG element
      // NOTE: If changing, see Instance.updateRenderingState
      if ( !requiresSplit && // Can't have a single SVG element if we are split
           Renderer.isSVG( node._rendererBitmask ) && // If our node doesn't support SVG, can't do it
           ( !rendererHint || Renderer.isSVG( rendererHint ) ) ) { // Can't if a renderer hint is set to something else
        bitmask |= Renderer.bitmaskSingleSVG;
      }

      // Whether this subtree will be able to support a single Canvas element
      // NOTE: If changing, see Instance.updateRenderingState
      if ( !requiresSplit && // Can't have a single SVG element if we are split
           !mightUseOpacity && // Opacity not supported for Canvas blocks yet
           !mightUseClip && // Clipping not supported for Canvas blocks yet
           Renderer.isCanvas( node._rendererBitmask ) && // If our node doesn't support Canvas, can't do it
           ( !rendererHint || Renderer.isCanvas( rendererHint ) ) ) { // Can't if a renderer hint is set to something else
        bitmask |= Renderer.bitmaskSingleCanvas;
      }

      if ( !node.isPainted() ) {
        bitmask |= Renderer.bitmaskNotPainted;
      }
      if ( node.areSelfBoundsValid() ) {
        bitmask |= Renderer.bitmaskBoundsValid;
      }
      if ( !node.accessibleContent ) {
        bitmask |= Renderer.bitmaskNotAccessible;
      }

      return bitmask;
    },

    // for debugging purposes
    bitToString: function( bit ) {
      if ( bit === Renderer.bitmaskCanvas ) { return 'Canvas'; }
      if ( bit === Renderer.bitmaskSVG ) { return 'SVG'; }
      if ( bit === Renderer.bitmaskDOM ) { return 'DOM'; }
      if ( bit === Renderer.bitmaskWebGL ) { return 'WebGL'; }
      if ( bit === Renderer.bitmaskLacksCanvas ) { return '(-Canvas)'; }
      if ( bit === Renderer.bitmaskLacksSVG ) { return '(-SVG)'; }
      if ( bit === Renderer.bitmaskLacksDOM ) { return '(-DOM)'; }
      if ( bit === Renderer.bitmaskLacksWebGL ) { return '(-WebGL)'; }
      if ( bit === Renderer.bitmaskSingleCanvas ) { return 'SingleCanvas'; }
      if ( bit === Renderer.bitmaskSingleSVG ) { return 'SingleSVG'; }
      if ( bit === Renderer.bitmaskNotPainted ) { return 'NotPainted'; }
      if ( bit === Renderer.bitmaskBoundsValid ) { return 'BoundsValid'; }
      if ( bit === Renderer.bitmaskNotAccessible ) { return 'NotAccessible'; }
      return '?';
    },

    // for debugging purposes
    bitmaskToString: function( bitmask ) {
      var result = '';
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];
        if ( bitmask & bit ) {
          result += RendererSummary.bitToString( bit ) + ' ';
        }
      }
      return result;
    }
  } );

  return RendererSummary;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Wraps the context and contains a reference to the canvas, so that we can absorb unnecessary state changes,
 * and possibly combine certain fill operations.
 *
 * TODO: performance analysis, possibly axe this and use direct modification.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/CanvasContextWrapper',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  function CanvasContextWrapper( canvas, context ) {
    this.canvas = canvas;
    this.context = context;

    this.resetStyles();

    phetAllocation && phetAllocation( 'CanvasContextWrapper' );
  }

  scenery.register( 'CanvasContextWrapper', CanvasContextWrapper );

  inherit( Object, CanvasContextWrapper, {
    // set local styles to undefined, so that they will be invalidated later
    resetStyles: function() {
      this.fillStyle = undefined; // null
      this.strokeStyle = undefined; // null
      this.lineWidth = undefined; // 1
      this.lineCap = undefined; // 'butt'
      this.lineJoin = undefined; // 'miter'
      this.lineDash = undefined; // []
      this.lineDashOffset = undefined; // 0
      this.miterLimit = undefined; // 10

      this.font = undefined; // '10px sans-serif'
      this.direction = undefined; // 'inherit'
    },

    /**
     * Sets a (possibly) new width and height, and clears the canvas.
     * @param width
     * @param height
     */
    setDimensions: function( width, height ) {

      //Don't guard against width and height, because we need to clear the canvas.
      //TODO: Is it expensive to clear by setting both the width and the height?  Maybe we just need to set the width to clear it.
      this.canvas.width = width;
      this.canvas.height = height;

      // assume all persistent data could have changed
      this.resetStyles();
    },

    setFillStyle: function( style ) {
      // turn {Color}s into strings when necessary
      if ( style && style.getCanvasStyle ) {
        style = style.getCanvasStyle();
      }

      if ( this.fillStyle !== style ) {
        this.fillStyle = style;

        // allow gradients / patterns
        this.context.fillStyle = style;
      }
    },

    setStrokeStyle: function( style ) {
      // turn {Color}s into strings when necessary
      if ( style && style.getCanvasStyle ) {
        style = style.getCanvasStyle();
      }

      if ( this.strokeStyle !== style ) {
        this.strokeStyle = style;

        // allow gradients / patterns
        this.context.strokeStyle = style;
      }
    },

    setLineWidth: function( width ) {
      if ( this.lineWidth !== width ) {
        this.lineWidth = width;
        this.context.lineWidth = width;
      }
    },

    setLineCap: function( cap ) {
      if ( this.lineCap !== cap ) {
        this.lineCap = cap;
        this.context.lineCap = cap;
      }
    },

    setLineJoin: function( join ) {
      if ( this.lineJoin !== join ) {
        this.lineJoin = join;
        this.context.lineJoin = join;
      }
    },

    setMiterLimit: function( miterLimit ) {
      assert && assert( typeof miterLimit === 'number' );
      if ( this.miterLimit !== miterLimit ) {
        this.miterLimit = miterLimit;
        this.context.miterLimit = miterLimit;
      }
    },

    setLineDash: function( dash ) {
      assert && assert( dash !== undefined, 'undefined line dash would cause hard-to-trace errors' );
      if ( this.lineDash !== dash ) {
        this.lineDash = dash;
        if ( this.context.setLineDash ) {
          this.context.setLineDash( dash === null ? [] : dash ); // see https://github.com/phetsims/scenery/issues/101 for null line-dash workaround
        }
        else if ( this.context.mozDash !== undefined ) {
          this.context.mozDash = dash;
        }
        else if ( this.context.webkitLineDash !== undefined ) {
          this.context.webkitLineDash = dash ? dash : [];
        }
        else {
          // unsupported line dash! do... nothing?
        }
      }
    },

    setLineDashOffset: function( lineDashOffset ) {
      if ( this.lineDashOffset !== lineDashOffset ) {
        this.lineDashOffset = lineDashOffset;
        if ( this.context.lineDashOffset !== undefined ) {
          this.context.lineDashOffset = lineDashOffset;
        }
        else if ( this.context.webkitLineDashOffset !== undefined ) {
          this.context.webkitLineDashOffset = lineDashOffset;
        }
        else {
          // unsupported line dash! do... nothing?
        }
      }
    },

    setFont: function( font ) {
      if ( this.font !== font ) {
        this.font = font;
        this.context.font = font;
      }
    },

    setDirection: function( direction ) {
      if ( this.direction !== direction ) {
        this.direction = direction;
        this.context.direction = direction;
      }
    }
  } );

  return CanvasContextWrapper;
} );

// Copyright 2012-2015, University of Colorado Boulder

/**
 * A node for the Scenery scene graph. Supports general directed acyclic graphics (DAGs).
 * Handles multiple layers with assorted types (Canvas 2D, SVG, DOM, WebGL, etc.).
 *
 * See http://phetsims.github.io/scenery/doc/#node
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Node',['require','PHET_CORE/inherit','PHET_CORE/extend','AXON/Events','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','DOT/Vector2','DOT/Util','KITE/Shape','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/util/RendererSummary','SCENERY/util/CanvasContextWrapper'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var Events = require( 'AXON/Events' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Transform3 = require( 'DOT/Transform3' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Vector2 = require( 'DOT/Vector2' );
  var clamp = require( 'DOT/Util' ).clamp;
  var Shape = require( 'KITE/Shape' );

  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var RendererSummary = require( 'SCENERY/util/RendererSummary' );
  require( 'SCENERY/util/CanvasContextWrapper' );
  // commented out so Require.js doesn't balk at the circular dependency
  // require( 'SCENERY/util/Trail' );
  // require( 'SCENERY/util/TrailPointer' );

  var globalIdCounter = 1;

  var eventsRequiringBoundsValidation = {
    'childBounds': true,
    'localBounds': true,
    'bounds': true
  };

  var trailUnderPointerOptions = {};

  function defaultTrailPredicate( node ) {
    return node._parents.length === 0;
  }

  function defaultLeafTrailPredicate( node ) {
    return node._children.length === 0;
  }

  function hasRootedDisplayPredicate( node ) {
    return node._rootedDisplays.length > 0;
  }

  var scratchBounds2 = Bounds2.NOTHING.copy(); // mutable {Bounds2} used temporarily in methods
  var scratchMatrix3 = new Matrix3();

  /*
   * See http://phetsims.github.io/scenery/doc/#node-options
   *
   * Available keys for use in the options parameter object for a vanilla Node (not inherited), in the order they are executed in:
   *
   * children:         A list of children to add (in order)
   * cursor:           Will display the specified CSS cursor when the mouse is over this Node or one of its descendents. The Scene needs to have input listeners attached with an initialize method first.
   * visible:          If false, this node (and its children) will not be displayed (or get input events)
   * pickable:         If false, this node (and its children) will not get input events
   * opacity:          Sets the opacity in the range [0,1]
   * matrix:           Sets the {Matrix3} transformation matrix (sets translation, rotation and scaling)
   * translation:      Sets the translation of the node to either the specified dot.Vector2 value, or the x,y values from an object (e.g. translation: { x: 1, y: 2 } )
   * x:                Sets the x-translation of the node
   * y:                Sets the y-translation of the node
   * rotation:         Sets the rotation of the node in radians
   * scale:            Sets the scale of the node. Supports either a number (same x-y scale), or a dot.Vector2 / object with ob.x and ob.y to set the scale for each axis independently
   * leftTop:          Sets the translation so that the left-top corner of the bounding box (in the parent coordinate frame) is at the specified point
   * centerTop:        Sets the translation so that the center of the top edge of the bounding box (in the parent coordinate frame) is at the specified point
   * rightTop:         Sets the translation so that the right-top corner of the bounding box (in the parent coordinate frame) is at the specified point
   * leftCenter:       Sets the translation so that the center of the left edge of the bounding box (in the parent coordinate frame) is at the specified point
   * center:           Sets the translation so that the center the bounding box (in the parent coordinate frame) is at the specified point
   * rightCenter:      Sets the translation so that the center of the right edge of the bounding box (in the parent coordinate frame) is at the specified point
   * leftBottom:       Sets the translation so that the left-bottom corner of the bounding box (in the parent coordinate frame) is at the specified point
   * centerBottom:     Sets the translation so that the center of the bottom edge of the bounding box (in the parent coordinate frame) is at the specified point
   * rightBottom:      Sets the translation so that the right-bottom corner of the bounding box (in the parent coordinate frame) is at the specified point
   * left:             Sets the x-translation so that the left (min X) of the bounding box (in the parent coordinate frame) is at the specified value
   * right:            Sets the x-translation so that the right (max X) of the bounding box (in the parent coordinate frame) is at the specified value
   * top:              Sets the y-translation so that the top (min Y) of the bounding box (in the parent coordinate frame) is at the specified value
   * bottom:           Sets the y-translation so that the bottom (min Y) of the bounding box (in the parent coordinate frame) is at the specified value
   * centerX:          Sets the x-translation so that the horizontal center of the bounding box (in the parent coordinate frame) is at the specified value
   * centerY:          Sets the y-translation so that the vertical center of the bounding box (in the parent coordinate frame) is at the specified value
   * renderer:         Forces Scenery to use the specific renderer (canvas/svg) to display this node (and if possible, children). Accepts both strings (e.g. 'canvas', 'svg', etc.) or actual Renderer objects (e.g. Renderer.Canvas, Renderer.SVG, etc.)
   * rendererOptions:  Parameter object that is passed to the created layer, and can affect how the layering process works.
   * layerSplit:       Forces a split between layers before and after this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.
   * mouseArea:        Shape (in local coordinate frame) that overrides the 'hit area' for mouse input.
   * touchArea:        Shape (in local coordinate frame) that overrides the 'hit area' for touch input.
   * clipArea:         Shape (in local coordinate frame) that causes any graphics outside of the shape to be invisible (for the node and any children).
   * transformBounds:  Whether to compute tighter parent bounding boxes for rotated bounding boxes, or to just use the bounding box of the rotated bounding box.
   * focusable:        True if the node should be able to receive keyboard focus.
   */
  function Node( options ) {
    // supertype call to axon.Events (should just initialize a few properties here, notably _eventListeners and _staticEventListeners)
    Events.call( this );

    // NOTE: All member properties with names starting with '_' are assumed to be @private!

    // @private {number} - Assigns a unique ID to this node (allows trails to get a unique list of IDs)
    this._id = globalIdCounter++;

    // @protected {Array.<Instance>} - All of the Instances tracking this Node
    this._instances = [];

    // @protected {Array.<AccessibleInstance>} - Empty unless the node contains some accessible instance.
    this._accessibleInstances = [];

    // @protected {Array.<Display>} - All displays where this node is the root.
    this._rootedDisplays = [];

    // @protected {Array.<Drawable>} - Drawable states that need to be updated on mutations. Generally added by SVG and
    // DOM elements that need to closely track state (possibly by Canvas to maintain dirty state).
    this._drawables = [];

    // @private {boolean} - Whether this node (and its children) will be visible when the scene is updated. Visible
    // nodes by default will not be pickable either.
    this._visible = true;

    // @private {number} - Opacity, in the range from 0 (fully transparent) to 1 (fully opaque).
    this._opacity = 1;

    // @private Whether this node (and its subtree) will allow hit-testing (and thus user interaction). Notably:
    // pickable: null  - default. Node is only pickable if it (or an ancestor/descendant) has either an input listener or pickable: true set
    // pickable: false - Node (and subtree) is pickable, just like if there is an input listener
    // pickable: true  - Node is unpickable (only has an effect when underneath a node with an input listener / pickable: true set)
    this._pickable = null;

    // @private - This node and all children will be clipped by this shape (in addition to any other clipping shapes).
    // {Shape|null} The shape should be in the local coordinate frame.
    this._clipArea = null;

    // @private - Areas for hit intersection. If set on a Node, no descendants can handle events.
    this._mouseArea = null; // {Shape|Bounds2} for mouse position in the local coordinate frame
    this._touchArea = null; // {Shape|Bounds2} for touch and pen position in the local coordinate frame

    // @private {string} - The CSS cursor to be displayed over this node. null should be the default (inherit) value.
    this._cursor = null;

    // @private @deprecated {boolean} - Whether this Node should be accessible via tab ordering. Defaults to false.
    this._focusable = false;

    // @private @deprecated {string} - 'cursor' or 'rectangle' at the moment. WARNING: in active development!
    this._focusIndicator = 'rectangle';

    // @private {null|Object} - If non-null, this node will be represented in the parallel DOM by the accessible content.
    // The accessibleContent object will be of the form:
    // {
    //   createPeer: function( {AccessibleInstance} ): {AccessiblePeer},
    //   [focusHighlight]: {Bounds2|Shape|Node}
    // }
    this._accessibleContent = null;

    // @private {Array.<Node> | null} - If provided, it will override the focus order between children (and optionally
    // descendants). If not provided, the focus order will default to the rendering order (first children first, last
    // children last) determined by the children array.
    this._accessibleOrder = null;

    // @public (scenery-internal) - Not for public use, but used directly internally for performance.
    this._children = []; // {Array.<Node>} - Ordered array of child nodes.
    this._parents = []; // {Array.<Node>} - Unordered array of parent nodes.

    // @private @deprecated
    this._peers = []; // array of peer factories: { element: ..., options: ... }, where element can be an element or a string
    this._liveRegions = []; // array of live region instances

    // @private {boolean} - Whether we will do more accurate (and tight) bounds computations for rotations and shears.
    this._transformBounds = false;

    /*
     * Set up the transform reference. we add a listener so that the transform itself can be modified directly
     * by reference, triggering the event notifications for Scenery The reference to the Transform3 will never change.
     */
    this._transform = new Transform3(); // @private {Transform3}
    this._transformListener = this.onTransformChange.bind( this ); // @private {Function}
    this._transform.onStatic( 'change', this._transformListener ); // NOTE: Listener/transform bound to this node.

    /*
     * Maxmimum dimensions for the node's local bounds before a corrective scaling factor is applied to maintain size.
     * The maximum dimensions are always compared to local bounds, and applied "before" the node's transform.
     * Whenever the local bounds or maximum dimensions of this Node change and it has at least one maximum dimension
     * (width or height), an ideal scale is computed (either the smallest scale for our local bounds to fit the
     * dimension constraints, OR 1, whichever is lower). Then the Node's transform will be scaled (prepended) with
     * a scale adjustment of ( idealScale / alreadyAppliedScaleFactor ).
     * In the simple case where the Node isn't otherwise transformed, this will apply and update the Node's scale so that
     * the node matches the maximum dimensions, while never scaling over 1. Note that manually applying transforms to
     * the Node is fine, but may make the node's width greater than the maximum width.
     * NOTE: If a dimension constraint is null, no resizing will occur due to it. If both maxWidth and maxHeight are null,
     * no scale adjustment will be applied.
     *
     * Also note that setting maxWidth/maxHeight is like adding a local bounds listener (will trigger validation of
     * bounds during the updateDisplay step). NOTE: this means updates to the transform (on a local bounds change) will
     * happen when bounds are validated (validateBounds()), which does not happen synchronously on a child's size
     * change. It does happen at least once in updateDisplay() before rendering, and calling validateBounds() can force
     * a re-check and transform.
     */
    this._maxWidth = null; // @private {number|null}
    this._maxHeight = null; // @private {number|null}
    this._appliedScaleFactor = 1; // @private {number} - Scale applied due to the maximum dimension constraints.

    // @private {Array.<Function>} - For user input handling (mouse/touch).
    this._inputListeners = [];

    // @private {Bounds2} - [mutable] Bounds for this node and its children in the "parent" coordinate frame.
    this._bounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - [mutable] Bounds for this node and its children in the "local" coordinate frame.
    this._localBounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - [mutable] Bounds just for this node, in the "local" coordinate frame.
    this._selfBounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - [mutable] Bounds just for children of this node (and sub-trees), in the "local" coordinate frame.
    this._childBounds = Bounds2.NOTHING.copy();

    // @private {boolean} - Whether our localBounds have been set (with the ES5 setter/setLocalBounds()) to a custom
    // overridden value. If true, then localBounds itself will not be updated, but will instead always be the
    // overridden value.
    this._localBoundsOverridden = false;

    this._boundsDirty = true; // @private {boolean} - Whether bounds needs to be recomputed to be valid.
    this._localBoundsDirty = true; // @private {boolean} - Whether localBounds needs to be recomputed to be valid.
    this._selfBoundsDirty = true; // @private {boolean} - Whether selfBounds needs to be recomputed to be valid.
    this._childBoundsDirty = true; // @private {boolean} - Whether childBounds needs to be recomputed to be valid.

    if ( assert ) {
      // for assertions later to ensure that we are using the same Bounds2 copies as before
      this._originalBounds = this._bounds;
      this._originalLocalBounds = this._localBounds;
      this._originalSelfBounds = this._selfBounds;
      this._originalChildBounds = this._childBounds;
    }

    // Similar to bounds, but includes any mouse/touch areas respectively, and excludes areas that would be pruned in
    // hit-testing. They are validated separately (independent from normal bounds validation), but should now always be
    // non-null (since we now properly handle pruning).
    this._mouseBounds = Bounds2.NOTHING.copy(); // @private {Bounds2} - [mutable] Hit bounds for mouse input
    this._touchBounds = Bounds2.NOTHING.copy(); // @private {Bounds2} - [mutable] Hit bounds for touch input
    this._mouseBoundsDirty = true; // @private {boolean} - Whether the bounds are marked as dirty
    this._touchBoundsDirty = true; // @private {boolean} - Whether the bounds are marked as dirty
    // Dirty flags for mouse/touch bounds. Since we only walk the dirty flags up ancestors, we need a way to
    // re-evaluate descendants when the existence of effective listeners changes.
    this._mouseBoundsHadListener = false; // @private {boolean}
    this._touchBoundsHadListener = false; // @private {boolean}

    // @public (scenery-internal) {Object} - Where rendering-specific settings are stored. They are generally modified
    // internally, so there is no ES5 setter for hints.
    this._hints = {
      // {number} - What type of renderer should be forced for this node. Uses the internal bitmask structure declared
      //            in scenery.js and Renderer.js.
      renderer: 0,

      // {boolean} - Whether it is ancitipated that opacity will be switched on. If so, having this set to true will
      //             make switching back-and-forth between opacity:1 and other opacities much faster.
      usesOpacity: false,

      // {boolean} - Whether layers should be split before and after this node.
      layerSplit: false,

      // {boolean} - Whether this node and its subtree should handle transforms by using a CSS transform of a div.
      cssTransform: false,

      // {boolean} - When rendered as Canvas, whether we should use full (device) resolution on retina-like devices.
      //             TODO: ensure that this is working? 0.2 may have caused a regression.
      fullResolution: false,

      // {boolean} - Whether SVG (or other) content should be excluded from the DOM tree when invisible
      //             (instead of just being hidden)
      excludeInvisible: false,

      // {number|null} - If non-null, a multiplier to the detected pixel-to-pixel scaling of the WebGL Canvas
      webglScale: null,

      // {boolean} - If true, Scenery will not fit any blocks that contain drawables attached to Nodes underneath this
      //             node's subtree. This will typically prevent Scenery from triggering bounds computation for this
      //             sub-tree, and movement of this node or its descendants will never trigger the refitting of a block.
      preventFit: false
    };

    // @public (scenery-internal) {number} - The subtree pickable count is #pickable:true + #inputListeners, since we
    // can prune subtrees with a pickable count of 0.
    this._subtreePickableCount = 0;

    // @public (scenery-internal) {number} - A bitmask which specifies which renderers this node (and only this node,
    // not its subtree) supports.
    this._rendererBitmask = Renderer.bitmaskNodeDefault;

    // @public (scenery-internal) {RendererSummary} - A bitmask-like summary of what renderers and options are supported
    // by this node and all of its descendants
    this._rendererSummary = new RendererSummary( this );

    /*
     * So we can traverse only the subtrees that require bounds validation for events firing.
     * This is a sum of the number of events requiring bounds validation on this Node, plus the number of children whose
     * count is non-zero.
     * NOTE: this means that if A has a child B, and B has a boundsEventCount of 5, it only contributes 1 to A's count.
     * This allows us to have changes localized (increasing B's count won't change A or any of A's ancestors), and
     * guarantees that we will know whether a subtree has bounds listeners. Also important: decreasing B's
     * boundsEventCount down to 0 will allow A to decrease its count by 1, without having to check its other children
     * (if we were just using a boolean value, this operation would require A to check if any OTHER children besides
     * B had bounds listeners)
     */
    this._boundsEventCount = 0; // @private {number}
    // @private {number} - This signals that we can validateBounds() on this subtree and we don't have to traverse further
    this._boundsEventSelfCount = 0;

    if ( options ) {
      this.mutate( options );
    }

    phetAllocation && phetAllocation( 'Node' );
  }

  scenery.register( 'Node', Node );

  inherit( Object, Node, extend( {
    /**
     * Inserts a child node at a specific index, see http://phetsims.github.io/scenery/doc/#node-insertChild
     * @public
     *
     * NOTE: overridden by Leaf for some subtypes
     *
     * @param {number} index
     * @param {Node} node
     */
    insertChild: function( index, node ) {
      assert && assert( node !== null && node !== undefined, 'insertChild cannot insert a null/undefined child' );
      assert && assert( node instanceof Node,
        'addChild/insertChild requires the child to be a Node. Constructor: ' +
        ( node.constructor ? node.constructor.name : 'none' ) );
      assert && assert( !_.contains( this._children, node ), 'Parent already contains child' );
      assert && assert( node !== this, 'Cannot add self as a child' );

      // needs to be early to prevent re-entrant children modifications
      this.changePickableCount( node._subtreePickableCount );
      this.changeBoundsEventCount( node._boundsEventCount > 0 ? 1 : 0 );
      this._rendererSummary.summaryChange( RendererSummary.bitmaskAll, node._rendererSummary.bitmask );

      node._parents.push( this );
      this._children.splice( index, 0, node );

      // If this added subtree contains accessible content, we need to notify any relevant displays
      if ( !node._rendererSummary.isNotAccessible() ) {
        this.onAccessibleAddChild( node );
      }

      node.invalidateBounds();

      // like calling this.invalidateBounds(), but we already marked all ancestors with dirty child bounds
      this._boundsDirty = true;

      this.trigger2( 'childInserted', node, index );

      return this; // allow chaining
    },

    /**
     * Appends a child node to our list of children, see http://phetsims.github.io/scenery/doc/#node-addChild
     * @public
     *
     * @param {Node} node
     */
    addChild: function( node ) {
      this.insertChild( this._children.length, node );

      return this; // allow chaining
    },

    /**
     * Removes a child node from our list of children, see http://phetsims.github.io/scenery/doc/#node-removeChild
     * Will fail an assertion if the node is not currently one of our children
     * @public
     *
     * @param {Node} node
     */
    removeChild: function( node ) {
      assert && assert( node && node instanceof Node, 'Need to call node.removeChild() with a Node.' );
      assert && assert( this.hasChild( node ), 'Attempted to removeChild with a node that was not a child.' );

      var indexOfChild = _.indexOf( this._children, node );

      this.removeChildWithIndex( node, indexOfChild );

      return this; // allow chaining
    },

    /**
     * Removes a child node at a specific index (node.children[ index ]) from our list of children.
     * Will fail if the index is out of bounds.
     * @public
     *
     * @param {number} index
     */
    removeChildAt: function( index ) {
      assert && assert( index >= 0 );
      assert && assert( index < this._children.length );

      var node = this._children[ index ];

      this.removeChildWithIndex( node, index );

      return this; // allow chaining
    },

    /**
     * Internal method for removing a node (always has the Node and index).
     * @private
     *
     * NOTE: overridden by Leaf for some subtypes
     *
     * @param {Node} node - The child node to remove from this node (it's parent)
     * @param {number} indexOfChild - Should satisfy this.children[ indexOfChild ] === node
     */
    removeChildWithIndex: function( node, indexOfChild ) {
      assert && assert( node && node instanceof Node, 'Need to call node.removeChildWithIndex() with a Node.' );
      assert && assert( this.hasChild( node ), 'Attempted to removeChild with a node that was not a child.' );
      assert && assert( this._children[ indexOfChild ] === node, 'Incorrect index for removeChildWithIndex' );

      var indexOfParent = _.indexOf( node._parents, this );

      // If this added subtree contains accessible content, we need to notify any relevant displays
      // NOTE: Potentially removes bounds listeners here!
      if ( !node._rendererSummary.isNotAccessible() ) {
        this.onAccessibleRemoveChild( node );
      }

      // needs to be early to prevent re-entrant children modifications
      this.changePickableCount( -node._subtreePickableCount );
      this.changeBoundsEventCount( node._boundsEventCount > 0 ? -1 : 0 );
      this._rendererSummary.summaryChange( node._rendererSummary.bitmask, RendererSummary.bitmaskAll );

      node._parents.splice( indexOfParent, 1 );
      this._children.splice( indexOfChild, 1 );

      this.invalidateBounds();
      this._childBoundsDirty = true; // force recomputation of child bounds after removing a child

      this.trigger2( 'childRemoved', node, indexOfChild );
    },

    /**
     * Removes all children from this Node.
     * @public
     */
    removeAllChildren: function() {
      this.setChildren( [] );

      return this; // allow chaining
    },

    /**
     * Sets the children of the Node to be equivalent to the passed-in array of Nodes. Does this by removing all current
     * children, and adding in children from the array.
     * @public
     *
     * @param {Array.<Node>} children
     */
    setChildren: function( children ) {
      if ( this._children !== children ) {
        // remove all children in a way where we don't have to copy the child array for safety
        while ( this._children.length ) {
          this.removeChild( this._children[ this._children.length - 1 ] );
        }

        var len = children.length;
        for ( var i = 0; i < len; i++ ) {
          this.addChild( children[ i ] );
        }
      }

      return this; // allow chaining
    },
    set children( value ) { this.setChildren( value ); },

    /**
     * Returns a defensive copy of our children.
     * @public
     *
     * @returns {Array.<Node>}
     */
    getChildren: function() {
      // TODO: ensure we are not triggering this in Scenery code when not necessary!
      return this._children.slice( 0 ); // create a defensive copy
    },
    get children() { return this.getChildren(); },

    /**
     * Returns a count of children, without needing to make a defensive copy.
     * @public
     *
     * @returns {number}
     */
    getChildrenCount: function() {
      return this._children.length;
    },

    /**
     * Returns a defensive copy of our parents.
     * @public
     *
     * @returns {Array.<Node>}
     */
    getParents: function() {
      return this._parents.slice( 0 ); // create a defensive copy
    },
    get parents() { return this.getParents(); },

    /**
     * Returns a single parent if it exists, otherwise null (no parents), or an assertion failure (multiple parents).
     * @public
     *
     * @returns {Node|null}
     */
    getParent: function() {
      assert && assert( this._parents.length <= 1, 'Cannot call getParent on a node with multiple parents' );
      return this._parents.length ? this._parents[ 0 ] : null;
    },

    /**
     * Gets the child at a specific index into the children array.
     * @public
     *
     * @param {number} index
     * @returns {Node}
     */
    getChildAt: function( index ) {
      return this._children[ index ];
    },

    /**
     * Finds the index of a parent Node in the parents array.
     * @public
     *
     * @param {Node} parent - Should be a parent of this node.
     * @returns {number} - An index such that this.parents[ index ] === parent
     */
    indexOfParent: function( parent ) {
      return _.indexOf( this._parents, parent );
    },

    /**
     * Finds the index of a child Node in the children array.
     * @public
     *
     * @param {Node} child - Should be a child of this node.
     * @returns {number} - An index such that this.children[ index ] === child
     */
    indexOfChild: function( child ) {
      return _.indexOf( this._children, child );
    },

    /**
     * Moves this node to the front (end) of all of its parents children array.
     * @public
     */
    moveToFront: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.moveChildToFront( self );
      } );

      return this; // allow chaining
    },

    /**
     * Moves one of our children to the front (end) of our children array.
     * @public
     *
     * @param {Node} child - Our child to move to the front.
     */
    moveChildToFront: function( child ) {
      if ( this.indexOfChild( child ) !== this._children.length - 1 ) {
        this.removeChild( child );
        this.addChild( child );
      }

      return this; // allow chaining
    },

    /**
     * Moves this node to the back (front) of all of its parents children array.
     * @public
     */
    moveToBack: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.moveChildToBack( self );
      } );

      return this; // allow chaining
    },

    /**
     * Moves one of our children to the back (front) of our children array.
     * @public
     *
     * @param {Node} child - Our child to move to the back.
     */
    moveChildToBack: function( child ) {
      if ( this.indexOfChild( child ) !== 0 ) {
        this.removeChild( child );
        this.insertChild( 0, child );
      }

      return this; // allow chaining
    },

    /**
     * Removes this node from all of its parents.
     * @public
     */
    detach: function() {
      var that = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.removeChild( that );
      } );

      return this; // allow chaining
    },

    /**
     * Propagate the pickable count change down to our ancestors.
     * @private (Scenery-internal)
     *
     * @param {number} n - The delta of how many pickable counts have been added/removed
     */
    changePickableCount: function( n ) {
      this._subtreePickableCount += n;
      assert && assert( this._subtreePickableCount >= 0, 'subtree pickable count should be guaranteed to be >= 0' );
      var len = this._parents.length;
      for ( var i = 0; i < len; i++ ) {
        this._parents[ i ].changePickableCount( n );
      }

      // changing pickability can affect the mouseBounds/touchBounds used for hit testing
      this.invalidateMouseTouchBounds();
    },

    /**
     * Update our event count, usually by 1 or -1. See documentation on _boundsEventCount in constructor.
     * @private
     *
     * @param {number} n - How to increment/decrement the bounds event listener count
     */
    changeBoundsEventCount: function( n ) {
      if ( n !== 0 ) {
        var zeroBefore = this._boundsEventCount === 0;

        this._boundsEventCount += n;
        assert && assert( this._boundsEventCount >= 0, 'subtree bounds event count should be guaranteed to be >= 0' );

        var zeroAfter = this._boundsEventCount === 0;

        if ( zeroBefore !== zeroAfter ) {
          // parents will only have their count
          var parentDelta = zeroBefore ? 1 : -1;

          var len = this._parents.length;
          for ( var i = 0; i < len; i++ ) {
            this._parents[ i ].changeBoundsEventCount( parentDelta );
          }
        }
      }
    },

    /**
     * @deprecated?
     * currently, there is no way to remove peers. if a string is passed as the element pattern, it will be turned into
     * an element
     */
    addPeer: function( element, options ) {
      assert && assert( !this.instances.length, 'Cannot call addPeer after a node has instances (yet)' );

      this._peers.push( { element: element, options: options } );
    },

    /**
     * @param property any object that has es5 getter for 'value' es5 setter for value, and
     */
    addLiveRegion: function( property, options ) {
      this._liveRegions.push( { property: property, options: options } );
    },

    /**
     * Ensures that the cached _selfBounds of this node is accurate. Returns true if any sort of dirty flag was set
     * before this was called.
     * @public
     *
     * @returns {boolean} - Was the self-bounds potentially updated?
     */
    validateSelfBounds: function() {
      // validate bounds of ourself if necessary
      if ( this._selfBoundsDirty ) {
        // Rely on an overloadable method to accomplish computing our self bounds. This should update
        // this._selfBounds itself, returning whether it was actually changed. If it didn't change, we don't want to
        // send a 'selfBounds' event.
        var didSelfBoundsChange = this.updateSelfBounds();
        this._selfBoundsDirty = false;

        if ( didSelfBoundsChange ) {
          this.trigger0( 'selfBounds' );
        }

        return true;
      }

      return false;
    },

    /**
     * Ensures that cached bounds stored on this node (and all children) are accurate. Returns true if any sort of dirty
     * flag was set before this was called.
     * @public
     *
     * @returns {boolean} - Was something potentially updated?
     */
    validateBounds: function() {
      var that = this;
      var i;

      var wasDirtyBefore = this.validateSelfBounds();

      // validate bounds of children if necessary
      if ( this._childBoundsDirty ) {
        wasDirtyBefore = true;

        // have each child validate their own bounds
        i = this._children.length;
        while ( i-- ) {
          this._children[ i ].validateBounds();
        }

        // and recompute our _childBounds
        var oldChildBounds = scratchBounds2.set( this._childBounds ); // store old value in a temporary Bounds2
        this._childBounds.set( Bounds2.NOTHING ); // initialize to a value that can be unioned with includeBounds()

        i = this._children.length;
        while ( i-- ) {
          this._childBounds.includeBounds( this._children[ i ]._bounds );
        }

        // run this before firing the event
        this._childBoundsDirty = false;

        if ( !this._childBounds.equals( oldChildBounds ) ) {
          // notifies only on an actual change
          this.trigger0( 'childBounds' );
        }
      }

      if ( this._localBoundsDirty && !this._localBoundsOverridden ) {
        wasDirtyBefore = true;

        this._localBoundsDirty = false; // we only need this to set local bounds as dirty

        var oldLocalBounds = scratchBounds2.set( this._localBounds ); // store old value in a temporary Bounds2

        // local bounds are a union between our self bounds and child bounds
        this._localBounds.set( this._selfBounds ).includeBounds( this._childBounds );

        // apply clipping to the bounds if we have a clip area (all done in the local coordinate frame)
        if ( this.hasClipArea() ) {
          this._localBounds.constrainBounds( this._clipArea.bounds );
        }

        if ( !this._localBounds.equals( oldLocalBounds ) ) {
          this.trigger0( 'localBounds' );

          // sanity check
          this._boundsDirty = true;
        }

        // adjust our transform to match maximum bounds if necessary on a local bounds change
        if ( this._maxWidth !== null || this._maxHeight !== null ) {
          this.updateMaxDimension( this._localBounds );
        }
      }

      // TODO: layout here?

      if ( this._boundsDirty ) {
        wasDirtyBefore = true;

        // run this before firing the event
        this._boundsDirty = false;

        var oldBounds = scratchBounds2.set( this._bounds ); // store old value in a temporary Bounds2

        // no need to do the more expensive bounds transformation if we are still axis-aligned
        if ( this._transformBounds && !this._transform.getMatrix().isAxisAligned() ) {
          // mutates the matrix and bounds during recursion

          var matrix = scratchMatrix3.set( this.getMatrix() ); // calls below mutate this matrix
          this._bounds.set( Bounds2.NOTHING );
          // Include each painted self individually, transformed with the exact transform matrix.
          // This is expensive, as we have to do 2 matrix transforms for every descendant.
          this._includeTransformedSubtreeBounds( matrix, this._bounds ); // self and children

          if ( this.hasClipArea() ) {
            this._bounds.constrainBounds( this._clipArea.getBoundsWithTransform( matrix ) );
          }
        }
        else {
          // converts local to parent bounds. mutable methods used to minimize number of created bounds instances
          // (we create one so we don't change references to the old one)
          this._bounds.set( this._localBounds );
          this.transformBoundsFromLocalToParent( this._bounds );
        }

        if ( !this._bounds.equals( oldBounds ) ) {
          // if we have a bounds change, we need to invalidate our parents so they can be recomputed
          i = this._parents.length;
          while ( i-- ) {
            this._parents[ i ].invalidateBounds();
          }

          // TODO: consider changing to parameter object (that may be a problem for the GC overhead)
          this.trigger0( 'bounds' );
        }
      }

      // if there were side-effects, run the validation again until we are clean
      if ( this._childBoundsDirty || this._boundsDirty ) {
        // TODO: if there are side-effects in listeners, this could overflow the stack. we should report an error
        // instead of locking up
        this.validateBounds();
      }

      if ( assert ) {
        assert( this._originalBounds === this._bounds, 'Reference for _bounds changed!' );
        assert( this._originalLocalBounds === this._localBounds, 'Reference for _localBounds changed!' );
        assert( this._originalSelfBounds === this._selfBounds, 'Reference for _selfBounds changed!' );
        assert( this._originalChildBounds === this._childBounds, 'Reference for _childBounds changed!' );
      }

      // double-check that all of our bounds handling has been accurate
      if ( assertSlow ) {
        // new scope for safety
        (function() {
          var epsilon = 0.000001;

          var childBounds = Bounds2.NOTHING.copy();
          _.each( that._children, function( child ) { childBounds.includeBounds( child._bounds ); } );

          var localBounds = that._selfBounds.union( childBounds );

          if ( that.hasClipArea() ) {
            localBounds = localBounds.intersection( that._clipArea.bounds );
          }

          var fullBounds = that.localToParentBounds( localBounds );

          assertSlow && assertSlow( that._childBounds.equalsEpsilon( childBounds, epsilon ),
            'Child bounds mismatch after validateBounds: ' +
            that._childBounds.toString() + ', expected: ' + childBounds.toString() );
          assertSlow && assertSlow( that._localBoundsOverridden ||
                                    that._transformBounds ||
                                    that._bounds.equalsEpsilon( fullBounds, epsilon ) ||
                                    that._bounds.equalsEpsilon( fullBounds, epsilon ),
            'Bounds mismatch after validateBounds: ' + that._bounds.toString() +
            ', expected: ' + fullBounds.toString() );
        })();
      }

      return wasDirtyBefore; // whether any dirty flags were set
    },

    /**
     * Recursion for accurate transformed bounds handling. Mutates bounds with the added bounds.
     * Mutates the matrix (parameter), but mutates it back to the starting point (within floating-point error).
     * @private
     *
     * @param {Matrix3} matrix
     * @param {Bounds2} bounds
     */
    _includeTransformedSubtreeBounds: function( matrix, bounds ) {
      if ( !this.selfBounds.isEmpty() ) {
        bounds.includeBounds( this.getTransformedSelfBounds( matrix ) );
      }

      var numChildren = this._children.length;
      for ( var i = 0; i < numChildren; i++ ) {
        var child = this._children[ i ];

        matrix.multiplyMatrix( child._transform.getMatrix() );
        child._includeTransformedSubtreeBounds( matrix, bounds );
        matrix.multiplyMatrix( child._transform.getInverse() );
      }

      return bounds;
    },

    /**
     * Traverses this subtree and validates bounds only for subtrees that have bounds listeners (trying to exclude as
     * much as possible for performance). This is done so that we can do the minimum bounds validation to prevent any
     * bounds listeners from being triggered in further validateBounds() calls without other Node changes being done.
     * This is required for Display's atomic (non-reentrant) updateDisplay(), so that we don't accidentally trigger
     * bounds listeners while computing bounds during updateDisplay().
     * @public (scenery-internal)
     *
     * NOTE: this should pass by (ignore) any overridden localBounds, to trigger listeners below.
     */
    validateWatchedBounds: function() {
      // Since a bounds listener on one of the roots could invalidate bounds on the other, we need to keep running this
      // until they are all clean. Otherwise, side-effects could occur from bounds validations
      // TODO: consider a way to prevent infinite loops here that occur due to bounds listeners triggering cycles
      while ( this.watchedBoundsScan() ) {
        // do nothing
      }
    },

    /**
     * Recursive function for validateWatchedBounds. Returned whether any validateBounds() returned true (means we have
     * to traverse again)
     * @public (scenery-internal)
     *
     * @returns {boolean} - Whether there could have been any changes.
     */
    watchedBoundsScan: function() {
      if ( this._boundsEventSelfCount !== 0 ) {
        // we are a root that should be validated. return whether we updated anything
        return this.validateBounds();
      }
      else if ( this._boundsEventCount > 0 && this._childBoundsDirty ) {
        // descendants have watched bounds, traverse!
        var changed = false;
        var numChildren = this._children.length;
        for ( var i = 0; i < numChildren; i++ ) {
          changed = this._children[ i ].watchedBoundsScan() || changed;
        }
        return changed;
      }
      else {
        // if _boundsEventCount is zero, no bounds are watched below us (don't traverse), and it wasn't changed
        return false;
      }
    },

    /*
     * Updates the mouseBounds for the Node. It will include only the specific bounded areas that are relevant for
     * hit-testing mouse events. Thus it:
     * - includes mouseAreas (normal bounds don't)
     * - does not include subtrees that would be pruned in hit-testing
     * @public (scenery-internal)
     */
    validateMouseBounds: function( hasListenerEquivalentSelfOrInAncestor ) {
      var that = this;

      // we'll need an updated value for this before deciding whether or not to bail
      hasListenerEquivalentSelfOrInAncestor = hasListenerEquivalentSelfOrInAncestor || this.hasInputListenerEquivalent();

      // Mouse bounds should be valid still if they aren't marked as dirty AND if the "had listener" matches.
      // Thus, even if the mouse bounds aren't marked as dirty, we can still force a refresh (for example: an input listener was added to an ancestor)
      if ( this._mouseBoundsDirty || this._mouseBoundsHadListener !== hasListenerEquivalentSelfOrInAncestor ) {
        // update whether we have a listener equivalent, so we can prune properly

        if ( this.isSubtreePickablePruned( hasListenerEquivalentSelfOrInAncestor ) ) {
          // if this subtree would be pruned, set the mouse bounds to nothing, and bail (skips the entire subtree, since it would never be hit-tested)
          this._mouseBounds.set( Bounds2.NOTHING );
        }
        else {
          // start with the self bounds, then add from there
          this._mouseBounds.set( this.selfBounds );

          // union of all children's mouse bounds
          var i = this._children.length;
          while ( i-- ) {
            var child = this._children[ i ];

            // make sure the child's mouseBounds are up to date
            child.validateMouseBounds( hasListenerEquivalentSelfOrInAncestor );
            that._mouseBounds.includeBounds( child._mouseBounds );
          }

          // do this before the transformation to the parent coordinate frame (the mouseArea is in the local coordinate frame)
          if ( this._mouseArea ) {
            // we accept either Bounds2, or a Shape (in which case, we take the Shape's bounds)
            this._mouseBounds.includeBounds( this._mouseArea.isBounds ? this._mouseArea : this._mouseArea.bounds );
          }

          if ( this.hasClipArea() ) {
            // exclude areas outside of the clipping area's bounds (for efficiency)
            this._mouseBounds.constrainBounds( this._clipArea.bounds );
          }

          // transform it to the parent coordinate frame
          this.transformBoundsFromLocalToParent( this._mouseBounds );
        }

        // update the "dirty" flags
        this._mouseBoundsDirty = false;
        this._mouseBoundsHadListener = hasListenerEquivalentSelfOrInAncestor;
      }
    },

    /*
     * Updates the touchBounds for the Node. It will include only the specific bounded areas that are relevant for hit-testing
     * touch events. Thus it:
     * - includes touchAreas (normal bounds don't)
     * - does not include subtrees that would be pruned in hit-testing
     * @public (scenery-internal)
     */
    validateTouchBounds: function( hasListenerEquivalentSelfOrInAncestor ) {
      var that = this;

      // we'll need an updated value for this before deciding whether or not to bail
      hasListenerEquivalentSelfOrInAncestor = hasListenerEquivalentSelfOrInAncestor || this.hasInputListenerEquivalent();

      // Touch bounds should be valid still if they aren't marked as dirty AND if the "had listener" matches.
      // Thus, even if the touch bounds aren't marked as dirty, we can still force a refresh (for example: an input listener was added to an ancestor)
      if ( this._touchBoundsDirty || this._touchBoundsHadListener !== hasListenerEquivalentSelfOrInAncestor ) {
        // update whether we have a listener equivalent, so we can prune properly

        if ( this.isSubtreePickablePruned( hasListenerEquivalentSelfOrInAncestor ) ) {
          // if this subtree would be pruned, set the touch bounds to nothing, and bail (skips the entire subtree, since it would never be hit-tested)
          this._touchBounds.set( Bounds2.NOTHING );
        }
        else {
          // start with the self bounds, then add from there
          this._touchBounds.set( this.selfBounds );

          // union of all children's touch bounds
          var i = this._children.length;
          while ( i-- ) {
            var child = this._children[ i ];

            // make sure the child's touchBounds are up to date
            child.validateTouchBounds( hasListenerEquivalentSelfOrInAncestor );
            that._touchBounds.includeBounds( child._touchBounds );
          }

          // do this before the transformation to the parent coordinate frame (the touchArea is in the local coordinate frame)
          if ( this._touchArea ) {
            // we accept either Bounds2, or a Shape (in which case, we take the Shape's bounds)
            this._touchBounds.includeBounds( this._touchArea.isBounds ? this._touchArea : this._touchArea.bounds );
          }

          if ( this.hasClipArea() ) {
            // exclude areas outside of the clipping area's bounds (for efficiency)
            this._touchBounds.constrainBounds( this._clipArea.bounds );
          }

          // transform it to the parent coordinate frame
          this.transformBoundsFromLocalToParent( this._touchBounds );
        }

        // update the "dirty" flags
        this._touchBoundsDirty = false;
        this._touchBoundsHadListener = hasListenerEquivalentSelfOrInAncestor;
      }
    },

    /**
     * Marks the bounds of this node as invalid, so they are recomputed before being accessed again.
     * @public
     */
    invalidateBounds: function() {
      // TODO: sometimes we won't need to invalidate local bounds! it's not too much of a hassle though?
      this._boundsDirty = true;
      this._localBoundsDirty = true;
      this._mouseBoundsDirty = true;
      this._touchBoundsDirty = true;

      // and set flags for all ancestors
      var i = this._parents.length;
      while ( i-- ) {
        this._parents[ i ].invalidateChildBounds();
      }

      // TODO: consider calling invalidateMouseTouchBounds from here? it would mean two traversals, but it may bail out sooner. Hard call.
    },

    /**
     * Recursively tag all ancestors with _childBoundsDirty
     * @public (scenery-internal)
     */
    invalidateChildBounds: function() {
      // don't bother updating if we've already been tagged
      if ( !this._childBoundsDirty || !this._mouseBoundsDirty || !this._touchBoundsDirty ) {
        this._childBoundsDirty = true;
        this._localBoundsDirty = true;
        this._mouseBoundsDirty = true;
        this._touchBoundsDirty = true;
        var i = this._parents.length;
        while ( i-- ) {
          this._parents[ i ].invalidateChildBounds();
        }
      }
    },

    /**
     * Mark mouse/touch bounds as invalid (can occur from normal bounds invalidation, or from anything that could change
     * pickability).
     * @public (scenery-internal)
     *
     * NOTE: we don't have to touch descendants because we also store the last used "under effective listener" value, so
     * "non-dirty" subtrees will still be investigated (or freshly pruned) if the listener status has changed.
     */
    invalidateMouseTouchBounds: function() {
      if ( !this._mouseBoundsDirty || !this._touchBoundsDirty ) {
        this._mouseBoundsDirty = true;
        this._touchBoundsDirty = true;
        var i = this._parents.length;
        while ( i-- ) {
          this._parents[ i ].invalidateMouseTouchBounds();
        }
      }
    },

    /**
     * Should be called to notify that our selfBounds needs to change to this new value.
     * @public
     *
     * @param {Bounds2} newSelfBounds
     */
    invalidateSelf: function( newSelfBounds ) {
      // If no self bounds are provided, rely on the bounds validation to trigger computation (using updateSelfBounds()).
      if ( !newSelfBounds ) {
        this._selfBoundsDirty = true;
        this.invalidateBounds();
      }
      // Otherwise, set the self bounds directly
      else {
        assert && assert( newSelfBounds.isEmpty() || newSelfBounds.isFinite(), 'Bounds must be empty or finite in invalidateSelf' );

        // Don't recompute the self bounds
        this._selfBoundsDirty = false;

        // if these bounds are different than current self bounds
        if ( !this._selfBounds.equals( newSelfBounds ) ) {
          // set repaint flags
          this.invalidateBounds();

          // record the new bounds
          this._selfBounds.set( newSelfBounds );

          // fire the event immediately
          this.trigger0( 'selfBounds' );
        }
      }
    },

    /**
     * Meant to be overridden by Node sub-types to compute self bounds (if invalidateSelf() with no argments was called).
     * @protected
     *
     * @returns {boolean} - Whether the self bounds changed.
     */
    updateSelfBounds: function() {
      // The Node implementation (un-overridden) will never change the self bounds (always NOTHING).
      assert && assert( this._selfBounds.equals( Bounds2.NOTHING ) );
      return false;
    },

    /**
     * Returns whether a Node is a child of this node.
     * @public
     *
     * @param {Node} potentialChild
     * @returns {boolean} - Whether potentialChild is actually our child.
     */
    hasChild: function( potentialChild ) {
      assert && assert( potentialChild && ( potentialChild instanceof Node ), 'hasChild needs to be called with a Node' );
      var ourChild = _.contains( this._children, potentialChild );
      var itsParent = _.contains( potentialChild._parents, this );
      assert && assert( ourChild === itsParent );
      return ourChild;
    },

    /**
     * Returns our selfBounds (the bounds for this Node's content in the local coordinates, excluding anything from our
     * children and descendants).
     * @public
     *
     * NOTE: Do NOT mutate the returned value!
     *
     * @returns {Bounds2}
     */
    getSelfBounds: function() {
      this.validateSelfBounds();
      return this._selfBounds;
    },
    get selfBounds() { return this.getSelfBounds(); },

    /**
     * Returns a bounding box that should contain all self content in the local coordinate frame (our normal self bounds
     * aren't guaranteed this for Text, etc.)
     * @public
     *
     * Override this to provide different behavior.
     *
     * @returns {Bounds2}
     */
    getSafeSelfBounds: function() {
      this.validateSelfBounds();
      return this._selfBounds;
    },

    /**
     * Returns the bounding box that should contain all content of our children in our local coordinate frame. Does not
     * include our "self" bounds.
     * @public
     *
     * NOTE: Do NOT mutate the returned value!
     *
     * @returns {Bounds2}
     */
    getChildBounds: function() {
      this.validateBounds();
      return this._childBounds;
    },
    get childBounds() { return this.getChildBounds(); },

    /**
     * Returns the bounding box that should contain all content of our children AND our self in our local coordinate
     * frame.
     * @public
     *
     * NOTE: Do NOT mutate the returned value!
     *
     * @returns {Bounds2}
     */
    getLocalBounds: function() {
      this.validateBounds();
      return this._localBounds;
    },
    get localBounds() { return this.getLocalBounds(); },

    /**
     * Allows overriding the value of localBounds (and thus changing things like 'bounds' that depend on localBounds).
     * If it's set to a non-null value, that value will always be used for localBounds until this function is called
     * again. To revert to having Scenery compute the localBounds, set this to null.
     * @public
     *
     * @param {Bounds2|null} localBounds
     */
    setLocalBounds: function( localBounds ) {
      assert && assert( localBounds === null || localBounds instanceof Bounds2, 'localBounds override should be set to either null or a Bounds2' );

      if ( localBounds === null ) {
        // we can just ignore this if we weren't actually overriding local bounds before
        if ( this._localBoundsOverridden ) {
          this._localBoundsOverridden = false;
          this.trigger1( 'localBoundsOverride', false );
          this.invalidateBounds();
        }
      }
      else {
        // just an instance check for now. consider equals() in the future depending on cost
        var changed = !localBounds.equals( this._localBounds ) || !this._localBoundsOverridden;

        if ( changed ) {
          this._localBounds.set( localBounds );
        }

        if ( !this._localBoundsOverridden ) {
          this._localBoundsOverridden = true; // NOTE: has to be done before invalidating bounds, since this disables localBounds computation
          this.trigger1( 'localBoundsOverride', true );
        }

        if ( changed ) {
          this.invalidateBounds();
        }
      }

      return this; // allow chaining
    },
    set localBounds( value ) { return this.setLocalBounds( value ); },

    /**
     * Meant to be overridden in sub-types that have more accurate bounds determination for when we are transformed.
     * Usually rotation is significant here, so that transformed bounds for non-rectangular shapes will be different.
     * @public
     *
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    getTransformedSelfBounds: function( matrix ) {
      this.validateBounds(); // TODO: consider more fine-grained validation?
      // assume that we take up the entire rectangular bounds.
      return this._selfBounds.transformed( matrix );
    },

    /**
     * Sets the flag that determines whether we will require more accurate (and expensive) bounds computation for this
     * node's transform.
     * @public
     *
     * If set to false (default), Scenery will get the bounds of content, and then if rotated will determine the on-axis
     * bounds that completely cover the rotated bounds (potentially larger than actual content).
     * If set to true, Scenery will try to get the bounds of the actual rotated/transformed content.
     *
     * A good example of when this is necessary is if there are a bunch of nested children that each have pi/4 rotations.
     *
     * @param {boolean} transformBounds - Whether accurate transform bounds should be used.
     */
    setTransformBounds: function( transformBounds ) {
      assert && assert( typeof transformBounds === 'boolean', 'transformBounds should be boolean' );

      if ( this._transformBounds !== transformBounds ) {
        this._transformBounds = transformBounds;

        this.invalidateBounds();
      }

      return this; // allow chaining
    },
    set transformBounds( value ) { return this.setTransformBounds( value ); },

    /**
     * Returns whether accurate transformation bounds are used in bounds computation (see setTransformBounds).
     * @public
     *
     * @returns {boolean}
     */
    getTransformBounds: function() {
      return this._transformBounds;
    },
    get transformBounds() { return this.getTransformBounds(); },

    /**
     * Returns the bounding box of this Node and all of its sub-trees (in the "parent" coordinate frame).
     *
     * NOTE: Do NOT mutate the returned value!
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      this.validateBounds();
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    /**
     * Like getLocalBounds() in the "local" coordinate frame, but includes only visible nodes.
     * @public
     *
     * @returns {Bounds2}
     */
    getVisibleLocalBounds: function() {
      // defensive copy, since we use mutable modifications below
      var bounds = this.selfBounds.copy();

      var i = this._children.length;
      while ( i-- ) {
        var child = this._children[ i ];
        if ( child.isVisible() ) {
          bounds.includeBounds( child.getVisibleBounds() );
        }
      }

      assert && assert( bounds.isFinite() || bounds.isEmpty(), 'Visible bounds should not be infinite' );
      return bounds;
    },
    get visibleLocalBounds() { return this.getVisibleLocalBounds(); },

    /**
     * Like getBounds() in the "parent" coordinate frame, but includes only visible nodes
     * @public
     *
     * @returns {Bounds2}
     */
    getVisibleBounds: function() {
      return this.getVisibleLocalBounds().transform( this.getMatrix() );
    },
    get visibleBounds() { return this.getVisibleBounds(); },

    /**
     * Whether this node effectively behaves as if it has an input listener.
     * @public (scenery-internal)
     *
     * @returns {boolean}
     */
    hasInputListenerEquivalent: function() {
      // NOTE: if anything here is added, update when invalidateMouseTouchBounds gets called (since changes to pickability pruning affect mouse/touch bounds)
      return this._inputListeners.length > 0 || this._pickable === true;
    },

    /**
     * Whether hit-testing for events should be pruned at this node (not even considering this node's self).
     * @public (scenery-internal)
     *
     * @param {boolean} hasListenerEquivalentSelfOrInAncestor - Indicates whether this node (or an ancestor) either has
     *                                                          input listeners, or has pickable set to true (which is
     *                                                          not the default).
     * @returns {boolean}
     */
    //
    //
    isSubtreePickablePruned: function( hasListenerEquivalentSelfOrInAncestor ) {
      // NOTE: if anything here is added, update when invalidateMouseTouchBounds gets called (since changes to pickability pruning affect mouse/touch bounds)
      // if invisible: skip it
      // if pickable: false, skip it
      // if pickable: undefined and our pickable count indicates there are no input listeners / pickable: true in our subtree, skip it
      return !this.isVisible() || this._pickable === false || ( this._pickable !== true && !hasListenerEquivalentSelfOrInAncestor && this._subtreePickableCount === 0 );
    },

    /**
     * Hit-tests what is under the pointer, and returns a {Trail} to that node (or null if there is no matching node).
     * @public
     *
     * @param {Pointer} pointer
     * @returns {Trail|null}
     */
    trailUnderPointer: function( pointer ) {
      // grab our global reference. this isn't re-entrant, and we don't want to cause allocations here
      var options = trailUnderPointerOptions;

      options.isMouse = !!pointer.isMouse;
      options.isTouch = !!pointer.isTouch;
      options.isPen = !!pointer.isPen;

      return this.trailUnderPoint( pointer.point, options );
    },

    /*
     * Return a trail to the top node (if any, otherwise null) whose self-rendered area contains the
     * point (in parent coordinates).
     * @public
     *
     * For now, prune anything that is invisible or effectively unpickable
     *
     * @param {Vector2} point
     * @param {Object} options - Checks for options.isMouse/isTouch/isPen currently
     * @param {boolean} [recursive] - Don't pass when calling, signals that the point passed can be mutated
     * @param {boolean} [hasListenerEquivalentSelfOrInAncestor] - Don't pass when calling, used for recursion
     * @returns {Trail|null}
     */
    trailUnderPoint: function( point, options, recursive, hasListenerEquivalentSelfOrInAncestor ) {
      assert && assert( point, 'trailUnderPointer requires a point' );

      hasListenerEquivalentSelfOrInAncestor = hasListenerEquivalentSelfOrInAncestor || this.hasInputListenerEquivalent();

      // prune if possible (usually invisible, pickable:false, no input listeners that would be triggered by this node or anything under it, etc.)
      if ( this.isSubtreePickablePruned( hasListenerEquivalentSelfOrInAncestor ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.constructor.name + '#' + this.id + ' isSubtreePickablePruned(' + hasListenerEquivalentSelfOrInAncestor + ')' );
        return null;
      }

      // TODO: consider changing the trailUnderPoint API so that these are fixed (and add an option to override trailUnderPoint handling, like in BAM)
      var useMouseAreas = options && options.isMouse;
      var useTouchAreas = options && ( options.isTouch || options.isPen );

      var pruningBounds;
      // only validate the needed type of bounds. definitely don't do a full 'validateBounds' when testing mouse/touch, since there are large pruned areas,
      // and we want to avoid computing bounds where not needed (think something that is animated and expensive to compute)
      if ( useMouseAreas ) {
        !recursive && this.validateMouseBounds( false ); // update mouse bounds for pruning if we aren't being called from trailUnderPoint (ourself)
        pruningBounds = this._mouseBounds;
      }
      else if ( useTouchAreas ) {
        !recursive && this.validateTouchBounds( false ); // update touch bounds for pruning if we aren't being called from trailUnderPoint (ourself)
        pruningBounds = this._touchBounds;
      }
      else {
        !recursive && this.validateBounds(); // update general bounds for pruning if we aren't being called from trailUnderPoint (ourself)
        pruningBounds = this._bounds;
      }

      // bail quickly if this doesn't hit our computed bounds
      if ( !pruningBounds.containsPoint( point ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.constructor.name + '#' + this.id + ' pruned: ' + ( useMouseAreas ? 'mouse' : ( useTouchAreas ? 'touch' : 'regular' ) ) );
        return null; // not in our bounds, so this point can't possibly be contained
      }

      // temporary result variable, since it's easier to do this way to free the computed point
      var result = null;

      // point in the local coordinate frame. computed after the main bounds check, so we can bail out there efficiently
      var localPoint = this._transform.getInverse().multiplyVector2( Vector2.createFromPool( point.x, point.y ) );
      // var localPoint = this.parentToLocalPoint( point );

      // if our point is outside of the local-coordinate clipping area, we shouldn't return a hit
      if ( this.hasClipArea() && !this._clipArea.containsPoint( localPoint ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.constructor.name + '#' + this.id + ' out of clip area' );
        return null;
      }

      sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.constructor.name + '#' + this.id );

      // check children first, since they are rendered later. don't bother checking childBounds, we usually are using mouse/touch.
      // manual iteration here so we can return directly, and so we can iterate backwards (last node is in front)
      for ( var i = this._children.length - 1; i >= 0; i-- ) {
        var child = this._children[ i ];

        sceneryLog && sceneryLog.hitTest && sceneryLog.push();
        var childHit = child.trailUnderPoint( localPoint, options, true, hasListenerEquivalentSelfOrInAncestor );
        sceneryLog && sceneryLog.hitTest && sceneryLog.pop();

        // the child will have the point in its parent's coordinate frame (i.e. this node's frame)
        if ( childHit ) {
          childHit.addAncestor( this, i );
          localPoint.freeToPool();
          return childHit;
        }
      }

      // tests for mouse and touch hit areas before testing containsPointSelf
      if ( useMouseAreas && this._mouseArea ) {
        // NOTE: both Bounds2 and Shape have containsPoint! We use both here!
        result = this._mouseArea.containsPoint( localPoint ) ? new scenery.Trail( this ) : null;
        localPoint.freeToPool();
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.constructor.name + '#' + this.id + ' mouse area hit' );
        return result;
      }
      if ( useTouchAreas && this._touchArea ) {
        // NOTE: both Bounds2 and Shape have containsPoint! We use both here!
        result = this._touchArea.containsPoint( localPoint ) ? new scenery.Trail( this ) : null;
        localPoint.freeToPool();
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.constructor.name + '#' + this.id + ' touch area hit' );
        return result;
      }

      // didn't hit our children, so check ourself as a last resort. check our selfBounds first, to avoid a potentially more expensive operation
      if ( this.selfBounds.containsPoint( localPoint ) ) {
        if ( this.containsPointSelf( localPoint ) ) {
          localPoint.freeToPool();
          sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.constructor.name + '#' + this.id + ' self hit' );
          return new scenery.Trail( this );
        }
      }

      // signal no hit
      localPoint.freeToPool();
      return null;
    },

    /**
     * Returns whether a point (in parent coordinates) is contained in this node's sub-tree.
     * @public
     *
     * @param {Vector2} point
     * @returns {boolean} - Whether the point is contained.
     */
    containsPoint: function( point ) {
      return this.trailUnderPoint( point ) !== null;
    },

    /**
     * Override this for computation of whether a point is inside our self content (defaults to selfBounds check).
     * @protected
     *
     * @param {Vector2} point - Considered to be in the local coordinate frame
     * @returns {boolean}
     */
    containsPointSelf: function( point ) {
      // if self bounds are not null default to checking self bounds
      return this.selfBounds.containsPoint( point );
    },

    /**
     * Returns whether this node's selfBounds is intersected by the specified bounds.
     * @public
     *
     * @param {Bounds2} bounds - Bounds to test, assumed to be in the local coordinate frame.
     * @returns {boolean}
     */
    intersectsBoundsSelf: function( bounds ) {
      // if self bounds are not null, child should override this
      return this.selfBounds.intersectsBounds( bounds );
    },

    /**
     * Whether this Node itself is painted (displays something itself). Meant to be overridden.
     * @public
     *
     * @returns {boolean}
     */
    isPainted: function() {
      return false;
    },

    /**
     * Whether this Node's selfBounds are considered to be valid (always containing the displayed self content
     * of this node). Meant to be overridden in subtypes when this can change (e.g. Text).
     * @public
     *
     * If this value would potentially change, please trigger the event 'selfBoundsValid'.
     *
     * @returns {boolean}
     */
    areSelfBoundsValid: function() {
      return true;
    },

    /**
     * Returns whether this node has any parents at all.
     * @public
     *
     * @returns {boolean}
     */
    hasParent: function() {
      return this._parents.length !== 0;
    },

    /**
     * Returns whether this node has any children at all.
     * @public
     *
     * @returns {boolean}
     */
    hasChildren: function() {
      return this._children.length > 0;
    },

    /**
     * Calls the callback on nodes recursively in a depth-first manner.
     * @public
     *
     * @param {Function} callback
     */
    walkDepthFirst: function( callback ) {
      callback( this );
      var length = this._children.length;
      for ( var i = 0; i < length; i++ ) {
        this._children[ i ].walkDepthFirst( callback );
      }
    },

    /**
     * Returns a list of child nodes that intersect the passed in bounds.
     * @public
     *
     * @param {Bounds2} bounds - In the local coordinate frame
     * @returns {Array.<Node>}
     */
    getChildrenWithinBounds: function( bounds ) {
      var result = [];
      var length = this._children.length;
      for ( var i = 0; i < length; i++ ) {
        var child = this._children[ i ];
        if ( !child._bounds.intersection( bounds ).isEmpty() ) {
          result.push( child );
        }
      }
      return result;
    },

    /**
     * Adds an input listener.
     * @public
     *
     * @param {Object} listener
     */
    addInputListener: function( listener ) {
      // don't allow listeners to be added multiple times
      if ( _.indexOf( this._inputListeners, listener ) === -1 ) {
        this._inputListeners.push( listener );
        this.changePickableCount( 1 ); // NOTE: this should also trigger invalidation of mouse/touch bounds
      }
      return this;
    },

    /**
     * Removes an input listener that was previously added with addInputListener.
     * @public
     *
     * @param {Object} listener
     */
    removeInputListener: function( listener ) {
      // ensure the listener is in our list
      assert && assert( _.indexOf( this._inputListeners, listener ) !== -1 );

      this._inputListeners.splice( _.indexOf( this._inputListeners, listener ), 1 );
      this.changePickableCount( -1 ); // NOTE: this should also trigger invalidation of mouse/touch bounds
      return this;
    },

    /**
     * Returns a copy of all of our input listeners.
     * @public
     *
     * @returns {Array.<Object>}
     */
    getInputListeners: function() {
      return this._inputListeners.slice( 0 ); // defensive copy
    },

    /**
     * Called when the node is added as a child to this node AND the node's subtree contains accessible content.
     * We need to notify all Displays that can see this change, so that they can update the AccessibleInstance tree.
     * @private
     *
     * @param {Node} node
     */
    onAccessibleAddChild: function( node ) {
      // All trails starting with nodes that have display roots, and ending with the added node.
      var trails = node.getTrails( hasRootedDisplayPredicate );
      for ( var i = 0; i < trails.length; i++ ) {
        var trail = trails[ i ];

        // Ignore trails where this node is not the child node's parent. See https://github.com/phetsims/scenery/issues/491
        if ( trail.nodeFromTop( 1 ) !== this ) {
          continue;
        }

        // Notify each Display of the trail
        var rootedDisplays = trail.rootNode()._rootedDisplays;
        for ( var j = 0; j < rootedDisplays.length; j++ ) {
          rootedDisplays[ j ].addAccessibleTrail( trail );
        }
      }
    },

    /**
     * Called when the node is removed as a child from this node AND the node's subtree contains accessible content.
     * We need to notify all Displays that can see this change, so that they can update the AccessibleInstance tree.
     * @private
     *
     * @param {Node} node
     */
    onAccessibleRemoveChild: function( node ) {
      // All trails starting with nodes that have display roots, and ending with the removed node.
      var trails = node.getTrails( hasRootedDisplayPredicate );
      for ( var i = 0; i < trails.length; i++ ) {
        var trail = trails[ i ];

        // Ignore trails where this node is not the child node's parent. See https://github.com/phetsims/scenery/issues/491
        if ( trail.nodeFromTop( 1 ) !== this ) {
          continue;
        }

        // Notify each Display of the trail
        var rootedDisplays = trail.rootNode()._rootedDisplays;
        for ( var j = 0; j < rootedDisplays.length; j++ ) {
          rootedDisplays[ j ].removeAccessibleTrail( trail );
        }
      }
    },

    /**
     * Changes the transform of this node by adding a transform. The default "appends" the transform, so that it will
     * appear to happen to the node before the rest of the transform would apply, but if "prepended", the rest of the
     * transform would apply first.
     * @public
     *
     * As an example, if a Node is centered at (0,0) and scaled by 2:
     * translate( 100, 0 ) would cause the center of the node (in the parent coordinate frame) to be at (200,0).
     * translate( 100, 0, true ) would cause the center of the node (in the parent coordinate frame) to be at (100,0).
     *
     * Allowed call signatures:
     * translate( x {number}, y {number} )
     * translate( x {number}, y {number}, prependInstead {boolean} )
     * translate( vector {Vector2} )
     * translate( vector {Vector2}, prependInstead {boolean} )
     *
     * @param {number} x - The x coordinate
     * @param {number} y - The y coordinate
     * @param {Vector2} vector - If present, the y coordinate (required if x is a number)
     * @param {boolean} [prependInstead] - Whether the transform should be prepended (defaults to false)
     */
    translate: function( x, y, prependInstead ) {
      if ( typeof x === 'number' ) {
        // translate( x, y, prependInstead )
        if ( !x && !y ) { return; } // bail out if both are zero
        if ( prependInstead ) {
          this.prependTranslation( x, y );
        }
        else {
          this.appendMatrix( Matrix3.translation( x, y ) );
        }
      }
      else {
        // translate( vector, prependInstead )
        var vector = x;
        if ( !vector.x && !vector.y ) { return; } // bail out if both are zero
        this.translate( vector.x, vector.y, y ); // forward to full version
      }
    },

    /**
     * Scales the node's transform. The default "appends" the transform, so that it will
     * appear to happen to the node before the rest of the transform would apply, but if "prepended", the rest of the
     * transform would apply first.
     * @public
     *
     * As an example, if a Node is translated to (100,0):
     * scale( 2 ) will leave the node translated at (100,0), but it will be twice as big around its origin at that location.
     * scale( 2, true ) will shift the node to (200,0).
     *
     * Allowed call signatures:
     * scale( s {number} )
     * scale( s {number}, prependInstead {boolean} )
     * scale( sx {number}, sy {number} )
     * scale( sx {number}, sy {number}, prependInstead {boolean} )
     *
     * @param {number} s - Scales in both the X and Y directions
     * @param {number} sx - Scales in the X direction
     * @param {number} sy - Scales in the Y direction
     * @param {boolean} [prependInstead] - Whether the transform should be prepended (defaults to false)
     */
    scale: function( x, y, prependInstead ) {
      if ( typeof x === 'number' ) {
        if ( y === undefined ) {
          // scale( scale )
          if ( x === 1 ) { return; } // bail out if we are scaling by 1 (identity)
          this.appendMatrix( Matrix3.scaling( x, x ) );
        }
        else {
          // scale( x, y, prependInstead )
          if ( x === 1 && y === 1 ) { return; } // bail out if we are scaling by 1 (identity)
          if ( prependInstead ) {
            this.prependMatrix( Matrix3.scaling( x, y ) );
          }
          else {
            this.appendMatrix( Matrix3.scaling( x, y ) );
          }
        }
      }
      else {
        // scale( vector, prependInstead ) or scale( { x: x, y: y }, prependInstead )
        var vector = x;
        this.scale( vector.x, vector.y, y ); // forward to full version
      }
    },

    /**
     * Rotates the node's transform. The default "appends" the transform, so that it will
     * appear to happen to the node before the rest of the transform would apply, but if "prepended", the rest of the
     * transform would apply first.
     * @public
     *
     * As an example, if a Node is translated to (100,0):
     * rotate( Math.PI ) will rotate the node around (100,0)
     * rotate( Math.PI, true ) will rotate the node around the origin, moving it to (-100,0)
     *
     * @param {number} angle - The angle (in radians) to rotate by
     * @param {boolean} [prependInstead] - Whether the transform should be prepended (defaults to false)
     */
    rotate: function( angle, prependInstead ) {
      if ( angle % ( 2 * Math.PI ) === 0 ) { return; } // bail out if our angle is effectively 0
      if ( prependInstead ) {
        this.prependMatrix( Matrix3.rotation2( angle ) );
      }
      else {
        this.appendMatrix( Matrix3.rotation2( angle ) );
      }
    },

    /**
     * Rotates the node's transform around a specific point (in the parent coordinate frame) by prepending the transform.
     * @public
     *
     * @param {Vector2} point - In the parent coordinate frame
     * @param {number} angle - In radians
     *
     * TODO: determine whether this should use the appendMatrix method
     */
    rotateAround: function( point, angle ) {
      var matrix = Matrix3.translation( -point.x, -point.y );
      matrix = Matrix3.rotation2( angle ).timesMatrix( matrix );
      matrix = Matrix3.translation( point.x, point.y ).timesMatrix( matrix );
      this.prependMatrix( matrix );
    },

    /**
     * Shifts the x coordinate (in the parent coordinate frame) of where the node's origin is transformed to.
     * @public
     *
     * @param {number} x
     */
    setX: function( x ) {
      assert && assert( typeof x === 'number' );

      this.translate( x - this.getX(), 0, true );
      return this;
    },
    set x( value ) { this.setX( value ); },

    /**
     * Returns the x coordinate (in the parent coorindate frame) of where the node's origin is transformed to.
     * @public
     *
     * @returns {number}
     */
    getX: function() {
      return this._transform.getMatrix().m02();
    },
    get x() { return this.getX(); },

    /**
     * Shifts the y coordinate (in the parent coordinate frame) of where the node's origin is transformed to.
     * @public
     *
     * @param {number} y
     */
    setY: function( y ) {
      assert && assert( typeof y === 'number' );

      this.translate( 0, y - this.getY(), true );
      return this;
    },
    set y( value ) { this.setY( value ); },

    /**
     * Returns the y coordinate (in the parent coorindate frame) of where the node's origin is transformed to.
     * @public
     *
     * @returns {number}
     */
    getY: function() {
      return this._transform.getMatrix().m12();
    },
    get y() { return this.getY(); },

    /**
     * Typically without rotations or negative parameters, this sets the scale for each axis. In its more general form,
     * it modifies the node's transform so that:
     * - Transforming (1,0) with our transform will result in a vector with magnitude abs( x-scale-magnitude )
     * - Transforming (0,1) with our transform will result in a vector with magnitude abs( y-scale-magnitude )
     * - If parameters are negative, it will flip orientation in that direct.
     * @public
     *
     * Allowed call signatures:
     * setScaleMagnitude( s )
     * setScaleMagnitude( sx, sy )
     * setScaleMagnitude( vector )
     *
     * @param {number} s - Scale for both axes
     * @param {number} sx - Scale for the X axis
     * @param {number} sy - Scale for the Y axis
     * @param {Vector2} vector - Scale for the x/y axes in the vector's components.
     */
    setScaleMagnitude: function( a, b ) {
      var currentScale = this.getScaleVector();

      if ( typeof a === 'number' ) {
        if ( b === undefined ) {
          // to map setScaleMagnitude( scale ) => setScaleMagnitude( scale, scale )
          b = a;
        }
        // setScaleMagnitude( x, y )
        this.appendMatrix( Matrix3.scaling( a / currentScale.x, b / currentScale.y ) );
      }
      else {
        // setScaleMagnitude( vector ), where we set the x-scale to vector.x and y-scale to vector.y
        this.appendMatrix( Matrix3.scaling( a.x / currentScale.x, a.y / currentScale.y ) );
      }
      return this;
    },

    /**
     * Returns a vector with an entry for each axis, e.g. (5,2) for an affine matrix with rows ((5,0,0),(0,2,0),(0,0,1)).
     * @public
     *
     * It is equivalent to:
     * ( T(1,0).magnitude(), T(0,1).magnitude() ) where T() transforms points with our transform.
     *
     * @returns {Vector2}
     */
    getScaleVector: function() {
      return this._transform.getMatrix().getScaleVector();
    },

    /**
     * Rotates this node's transform so that a unit (1,0) vector would be rotated by this node's transform by the
     * specified amount.
     * @public
     *
     * @param {number} rotation - In radians
     */
    setRotation: function( rotation ) {
      assert && assert( typeof rotation === 'number' );

      this.appendMatrix( scratchMatrix3.setToRotationZ( rotation - this.getRotation() ) );
      return this;
    },
    set rotation( value ) { this.setRotation( value ); },

    /**
     * Returns the rotation (in radians) that would be applied to a unit (1,0) vector when transformed with this Node's
     * transform.
     * @public
     *
     * @returns {number}
     */
    getRotation: function() {
      return this._transform.getMatrix().getRotation();
    },
    get rotation() { return this.getRotation(); },

    /**
     * Modifies the translation of this Node's transform so that the node's local-coordinate origin will be transformed
     * to the passed-in x/y.
     * @public
     *
     * Allowed call signatures:
     * setTranslation( x, y )
     * setTranslation( vector )
     *
     * @param {number} x - X translation
     * @param {number} y - Y translation
     * @param {Vector2} vector - Vector with x/y translation in components
     */
    setTranslation: function( a, b ) {
      var m = this._transform.getMatrix();
      var tx = m.m02();
      var ty = m.m12();

      var dx;
      var dy;

      if ( typeof a === 'number' ) {
        dx = a - tx;
        dy = b - ty;
      }
      else {
        dx = a.x - tx;
        dy = a.y - ty;
      }

      this.translate( dx, dy, true );

      return this;
    },
    set translation( value ) { this.setTranslation( value ); },

    /**
     * Returns a vector of where this Node's local-coordinate origin will be transformed by it's own transform.
     * @public
     *
     * @returns {Vector2}
     */
    getTranslation: function() {
      var matrix = this._transform.getMatrix();
      return new Vector2( matrix.m02(), matrix.m12() );
    },
    get translation() { return this.getTranslation(); },

    /**
     * Appends a transformation matrix to this Node's transform. Appending means this transform is conceptually applied
     * first before the rest of the Node's current transform (i.e. applied in the local coordinate frame).
     * @public
     *
     * @param {Matrix3} matrix
     */
    appendMatrix: function( matrix ) {
      this._transform.append( matrix );
    },

    /**
     * Prepends a transformation matrix to this Node's transform. Prepending means this transform is conceptually applied
     * after the rest of the Node's current transform (i.e. applied in the parent coordinate frame).
     * @public
     *
     * @param {Matrix3} matrix
     */
    prependMatrix: function( matrix ) {
      this._transform.prepend( matrix );
    },

    /**
     * Prepends an (x,y) translation to our Node's transform in an efficient manner without allocating a matrix.
     * see https://github.com/phetsims/scenery/issues/119
     * @public
     *
     * @param {number} x
     * @param {number} y
     */
    prependTranslation: function( x, y ) {
      assert && assert( typeof x === 'number', 'x not a number' );
      assert && assert( typeof y === 'number', 'y not a number' );
      assert && assert( isFinite( x ), 'x not finite' );
      assert && assert( isFinite( y ), 'y not finite' );

      if ( !x && !y ) { return; } // bail out if both are zero

      this._transform.prependTranslation( x, y );
    },

    /**
     * Changes this Node's transform to match the passed-in transformation matrix.
     * @public
     *
     * @param {Matrix3} matrix
     */
    setMatrix: function( matrix ) {
      this._transform.setMatrix( matrix );
    },
    set matrix( value ) { this.setMatrix( value ); },

    /**
     * Returns a Matrix3 representing our Node's transform.
     * @public
     *
     * NOTE: Do not mutate the returned matrix.
     *
     * @returns {Matrix3}
     */
    getMatrix: function() {
      return this._transform.getMatrix();
    },
    get matrix() { return this.getMatrix(); },

    /**
     * Returns a reference to our Node's transform
     * @public
     *
     * @returns {Transform3}
     */
    getTransform: function() {
      // for now, return an actual copy. we can consider listening to changes in the future
      return this._transform;
    },
    get transform() { return this.getTransform(); },

    /**
     * Resets our Node's transform to an identity transform (i.e. no transform is applied).
     * @public
     */
    resetTransform: function() {
      this.setMatrix( Matrix3.IDENTITY );
    },

    /**
     * Callback function that should be called when our transform is changed.
     * @private
     */
    onTransformChange: function() {
      // NOTE: why is local bounds invalidation needed here?
      this.invalidateBounds();

      this.trigger0( 'transform' );
    },

    /**
     * Updates our node's scale and applied scale factor if we need to change our scale to fit within the maximum
     * dimensions (maxWidth and maxHeight). See documentation in constructor for detailed behavior.
     * @private
     *
     * @param {Bounds2} localBounds
     */
    updateMaxDimension: function( localBounds ) {
      var currentScale = this._appliedScaleFactor;
      var idealScale = 1;

      if ( this._maxWidth !== null ) {
        var width = localBounds.width;
        if ( width > this._maxWidth ) {
          idealScale = Math.min( idealScale, this._maxWidth / width );
        }
      }

      if ( this._maxHeight !== null ) {
        var height = localBounds.height;
        if ( height > this._maxHeight ) {
          idealScale = Math.min( idealScale, this._maxHeight / height );
        }
      }

      var scaleAdjustment = idealScale / currentScale;
      if ( scaleAdjustment !== 1 ) {
        this.scale( scaleAdjustment );

        this._appliedScaleFactor = idealScale;
      }
    },

    /**
     * Increments/decrements bounds "listener" count based on the values of maxWidth/maxHeight before and after.
     * null is like no listener, non-null is like having a listener, so we increment for null => non-null, and
     * decrement for non-null => null.
     * @private
     *
     * @param {null | number} beforeMaxLength
     * @param {null | number} afterMaxLength
     */
    onMaxDimensionChange: function( beforeMaxLength, afterMaxLength ) {
      if ( beforeMaxLength === null && afterMaxLength !== null ) {
        this.changeBoundsEventCount( 1 );
        this._boundsEventSelfCount++;
      }
      else if ( beforeMaxLength !== null && afterMaxLength === null ) {
        this.changeBoundsEventCount( -1 );
        this._boundsEventSelfCount--;
      }
    },

    /**
     * Sets the maximum width of the Node (see constructor for documentation on how maximum dimensions work).
     * @public
     *
     * @param {number|null} maxWidth
     */
    setMaxWidth: function( maxWidth ) {
      assert && assert( maxWidth === null || typeof maxWidth === 'number',
        'maxWidth should be null (no constraint) or a number' );

      if ( this._maxWidth !== maxWidth ) {
        // update synthetic bounds listener count (to ensure our bounds are validated at the start of updateDisplay)
        this.onMaxDimensionChange( this._maxWidth, maxWidth );

        this._maxWidth = maxWidth;

        this.updateMaxDimension( this._localBounds );
      }
    },
    set maxWidth( value ) { this.setMaxWidth( value ); },

    /**
     * Returns the maximum width (if any) of the Node.
     * @public
     *
     * @returns {number|null}
     */
    getMaxWidth: function() {
      return this._maxWidth;
    },
    get maxWidth() { return this.getMaxWidth(); },

    /**
     * Sets the maximum height of the Node (see constructor for documentation on how maximum dimensions work).
     * @public
     *
     * @param {number|null} maxHeight
     */
    setMaxHeight: function( maxHeight ) {
      assert && assert( maxHeight === null || typeof maxHeight === 'number',
        'maxHeight should be null (no constraint) or a number' );

      if ( this._maxHeight !== maxHeight ) {
        // update synthetic bounds listener count (to ensure our bounds are validated at the start of updateDisplay)
        this.onMaxDimensionChange( this._maxHeight, maxHeight );

        this._maxHeight = maxHeight;

        this.updateMaxDimension( this._localBounds );
      }
    },
    set maxHeight( value ) { this.setMaxHeight( value ); },

    /**
     * Returns the maximum height (if any) of the Node.
     * @public
     *
     * @returns {number|null}
     */
    getMaxHeight: function() {
      return this._maxHeight;
    },
    get maxHeight() { return this.getMaxHeight(); },

    /**
     * Shifts this node horizontally so that its left bound (in the parent coordinate frame) is equal to the passed-in
     * 'left' X value.
     * @public
     *
     * @param {number} left
     */
    setLeft: function( left ) {
      assert && assert( typeof left === 'number' );

      this.translate( left - this.getLeft(), 0, true );
      return this; // allow chaining
    },
    set left( value ) { this.setLeft( value ); },

    /**
     * Returns the X value of the left side of the bounding box of this node (in the parent coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getLeft: function() {
      return this.getBounds().minX;
    },
    get left() { return this.getLeft(); },

    /**
     * Shifts this node horizontally so that its right bound (in the parent coordinate frame) is equal to the passed-in
     * 'right' X value.
     * @public
     *
     * @param {number} right
     */
    setRight: function( right ) {
      assert && assert( typeof right === 'number' );

      this.translate( right - this.getRight(), 0, true );
      return this; // allow chaining
    },
    set right( value ) { this.setRight( value ); },

    /**
     * Returns the X value of the right side of the bounding box of this node (in the parent coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getRight: function() {
      return this.getBounds().maxX;
    },
    get right() { return this.getRight(); },

    /**
     * Shifts this node horizontally so that its horizontal center (in the parent coordinate frame) is equal to the
     * passed-in center X value.
     * @public
     *
     * @param {number} x
     */
    setCenterX: function( x ) {
      assert && assert( typeof x === 'number' );

      this.translate( x - this.getCenterX(), 0, true );
      return this; // allow chaining
    },
    set centerX( value ) { this.setCenterX( value ); },

    /**
     * Returns the X value of this node's horizontal center (in the parent coordinate frame)
     * @public
     *
     * @returns {number}
     */
    getCenterX: function() {
      return this.getBounds().getCenterX();
    },
    get centerX() { return this.getCenterX(); },

    /**
     * Shifts this node vertically so that its vertical center (in the parent coordinate frame) is equal to the
     * passed-in center Y value.
     * @public
     *
     * @param {number} y
     */
    setCenterY: function( y ) {
      assert && assert( typeof y === 'number' );

      this.translate( 0, y - this.getCenterY(), true );
      return this; // allow chaining
    },
    set centerY( value ) { this.setCenterY( value ); },

    /**
     * Returns the Y value of this node's vertical center (in the parent coordinate frame)
     * @public
     *
     * @returns {number}
     */
    getCenterY: function() {
      return this.getBounds().getCenterY();
    },
    get centerY() { return this.getCenterY(); },

    /**
     * Shifts this node vertically so that its top (in the parent coordinate frame) is equal to the passed-in Y value.
     * @public
     *
     * NOTE: top is the lowest Y value in our bounds.
     *
     * @param {number} top
     */
    setTop: function( top ) {
      assert && assert( typeof top === 'number' );

      this.translate( 0, top - this.getTop(), true );
      return this; // allow chaining
    },
    set top( value ) { this.setTop( value ); },

    /**
     * Returns the lowest Y value of this node's bounding box (in the parent coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getTop: function() {
      return this.getBounds().minY;
    },
    get top() { return this.getTop(); },

    /**
     * Shifts this node vertically so that its bottom (in the parent coordinate frame) is equal to the passed-in Y value.
     * @public
     *
     * NOTE: top is the highest Y value in our bounds.
     *
     * @param {number} top
     */
    setBottom: function( bottom ) {
      assert && assert( typeof bottom === 'number' );

      this.translate( 0, bottom - this.getBottom(), true );
      return this; // allow chaining
    },
    set bottom( value ) { this.setBottom( value ); },

    /**
     * Returns the highest Y value of this node's bounding box (in the parent coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getBottom: function() {
      return this.getBounds().maxY;
    },
    get bottom() { return this.getBottom(); },

    /**
     * Returns the width of this node's bounding box (in the parent coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getWidth: function() {
      return this.getBounds().getWidth();
    },
    get width() { return this.getWidth(); },

    /**
     * Returns the height of this node's bounding box (in the parent coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getHeight: function() {
      return this.getBounds().getHeight();
    },
    get height() { return this.getHeight(); },

    /**
     * Returns the unique integral ID for this node.
     * @public
     *
     * @returns {number}
     */
    getId: function() {
      return this._id;
    },
    get id() { return this.getId(); },

    /**
     * Sets whether this node is visible.
     * @public
     *
     * @param {boolean} visible
     */
    setVisible: function( visible ) {
      assert && assert( typeof visible === 'boolean' );

      if ( visible !== this._visible ) {
        // changing visibility can affect pickability pruning, which affects mouse/touch bounds
        this.invalidateMouseTouchBounds();

        this._visible = visible;

        this.trigger0( 'visibility' );
      }
      return this;
    },
    set visible( value ) { this.setVisible( value ); },

    /**
     * Returns whether this node is visible.
     * @public
     *
     * @returns {boolean}
     */
    isVisible: function() {
      return this._visible;
    },
    get visible() { return this.isVisible(); },

    /**
     * Sets the opacity of this node (and its sub-tree), where 0 is fully transparent, and 1 is fully opaque.
     * @public
     *
     * @param {number} opacity
     */
    setOpacity: function( opacity ) {
      assert && assert( typeof opacity === 'number' );

      var clampedOpacity = clamp( opacity, 0, 1 );
      if ( clampedOpacity !== this._opacity ) {
        this._opacity = clampedOpacity;

        this.trigger0( 'opacity' );
      }
    },
    set opacity( value ) { this.setOpacity( value ); },

    /**
     * Returns the opacity of this node.
     * @public
     *
     * @returns {number}
     */
    getOpacity: function() {
      return this._opacity;
    },
    get opacity() { return this.getOpacity(); },

    /**
     * Sets the pickability of this node (see the constructor for more detailed documentation).
     * @public
     *
     * @param {boolean|null} pickable
     */
    setPickable: function( pickable ) {
      assert && assert( pickable === null || typeof pickable === 'boolean' );

      if ( this._pickable !== pickable ) {
        var n = this._pickable === true ? -1 : 0;

        // no paint or invalidation changes for now, since this is only handled for the mouse
        this._pickable = pickable;
        n += this._pickable === true ? 1 : 0;

        if ( n ) {
          this.changePickableCount( n ); // should invalidate mouse/touch bounds, since it changes the pickability
        }

        // TODO: invalidate the cursor somehow? #150
      }
    },
    set pickable( value ) { this.setPickable( value ); },

    /**
     * Returns the pickability of this node.
     * @public
     *
     * @returns {boolean|null}
     */
    isPickable: function() {
      return this._pickable;
    },
    get pickable() { return this.isPickable(); },

    /**
     * Sets the CSS cursor string that should be used when the mouse is over this node. null is the default, and
     * indicates that ancestor nodes (or the browser default) should be used.
     * @public
     *
     * @param {string} cursor - A CSS cursor string, like 'pointer', or 'none'
     */
    setCursor: function( cursor ) {
      assert && assert( typeof cursor === 'string' || cursor === null );

      // TODO: consider a mapping of types to set reasonable defaults
      /*
       auto default none inherit help pointer progress wait crosshair text vertical-text alias copy move no-drop not-allowed
       e-resize n-resize w-resize s-resize nw-resize ne-resize se-resize sw-resize ew-resize ns-resize nesw-resize nwse-resize
       context-menu cell col-resize row-resize all-scroll url( ... ) --> does it support data URLs?
       */

      // allow the 'auto' cursor type to let the ancestors or scene pick the cursor type
      this._cursor = cursor === 'auto' ? null : cursor;
    },
    set cursor( value ) { this.setCursor( value ); },

    /**
     * Returns the CSS cursor string for this node.
     * @public
     *
     * @returns {string}
     */
    getCursor: function() {
      return this._cursor;
    },
    get cursor() { return this.getCursor(); },

    /**
     * Sets the hit-tested mouse area for this node (see constructor for more advanced documentation). Use null for the
     * default behavior.
     * @public
     *
     * @param {Bounds2|Shape|null} area
     */
    setMouseArea: function( area ) {
      assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'mouseArea needs to be a kite.Shape, dot.Bounds2, or null' );

      if ( this._mouseArea !== area ) {
        this._mouseArea = area; // TODO: could change what is under the mouse, invalidate!

        this.invalidateMouseTouchBounds();
      }
    },
    set mouseArea( value ) { this.setMouseArea( value ); },

    /**
     * Returns the hit-tested mouse area for this node.
     * @public
     *
     * @returns {Bounds2|Shape|null}
     */
    getMouseArea: function() {
      return this._mouseArea;
    },
    get mouseArea() { return this.getMouseArea(); },

    /**
     * Sets the hit-tested touch area for this node (see constructor for more advanced documentation). Use null for the
     * default behavior.
     * @public
     *
     * @param {Bounds2|Shape|null} area
     */
    setTouchArea: function( area ) {
      assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'touchArea needs to be a kite.Shape, dot.Bounds2, or null' );

      if ( this._touchArea !== area ) {
        this._touchArea = area; // TODO: could change what is under the touch, invalidate!

        this.invalidateMouseTouchBounds();
      }
    },
    set touchArea( value ) { this.setTouchArea( value ); },

    /**
     * Returns the hit-tested touch area for this node.
     * @public
     *
     * @returns {Bounds2|Shape|null}
     */
    getTouchArea: function() {
      return this._touchArea;
    },
    get touchArea() { return this.getTouchArea(); },

    /**
     * Sets a clipped shape where only content in our local coordinate frame that is inside the clip area will be shown
     * (anything outside is fully transparent).
     * @public
     *
     * @param {Shape|null} shape
     */
    setClipArea: function( shape ) {
      assert && assert( shape === null || shape instanceof Shape, 'clipArea needs to be a kite.Shape, or null' );

      if ( this._clipArea !== shape ) {
        this._clipArea = shape;

        this.trigger0( 'clip' );

        this.invalidateBounds();
      }
    },
    set clipArea( value ) { this.setClipArea( value ); },

    /**
     * Returns the clipped area for this node.
     * @public
     *
     * @returns {Shape|null}
     */
    getClipArea: function() {
      return this._clipArea;
    },
    get clipArea() { return this.getClipArea(); },

    /**
     * Returns whether this node has a clip area.
     * @public
     *
     * @returns {boolean}
     */
    hasClipArea: function() {
      return this._clipArea !== null;
    },

    /**
     * Sets whether this node should be focusable for keyboard support.
     * @public
     *
     * @param {boolean} focusable
     */
    setFocusable: function( focusable ) {
      if ( this._focusable !== focusable ) {
        this._focusable = focusable;

        this.trigger0( 'focusable' );
      }
    },
    set focusable( value ) { this.setFocusable( value ); },

    /**
     * Returns whether this node is focusable.
     * @public
     *
     * @returns {boolean}
     */
    getFocusable: function() {
      return this._focusable;
    },
    get focusable() { return this.getFocusable(); },

    /**
     * Sets the focus indicator for the node ('rectangle' or 'cursor').
     * @public
     *
     * @param {string} focusIndicator
     */
    setFocusIndicator: function( focusIndicator ) {
      if ( this._focusIndicator !== focusIndicator ) {
        this._focusIndicator = focusIndicator;

        this.trigger0( 'focusIndicator' );
      }
    },
    set focusIndicator( value ) { this.setFocusIndicator( value ); },

    /**
     * Returns the focus indicator string for this node.
     * @public
     *
     * @returns {string}
     */
    getFocusIndicator: function() {
      return this._focusIndicator;
    },
    get focusIndicator() { return this.getFocusIndicator(); },

    /**
     * Sets the accessible focus order for this node. This includes not only focussed items, but elements that can be
     * placed in the parallel DOM. If provided, it will override the focus order between children (and
     * optionally descendants). If not provided, the focus order will default to the rendering order (first children
     * first, last children last), determined by the children array.
     * @public
     *
     * @param {Array.<Node>|null} accessibleOrder
     */
    setAccessibleOrder: function( accessibleOrder ) {
      assert && assert( accessibleOrder === null || accessibleOrder instanceof Array );

      if ( this._accessibleOrder !== accessibleOrder ) {
        this._accessibleOrder = accessibleOrder;

        var trails = this.getTrails( hasRootedDisplayPredicate );
        for ( var i = 0; i < trails.length; i++ ) {
          var trail = trails[ i ];
          var rootedDisplays = trail.rootNode()._rootedDisplays;
          for ( var j = 0; j < rootedDisplays.length; j++ ) {
            rootedDisplays[ j ].changedAccessibleOrder( trail );
          }
        }

        this.trigger0( 'accessibleOrder' );
      }
    },
    set accessibleOrder( value ) { this.setAccessibleOrder( value ); },

    /**
     * Returns the accessible (focus) order for this node.
     * @public
     *
     * @returns {Array.<Node>|null}
     */
    getAccessibleOrder: function() {
      return this._accessibleOrder;
    },
    get accessibleOrder() { return this.getAccessibleOrder(); },

    /**
     * Sets the accessible content for a Node. See constructor for more information.
     * @public
     *
     * @param {null|Object} accessibleContent
     */
    setAccessibleContent: function( accessibleContent ) {
      assert && assert( accessibleContent === null || accessibleContent instanceof Object );

      if ( this._accessibleContent !== accessibleContent ) {
        var oldAccessibleContent = this._accessibleContent;
        this._accessibleContent = accessibleContent;

        var trails = this.getTrails( hasRootedDisplayPredicate );
        for ( var i = 0; i < trails.length; i++ ) {
          var trail = trails[ i ];
          var rootedDisplays = trail.rootNode()._rootedDisplays;
          for ( var j = 0; j < rootedDisplays.length; j++ ) {
            rootedDisplays[ j ].changedAccessibleContent( trail, oldAccessibleContent, accessibleContent );
          }
        }

        this.trigger0( 'accessibleContent' );
      }
    },
    set accessibleContent( value ) { this.setAccessibleContent( value ); },

    /**
     * Returns the accessible content for this node.
     * @public
     *
     * @returns {Array.<Node>|null}
     */
    getAccessibleContent: function() {
      return this._accessibleContent;
    },
    get accessibleContent() { return this.getAccessibleContent(); },

    // @deprecated
    supportsCanvas: function() {
      return ( this._rendererBitmask & Renderer.bitmaskCanvas ) !== 0;
    },

    // @deprecated
    supportsSVG: function() {
      return ( this._rendererBitmask & Renderer.bitmaskSVG ) !== 0;
    },

    // @deprecated
    supportsDOM: function() {
      return ( this._rendererBitmask & Renderer.bitmaskDOM ) !== 0;
    },

    // @deprecated
    supportsWebGL: function() {
      return ( this._rendererBitmask & Renderer.bitmaskWebGL ) !== 0;
    },

    // @deprecated
    supportsRenderer: function( renderer ) {
      return ( this._rendererBitmask & renderer.bitmask ) !== 0;
    },

    /**
     * Sets what self renderers (and other bitmask flags) are supported by this node.
     * @protected
     *
     * @param {number} bitmask
     */
    setRendererBitmask: function( bitmask ) {
      if ( bitmask !== this._rendererBitmask ) {
        this._rendererBitmask = bitmask;

        this._rendererSummary.selfChange();
        this.trigger0( 'rendererBitmask' );
      }
    },

    /**
     * Meant to be overridden, so that it can be called to ensure that the renderer bitmask will be up-to-date.
     * @protected
     */
    invalidateSupportedRenderers: function() {

    },

    /*---------------------------------------------------------------------------*
     * Hints
     *----------------------------------------------------------------------------*/

    /**
     * Sets a preferred renderer for this node and its sub-tree. Scenery will attempt to use this renderer under here
     * unless it isn't supported, OR another preferred renderer is set as a closer ancestor. Acceptable values are:
     * - null (default, no preference)
     * - 'canvas'
     * - 'svg'
     * - 'dom'
     * - 'webgl'
     * @public
     *
     * @param {string|null} renderer
     */
    setRenderer: function( renderer ) {
      assert && assert( renderer === null || renderer === 'canvas' || renderer === 'svg' || renderer === 'dom' || renderer === 'webgl',
        'Renderer input should be null, or one of: "canvas", "svg", "dom" or "webgl".' );

      var newRenderer = 0;
      if ( renderer === 'canvas' ) {
        newRenderer = Renderer.bitmaskCanvas;
      }
      else if ( renderer === 'svg' ) {
        newRenderer = Renderer.bitmaskSVG;
      }
      else if ( renderer === 'dom' ) {
        newRenderer = Renderer.bitmaskDOM;
      }
      else if ( renderer === 'webgl' ) {
        newRenderer = Renderer.bitmaskWebGL;
      }
      assert && assert( ( renderer === null ) === ( newRenderer === 0 ),
        'We should only end up with no actual renderer if renderer is null' );

      if ( this._hints.renderer !== newRenderer ) {
        this._hints.renderer = newRenderer;

        this.trigger1( 'hint', 'renderer' );
      }
    },
    set renderer( value ) { this.setRenderer( value ); },

    /**
     * Returns the preferred renderer (if any) of this node, as a string.
     * @public
     *
     * @returns {string|null}
     */
    getRenderer: function() {
      if ( this._hints.renderer === 0 ) {
        return null;
      }
      else if ( this._hints.renderer === Renderer.bitmaskCanvas ) {
        return 'canvas';
      }
      else if ( this._hints.renderer === Renderer.bitmaskSVG ) {
        return 'svg';
      }
      else if ( this._hints.renderer === Renderer.bitmaskDOM ) {
        return 'dom';
      }
      else if ( this._hints.renderer === Renderer.bitmaskWebGL ) {
        return 'webgl';
      }
      assert && assert( false, 'Seems to be an invalid renderer?' );
      return this._hints.renderer;
    },
    get renderer() { return this.getRenderer(); },

    /**
     * Returns whether there is a preferred renderer for this node.
     * @public
     *
     * @returns {boolean}
     */
    hasRenderer: function() {
      return !!this._hints.renderer;
    },

    // @deprecated
    setRendererOptions: function( options ) {
      // TODO: consider checking options based on the specified 'renderer'?
      // TODO: consider a guard where we check if anything changed
      //OHTWO TODO: Split out all of the renderer options into individual flag ES5'ed getter/setters
      _.extend( this._hints, options );

      this.trigger0( 'hint' );
    },
    set rendererOptions( value ) { this.setRendererOptions( value ); },

    // @deprecated
    getRendererOptions: function() {
      return this._hints;
    },
    get rendererOptions() { return this.getRendererOptions(); },

    /**
     * Sets whether or not Scenery will try to put this node (and its descendants) into a separate SVG/Canvas/WebGL/etc.
     * layer, different from other siblings or other nodes. Can be used for performance purposes.
     * @public
     *
     * @param {boolean} split
     */
    setLayerSplit: function( split ) {
      assert && assert( typeof split === 'boolean' );

      if ( split !== this._hints.layerSplit ) {
        this._hints.layerSplit = split;
        this.trigger1( 'hint', 'layerSplit' );
      }
    },
    set layerSplit( value ) { this.setLayerSplit( value ); },

    /**
     * Returns whether the layerSplit performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    isLayerSplit: function() {
      return this._hints.layerSplit;
    },
    get layerSplit() { return this.isLayerSplit(); },

    /**
     * Sets whether or not Scenery will take into account that this Node plans to use opacity. Can have performance
     * gains if there need to be multiple layers for this node's descendants.
     * @public
     *
     * @param {boolean} usesOpacity
     */
    setUsesOpacity: function( usesOpacity ) {
      assert && assert( typeof usesOpacity === 'boolean' );

      if ( usesOpacity !== this._hints.usesOpacity ) {
        this._hints.usesOpacity = usesOpacity;
        this.trigger1( 'hint', 'usesOpacity' );
      }
    },
    set usesOpacity( value ) { this.setUsesOpacity( value ); },

    /**
     * Returns whether the usesOpacity performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    getUsesOpacity: function() {
      return this._hints.usesOpacity;
    },
    get usesOpacity() { return this.getUsesOpacity(); },

    /**
     * Sets a flag for whether whether the contents of this Node and its children should be displayed in a separate
     * DOM element that is transformed with CSS transforms. It can have potential speedups, since the browser may not
     * have to rerasterize contents when it is animated.
     * @public
     *
     * @param {boolean} cssTransform
     */
    setCSSTransform: function( cssTransform ) {
      assert && assert( typeof cssTransform === 'boolean' );

      if ( cssTransform !== this._hints.cssTransform ) {
        this._hints.cssTransform = cssTransform;
        this.trigger1( 'hint', 'cssTransform' );
      }
    },
    set cssTransform( value ) { this.setCSSTransform( value ); },

    /**
     * Returns wehther the cssTransform performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    isCSSTransformed: function() {
      return this._hints.cssTransform;
    },
    get cssTransform() { return this._hints.cssTransform; },

    /**
     * Sets a performance flag for whether layers/DOM elements should be excluded (or included) when things are
     * invisible. The default is false, and invisible content is in the DOM, but hidden.
     * @public
     *
     * @param {boolean} excludeInvisible
     */
    setExcludeInvisible: function( excludeInvisible ) {
      assert && assert( typeof excludeInvisible === 'boolean' );

      if ( excludeInvisible !== this._hints.excludeInvisible ) {
        this._hints.excludeInvisible = excludeInvisible;
        this.trigger1( 'hint', 'excludeInvisible' );
      }
    },
    set excludeInvisible( value ) { this.setExcludeInvisible( value ); },

    /**
     * Returns whether the excludeInvisible performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    isExcludeInvisible: function() {
      return this._hints.excludeInvisible;
    },
    get excludeInvisible() { return this.isExcludeInvisible(); },

    setPreventFit: function( preventFit ) {
      assert && assert( typeof preventFit === 'boolean' );

      if ( preventFit !== this._hints.preventFit ) {
        this._hints.preventFit = preventFit;
        this.trigger1( 'hint', 'preventFit' );
      }
    },
    set preventFit( value ) { this.setPreventFit( value ); },

    /**
     * Returns whether the preventFit performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    isPreventFit: function() {
      return this._hints.preventFit;
    },
    get preventFit() { return this.isPreventFit(); },

    /**
     * Sets whether there is a custom WebGL scale applied to the Canvas, and if so what scale.
     * @public
     *
     * @param {number|null} webglScale
     */
    setWebGLScale: function( webglScale ) {
      assert && assert( webglScale === null || typeof webglScale === 'number' );

      if ( webglScale !== this._hints.webglScale ) {
        this._hints.webglScale = webglScale;
        this.trigger1( 'hint', 'webglScale' );
      }
    },
    set webglScale( value ) { this.setWebGLScale( value ); },

    /**
     * Returns the value of the webglScale performance flag.
     * @public
     *
     * @returns {number|null}
     */
    getWebGLScale: function() {
      return this._hints.webglScale;
    },
    get webglScale() { return this.getWebGLScale(); },

    /*---------------------------------------------------------------------------*
     * Trail operations
     *----------------------------------------------------------------------------*/

    /**
     * Returns the one Trail that starts from a node with no parents (or if the predicate is present, a node that
     * satisfies it), and ends at this node. If more than one Trail would satisfy these conditions, an assertion is
     * thrown (please use getTrails() for those cases).
     * @public
     *
     * @param {function( node ) : boolean} [predicate] - If supplied, we will only return trails rooted at a node that
     *                                                   satisfies predicate( node ) == true
     * @returns {Trail}
     */
    getUniqueTrail: function( predicate ) {

      // Without a predicate, we'll be able to bail out the instant we hit a node with 2+ parents, and it makes the
      // logic easier.
      if ( !predicate ) {
        var trail = new scenery.Trail();
        var node = this;

        while ( node ) {
          assert && assert( node._parents.length <= 1,
            'getUniqueTrail found a node with ' + node._parents.length + ' parents.' );

          trail.addAncestor( node );
          node = node._parents[ 0 ]; // should be undefined if there aren't any parents
        }

        return trail;
      }
      // With a predicate, we need to explore multiple parents (since the predicate may filter out all but one)
      else {
        var trails = this.getTrails( predicate );

        assert && assert( trails.length === 1,
          'getUniqueTrail found ' + trails.length + ' matching trails for the predicate' );

        return trails[ 0 ];
      }
    },

    /**
     * Returns a Trail rooted at rootNode and ends at this node. Throws an assertion if the number of trails that match
     * this condition isn't exactly 1.
     * @public
     *
     * @param {Node} rootNode
     * @returns {Trail}
     */
    getUniqueTrailTo: function( rootNode ) {
      return this.getUniqueTrail( function( node ) {
        return rootNode === node;
      } );
    },

    /**
     * Returns an array of all Trails that start from nodes with no parent (or if a predicate is present, those that
     * satisfy the predicate), and ends at this node.
     * @public
     *
     * @param {function( node ) : boolean} [predicate] - If supplied, we will only return Trails rooted at nodes that
     *                                                   satisfy predicate( node ) == true.
     * @returns {Array.<Trail>}
     */
    getTrails: function( predicate ) {
      predicate = predicate || defaultTrailPredicate;

      var trails = [];
      var trail = new scenery.Trail( this );
      scenery.Trail.appendAncestorTrailsWithPredicate( trails, trail, predicate );

      return trails;
    },

    /**
     * Returns an array of all Trails rooted at rootNode and end at this node.
     * @public

     * @param {Node} rootNode
     * @returns {Array.<Trail>}
     */
    getTrailsTo: function( rootNode ) {
      return this.getTrails( function( node ) {
        return node === rootNode;
      } );
    },

    /**
     * Returns an array of all Trails rooted at this node and end with nodes with no children (or if a predicate is
     * present, those that satisfy the predicate).
     * @public
     *
     * @param {function( node ) : boolean} [predicate] - If supplied, we will only return Trails ending at nodes that
     *                                                   satisfy predicate( node ) == true.
     * @returns {Array.<Trail>}
     */
    getLeafTrails: function( predicate ) {
      predicate = predicate || defaultLeafTrailPredicate;

      var trails = [];
      var trail = new scenery.Trail( this );
      scenery.Trail.appendDescendantTrailsWithPredicate( trails, trail, predicate );

      return trails;
    },

    /**
     * Returns an array of all Trails rooted at this node and end with leafNode.
     * @public
     *
     * @param {Node} leafNode
     * @returns {Array.<Trail>}
     */
    getLeafTrailsTo: function( leafNode ) {
      return this.getLeafTrails( function( node ) {
        return node === leafNode;
      } );
    },

    /**
     * Returns a Trail rooted at this node and ending at a node that has no children (or if a predicate is provided, a
     * node that satisfies the predicate). If more than one trail matches this description, an assertion will be fired.
     * @public
     *
     * @param {function( node ) : boolean} [predicate] - If supplied, we will return a Trail that ends with a node that
     *                                                   satisfies predicate( node ) == true
     * @returns {Trail}
     */
    getUniqueLeafTrail: function( predicate ) {
      var trails = this.getLeafTrails( predicate );

      assert && assert( trails.length === 1,
        'getUniqueLeafTrail found ' + trails.length + ' matching trails for the predicate' );

      return trails[ 0 ];
    },

    /**
     * Returns a Trail rooted at this node and ending at leafNode. If more than one trail matches this description,
     * an assertion will be fired.
     * @public
     *
     * @param {Node} leafNode
     * @returns {Trail}
     */
    getUniqueLeafTrailTo: function( leafNode ) {
      return this.getUniqueLeafTrail( function( node ) {
        return node === leafNode;
      } );
    },

    /*
     * Returns all nodes in the connected component, returned in an arbitrary order, including nodes that are ancestors
     * of this node.
     * @public
     *
     * @returns {Array.<Node>}
     */
    getConnectedNodes: function() {
      var result = [];
      var fresh = this._children.concat( this._parents ).concat( this );
      while ( fresh.length ) {
        var node = fresh.pop();
        if ( !_.contains( result, node ) ) {
          result.push( node );
          fresh = fresh.concat( node._children, node._parents );
        }
      }
      return result;
    },

    /**
     * Returns a recursive data structure that represents the nested ordering of accessible content for this Node's
     * subtree. Each "Item" will have the type { trail: {Trail}, children: {Array.<Item>} }, forming a tree-like
     * structure.
     * @public
     *
     * @returns {Array.<Item>}
     */
    getNestedAccessibleOrder: function() {
      var currentTrail = new scenery.Trail( this );
      var pruneStack = []; // {Array.<Node>} - A list of nodes to prune

      // {Array.<Item>} - The main result we will be returning. It is the top-level array where child items will be
      // inserted.
      var result = [];

      // {Array.<Array.<Item>>} A stack of children arrays, where we should be inserting items into the top array.
      // We will start out with the result, and as nested levels are added, the children arrays of those items will be
      // pushed and poppped, so that the top array on this stack is where we should insert our next child item.
      var nestedChildStack = [ result ];

      function addTrailsForNode( node, overridePruning ) {
        // If subtrees were specified with accessibleOrder, they should be skipped from the ordering of ancestor subtrees,
        // otherwise we could end up having multiple references to the same trail (which should be disallowed).
        var pruneCount = 0;
        // count the number of times our node appears in the pruneStack
        _.each( pruneStack, function( pruneNode ) {
          if ( node === pruneNode ) {
            pruneCount++;
          }
        } );

        // If overridePruning is set, we ignore one reference to our node in the prune stack. If there are two copies,
        // however, it means a node was specified in a accessibleOrder that already needs to be pruned (so we skip it instead
        // of creating duplicate references in the tab order).
        if ( pruneCount > 1 || ( pruneCount === 1 && !overridePruning ) ) {
          return;
        }

        // Pushing item and its children array, if accessible
        if ( node.accessibleContent ) {
          var item = {
            trail: currentTrail.copy(),
            children: []
          };
          nestedChildStack[ nestedChildStack.length - 1 ].push( item );
          nestedChildStack.push( item.children );
        }

        // Pushing pruned nodes to the stack (if ordered), AND visiting trails to ordered nodes.
        if ( node._accessibleOrder ) {
          // push specific focused nodes to the stack
          pruneStack = pruneStack.concat( node._accessibleOrder );

          _.each( node._accessibleOrder, function( descendant ) {
            // Find all descendant references to the node.
            // NOTE: We are not reordering trails (due to descendant constraints) if there is more than one instance for
            // this descendant node.
            _.each( node.getLeafTrailsTo( descendant ), function( descendantTrail ) {
              descendantTrail.removeAncestor(); // strip off 'node', so that we handle only children

              // same as the normal order, but adding a full trail (since we may be referencing a descendant node)
              currentTrail.addDescendantTrail( descendantTrail );
              addTrailsForNode( descendant, true ); // 'true' overrides one reference in the prune stack (added above)
              currentTrail.removeDescendantTrail( descendantTrail );
            } );
          } );
        }

        // Visit everything. If there is an accessibleOrder, those trails were already visited, and will be excluded.
        var numChildren = node._children.length;
        for ( var i = 0; i < numChildren; i++ ) {
          var child = node._children[ i ];

          currentTrail.addDescendant( child, i );
          addTrailsForNode( child, false );
          currentTrail.removeDescendant();
        }

        // Popping pruned nodes from the stack (if ordered)
        if ( node._accessibleOrder ) {
          // pop focused nodes from the stack (that were added above)
          _.each( node._accessibleOrder, function( descendant ) {
            pruneStack.pop();
          } );
        }

        // Popping children array if accessible
        if ( node.accessibleContent ) {
          nestedChildStack.pop();
        }
      }

      addTrailsForNode( this, false );

      return result;
    },

    /**
     * Returns all nodes that are connected to this node, sorted in topological order.
     * @public
     *
     * @returns {Array.<Node>}
     */
    getTopologicallySortedNodes: function() {
      // see http://en.wikipedia.org/wiki/Topological_sorting
      var edges = {};
      var s = [];
      var l = [];
      var n;
      _.each( this.getConnectedNodes(), function( node ) {
        edges[ node.id ] = {};
        _.each( node._children, function( m ) {
          edges[ node.id ][ m.id ] = true;
        } );
        if ( !node.parents.length ) {
          s.push( node );
        }
      } );
      function handleChild( m ) {
        delete edges[ n.id ][ m.id ];
        if ( _.every( edges, function( children ) { return !children[ m.id ]; } ) ) {
          // there are no more edges to m
          s.push( m );
        }
      }

      while ( s.length ) {
        n = s.pop();
        l.push( n );

        _.each( n._children, handleChild );
      }

      // ensure that there are no edges left, since then it would contain a circular reference
      assert && assert( _.every( edges, function( children ) {
        return _.every( children, function( final ) { return false; } );
      } ), 'circular reference check' );

      return l;
    },

    /**
     * Returns whether this.addChild( child ) will not cause circular references.
     * @public
     *
     * @param {Node} child
     * @returns {boolean}
     */
    canAddChild: function( child ) {
      if ( this === child || _.contains( this._children, child ) ) {
        return false;
      }

      // see http://en.wikipedia.org/wiki/Topological_sorting
      // TODO: remove duplication with above handling?
      var edges = {};
      var s = [];
      var l = [];
      var n;
      _.each( this.getConnectedNodes().concat( child.getConnectedNodes() ), function( node ) {
        edges[ node.id ] = {};
        _.each( node._children, function( m ) {
          edges[ node.id ][ m.id ] = true;
        } );
        if ( !node.parents.length && node !== child ) {
          s.push( node );
        }
      } );
      edges[ this.id ][ child.id ] = true; // add in our 'new' edge
      function handleChild( m ) {
        delete edges[ n.id ][ m.id ];
        if ( _.every( edges, function( children ) { return !children[ m.id ]; } ) ) {
          // there are no more edges to m
          s.push( m );
        }
      }

      while ( s.length ) {
        n = s.pop();
        l.push( n );

        _.each( n._children, handleChild );

        // handle our new edge
        if ( n === this ) {
          handleChild( child );
        }
      }

      // ensure that there are no edges left, since then it would contain a circular reference
      return _.every( edges, function( children ) {
        return _.every( children, function( final ) { return false; } );
      } );
    },

    /**
     * To be overridden in paintable node types. Should hook into the drawable's prototype (presumably).
     * @protected
     *
     * @param {CanvasContextWrapper} wrapper
     */
    canvasPaintSelf: function( wrapper ) {

    },

    /**
     * Renders this Node only (its self) into the Canvas wrapper, in its local coordinate frame.
     * @public
     *
     * @param {CanvasContextWrapper} wrapper
     */
    renderToCanvasSelf: function( wrapper ) {
      if ( this.isPainted() && ( this._rendererBitmask & Renderer.bitmaskCanvas ) ) {
        this.canvasPaintSelf( wrapper );
      }
    },

    /**
     * Renders this node and its descendants into the Canvas wrapper.
     * @public
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} [matrix] - Optional transform to be applied
     */
    renderToCanvasSubtree: function( wrapper, matrix ) {
      matrix = matrix || Matrix3.identity();

      wrapper.resetStyles();

      this.renderToCanvasSelf( wrapper );
      for ( var i = 0; i < this._children.length; i++ ) {
        var child = this._children[ i ];

        if ( child.isVisible() ) {
          var requiresScratchCanvas = child._opacity !== 1 || child._clipArea;

          wrapper.context.save();
          matrix.multiplyMatrix( child._transform.getMatrix() );
          matrix.canvasSetTransform( wrapper.context );
          if ( requiresScratchCanvas ) {
            var canvas = document.createElement( 'canvas' );
            canvas.width = wrapper.canvas.width;
            canvas.height = wrapper.canvas.height;
            var context = canvas.getContext( '2d' );
            var childWrapper = new scenery.CanvasContextWrapper( canvas, context );

            matrix.canvasSetTransform( context );

            child.renderToCanvasSubtree( childWrapper, matrix );

            wrapper.context.save();
            if ( child._clipArea ) {
              wrapper.context.beginPath();
              child._clipArea.writeToContext( wrapper.context );
              wrapper.context.clip();
            }
            wrapper.context.setTransform( 1, 0, 0, 1, 0, 0 ); // identity
            wrapper.context.globalAlpha = child._opacity;
            wrapper.context.drawImage( canvas, 0, 0 );
            wrapper.context.restore();
          }
          else {
            child.renderToCanvasSubtree( wrapper, matrix );
          }
          matrix.multiplyMatrix( child._transform.getInverse() );
          wrapper.context.restore();
        }
      }
    },

    /**
     * @deprecated
     * Render this node to the Canvas (clearing it first)
     * @public
     *
     * @param {HTMLCanvasElement} canvas
     * @param {CanvasRenderingContext2D} context
     * @param {Function} callback - Called with no arguments
     * @param {string} [backgroundColor]
     */
    // @public @deprecated (API compatibility for now): Render this node to the Canvas (clearing it first)
    renderToCanvas: function( canvas, context, callback, backgroundColor ) {
      // should basically reset everything (and clear the Canvas)
      canvas.width = canvas.width;

      if ( backgroundColor ) {
        context.fillStyle = backgroundColor;
        context.fillRect( 0, 0, canvas.width, canvas.height );
      }

      var wrapper = new scenery.CanvasContextWrapper( canvas, context );

      this.renderToCanvasSubtree( wrapper, Matrix3.identity() );

      callback && callback(); // this was originally asynchronous, so we had a callback
    },

    /*
     * Renders this node to a canvas. If toCanvas( callback ) is used, the canvas will contain the node's
     * entire bounds (if no x/y/width/height is provided)
     * @public
     *
     * @param {Function} callback - callback( canvas, x, y ) is called, where x,y are computed if not specified.
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toCanvas: function( callback, x, y, width, height ) {
      var padding = 2; // padding used if x and y are not set

      // for now, we add an unpleasant hack around Text and safe bounds in general. We don't want to add another Bounds2 object per Node for now.
      var bounds = this.getBounds().union( this.localToParentBounds( this.getSafeSelfBounds() ) );

      x = x !== undefined ? x : Math.ceil( padding - bounds.minX );
      y = y !== undefined ? y : Math.ceil( padding - bounds.minY );
      width = width !== undefined ? width : Math.ceil( bounds.getWidth() + 2 * padding );
      height = height !== undefined ? height : Math.ceil( bounds.getHeight() + 2 * padding );

      var canvas = document.createElement( 'canvas' );
      canvas.width = width;
      canvas.height = height;
      var context = canvas.getContext( '2d' );

      // shift our rendering over by the desired amount
      context.translate( x, y );

      // for API compatibility, we apply our own transform here
      this._transform.getMatrix().canvasAppendTransform( context );

      var wrapper = new scenery.CanvasContextWrapper( canvas, context );

      this.renderToCanvasSubtree( wrapper, Matrix3.translation( x, y ).timesMatrix( this._transform.getMatrix() ) );

      callback( canvas, x, y ); // we used to be asynchronous
    },

    /**
     * Renders this node to a Canvas, then calls the callback with the data URI from it.
     * @public
     *
     * @param {Function} callback - callback( dataURI {string}, x, y ) is called, where x,y are computed if not specified.
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toDataURL: function( callback, x, y, width, height ) {
      this.toCanvas( function( canvas, x, y ) {
        // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined
        callback( canvas.toDataURL(), x, y );
      }, x, y, width, height );
    },

    /**
     * Calls the callback with an HTMLImageElement that contains this Node's subtree's visual form.
     * Will always be asynchronous.
     * @public
     *
     * @param {Function} callback - callback( image {HTMLImageElement}, x, y ) is called
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toImage: function( callback, x, y, width, height ) {
      this.toDataURL( function( url, x, y ) {
        // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined
        var img = document.createElement( 'img' );
        img.onload = function() {
          callback( img, x, y );
          try {
            delete img.onload;
          }
          catch( e ) {
            // do nothing
          } // fails on Safari 5.1
        };
        img.src = url;
      }, x, y, width, height );
    },

    /**
     * Calls the callback with an Image node that contains this Node's subtree's visual form. This is always
     * asynchronous, but the resulting image node can be used with any back-end (Canvas/WebGL/SVG/etc.)
     * @public
     *
     * @param {Function} callback - callback( imageNode {Image} ) is called
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toImageNodeAsynchronous: function( callback, x, y, width, height ) {
      this.toImage( function( image, x, y ) {
        callback( new scenery.Node( {
          children: [
            new scenery.Image( image, { x: -x, y: -y } )
          ]
        } ) );
      }, x, y, width, height );
    },

    /**
     * Calls the callback with an Image node that contains this Node's subtree's visual form. This is always
     * synchronous, but the resulting image node can ONLY used with Canvas/WebGL (NOT SVG).
     * @public
     *
     * @param {Function} callback - callback( imageNode {Image} ) is called
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toCanvasNodeSynchronous: function( x, y, width, height ) {
      var result;
      this.toCanvas( function( canvas, x, y ) {
        result = new scenery.Node( {
          children: [
            new scenery.Image( canvas, { x: -x, y: -y } )
          ]
        } );
      }, x, y, width, height );
      assert && assert( result, 'toCanvasNodeSynchronous requires that the node can be rendered only using Canvas' );
      return result;
    },

    /**
     * Calls the callback with a Node that contains this Node's subtree's visual form. This is always
     * synchronous, but the resulting node will not have the correct bounds immediately (that will be asynchronous).
     * @public
     *
     * TODO: set initialWidth/initialHeight so that we have the bounds immediately?
     *
     * @param {Function} callback - callback( imageNode {Image} ) is called
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toDataURLNodeSynchronous: function( x, y, width, height ) {
      var result;
      this.toDataURL( function( dataURL, x, y ) {
        result = new scenery.Node( {
          children: [
            new scenery.Image( dataURL, { x: -x, y: -y } )
          ]
        } );
      }, x, y, width, height );
      assert && assert( result, 'toDataURLNodeSynchronous requires that the node can be rendered only using Canvas' );
      return result;
    },

    /*---------------------------------------------------------------------------*
     * Instance handling
     *----------------------------------------------------------------------------*/

    /**
     * Returns a reference to the instances array.
     * @public (scenery-internal)
     *
     * @returns {Array.<Instance>}
     */
    getInstances: function() {
      return this._instances;
    },
    get instances() { return this.getInstances(); },

    /**
     * Adds an Instance reference to our array.
     * @public (scenery-internal)
     *
     * @param {Instance} instance
     */
    addInstance: function( instance ) {
      assert && assert( instance instanceof scenery.Instance );
      this._instances.push( instance );
    },

    /**
     * Removes an Instance reference from our array.
     * @public (scenery-internal)
     *
     * @param {Instance} instance
     */
    removeInstance: function( instance ) {
      assert && assert( instance instanceof scenery.Instance );
      var index = _.indexOf( this._instances, instance );
      assert && assert( index !== -1, 'Cannot remove a Instance from a Node if it was not there' );
      this._instances.splice( index, 1 );
    },

    /*---------------------------------------------------------------------------*
     * Accessible Instance handling
     *----------------------------------------------------------------------------*/

    /**
     * Returns a reference to the accessible instances array.
     * @public (scenery-internal)
     *
     * @returns {Array.<AccessibleInstance>}
     */
    getAccessibleInstances: function() {
      return this._accessibleInstances;
    },
    get accessibleInstances() { return this.getAccessibleInstances(); },

    /**
     * Adds an AccessibleInstance reference to our array.
     * @public (scenery-internal)
     *
     * @param {AccessibleInstance} accessibleInstance
     */
    addAccessibleInstance: function( accessibleInstance ) {
      assert && assert( accessibleInstance instanceof scenery.AccessibleInstance );
      this._accessibleInstances.push( accessibleInstance );
    },

    /**
     * Removes an AccessibleInstance reference from our array.
     * @public (scenery-internal)
     *
     * @param {AccessibleInstance} accessibleInstance
     */
    removeAccessibleInstance: function( accessibleInstance ) {
      assert && assert( accessibleInstance instanceof scenery.AccessibleInstance );
      var index = _.indexOf( this._accessibleInstances, accessibleInstance );
      assert && assert( index !== -1, 'Cannot remove an AccessibleInstance from a Node if it was not there' );
      this._accessibleInstances.splice( index, 1 );
    },

    /*---------------------------------------------------------------------------*
     * Display handling
     *----------------------------------------------------------------------------*/

    /**
     * Returns a reference to the display array.
     * @public (scenery-internal)
     *
     * @returns {Array.<Display>}
     */
    getRootedDisplays: function() {
      return this._rootedDisplays;
    },
    get rootedDisplays() { return this.getRootedDisplays(); },

    /**
     * Adds an display reference to our array.
     * @public (scenery-internal)
     *
     * @param {Display} display
     */
    addRootedDisplay: function( display ) {
      assert && assert( display instanceof scenery.Display );
      this._rootedDisplays.push( display );
    },

    /**
     * Removes a Display reference from our array.
     * @public (scenery-internal)
     *
     * @param {Display} display
     */
    removeRootedDisplay: function( display ) {
      assert && assert( display instanceof scenery.Display );
      var index = _.indexOf( this._rootedDisplays, display );
      assert && assert( index !== -1, 'Cannot remove a Display from a Node if it was not there' );
      this._rootedDisplays.splice( index, 1 );
    },

    /*---------------------------------------------------------------------------*
     * Coordinate transform methods
     *----------------------------------------------------------------------------*/

    /**
     * Returns a point transformed from our local coordinate frame into our parent coordinate frame. Applies our node's
     * transform to it.
     * @public
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    localToParentPoint: function( point ) {
      return this._transform.transformPosition2( point );
    },

    /**
     * Returns bounds transformed from our local coordinate frame into our parent coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * @param   unds2} bounds
     * @returns {Bounds2}
     */
    localToParentBounds: function( bounds ) {
      return this._transform.transformBounds2( bounds );
    },

    /**
     * Returns a point transformed from our parent coordinate frame into our local coordinate frame. Applies the inverse
     * of our node's transform to it.
     * @public
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    parentToLocalPoint: function( point ) {
      return this._transform.inversePosition2( point );
    },

    /**
     * Returns bounds transformed from our parent coordinate frame into our local coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    parentToLocalBounds: function( bounds ) {
      return this._transform.inverseBounds2( bounds );
    },

    /**
     * A mutable-optimized form of localToParentBounds() that will modify the provided bounds, transforming it from our
     * local coordinate frame to our parent coordinate frame.
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2} - The same bounds object.
     */
    transformBoundsFromLocalToParent: function( bounds ) {
      return bounds.transform( this._transform.getMatrix() );
    },

    /**
     * A mutable-optimized form of parentToLocalBounds() that will modify the provided bounds, transforming it from our
     * parent coordinate frame to our local coordinate frame.
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2} - The same bounds object.
     */
    transformBoundsFromParentToLocal: function( bounds ) {
      return bounds.transform( this._transform.getInverse() );
    },

    /**
     * Returns a new matrix (fresh copy) that would transform points from our local coordinate frame to the global
     * coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @returns {Matrix3}
     */
    getLocalToGlobalMatrix: function() {
      var node = this;

      // we need to apply the transformations in the reverse order, so we temporarily store them
      var matrices = [];

      // concatenation like this has been faster than getting a unique trail, getting its transform, and applying it
      while ( node ) {
        matrices.push( node._transform.getMatrix() );
        assert && assert( node._parents[ 1 ] === undefined, 'getLocalToGlobalMatrix unable to work for DAG' );
        node = node._parents[ 0 ];
      }

      var matrix = Matrix3.identity(); // will be modified in place

      // iterate from the back forwards (from the root node to here)
      for ( var i = matrices.length - 1; i >= 0; i-- ) {
        matrix.multiplyMatrix( matrices[ i ] );
      }

      // NOTE: always return a fresh copy, getGlobalToLocalMatrix depends on it to minimize instance usage!
      return matrix;
    },

    /**
     * Returns a Transform3 that would transform things from our local coordinate frame to the global coordinate frame.
     * Equivalent to getUniqueTrail().getTransform(), but faster.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @returns {Transform3}
     */
    getUniqueTransform: function() {
      return new Transform3( this.getLocalToGlobalMatrix() );
    },

    /**
     * Returns a new matrix (fresh copy) that would transform points from the global coordinate frame to our local
     * coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @returns {Matrix3}
     */
    getGlobalToLocalMatrix: function() {
      return this.getLocalToGlobalMatrix().invert();
    },

    /**
     * Transforms a point from our local coordinate frame to the global coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    localToGlobalPoint: function( point ) {
      var node = this;
      var resultPoint = point.copy();
      while ( node ) {
        // in-place multiplication
        node._transform.getMatrix().multiplyVector2( resultPoint );
        assert && assert( node._parents[ 1 ] === undefined, 'localToGlobalPoint unable to work for DAG' );
        node = node._parents[ 0 ];
      }
      return resultPoint;
    },

    /**
     * Transforms a point from the global coordinate frame to our local coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    globalToLocalPoint: function( point ) {
      var node = this;
      // TODO: performance: test whether it is faster to get a total transform and then invert (won't compute individual inverses)

      // we need to apply the transformations in the reverse order, so we temporarily store them
      var transforms = [];
      while ( node ) {
        transforms.push( node._transform );
        assert && assert( node._parents[ 1 ] === undefined, 'globalToLocalPoint unable to work for DAG' );
        node = node._parents[ 0 ];
      }

      // iterate from the back forwards (from the root node to here)
      var resultPoint = point.copy();
      for ( var i = transforms.length - 1; i >= 0; i-- ) {
        // in-place multiplication
        transforms[ i ].getInverse().multiplyVector2( resultPoint );
      }
      return resultPoint;
    },

    /**
     * Transforms bounds from our local coordinate frame to the global coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    localToGlobalBounds: function( bounds ) {
      // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations
      // it also seems to be a bit faster this way
      return bounds.transformed( this.getLocalToGlobalMatrix() );
    },

    /**
     * Transforms bounds from the global coordinate frame to our local coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    globalToLocalBounds: function( bounds ) {
      // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations
      return bounds.transformed( this.getGlobalToLocalMatrix() );
    },

    /**
     * Transforms a point from our parent coordinate frame to the global coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    parentToGlobalPoint: function( point ) {
      assert && assert( this.parents.length <= 1, 'parentToGlobalPoint unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].localToGlobalPoint( point ) : point;
    },

    /**
     * Transforms bounds from our parent coordinate frame to the global coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    parentToGlobalBounds: function( bounds ) {
      assert && assert( this.parents.length <= 1, 'parentToGlobalBounds unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].localToGlobalBounds( bounds ) : bounds;
    },

    /**
     * Transforms a point from the global coordinate frame to our parent coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    globalToParentPoint: function( point ) {
      assert && assert( this.parents.length <= 1, 'globalToParentPoint unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].globalToLocalPoint( point ) : point;
    },

    /**
     * Transforms bounds from the global coordinate frame to our parent coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    globalToParentBounds: function( bounds ) {
      assert && assert( this.parents.length <= 1, 'globalToParentBounds unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].globalToLocalBounds( bounds ) : bounds;
    },

    /**
     * Returns a bounding box for this Node (and its sub-tree) in the global coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @returns {Bounds2}
     */
    getGlobalBounds: function() {
      assert && assert( this.parents.length <= 1, 'globalBounds unable to work for DAG' );
      return this.parentToGlobalBounds( this.getBounds() );
    },
    get globalBounds() { return this.getGlobalBounds(); },

    /**
     * Returns the bounds of any other node in our local coordinate frame.
     *
     * NOTE: If this node or the passed in node have multiple instances (e.g. this or one ancestor has two parents), it will fail
     * with an assertion.
     *
     * TODO: Possible to be well-defined and have multiple instances of each.
     *
     * @param {Node} node
     * @returns {Bounds2}
     */
    boundsOf: function( node ) {
      return this.globalToLocalBounds( node.getGlobalBounds() );
    },

    /**
     * Returns the bounds of this node in another node's local coordinate frame.
     *
     * NOTE: If this node or the passed in node have multiple instances (e.g. this or one ancestor has two parents), it will fail
     * with an assertion.
     *
     * TODO: Possible to be well-defined and have multiple instances of each.
     *
     * @param {Node} node
     * @returns {Bounds2}
     */
    boundsTo: function( node ) {
      return node.globalToLocalBounds( this.getGlobalBounds() );
    },

    /*---------------------------------------------------------------------------*
     * Drawable handling
     *----------------------------------------------------------------------------*/

    /**
     * Adds the drawable to our list of drawables to notify of visual changes.
     * @public (scenery-internal)
     *
     * @param {Drawable} drawable
     */
    attachDrawable: function( drawable ) {
      this._drawables.push( drawable );
      return this; // allow chaining
    },

    /**
     * Removes the drawable from our list of drawables to notify of visual changes.
     * @public (scenery-internal)
     *
     * @param {Drawable} drawable
     */
    detachDrawable: function( drawable ) {
      var index = _.indexOf( this._drawables, drawable );

      assert && assert( index >= 0, 'Invalid operation: trying to detach a non-referenced drawable' );

      this._drawables.splice( index, 1 ); // TODO: replace with a remove() function
      return this;
    },

    /**
     * Scans the options object for key names that correspond to ES5 setters or other setter functions, and calls those
     * with the values.
     * @public
     *
     * For example:
     *
     * node.mutate( { top: 0, left: 5 } );
     *
     * will be equivalent to:
     *
     * node.left = 5;
     * node.top = 0;
     *
     * In particular, note that the order is different. Mutators will be applied in the order of _mutatorKeys, which can
     * be added to by subtypes.
     *
     * Additionally, some keys are actually direct function names, like 'scale'. mutate( { scale: 2 } ) will call
     * node.scale( 2 ) instead of activating an ES5 setter directly.
     *
     * @param {Object} [options]
     */
    mutate: function( options ) {
      if ( !options ) {
        return this;
      }

      if ( assert ) {
        assert && assert( _.filter( [ 'translation', 'x', 'left', 'right', 'centerX', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom', 'centerBottom', 'rightBottom' ], function( key ) { return options[ key ] !== undefined; } ).length <= 1,
          'More than one mutation on this Node set the x component, check ' + Object.keys( options ).join( ',' ) );

        assert && assert( _.filter( [ 'translation', 'y', 'top', 'bottom', 'centerY', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom', 'centerBottom', 'rightBottom' ], function( key ) { return options[ key ] !== undefined; } ).length <= 1,
          'More than one mutation on this Node set the y component, check ' + Object.keys( options ).join( ',' ) );
      }

      var node = this;

      _.each( this._mutatorKeys, function( key ) {
        if ( options[ key ] !== undefined ) {
          var descriptor = Object.getOwnPropertyDescriptor( Node.prototype, key );

          // if the key refers to a function that is not ES5 writable, it will execute that function with the single argument
          if ( descriptor && typeof descriptor.value === 'function' ) {
            node[ key ]( options[ key ] );
          }
          else {
            node[ key ] = options[ key ];
          }
        }
      } );

      return this; // allow chaining
    },

    /**
     * Override for extra information in the debugging output
     * @protected (scenery-internal)
     */
    getDebugHTMLExtras: function() {
      return '';
    },

    /**
     * Returns a debugging string that is an attempted serialization of this node's sub-tree.
     * @public
     *
     * @param {string} spaces - Whitespace to add
     * @param {boolean} [includeChildren]
     */
    toString: function( spaces, includeChildren ) {
      spaces = spaces || '';
      var props = this.getPropString( spaces + '  ', includeChildren === undefined ? true : includeChildren );
      return spaces + this.getBasicConstructor( props ? ( '\n' + props + '\n' + spaces ) : '' );
    },

    /**
     * Returns a constructor template for toString(). Meant to be overridden by subtypes.
     * @protected (scenery-internal)
     *
     * @param {string} propLines - What is included.
     */
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Node( {' + propLines + '} )';
    },

    /**
     * Returns the property object string for use with toString(). Meant to be overridden to add subtype-specific types.
     * @protected (scenery-internal)
     *
     * @param {string} spaces - Whitespace to add
     * @param {boolean} [includeChildren]
     */
    getPropString: function( spaces, includeChildren ) {
      var result = '';

      function addProp( key, value, nowrap ) {
        if ( result ) {
          result += ',\n';
        }
        if ( !nowrap && typeof value === 'string' ) {
          result += spaces + key + ': \'' + value + '\'';
        }
        else {
          result += spaces + key + ': ' + value;
        }
      }

      if ( this._children.length && includeChildren ) {
        var childString = '';
        _.each( this._children, function( child ) {
          if ( childString ) {
            childString += ',\n';
          }
          childString += child.toString( spaces + '  ' );
        } );
        addProp( 'children', '[\n' + childString + '\n' + spaces + ']', true );
      }

      // direct copy props
      if ( this.cursor ) { addProp( 'cursor', this.cursor ); }
      if ( !this.visible ) { addProp( 'visible', this.visible ); }
      if ( this.pickable !== null ) { addProp( 'pickable', this.pickable ); }
      if ( this.opacity !== 1 ) { addProp( 'opacity', this.opacity ); }

      if ( !this.transform.isIdentity() ) {
        var m = this.transform.getMatrix();
        addProp( 'matrix', 'dot.Matrix3.createFromPool(' +
                           m.m00() + ', ' + m.m01() + ', ' + m.m02() + ', ' +
                           m.m10() + ', ' + m.m11() + ', ' + m.m12() + ', ' +
                           m.m20() + ', ' + m.m21() + ', ' + m.m22() + ' )', true );
      }

      if ( this.renderer ) {
        addProp( 'renderer', this.renderer );
        if ( this.rendererOptions ) {
          // addProp( 'rendererOptions', JSON.stringify( this.rendererOptions ), true );
        }
      }

      if ( this._hints.layerSplit ) {
        addProp( 'layerSplit', true );
      }

      return result;
    },

    /**
     * Performs checks to see if the internal state of Instance references is correct at a certain point in/after the
     * Display's updateDisplay().
     * @private
     */
    auditInstanceSubtreeForDisplay: function( display ) {
      if ( assertSlow ) {
        var numInstances = this._instances.length;
        for ( var i = 0; i < numInstances; i++ ) {
          var instance = this._instances[ i ];
          if ( instance.display === display ) {
            assertSlow( instance.trail.isValid(),
              'Invalid trail on Instance: ' + instance.toString() + ' with trail ' + instance.trail.toString() );
          }
        }

        // audit all of the children
        this.children.forEach( function( child ) {
          child.auditInstanceSubtreeForDisplay( display );
        } );
      }
    },

    /*---------------------------------------------------------------------------*
     * Compatibility with old events API (now using axon.Events)
     *----------------------------------------------------------------------------*/

    /**
     * @deprecated, please use node.on( eventName, listener) instead.
     * Adds a listener for a specific event name.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    addEventListener: function( eventName, listener ) {
      // can't guarantee static with old usage
      return this.on( eventName, listener );
    },

    /**
     * @deprecated, please use node.off( eventName, listener) instead.
     * Removes a listener for a specific event name.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    removeEventListener: function( eventName, listener ) {
      // can't guarantee static with old usage
      return this.off( eventName, listener );
    },

    /**
     * @deprecated, please use node.hasListener( eventName, listener) instead.
     * Checks for the presence of a listener for a specific event name.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    containsEventListener: function( eventName, listener ) {
      return this.hasListener( eventName, listener );
    },

    /**
     * Tracks when an event listener is added, so that we can prune hit testing for performance.
     * @private
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    onEventListenerAdded: function( eventName, listener ) {
      if ( eventName in eventsRequiringBoundsValidation ) {
        this.changeBoundsEventCount( 1 );
        this._boundsEventSelfCount++;
      }
    },

    /**
     * Tracks when an event listener is removed, so that we can prune hit testing for performance.
     * @private
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    onEventListenerRemoved: function( eventName, listener ) {
      if ( eventName in eventsRequiringBoundsValidation ) {
        this.changeBoundsEventCount( -1 );
        this._boundsEventSelfCount--;
      }
    }

  }, Events.prototype, {
    /**
     * Adds a listener for a specific event name. Overridden so we can track specific types of listeners.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    on: function onOverride( eventName, listener ) {
      Events.prototype.on.call( this, eventName, listener );
      this.onEventListenerAdded( eventName, listener );
    },

    /**
     * Adds a listener for a specific event name, that guarantees it won't trigger changes to the listener list when
     * the listener is called. Overridden so we can track specific types of listeners.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    onStatic: function onStaticOverride( eventName, listener ) {
      Events.prototype.onStatic.call( this, eventName, listener );
      this.onEventListenerAdded( eventName, listener );
    },

    /**
     * Removes a listener for a specific event name. Overridden so we can track specific types of listeners.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    off: function offOverride( eventName, listener ) {
      var index = Events.prototype.off.call( this, eventName, listener );
      assert && assert( index >= 0, 'Node.off was called but no listener was removed' );
      this.onEventListenerRemoved( eventName, listener );
      return index;
    },

    /**
     * Removes a listener for a specific event name, that guarantees it won't trigger changes to the listener list when
     * the listener is called. Overridden so we can track specific types of listeners.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    offStatic: function offStaticOverride( eventName, listener ) {
      var index = Events.prototype.offStatic.call( this, eventName, listener );
      assert && assert( index >= 0, 'Node.offStatic was called but no listener was removed' );
      this.onEventListenerRemoved( eventName, listener );
      return index;
    }
  } ) );


  /*
   * Convenience locations
   * @public
   *
   * Upper is in terms of the visual layout in Scenery and other programs, so the minY is the "upper", and minY is the "lower"
   *
   *             left (x)     centerX        right
   *          ---------------------------------------
   * top  (y) | leftTop     centerTop     rightTop
   * centerY  | leftCenter  center        rightCenter
   * bottom   | leftBottom  centerBottom  rightBottom
   */

  // assumes the getterMethod is the same for Node and Bounds2
  function addBoundsVectorGetterSetter( getterMethod, setterMethod, propertyName ) {
    Node.prototype[ getterMethod ] = function() {
      return this.getBounds()[ getterMethod ]();
    };

    Node.prototype[ setterMethod ] = function( value ) {
      assert && assert( value instanceof Vector2 );

      this.translate( value.minus( this[ getterMethod ]() ), true );
      return this; // allow chaining
    };

    // ES5 getter and setter
    Object.defineProperty( Node.prototype, propertyName, {
      set: Node.prototype[ setterMethod ],
      get: Node.prototype[ getterMethod ]
    } );
  }

  // @public
  // arguments are more explicit so text-searches will hopefully identify this code.
  addBoundsVectorGetterSetter( 'getLeftTop', 'setLeftTop', 'leftTop' );
  addBoundsVectorGetterSetter( 'getCenterTop', 'setCenterTop', 'centerTop' );
  addBoundsVectorGetterSetter( 'getRightTop', 'setRightTop', 'rightTop' );
  addBoundsVectorGetterSetter( 'getLeftCenter', 'setLeftCenter', 'leftCenter' );
  addBoundsVectorGetterSetter( 'getCenter', 'setCenter', 'center' );
  addBoundsVectorGetterSetter( 'getRightCenter', 'setRightCenter', 'rightCenter' );
  addBoundsVectorGetterSetter( 'getLeftBottom', 'setLeftBottom', 'leftBottom' );
  addBoundsVectorGetterSetter( 'getCenterBottom', 'setCenterBottom', 'centerBottom' );
  addBoundsVectorGetterSetter( 'getRightBottom', 'setRightBottom', 'rightBottom' );

  /*
   * This is an array of property (setter) names for Node.mutate(), which are also used when creating nodes with
   * parameter objects.
   * @protected
   *
   * E.g. new scenery.Node( { x: 5, rotation: 20 } ) will create a Path, and apply setters in the order below
   * (node.x = 5; node.rotation = 20)
   *
   * The order below is important! Don't change this without knowing the implications.
   * NOTE: translation-based mutators come before rotation/scale, since typically we think of their operations occuring
   * "after" the rotation / scaling
   * NOTE: left/right/top/bottom/centerX/centerY are at the end, since they rely potentially on rotation / scaling
   * changes of bounds that may happen beforehand
   */
  Node.prototype._mutatorKeys = [
    'children', 'cursor', 'visible', 'pickable', 'opacity', 'matrix', 'translation', 'x', 'y', 'rotation', 'scale',
    'localBounds',
    'maxWidth', 'maxHeight', 'leftTop', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom',
    'centerBottom', 'rightBottom', 'left', 'right', 'top', 'bottom', 'centerX', 'centerY', 'renderer',
    'rendererOptions', 'layerSplit', 'usesOpacity', 'cssTransform', 'excludeInvisible', 'webglScale', 'preventFit',
    'mouseArea', 'touchArea', 'clipArea', 'transformBounds', 'focusable', 'focusIndicator', 'accessibleContent',
    'accessibleOrder', 'textDescription'
  ];

  return Node;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Scans through potential properties on an object to detect prefixed forms, and returns the first match.
 *
 * E.g. currently:
 * phetCore.detectPrefix( document.createElement( 'div' ).style, 'transform' ) === 'webkitTransform'
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/detectPrefix',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  // @returns the best String str where obj[str] !== undefined, or returns undefined if that is not available
  function detectPrefix( obj, name ) {
    if ( obj[ name ] !== undefined ) { return name; }

    // prepare for camelCase
    name = name.charAt( 0 ).toUpperCase() + name.slice( 1 );

    // Chrome planning to not introduce prefixes in the future, hopefully we will be safe
    if ( obj[ 'moz' + name ] !== undefined ) { return 'moz' + name; }
    if ( obj[ 'Moz' + name ] !== undefined ) { return 'Moz' + name; } // some prefixes seem to have all-caps?
    if ( obj[ 'webkit' + name ] !== undefined ) { return 'webkit' + name; }
    if ( obj[ 'ms' + name ] !== undefined ) { return 'ms' + name; }
    if ( obj[ 'o' + name ] !== undefined ) { return 'o' + name; }
    return undefined;
  }

  phetCore.register( 'detectPrefix', detectPrefix );

  return detectPrefix;
} );
// Copyright 2013-2015, University of Colorado Boulder


/**
 * Feature detection
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Features',['require','PHET_CORE/detectPrefix','SCENERY/scenery'],function( require ) {
  'use strict';

  var detectPrefix = require( 'PHET_CORE/detectPrefix' );
  var scenery = require( 'SCENERY/scenery' );

  var Features = {};
  scenery.register( 'Features', Features );

  function supportsDataURLFormatOutput( format ) {
    try {
      var canvas = document.createElement( 'canvas' );
      canvas.width = 1;
      canvas.height = 1;
      var context = canvas.getContext( '2d' );
      context.fillStyle = 'black';
      context.fillRect( 0, 0, 1, 1 );
      var url = canvas.toDataURL( [ format ] );

      var target = 'data:' + format;
      // var pngFallback = 'data:image/png';

      return url.slice( 0, target.length ) === target;
    }
    catch( e ) {
      return false;
    }
  }

  function supportsDataURLFormatOrigin( name, black1x1Url ) {
    var canvas = document.createElement( 'canvas' );
    canvas.width = 1;
    canvas.height = 1;
    var context = canvas.getContext( '2d' );

    var img = document.createElement( 'img' );
    img.crossOrigin = 'Anonymous'; // maybe setting the CORS attribute will help?

    var loadCall = function() {
      try {
        context.drawImage( img, 0, 0 );
        canvas.toDataURL();
        Features[ name ] = true;
      }
      catch( e ) {
        Features[ name ] = false;
      }
    };
    img.onload = loadCall;
    try {
      img.src = black1x1Url;
      if ( img.complete ) {
        loadCall();
      }
    }
    catch( e ) {
      Features[ name ] = false;
    }
  }

  Features.canvasPNGOutput = supportsDataURLFormatOutput( 'image/png' );
  Features.canvasJPEGOutput = supportsDataURLFormatOutput( 'image/jpeg' );
  Features.canvasGIFOutput = supportsDataURLFormatOutput( 'image/gif' );
  Features.canvasICONOutput = supportsDataURLFormatOutput( 'image/x-icon' );

  // 1x1 black output from Chrome Canvas in PNG
  supportsDataURLFormatOrigin( 'canvasPNGInput', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==' );

  // 1x1 black output from Chrome Canvas in JPEG
  supportsDataURLFormatOrigin( 'canvasJPEGInput', 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD8qqKKKAP/2Q==' );

  /*
   * This is from the following SVG:
   *
   * <?xml version="1.0"?>
   * <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewport="0 0 1 1" width="1" height="1" >
   *   <rect x="0" y="0" width="1" height="1" rx="0" ry="0" style="fill: black; stroke: none;"></rect>
   * </svg>
   */
  supportsDataURLFormatOrigin( 'canvasSVGInput', 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3cG9ydD0iMCAwIDEgMSIgd2lkdGg9IjEiIGhlaWdodD0iMSIgPg0KICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiByeD0iMCIgcnk9IjAiIHN0eWxlPSJmaWxsOiBibGFjazsgc3Ryb2tlOiBub25lOyI+PC9yZWN0Pg0KPC9zdmc+DQo=' );

  // 1x1 black output from Photoshop in GIF
  supportsDataURLFormatOrigin( 'canvasGIFInput', 'data:image/gif;base64,R0lGODlhAQABAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAABAAEAAAICRAEAOw==' );

  // canvas prefixed names
  var canvas = document.createElement( 'canvas' );
  var ctx = canvas.getContext( '2d' );
  Features.toDataURLHD = detectPrefix( canvas, 'toDataURLHD' );
  Features.createImageDataHD = detectPrefix( ctx, 'createImageDataHD' );
  Features.getImageDataHD = detectPrefix( ctx, 'getImageDataHD' );
  Features.putImageDataHD = detectPrefix( ctx, 'putImageDataHD' );
  Features.currentTransform = detectPrefix( ctx, 'currentTransform' );

  var span = document.createElement( 'span' );
  var div = document.createElement( 'div' );
  Features.textStroke = detectPrefix( span.style, 'textStroke' );
  Features.textStrokeColor = detectPrefix( span.style, 'textStrokeColor' );
  Features.textStrokeWidth = detectPrefix( span.style, 'textStrokeWidth' );

  Features.transform = detectPrefix( div.style, 'transform' );
  Features.transformOrigin = detectPrefix( div.style, 'transformOrigin' );
  Features.backfaceVisibility = detectPrefix( div.style, 'backfaceVisibility' );
  Features.borderRadius = detectPrefix( div.style, 'borderRadius' );

  Features.userSelect = detectPrefix( div.style, 'userSelect' );
  Features.touchAction = detectPrefix( div.style, 'touchAction' );
  Features.touchCallout = detectPrefix( div.style, 'touchCallout' );
  Features.userDrag = detectPrefix( div.style, 'userDrag' );
  Features.tapHighlightColor = detectPrefix( div.style, 'tapHighlightColor' );

  Features.fontSmoothing = detectPrefix( div.style, 'fontSmoothing' );

  Features.requestAnimationFrame = detectPrefix( window, 'requestAnimationFrame' );
  Features.cancelAnimationFrame = detectPrefix( window, 'cancelAnimationFrame' );

  // e.g. Features.setStyle( domElement, Features.transform, '...' ), and doesn't set it if no 'transform' attribute (prefixed or no) is found
  Features.setStyle = function( domElement, optionalKey, value ) {
    if ( optionalKey !== undefined ) {
      domElement.style[ optionalKey ] = value;
    }
  };

  return Features;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Something that can be displayed with a specific renderer.
 * NOTE: Drawables are assumed to be pooled with PoolableMixin, as freeToPool() is called.
 *
 * A drawable's life-cycle starts with its initialization (calling initializeDrawable once), and ends with its disposal
 * (where it is freed to its own pool).
 *
 * Drawables are part of an unordered drawable "tree" where each drawable can have a parent references. This is used
 * for, among other things, propagation of 'dirty' flags and usage during stitching.
 *
 * Blocks and backbones (sub-types of Drawable) contain children (creating a tree, although shared caches make it more
 * like a DAG). Our Scenery Display is built from a root backbone, that contains blocks. This can be Canvas/SVG, but
 * may also contain a DOM block with another backbone (used for opacity, CSS transforms, etc.).
 *
 * Drawables are part of two inherent linked lists: an "old" and a "new" one. Usually they are the same, but during
 * updates, the "new" linked list is changed to accomodate any changes, and then a stitch process is done to mark which
 * block (parent) we will belong to.
 *
 * As part of stitching or other processes, a Drawable is responsible for recording its pending state changes. Most
 * notably, we need to determine whether a drawable is being added, moved, or removed in the next frame. This is done
 * with an idempotent API using notePendingAddition/notePendingRemoval/notePendingMove. Either:
 *   - One or more notePendingMove() calls are made. When we are updated with updateBlock(), we will move to the
 *     last block referenced with notePendingMove() (which may be a no-op if it is the same block).
 *   - Zero or one notePendingAddition() call is made, and zero or one notePendingRemoval() call is made. Our action is:
 *     - No addition, no removal: nothing done
 *     - No addition, one removal: We are removed from our last block (and then presumably disposed later)
 *     - One addition, no removal: We are added to our new (pending) block, without being removed from anything
 *     - One addition, one removal: We are removed from our last block and added to our new (pending) block.
 * It is set up so that the order of addition/removal calls doesn't matter, since these can occur from within different
 * backbone stitches (removed in one, added in another, or with the order reversed). Our updateBlocks() is guaranteed
 * to be called after all of those have been completed.
 *
 * APIs for drawable types:
 *
 * DOM: {
 *   domElement: {HTMLElement}
 * }
 * Canvas: {
 *   paintCanvas: function( {CanvasContextWrapper} wrapper, {Node} node )
 * }
 * SVG: {
 *   svgElement: {SVGElement}
 * }
 * WebGL: {
 *   onAddToBlock: function( {WebGLBlock} block )
 *   onRemoveFromBlock: function( {WebGLBlock} block )
 *   render: function( {ShaderProgram} shaderProgram )
 *   shaderAttributes: {string[]} - names of vertex attributes to be used
 * }
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Drawable',['require','PHET_CORE/inherit','AXON/Events','SCENERY/scenery','SCENERY/display/Renderer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );

  var globalId = 1;

  function Drawable( renderer ) {
    this.initializeDrawable( renderer );
  }

  scenery.register( 'Drawable', Drawable );

  inherit( Events, Drawable, {
    initializeDrawable: function( renderer ) {
      Events.call( this );

      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );

      // unique ID for drawables
      this.id = this.id || globalId++;

      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] initialize ' + this.toString() );

      this.cleanDrawable();

      this.renderer = renderer;

      this.dirty = true;
      this.disposed = false;

      this.linksDirty = false;

      this._visible = true; // {boolean}, ES5 getter/setter provided

      // {boolean} - If false, will cause our parent block to not be fitted. (ES5 getter/setter provided)
      this._fittable = true;

      return this;
    },

    cleanDrawable: function() {
      // what drawble we are being rendered (or put) into (will be filled in later)
      this.parentDrawable = null;
      this.backbone = null; // a backbone reference (if applicable).

      this.pendingParentDrawable = null; // what our parent drawable will be after the stitch is finished
      this.pendingBackbone = null;       // what our backbone will be after the stitch is finished (if applicable)
      this.pendingAddition = false;      // whether we are to be added to a block/backbone in our updateBlock() call
      this.pendingRemoval = false;       // whether we are to be removed from a block/backbone in our updateBlock() call

      assert && assert( !this.previousDrawable && !this.nextDrawable,
        'By cleaning (disposal or fresh creation), we should have disconnected from the linked list' );

      // linked list handling (will be filled in later)
      this.previousDrawable = null;
      this.nextDrawable = null;

      // similar but without recent changes, so that we can traverse both orders at the same time for stitching
      this.oldPreviousDrawable = null;
      this.oldNextDrawable = null;

      this.removeAllEventListeners();
    },

    setVisible: function( visible ) {
      if ( this._visible !== visible ) {
        this._visible = visible;
        this.trigger0( 'visibility' );
      }
    },
    set visible( value ) { this.setVisible( value ); },

    isVisible: function() {
      return this._visible;
    },
    get visible() { return this.isVisible(); },

    // Should be called just after initialization (before being added to blocks) if we aren't fittable.
    setFittable: function( fittable ) {
      if ( this._fittable !== fittable ) {
        this._fittable = fittable;
        this.trigger1( 'fittability', this );
      }
    },
    set fittable( value ) { this.setFittable( value ); },

    isFittable: function() {
      return this._fittable;
    },
    get fittable() { return this.isFittable(); },

    // called to add a block (us) as a child of a backbone
    setBlockBackbone: function( backboneInstance ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] setBlockBackbone ' +
                                                                this.toString() + ' with ' + backboneInstance.toString() );

      // if this is being called, Block will be guaranteed to be loaded
      assert && assert( this instanceof scenery.Block );

      this.parentDrawable = backboneInstance;
      this.backbone = backboneInstance;
      this.pendingParentDrawable = backboneInstance;
      this.pendingBackbone = backboneInstance;
      this.pendingAddition = false;
      this.pendingRemoval = false;
    },

    notePendingAddition: function( display, block, backbone ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingAddition ' +
                                                                this.toString() + ' with ' + block.toString() + ', ' +
                                                                ( backbone ? backbone.toString() : '-' ) );

      assert && assert( backbone !== undefined, 'backbone can be either null or a backbone' );
      assert && assert( block instanceof scenery.Block );

      this.pendingParentDrawable = block;
      this.pendingBackbone = backbone;
      this.pendingAddition = true;

      // if we weren't already marked for an update, mark us
      if ( !this.pendingRemoval ) {
        display.markDrawableChangedBlock( this );
      }
    },

    notePendingRemoval: function( display ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingRemoval ' +
                                                                this.toString() );

      this.pendingRemoval = true;

      // if we weren't already marked for an update, mark us
      if ( !this.pendingAddition ) {
        display.markDrawableChangedBlock( this );
      }
    },

    // moving a drawable that isn't changing backbones, just potentially changing its block.
    // it should not have notePendingAddition or notePendingRemoval called on it.
    notePendingMove: function( display, block ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingMove ' +
                                                                this.toString() + ' with ' + block.toString() );

      assert && assert( block instanceof scenery.Block );

      this.pendingParentDrawable = block;

      if ( !this.pendingRemoval || !this.pendingAddition ) {
        display.markDrawableChangedBlock( this );
      }

      // set both flags, since we need it to be removed and added
      this.pendingAddition = true;
      this.pendingRemoval = true;
    },

    // returns {Boolean} whether we changed our block
    updateBlock: function() {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] updateBlock ' + this.toString() +
                                                                ' with add:' + this.pendingAddition +
                                                                ' remove:' + this.pendingRemoval +
                                                                ' old:' + ( this.parentDrawable ? this.parentDrawable.toString() : '-' ) +
                                                                ' new:' + ( this.pendingParentDrawable ? this.pendingParentDrawable.toString() : '-' ) );
      sceneryLog && sceneryLog.Drawable && sceneryLog.push();

      var changed = false;

      if ( this.pendingRemoval || this.pendingAddition ) {
        // we are only unchanged if we have an addition AND removal, and the endpoints are identical
        changed = !this.pendingRemoval || !this.pendingAddition ||
                  this.parentDrawable !== this.pendingParentDrawable ||
                  this.backbone !== this.pendingBackbone;

        if ( changed ) {
          if ( this.pendingRemoval ) {
            sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'removing from ' + this.parentDrawable.toString() );
            this.parentDrawable.removeDrawable( this );

            // remove references if we are not being added back in
            if ( !this.pendingAddition ) {
              this.pendingParentDrawable = null;
              this.pendingBackbone = null;
            }
          }

          this.parentDrawable = this.pendingParentDrawable;
          this.backbone = this.pendingBackbone;

          if ( this.pendingAddition ) {
            sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'adding to ' + this.parentDrawable.toString() );
            this.parentDrawable.addDrawable( this );
          }
        }
        else {
          sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'unchanged' );

          if ( this.pendingAddition && Renderer.isCanvas( this.renderer ) ) {
            this.parentDrawable.onPotentiallyMovedDrawable( this );
          }
        }

        this.pendingAddition = false;
        this.pendingRemoval = false;
      }

      sceneryLog && sceneryLog.Drawable && sceneryLog.pop();

      return changed;
    },

    updateLinks: function() {
      this.oldNextDrawable = this.nextDrawable;
      this.oldPreviousDrawable = this.previousDrawable;
      this.linksDirty = false;
    },

    markDirty: function() {
      if ( !this.dirty ) {
        this.dirty = true;

        // TODO: notify what we want to call repaint() later
        if ( this.parentDrawable ) {
          this.parentDrawable.markDirtyDrawable( this );
        }
      }
    },

    // will ensure that after syncTree phase is done, we will have updateLinks() called on us
    markLinksDirty: function( display ) {
      if ( !this.linksDirty ) {
        this.linksDirty = true;
        display.markDrawableForLinksUpdate( this );
      }
    },

    // marks us for disposal in the next phase of updateDisplay(), and disconnects from the linked list
    markForDisposal: function( display ) {
      // as we are marked for disposal, we disconnect from the linked list (so our disposal setting nulls won't cause issues)
      Drawable.disconnectBefore( this, display );
      Drawable.disconnectAfter( this, display );

      display.markDrawableForDisposal( this );
    },

    // disposes immediately, and makes no guarantees about out linked list's state (disconnects).
    disposeImmediately: function( display ) {
      // as we are marked for disposal, we disconnect from the linked list (so our disposal setting nulls won't cause issues)
      Drawable.disconnectBefore( this, display );
      Drawable.disconnectAfter( this, display );

      this.dispose();
    },

    // generally do not call this directly, use markForDisposal (so Display will dispose us), or disposeImmediately.
    dispose: function() {
      assert && assert( !this.disposed, 'We should not re-dispose drawables' );

      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] dispose ' + this.toString() );
      sceneryLog && sceneryLog.Drawable && sceneryLog.push();

      this.cleanDrawable();
      this.disposed = true;

      // for now
      this.freeToPool();

      sceneryLog && sceneryLog.Drawable && sceneryLog.pop();
    },

    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        assertSlow && assertSlow( !this.disposed,
          'If we are being audited, we assume we are in the drawable display tree, and we should not be marked as disposed' );
        assertSlow && assertSlow( this.renderer, 'Should not have a 0 (no) renderer' );

        assertSlow && assertSlow( !this.backbone || this.parentDrawable,
          'If we have a backbone reference, we must have a parentDrawable (our block)' );

        if ( !allowPendingBlock ) {
          assertSlow && assertSlow( !this.pendingAddition );
          assertSlow && assertSlow( !this.pendingRemoval );
          assertSlow && assertSlow( this.parentDrawable === this.pendingParentDrawable,
            'Assure our parent and pending parent match, if we have updated blocks' );
          assertSlow && assertSlow( this.backbone === this.pendingBackbone,
            'Assure our backbone and pending backbone match, if we have updated blocks' );
        }

        if ( !allowPendingList ) {
          assertSlow && assertSlow( this.oldPreviousDrawable === this.previousDrawable,
            'Pending linked-list references should be cleared by now' );
          assertSlow && assertSlow( this.oldNextDrawable === this.nextDrawable,
            'Pending linked-list references should be cleared by now' );
          assertSlow && assertSlow( !this.linksDirty, 'Links dirty flag should be clean' );
        }

        if ( !allowDirty ) {
          assertSlow && assertSlow( !this.dirty,
            'Should not be dirty at this phase, if we are in the drawable display tree' );
        }
      }
    },

    toString: function() {
      return this.constructor.name + '#' + this.id;
    },

    toDetailedString: function() {
      return this.toString();
    }
  } );

  // a,b {Drawable}, connects the two drawables in the linked list, while cutting the previous connection and marking
  // the links for updates.
  Drawable.connectDrawables = function( a, b, display ) {
    // we don't need to do anything if there is no change
    if ( a.nextDrawable !== b ) {
      // touch previous neighbors
      if ( a.nextDrawable ) {
        a.nextDrawable.markLinksDirty( display );
        a.nextDrawable.previousDrawable = null;
      }
      if ( b.previousDrawable ) {
        b.previousDrawable.markLinksDirty( display );
        b.previousDrawable.nextDrawable = null;
      }

      a.nextDrawable = b;
      b.previousDrawable = a;

      // mark these as needing updates
      a.markLinksDirty( display );
      b.markLinksDirty( display );
    }
  };

  Drawable.disconnectBefore = function( a, display ) {
    // we don't need to do anything if there is no change
    if ( a.previousDrawable ) {
      a.markLinksDirty( display );
      a.previousDrawable.markLinksDirty( display );
      a.previousDrawable.nextDrawable = null;
      a.previousDrawable = null;
    }
  };

  Drawable.disconnectAfter = function( a, display ) {
    // we don't need to do anything if there is no change
    if ( a.nextDrawable ) {
      a.markLinksDirty( display );
      a.nextDrawable.markLinksDirty( display );
      a.nextDrawable.previousDrawable = null;
      a.nextDrawable = null;
    }
  };

  // converts a linked list of drawables to an array (useful for debugging/assertion purposes, should not be used in production code)
  Drawable.listToArray = function( firstDrawable, lastDrawable ) {
    var arr = [];

    // assumes we'll hit lastDrawable, otherwise we'll NPE
    for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
      arr.push( drawable );

      if ( drawable === lastDrawable ) {
        break;
      }
    }

    return arr;
  };

  // converts an old linked list of drawables to an array (useful for debugging/assertion purposes, should not be used in production code)
  Drawable.oldListToArray = function( firstDrawable, lastDrawable ) {
    var arr = [];

    // assumes we'll hit lastDrawable, otherwise we'll NPE
    for ( var drawable = firstDrawable; ; drawable = drawable.oldNextDrawable ) {
      arr.push( drawable );

      if ( drawable === lastDrawable ) {
        break;
      }
    }

    return arr;
  };

  return Drawable;
} );

// Copyright 2014, University of Colorado Boulder

/**
 * A specialized drawable for a layer of drawables with the same renderer (basically, it's a Canvas element, SVG
 * element, or some type of DOM container). Doesn't strictly have to have its DOM element used directly (Canvas block
 * used for caches).  This type is abstract, and meant to be subclassed.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Block',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  function Block( display, renderer ) {
    throw new Error( 'Should never be called' );
  }

  scenery.register( 'Block', Block );

  inherit( Drawable, Block, {

    /**
     * @param {Display} display
     * @param {number} renderer
     */
    initializeBlock: function( display, renderer ) {
      this.initializeDrawable( renderer );
      this.display = display;
      this.drawableCount = 0;
      this.used = true; // flag handled in the stitch

      this.firstDrawable = null;
      this.lastDrawable = null;
      this.pendingFirstDrawable = null;
      this.pendingLastDrawable = null;

      // linked-list handling for blocks
      this.previousBlock = null;
      this.nextBlock = null;

      // last set z-index, valid if > 0.
      this.zIndex = 0;

      if ( assertSlow ) {
        this.drawableList = cleanArray( this.drawableList );
      }

      return this;
    },

    dispose: function() {
      assert && assert( this.drawableCount === 0, 'There should be no drawables on a block when it is disposed' );

      // clear references
      this.display = null;
      this.firstDrawable = null;
      this.lastDrawable = null;
      this.pendingFirstDrawable = null;
      this.pendingLastDrawable = null;

      this.previousBlock = null;
      this.nextBlock = null;

      if ( assertSlow ) {
        cleanArray( this.drawableList );
      }

      Drawable.prototype.dispose.call( this );
    },

    addDrawable: function( drawable ) {
      this.drawableCount++;
      this.markDirtyDrawable( drawable );

      if ( assertSlow ) {
        var idx = _.indexOf( this.drawableList, drawable );
        assertSlow && assertSlow( idx === -1, 'Drawable should not be added when it has not been removed' );
        this.drawableList.push( drawable );

        assertSlow && assertSlow( this.drawableCount === this.drawableList.length, 'Count sanity check, to make sure our assertions are not buggy' );
      }
    },

    removeDrawable: function( drawable ) {
      this.drawableCount--;

      if ( assertSlow ) {
        var idx = _.indexOf( this.drawableList, drawable );
        assertSlow && assertSlow( idx !== -1, 'Drawable should be already added when it is removed' );
        this.drawableList.splice( idx, 1 );

        assertSlow && assertSlow( this.drawableCount === this.drawableList.length, 'Count sanity check, to make sure our assertions are not buggy' );
      }
    },

    // @protected
    onIntervalChange: function( firstDrawable, lastDrawable ) {
      // stub, should be filled in with behavior in blocks
    },

    updateInterval: function() {
      if ( this.pendingFirstDrawable !== this.firstDrawable ||
           this.pendingLastDrawable !== this.lastDrawable ) {
        this.onIntervalChange( this.pendingFirstDrawable, this.pendingLastDrawable );

        this.firstDrawable = this.pendingFirstDrawable;
        this.lastDrawable = this.pendingLastDrawable;
      }
    },

    notifyInterval: function( firstDrawable, lastDrawable ) {
      this.pendingFirstDrawable = firstDrawable;
      this.pendingLastDrawable = lastDrawable;

      this.updateInterval();
    },

    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        Drawable.prototype.audit.call( this, allowPendingBlock, allowPendingList, allowDirty );

        var count = 0;

        if ( !allowPendingList ) {

          // audit children, and get a count
          for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
            drawable.audit( allowPendingBlock, allowPendingList, allowDirty );
            count++;
            if ( drawable === this.lastDrawable ) { break; }
          }

          if ( !allowPendingBlock ) {
            assertSlow && assertSlow( count === this.drawableCount, 'drawableCount should match' );

            assertSlow && assertSlow( this.firstDrawable === this.pendingFirstDrawable, 'No pending first drawable' );
            assertSlow && assertSlow( this.lastDrawable === this.pendingLastDrawable, 'No pending last drawable' );

            // scan through to make sure our drawable lists are identical
            for ( var d = this.firstDrawable; d !== null; d = d.nextDrawable ) {
              assertSlow && assertSlow( d.renderer === this.renderer, 'Renderers should match' );
              assertSlow && assertSlow( d.parentDrawable === this, 'This block should be this drawable\'s parent' );
              assertSlow && assertSlow( _.indexOf( this.drawableList, d ) >= 0 );
              if ( d === this.lastDrawable ) { break; }
            }
          }
        }
      }
    }
  } );

  return Block;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * A Block that needs to be fitted to either the screen bounds or other local bounds. This potentially reduces memory
 * usage and can make graphical operations in the browser faster, yet if the fit is rapidly changing could cause
 * performance degradation.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/FittedBlock',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','SCENERY/scenery','SCENERY/display/Block'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var scenery = require( 'SCENERY/scenery' );
  var Block = require( 'SCENERY/display/Block' );

  var scratchBounds2 = Bounds2.NOTHING.copy();

  function FittedBlock( display, renderer, transformRootInstance ) {
    this.initialize( display, renderer, transformRootInstance );
  }

  scenery.register( 'FittedBlock', FittedBlock );

  inherit( Block, FittedBlock, {
    initializeFittedBlock: function( display, renderer, transformRootInstance, preferredFit ) {
      this.initializeBlock( display, renderer );

      this.transformRootInstance = transformRootInstance;

      assert && assert( typeof transformRootInstance.isDisplayRoot === 'boolean' );
      this.canBeFullDisplay = transformRootInstance.isDisplayRoot;

      assert && assert( preferredFit === FittedBlock.FULL_DISPLAY || preferredFit === FittedBlock.COMMON_ANCESTOR );

      // @private {FittedBlock.Fit} - Our preferred fit IF we can be fitted. Our fit can fall back if something's unfittable.
      this.preferredFit = preferredFit;

      // @protected {FittedBlock.Fit} - Our current fitting method.
      this.fit = preferredFit;

      this.dirtyFit = true;
      this.dirtyFitListener = this.dirtyFitListener || this.markDirtyFit.bind( this );
      this.commonFitInstance = null; // filled in if COMMON_ANCESTOR
      this.fitBounds = Bounds2.NOTHING.copy(); // tracks the "tight" bounds for fitting, not the actually-displayed bounds
      this.oldFitBounds = Bounds2.NOTHING.copy(); // copy for storage
      this.fitOffset = new Vector2();

      // {number} - Number of child drawables that are marked as unfittable.
      this.unfittableDrawableCount = 0;

      this.fittableListener = this.onFittabilityChange.bind( this );

      // TODO: improve how we handle graphical acceleration with transforms
      this.forceAcceleration = false;

      // now we always add a listener to the display size to invalidate our fit
      this.display.onStatic( 'displaySize', this.dirtyFitListener );

      // TODO: add count of boundsless objects?
      return this;
    },

    /**
     * Changes the current fit, if it's currently different from the argument.
     * @private
     *
     * @param {FittedBlock.Fit} fit
     */
    setFit: function( fit ) {
      // We can't allow full-display fits sometimes
      if ( !this.canBeFullDisplay && fit === FittedBlock.FULL_DISPLAY ) {
        fit = FittedBlock.COMMON_ANCESTOR;
      }

      if ( this.fit !== fit ) {
        this.fit = fit;

        // updateFit() needs to be called in the repaint phase
        this.markDirtyFit();

        // Reset the oldFitBounds so that any updates that check bounds changes will update it.
        // TODO: remove duplication here with updateFit()
        this.oldFitBounds.set( Bounds2.NOTHING );

        // If we switched to the common-ancestor fit, we need to compute the common-ancestor instance.
        if ( fit === FittedBlock.COMMON_ANCESTOR && this.firstDrawable && this.lastDrawable ) {
          this.updateCommonAncestorInstance( this.firstDrawable, this.lastDrawable );
        }
      }
    },

    markDirtyFit: function() {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyFit on FittedBlock#' + this.id );
      this.dirtyFit = true;

      // Make sure we are visited in the repaint phase
      this.markDirty();
    },

    /*
     * Should be called from update() whenever this block is dirty
     */
    updateFit: function() {
      assert && assert( this.fit === FittedBlock.FULL_DISPLAY || this.fit === FittedBlock.COMMON_ANCESTOR,
        'Unsupported fit' );

      // check to see if we don't need to re-fit
      if ( !this.dirtyFit && this.fit === FittedBlock.FULL_DISPLAY ) {
        return;
      }

      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( 'updateFit #' + this.id );

      this.dirtyFit = false;

      // If our fit WAS common-ancestor and our common fit instance's subtree as something unfittable, switch to
      // full-display fit.
      if ( this.fit === FittedBlock.COMMON_ANCESTOR &&
           this.commonFitInstance.fittability.subtreeUnfittableCount > 0 &&
           this.canBeFullDisplay ) {
        // Reset the oldFitBounds so that any updates that check bounds changes will update it.
        this.oldFitBounds.set( Bounds2.NOTHING );

        this.fit = FittedBlock.FULL_DISPLAY;
      }

      if ( this.fit === FittedBlock.FULL_DISPLAY ) {
        this.setSizeFullDisplay();
      }
      else if ( this.fit === FittedBlock.COMMON_ANCESTOR ) {
        assert && assert( this.commonFitInstance.trail.length >= this.transformRootInstance.trail.length );

        // will trigger bounds validation (for now) until we have a better way of handling this
        this.fitBounds.set( this.commonFitInstance.node.getLocalBounds() );

        // walk it up, transforming so it is relative to our transform root
        var instance = this.commonFitInstance;
        while ( instance !== this.transformRootInstance ) {
          // shouldn't infinite loop, we'll null-pointer beforehand unless something is seriously wrong
          this.fitBounds.transform( instance.node.getMatrix() );
          instance = instance.parent;
        }

        this.fitBounds.roundOut();
        this.fitBounds.dilate( 4 ); // for safety, modify in the future

        // ensure that our fitted bounds don't go outside of our display's bounds (see https://github.com/phetsims/scenery/issues/390)
        if ( this.transformRootInstance.isDisplayRoot ) {
          // Only apply this effect if our transform root is the display root. Otherwise we might be transformed, and
          // this could cause buggy situations. See https://github.com/phetsims/scenery/issues/454
          scratchBounds2.setMinMax( 0, 0, this.display.width, this.display.height );
          this.fitBounds.constrainBounds( scratchBounds2 );
        }

        if ( !this.fitBounds.isValid() ) {
          this.fitBounds.setMinMax( 0, 0, 0, 0 );
        }

        if ( !this.fitBounds.equals( this.oldFitBounds ) ) {
          // store our copy for future checks (and do it before we modify this.fitBounds)
          this.oldFitBounds.set( this.fitBounds );

          this.setSizeFitBounds();
        }
      }
      else {
        throw new Error( 'unknown fit' );
      }
    },

    setSizeFullDisplay: function() {
      // override in subtypes, use this.display.getSize()
    },

    setSizeFitBounds: function() {
      // override in subtypes, use this.fitBounds
    },

    setCommonFitInstance: function( instance ) {
      if ( instance !== this.commonFitInstance ) {
        if ( this.commonFitInstance ) {
          this.commonFitInstance.fittability.subtreeFittabilityChange.removeListener( this.dirtyFitListener );
        }
        this.commonFitInstance = instance;
        if ( this.commonFitInstance ) {
          this.commonFitInstance.fittability.subtreeFittabilityChange.addListener( this.dirtyFitListener );
        }
      }
    },

    dispose: function() {
      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( 'dispose #' + this.id );

      this.display.offStatic( 'displaySize', this.dirtyFitListener );

      this.setCommonFitInstance( null );

      // clear references
      this.transformRootInstance = null;

      Block.prototype.dispose.call( this );
    },

    /**
     * @override
     * Track the fittability of the added drawable.
     *
     * @param {Drawable} drawable
     */
    addDrawable: function( drawable ) {
      Block.prototype.addDrawable.call( this, drawable );

      drawable.onStatic( 'fittability', this.fittableListener );

      if ( !drawable.fittable ) {
        this.incrementUnfittable();
      }
    },

    /**
     * @override
     * Stop tracking the fittability of the removed drawable.
     *
     * @param {Drawable} drawable
     */
    removeDrawable: function( drawable ) {
      Block.prototype.removeDrawable.call( this, drawable );

      drawable.offStatic( 'fittability', this.fittableListener );

      if ( !drawable.fittable ) {
        this.decrementUnfittable();
      }
    },

    /**
     * Called from the fittability listener attached to child drawables when their fittability changes.
     * @private
     *
     * @param {Drawable} drawable
     */
    onFittabilityChange: function( drawable ) {
      assert && assert( drawable.parentDrawable === this );

      if ( drawable.isFittable() ) {
        this.decrementUnfittable();
      }
      else {
        this.incrementUnfittable();
      }
    },

    /**
     * The number of unfittable child drawables was increased by 1.
     * @private
     */
    incrementUnfittable: function() {
      this.unfittableDrawableCount++;

      if ( this.unfittableDrawableCount === 1 ) {
        this.checkFitConstraints();
      }
    },

    /**
     * The number of unfittable child drawables was decreased by 1.
     * @private
     */
    decrementUnfittable: function() {
      this.unfittableDrawableCount--;

      if ( this.unfittableDrawableCount === 0 ) {
        this.checkFitConstraints();
      }
    },

    /**
     * Check to make sure we are using the correct current fit.
     * @private
     */
    checkFitConstraints: function() {
      // If we have ANY unfittable drawables, take up the full display.
      if ( this.unfittableDrawableCount > 0 && this.canBeFullDisplay ) {
        this.setFit( FittedBlock.FULL_DISPLAY );
      }
      // Otherwise fall back to our "default"
      else {
        this.setFit( this.preferredFit );
      }
    },

    /**
     * Assuming our first and last drawables have instance references (very likely!), we can identify the leaf-most
     * common ancestor of both the first/last instance. We'll record this instance, so we can use its bounds to fit
     * using the common-ancestor fit strategy.
     * @private
     *
     * @param {Drawable} firstDrawable
     * @param {Drawable} secondDrawable
     */
    updateCommonAncestorInstance: function( firstDrawable, lastDrawable ) {
      assert && assert( firstDrawable.instance && lastDrawable.instance,
        'For common-ancestor fits, we need the first and last drawables to have direct instance references' );

      var firstInstance = firstDrawable.instance;
      var lastInstance = lastDrawable.instance;

      // walk down the longest one until they are a common length
      var minLength = Math.min( firstInstance.trail.length, lastInstance.trail.length );
      while ( firstInstance.trail.length > minLength ) {
        firstInstance = firstInstance.parent;
      }
      while ( lastInstance.trail.length > minLength ) {
        lastInstance = lastInstance.parent;
      }

      // step down until they match
      while ( firstInstance !== lastInstance ) {
        firstInstance = firstInstance.parent;
        lastInstance = lastInstance.parent;
      }

      this.setCommonFitInstance( firstInstance );
      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( '   common fit instance: ' + this.commonFitInstance.toString() );

      assert && assert( this.commonFitInstance.trail.length >= this.transformRootInstance.trail.length );
    },

    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );

      Block.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );

      // if we use a common ancestor fit, find the common ancestor instance
      if ( this.fit === FittedBlock.COMMON_ANCESTOR ) {
        this.updateCommonAncestorInstance( firstDrawable, lastDrawable );
        this.markDirtyFit();
      }
    }
  } );

  // Defines the FittedBlock.Fit enumeration type.
  FittedBlock.FULL_DISPLAY = 1;
  FittedBlock.COMMON_ANCESTOR = 2;

  FittedBlock.fitString = {
    1: 'fullDisplay',
    2: 'commonAncestor'
  };

  return FittedBlock;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * General utility functions for Scenery
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Util',['require','SCENERY/scenery','DOT/Matrix3','DOT/Transform3','DOT/Bounds2','DOT/Vector2','SCENERY/util/Features'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Features = require( 'SCENERY/util/Features' );

  // convenience function
  function p( x, y ) {
    return new Vector2( x, y );
  }

  // TODO: remove flag and tests after we're done
  var debugChromeBoundsScanning = false;

  // detect properly prefixed transform and transformOrigin properties
  var transformProperty = Features.transform;
  var transformOriginProperty = Features.transformOrigin || 'transformOrigin'; // fallback, so we don't try to set an empty string property later

  var Util = {
    /*---------------------------------------------------------------------------*
     * Transformation Utilities (TODO: separate file)
     *---------------------------------------------------------------------------*/

    /**
     * @deprecated (bad performance since it is setting multiple properties). see applyPreparedTransform
     * Applies the transformation matrix to the passed-in DOM element via a CSS transform.
     * @public
     *
     * @param {Matrix3} matrix - Assumed to be affine
     * @param {DOMElement} element - Any DOM element
     * @param {boolean} forceAcceleration - Whether to add flags to force graphical acceleration (can slow things down!)
     */
    applyCSSTransform: function( matrix, element, forceAcceleration ) {
      var transformCSS = matrix.getCSSTransform();
      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/

      if ( forceAcceleration ) {
        element.style.webkitBackfaceVisibility = 'hidden';
        transformCSS += ' translateZ(0)';
      }

      element.style[ transformProperty ] = transformCSS;
      element.style[ transformOriginProperty ] = 'top left'; //OHTWO TODO: performance: this only needs to be set once!
    },

    /**
     * Prepares a DOM element for use with applyPreparedTransform(). Applies some CSS styles that are required, but
     * that we don't want to set while animating.
     * @public
     *
     * @param {DOMElement} element
     * @param {boolean} forceAcceleration - Whether graphical acceleration should be forced (may slow things down!)
     */
    prepareForTransform: function( element, forceAcceleration ) {
      element.style[ transformOriginProperty ] = 'top left';
      if ( forceAcceleration ) {
        scenery.Util.setTransformAcceleration( element );
      }
      else {
        scenery.Util.unsetTransformAcceleration( element );
      }
    },

    /**
     * Apply CSS styles that will potentially trigger graphical acceleration. Use at your own risk.
     * @private
     *
     * @param {DOMElement} element
     */
    setTransformAcceleration: function( element ) {
      element.style.webkitBackfaceVisibility = 'hidden';
    },

    /**
     * Unapply CSS styles (from setTransformAcceleration) that would potentially trigger graphical acceleration.
     * @private
     *
     * @param {DOMElement} element
     */
    unsetTransformAcceleration: function( element ) {
      element.style.webkitBackfaceVisibility = '';
    },

    /**
     * Applies the CSS transform of the matrix to the element, with optional forcing of acceleration.
     * NOTE: prepareForTransform should be called at least once on the element before this method is used.
     * @public
     *
     * @param {Matrix3} matrix
     * @param {DOMElement} element
     * @param {boolean} forceAcceleration
     */
    applyPreparedTransform: function( matrix, element, forceAcceleration ) {
      // NOTE: not applying translateZ, see http://stackoverflow.com/questions/10014461/why-does-enabling-hardware-acceleration-in-css3-slow-down-performance
      element.style[ transformProperty ] = matrix.getCSSTransform();
    },

    /**
     * Applies a CSS transform value string to a DOM element.
     * NOTE: prepareForTransform should be called at least once on the element before this method is used.
     * @public
     *
     * @param {string} transformString
     * @param {DOMElement} element
     * @param {boolean} forceAcceleration
     */
    setTransform: function( transformString, element, forceAcceleration ) {
      assert && assert( typeof transformString === 'string' );

      element.style[ transformProperty ] = transformString;
    },

    /**
     * Removes a CSS transform from a DOM element.
     * @public
     *
     * @param {DOMElement} element
     */
    unsetTransform: function( element ) {
      element.style[ transformProperty ] = '';
    },

    /**
     * Ensures that window.requestAnimationFrame and window.cancelAnimationFrame use a native implementation if possible,
     * otherwise using a simple setTimeout internally. See https://github.com/phetsims/scenery/issues/426
     * @public
     */
    polyfillRequestAnimationFrame: function() {
      if ( !window.requestAnimationFrame || !window.cancelAnimationFrame ) {
        // Fallback implementation if no prefixed version is available
        if ( !Features.requestAnimationFrame || !Features.cancelAnimationFrame ) {
          window.requestAnimationFrame = function( callback ) {
            var timeAtStart = Date.now();

            return window.setTimeout( function() {
              callback( Date.now() - timeAtStart );
            }, 16 );
          };
          window.cancelAnimationFrame = clearTimeout;
        }
        // Fill in the non-prefixed names with the prefixed versions
        else {
          window.requestAnimationFrame = window[ Features.requestAnimationFrame ];
          window.cancelAnimationFrame = window[ Features.cancelAnimationFrame ];
        }
      }
    },

    /**
     * Returns the relative size of the context's backing store compared to the actual Canvas. For example, if it's 2,
     * the backing store has 2x2 the amount of pixels (4 times total).
     * @public
     *
     * @param {CanvasRenderingContext2D | WebGLRenderingContext} context
     * @returns {number} The backing store pixel ratio.
     */
    backingStorePixelRatio: function( context ) {
      return context.webkitBackingStorePixelRatio ||
             context.mozBackingStorePixelRatio ||
             context.msBackingStorePixelRatio ||
             context.oBackingStorePixelRatio ||
             context.backingStorePixelRatio || 1;
    },

    /**
     * Returns the scaling factor that needs to be applied for handling a HiDPI Canvas
     * See see http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html#//apple_ref/doc/uid/TP40010542-CH2-SW5
     * And it's updated based on http://www.html5rocks.com/en/tutorials/canvas/hidpi/
     * @public
     *
     * @param {CanvasRenderingContext2D | WebGLRenderingContext} context
     * @returns {number}
     */
    backingScale: function( context ) {
      if ( 'devicePixelRatio' in window ) {
        var backingStoreRatio = Util.backingStorePixelRatio( context );

        return window.devicePixelRatio / backingStoreRatio;
      }
      return 1;
    },

    /*---------------------------------------------------------------------------*
     * Text bounds utilities (TODO: separate file)
     *---------------------------------------------------------------------------*/

    /**
     * Given a data snapshot and transform, calculate range on how large / small the bounds can be. It's
     * very conservative, with an effective 1px extra range to allow for differences in anti-aliasing
     * for performance concerns, this does not support skews / rotations / anything but translation and scaling
     * @public
     *
     * @param {ImageData} imageData
     * @param {number} resolution
     * @param {Transform3} transform
     */
    scanBounds: function( imageData, resolution, transform ) {

      // entry will be true if any pixel with the given x or y value is non-rgba(0,0,0,0)
      var dirtyX = _.map( _.range( resolution ), function() { return false; } );
      var dirtyY = _.map( _.range( resolution ), function() { return false; } );

      for ( var x = 0; x < resolution; x++ ) {
        for ( var y = 0; y < resolution; y++ ) {
          var offset = 4 * ( y * resolution + x );
          if ( imageData.data[ offset ] !== 0 || imageData.data[ offset + 1 ] !== 0 || imageData.data[ offset + 2 ] !== 0 || imageData.data[ offset + 3 ] !== 0 ) {
            dirtyX[ x ] = true;
            dirtyY[ y ] = true;
          }
        }
      }

      var minX = _.indexOf( dirtyX, true );
      var maxX = _.lastIndexOf( dirtyX, true );
      var minY = _.indexOf( dirtyY, true );
      var maxY = _.lastIndexOf( dirtyY, true );

      // based on pixel boundaries. for minBounds, the inner edge of the dirty pixel. for maxBounds, the outer edge of the adjacent non-dirty pixel
      // results in a spread of 2 for the identity transform (or any translated form)
      var extraSpread = resolution / 16; // is Chrome antialiasing really like this? dear god... TODO!!!
      return {
        minBounds: new Bounds2(
          ( minX < 1 || minX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( minX + 1 + extraSpread, 0 ) ).x,
          ( minY < 1 || minY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, minY + 1 + extraSpread ) ).y,
          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( maxX - extraSpread, 0 ) ).x,
          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, maxY - extraSpread ) ).y
        ),
        maxBounds: new Bounds2(
          ( minX < 1 || minX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( minX - 1 - extraSpread, 0 ) ).x,
          ( minY < 1 || minY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, minY - 1 - extraSpread ) ).y,
          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( maxX + 2 + extraSpread, 0 ) ).x,
          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, maxY + 2 + extraSpread ) ).y
        )
      };
    },

    /**
     * Measures accurate bounds of a function that draws things to a Canvas.
     * @public
     *
     * @param {function} renderToContext - Called with the Canvas 2D context as a parameter, should draw to it.
     */
    canvasAccurateBounds: function( renderToContext, options ) {
      // how close to the actual bounds do we need to be?
      var precision = ( options && options.precision ) ? options.precision : 0.001;

      // 512x512 default square resolution
      var resolution = ( options && options.resolution ) ? options.resolution : 128;

      // at 1/16x default, we want to be able to get the bounds accurately for something as large as 16x our initial resolution
      // divisible by 2 so hopefully we avoid more quirks from Canvas rendering engines
      var initialScale = ( options && options.initialScale ) ? options.initialScale : ( 1 / 16 );

      var minBounds = Bounds2.NOTHING;
      var maxBounds = Bounds2.EVERYTHING;

      var canvas = document.createElement( 'canvas' );
      canvas.width = resolution;
      canvas.height = resolution;
      var context = canvas.getContext( '2d' );

      if ( debugChromeBoundsScanning ) {
        $( window ).ready( function() {
          var header = document.createElement( 'h2' );
          $( header ).text( 'Bounds Scan' );
          $( '#display' ).append( header );
        } );
      }

      // TODO: Don't use Transform3 unless it is necessary
      function scan( transform ) {
        // save/restore, in case the render tries to do any funny stuff like clipping, etc.
        context.save();
        transform.matrix.canvasSetTransform( context );
        renderToContext( context );
        context.restore();

        var data = context.getImageData( 0, 0, resolution, resolution );
        var minMaxBounds = Util.scanBounds( data, resolution, transform );

        function snapshotToCanvas( snapshot ) {
          var canvas = document.createElement( 'canvas' );
          canvas.width = resolution;
          canvas.height = resolution;
          var context = canvas.getContext( '2d' );
          context.putImageData( snapshot, 0, 0 );
          $( canvas ).css( 'border', '1px solid black' );
          $( window ).ready( function() {
            //$( '#display' ).append( $( document.createElement( 'div' ) ).text( 'Bounds: ' +  ) );
            $( '#display' ).append( canvas );
          } );
        }

        // TODO: remove after debug
        if ( debugChromeBoundsScanning ) {
          snapshotToCanvas( data );
        }

        context.clearRect( 0, 0, resolution, resolution );

        return minMaxBounds;
      }

      // attempts to map the bounds specified to the entire testing canvas (minus a fine border), so we can nail down the location quickly
      function idealTransform( bounds ) {
        // so that the bounds-edge doesn't land squarely on the boundary
        var borderSize = 2;

        var scaleX = ( resolution - borderSize * 2 ) / ( bounds.maxX - bounds.minX );
        var scaleY = ( resolution - borderSize * 2 ) / ( bounds.maxY - bounds.minY );
        var translationX = -scaleX * bounds.minX + borderSize;
        var translationY = -scaleY * bounds.minY + borderSize;

        return new Transform3( Matrix3.translation( translationX, translationY ).timesMatrix( Matrix3.scaling( scaleX, scaleY ) ) );
      }

      var initialTransform = new Transform3();
      // make sure to initially center our object, so we don't miss the bounds
      initialTransform.append( Matrix3.translation( resolution / 2, resolution / 2 ) );
      initialTransform.append( Matrix3.scaling( initialScale ) );

      var coarseBounds = scan( initialTransform );

      minBounds = minBounds.union( coarseBounds.minBounds );
      maxBounds = maxBounds.intersection( coarseBounds.maxBounds );

      var tempMin;
      var tempMax;
      var refinedBounds;

      // minX
      tempMin = maxBounds.minY;
      tempMax = maxBounds.maxY;
      while ( isFinite( minBounds.minX ) && isFinite( maxBounds.minX ) && Math.abs( minBounds.minX - maxBounds.minX ) > precision ) {
        // use maximum bounds except for the x direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( maxBounds.minX, tempMin, minBounds.minX, tempMax ) ) );

        if ( minBounds.minX <= refinedBounds.minBounds.minX && maxBounds.minX >= refinedBounds.maxBounds.minX ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
            console.log( 'transformed "min" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( minBounds.minX, 0 ) ) );
            console.log( 'transformed "max" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( maxBounds.minX, 0 ) ) );
          }
          break;
        }

        minBounds = minBounds.withMinX( Math.min( minBounds.minX, refinedBounds.minBounds.minX ) );
        maxBounds = maxBounds.withMinX( Math.max( maxBounds.minX, refinedBounds.maxBounds.minX ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
      }

      // maxX
      tempMin = maxBounds.minY;
      tempMax = maxBounds.maxY;
      while ( isFinite( minBounds.maxX ) && isFinite( maxBounds.maxX ) && Math.abs( minBounds.maxX - maxBounds.maxX ) > precision ) {
        // use maximum bounds except for the x direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( minBounds.maxX, tempMin, maxBounds.maxX, tempMax ) ) );

        if ( minBounds.maxX >= refinedBounds.minBounds.maxX && maxBounds.maxX <= refinedBounds.maxBounds.maxX ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }

        minBounds = minBounds.withMaxX( Math.max( minBounds.maxX, refinedBounds.minBounds.maxX ) );
        maxBounds = maxBounds.withMaxX( Math.min( maxBounds.maxX, refinedBounds.maxBounds.maxX ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
      }

      // minY
      tempMin = maxBounds.minX;
      tempMax = maxBounds.maxX;
      while ( isFinite( minBounds.minY ) && isFinite( maxBounds.minY ) && Math.abs( minBounds.minY - maxBounds.minY ) > precision ) {
        // use maximum bounds except for the y direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( tempMin, maxBounds.minY, tempMax, minBounds.minY ) ) );

        if ( minBounds.minY <= refinedBounds.minBounds.minY && maxBounds.minY >= refinedBounds.maxBounds.minY ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }

        minBounds = minBounds.withMinY( Math.min( minBounds.minY, refinedBounds.minBounds.minY ) );
        maxBounds = maxBounds.withMinY( Math.max( maxBounds.minY, refinedBounds.maxBounds.minY ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
      }

      // maxY
      tempMin = maxBounds.minX;
      tempMax = maxBounds.maxX;
      while ( isFinite( minBounds.maxY ) && isFinite( maxBounds.maxY ) && Math.abs( minBounds.maxY - maxBounds.maxY ) > precision ) {
        // use maximum bounds except for the y direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( tempMin, minBounds.maxY, tempMax, maxBounds.maxY ) ) );

        if ( minBounds.maxY >= refinedBounds.minBounds.maxY && maxBounds.maxY <= refinedBounds.maxBounds.maxY ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }

        minBounds = minBounds.withMaxY( Math.max( minBounds.maxY, refinedBounds.minBounds.maxY ) );
        maxBounds = maxBounds.withMaxY( Math.min( maxBounds.maxY, refinedBounds.maxBounds.maxY ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
      }

      if ( debugChromeBoundsScanning ) {
        console.log( 'minBounds: ' + minBounds );
        console.log( 'maxBounds: ' + maxBounds );
      }

      var result = new Bounds2(
        ( minBounds.minX + maxBounds.minX ) / 2,
        ( minBounds.minY + maxBounds.minY ) / 2,
        ( minBounds.maxX + maxBounds.maxX ) / 2,
        ( minBounds.maxY + maxBounds.maxY ) / 2
      );

      // extra data about our bounds
      result.minBounds = minBounds;
      result.maxBounds = maxBounds;
      result.isConsistent = maxBounds.containsBounds( minBounds );
      result.precision = Math.max(
        Math.abs( minBounds.minX - maxBounds.minX ),
        Math.abs( minBounds.minY - maxBounds.minY ),
        Math.abs( minBounds.maxX - maxBounds.maxX ),
        Math.abs( minBounds.maxY - maxBounds.maxY )
      );

      // return the average
      return result;
    },

    /*---------------------------------------------------------------------------*
     * WebGL utilities (TODO: separate file)
     *---------------------------------------------------------------------------*/

    /**
     * Finds the smallest power of 2 that is at least as large as n.
     * @public
     *
     * @param {number} n
     * @returns {number} The smallest power of 2 that is greater than or equal n
     */
    toPowerOf2: function( n ) {
      var result = 1;
      while ( result < n ) {
        result *= 2;
      }
      return result;
    },

    /*
     * Creates and compiles a GLSL Shader object in WebGL.
     * @public
     *
     * @param {WebGLRenderingContext} - WebGL Rendering Context
     * @param {number} type - Should be: gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
     * @param {tring} source - The shader source code.
     */
    createShader: function( gl, source, type ) {
      var shader = gl.createShader( type );
      gl.shaderSource( shader, source );
      gl.compileShader( shader );

      if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
        console.log( 'GLSL compile error:' );
        console.log( gl.getShaderInfoLog( shader ) );
        console.log( source );

        // Normally it would be best to throw an exception here, but a context loss could cause the shader parameter check
        // to fail, and we must handle context loss gracefully between any adjacent pair of gl calls.
        // Therefore, we simply report the errors to the console.  See #279
      }

      return shader;
    },

    /**
     * Check to see whether webgl is supported, using the same strategy as mrdoob and pixi.js
     * @public
     *
     * @param {Array.<string>} [extensions] - A list of WebGL extensions that need to be supported
     * @returns {boolean}
     */
    checkWebGLSupport: function( extensions ) {
      var canvas = document.createElement( 'canvas' );

      var args = { failIfMajorPerformanceCaveat: true };
      try {
        var gl = !!window.WebGLRenderingContext &&
                 ( canvas.getContext( 'webgl', args ) || canvas.getContext( 'experimental-webgl', args ) );

        if ( !gl ) {
          return false;
        }

        if ( extensions ) {
          for ( var i = 0; i < extensions.length; i++ ) {
            if ( gl.getExtension( extensions[ i ] ) === null ) {
              return false;
            }
          }
        }

        return true;
      }
      catch( e ) {
        return false;
      }
    },

    /**
     * Check to see whether IE11 has proper clearStencil support (required for three.js to work well).
     * @public
     *
     * @returns {boolean}
     */
    checkIE11StencilSupport: function() {
      var canvas = document.createElement( 'canvas' );

      try {
        var gl = !!window.WebGLRenderingContext &&
                 ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );

        if ( !gl ) {
          return false;
        }

        // Failure for https://github.com/mrdoob/three.js/issues/3600 / https://github.com/phetsims/molecule-shapes/issues/133
        gl.clearStencil( 0 );
        return gl.getError() === 0;
      }
      catch( e ) {
        return false;
      }
    },

    /**
     * Whether WebGL (with decent performance) is supported by the platform
     * @public {boolean}
     */
    get isWebGLSupported() {
      if ( this._extensionlessWebGLSupport === undefined ) {
        this._extensionlessWebGLSupport = scenery.Util.checkWebGLSupport();
      }
      return this._extensionlessWebGLSupport;
    }
  };
  scenery.register( 'Util', Util );

  return Util;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Handles a visual Canvas layer of drawables.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/CanvasBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','DOT/Vector2','SCENERY/scenery','SCENERY/display/FittedBlock','SCENERY/util/CanvasContextWrapper','SCENERY/display/Renderer','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Vector2 = require( 'DOT/Vector2' );
  var scenery = require( 'SCENERY/scenery' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var CanvasContextWrapper = require( 'SCENERY/util/CanvasContextWrapper' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Util = require( 'SCENERY/util/Util' );

  function CanvasBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }

  scenery.register( 'CanvasBlock', CanvasBlock );

  inherit( FittedBlock, CanvasBlock, {
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.COMMON_ANCESTOR );

      this.filterRootInstance = filterRootInstance;

      this.dirtyDrawables = cleanArray( this.dirtyDrawables );

      if ( !this.domElement ) {
        //OHTWO TODO: support tiled Canvas handling (will need to wrap then in a div, or something)
        this.canvas = document.createElement( 'canvas' );
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = '0';
        this.canvas.style.top = '0';
        this.canvas.style.pointerEvents = 'none';

        // unique ID so that we can support rasterization with Display.foreignObjectRasterization
        this.canvasId = this.canvas.id = 'scenery-canvas' + this.id;

        this.context = this.canvas.getContext( '2d' );

        // workaround for Chrome (WebKit) miterLimit bug: https://bugs.webkit.org/show_bug.cgi?id=108763
        this.context.miterLimit = 20;
        this.context.miterLimit = 10;

        this.wrapper = new CanvasContextWrapper( this.canvas, this.context );

        this.domElement = this.canvas;
      }

      // reset any fit transforms that were applied
      Util.prepareForTransform( this.canvas, this.forceAcceleration );
      Util.unsetTransform( this.canvas ); // clear out any transforms that could have been previously applied

      this.canvasDrawOffset = new Vector2();

      // store our backing scale so we don't have to look it up while fitting
      this.backingScale = ( renderer & Renderer.bitmaskCanvasLowResolution ) ? 1 : scenery.Util.backingScale( this.context );

      this.clipDirtyListener = this.markDirty.bind( this );
      this.filterRootNode = this.filterRootInstance.node;
      this.filterRootNode.onStatic( 'clip', this.clipDirtyListener );

      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'initialized #' + this.id );
      // TODO: dirty list of nodes (each should go dirty only once, easier than scanning all?)

      return this;
    },

    setSizeFullDisplay: function() {
      var size = this.display.getSize();
      this.canvas.width = size.width * this.backingScale;
      this.canvas.height = size.height * this.backingScale;
      this.canvas.style.width = size.width + 'px';
      this.canvas.style.height = size.height + 'px';
      this.wrapper.resetStyles();
      this.canvasDrawOffset.setXY( 0, 0 );
      Util.unsetTransform( this.canvas );
    },

    setSizeFitBounds: function() {
      var x = this.fitBounds.minX;
      var y = this.fitBounds.minY;
      this.canvasDrawOffset.setXY( -x, -y ); // subtract off so we have a tight fit
      //OHTWO TODO PERFORMANCE: see if we can get a speedup by putting the backing scale in our transform instead of with CSS?
      Util.setTransform( 'matrix(1,0,0,1,' + x + ',' + y + ')', this.canvas, this.forceAcceleration ); // reapply the translation as a CSS transform
      this.canvas.width = this.fitBounds.width * this.backingScale;
      this.canvas.height = this.fitBounds.height * this.backingScale;
      this.canvas.style.width = this.fitBounds.width + 'px';
      this.canvas.style.height = this.fitBounds.height + 'px';
      this.wrapper.resetStyles();
    },

    update: function() {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'update #' + this.id );
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.push();

      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }

        // udpate the fit BEFORE drawing, since it may change our offset
        this.updateFit();

        // for now, clear everything!
        this.context.setTransform( 1, 0, 0, 1, 0, 0 ); // identity
        this.context.clearRect( 0, 0, this.canvas.width, this.canvas.height ); // clear everything

        //OHTWO TODO: clipping handling!
        if ( this.filterRootNode.clipArea ) {
          this.context.save();

          this.temporaryRecursiveClip( this.filterRootInstance );
        }

        //OHTWO TODO: PERFORMANCE: create an array for faster drawable iteration (this is probably a hellish memory access pattern)
        //OHTWO TODO: why is "drawable !== null" check needed
        for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
          this.renderDrawable( drawable );
          if ( drawable === this.lastDrawable ) { break; }
        }

        if ( this.filterRootNode.clipArea ) {
          this.context.restore();
          this.wrapper.resetStyles();
        }
      }

      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.pop();
    },

    //OHTWO TODO: rework and do proper clipping support
    temporaryRecursiveClip: function( instance ) {
      if ( instance.parent ) {
        this.temporaryRecursiveClip( instance.parent );
      }
      if ( instance.node.clipArea ) {
        //OHTWO TODO: reduce duplication here
        this.context.setTransform( this.backingScale, 0, 0, this.backingScale, this.canvasDrawOffset.x * this.backingScale, this.canvasDrawOffset.y * this.backingScale );
        instance.relativeTransform.matrix.canvasAppendTransform( this.context );

        // do the clipping
        this.context.beginPath();
        instance.node.clipArea.writeToContext( this.context );
        this.context.clip();
      }
    },

    renderDrawable: function( drawable ) {
      // do not paint invisible drawables
      if ( !drawable.visible ) {
        return;
      }

      // we're directly accessing the relative transform below, so we need to ensure that it is up-to-date
      assert && assert( drawable.instance.relativeTransform.isValidationNotNeeded() );

      var matrix = drawable.instance.relativeTransform.matrix;

      // set the correct (relative to the transform root) transform up, instead of walking the hierarchy (for now)
      //OHTWO TODO: should we start premultiplying these matrices to remove this bottleneck?
      this.context.setTransform( this.backingScale, 0, 0, this.backingScale, this.canvasDrawOffset.x * this.backingScale, this.canvasDrawOffset.y * this.backingScale );
      if ( drawable.instance !== this.transformRootInstance ) {
        matrix.canvasAppendTransform( this.context );
      }

      // paint using its local coordinate frame
      drawable.paintCanvas( this.wrapper, drawable.instance.node );
    },

    dispose: function() {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'dispose #' + this.id );

      this.filterRootNode.offStatic( 'clip', this.clipDirtyListener );
      this.filterRootNode = null;

      // clear references
      this.transformRootInstance = null;
      cleanArray( this.dirtyDrawables );

      // minimize memory exposure of the backing raster
      this.canvas.width = 0;
      this.canvas.height = 0;

      FittedBlock.prototype.dispose.call( this );
    },

    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on CanvasBlock#' + this.id + ' with ' + drawable.toString() );

      assert && assert( drawable );

      if ( assert ) {
        // Catch infinite loops
        this.display.ensureNotPainting();
      }

      // TODO: instance check to see if it is a canvas cache (usually we don't need to call update on our drawables)
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },

    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );

      FittedBlock.prototype.addDrawable.call( this, drawable );
    },

    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );

      FittedBlock.prototype.removeDrawable.call( this, drawable );
    },

    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );

      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );
    },

    onPotentiallyMovedDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.onPotentiallyMovedDrawable ' + drawable.toString() );
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.push();

      assert && assert( drawable.parentDrawable === this );

      // For now, mark it as dirty so that we redraw anything containing it. In the future, we could have more advanced
      // behavior that figures out the intersection-region for what was moved and what it was moved past, but that's
      // a harder problem.
      drawable.markDirty();

      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.pop();
    },

    toString: function() {
      return 'CanvasBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );

  Poolable.mixin( CanvasBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'new from constructor' );
          return new CanvasBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );

  return CanvasBlock;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Code for testing which platform is running.  Use sparingly, if at all!
 *
 * Sample usage:
 * if (platform.firefox) {node.renderer = 'canvas';}
 *
 * @author Sam Reid
 */
define( 'PHET_CORE/platform',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  var ua = navigator.userAgent;

  // Checks to see whether we are IE, and if so whether the version matches.
  function isIE( version ) {
    return getInternetExplorerVersion() === version;
  }

  //IE11 no longer reports MSIE in the user agent string, see https://github.com/phetsims/phet-core/issues/12
  //This code is adapted from http://stackoverflow.com/questions/17907445/how-to-detect-ie11
  function getInternetExplorerVersion() {
    var rv = -1;
    var re = null;
    if ( navigator.appName === 'Microsoft Internet Explorer' ) {
      re = new RegExp( 'MSIE ([0-9]{1,}[.0-9]{0,})' );
      if ( re.exec( ua ) !== null ) {
        rv = parseFloat( RegExp.$1 );
      }
    }
    else if ( navigator.appName === 'Netscape' ) {
      re = new RegExp( 'Trident/.*rv:([0-9]{1,}[.0-9]{0,})' );
      if ( re.exec( ua ) !== null ) {
        rv = parseFloat( RegExp.$1 );
      }
    }
    return rv;
  }

  var platform = {
    // Whether the browser is most likely Firefox
    firefox: ua.toLowerCase().indexOf( 'firefox' ) > -1,

    // Whether the browser is most likely Safari running on iOS
    // See http://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari
    mobileSafari: !!( ua.match( /(iPod|iPhone|iPad)/ ) && ua.match( /AppleWebKit/ ) ),

    // Whether the browser is a matching version of Safari running on OS X
    safari5: !!( ua.match( /Version\/5\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),
    safari6: !!( ua.match( /Version\/6\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),
    safari7: !!( ua.match( /Version\/7\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),

    // Whether the browser is some type of IE (Internet Explorer)
    ie: getInternetExplorerVersion() !== -1,

    // Whether the browser is a specific version of IE (Internet Explorer)
    ie9: isIE( 9 ),
    ie10: isIE( 10 ),
    ie11: isIE( 11 ),

    // Whether the browser has Android in its user agent
    android: ua.indexOf( 'Android' ) > 0,

    // Whether the browser is Microsoft Edge
    edge: !!ua.match( /Edge\// ),

    // Whether the browser is Chromium-based (usually Chrome)
    chromium: (/chrom(e|ium)/).test( ua.toLowerCase() ) && !ua.match( /Edge\// )
  };
  phetCore.register( 'platform', platform );

  return platform;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * PoolableMixin wrapper for SVG <group> elements. We store state and add listeners directly to the corresponding Node, so that we can set dirty flags and
 * smartly update only things that have changed. This takes a load off of SVGBlock.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGGroup',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','PHET_CORE/platform','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );

  function SVGGroup( block, instance, parent ) {
    this.initialize( block, instance, parent );
  }

  scenery.register( 'SVGGroup', SVGGroup );

  inherit( Object, SVGGroup, {
    initialize: function( block, instance, parent ) {
      //OHTWO TODO: add collapsing groups! they can't have self drawables, transforms, filters, etc., and we probably shouldn't de-collapse groups

      this.block = block;
      this.instance = instance;
      this.node = instance.trail.lastNode();
      this.parent = parent;
      this.children = cleanArray( this.children );
      this.hasSelfDrawable = false;
      this.selfDrawable = null; // reference to a self drawable

      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'initializing ' + this.toString() );

      // general dirty flag (triggered on any other dirty event)
      this.dirty = true;

      // we won't listen for transform changes (or even want to set a transform) if our node is beneath a transform root
      this.willApplyTransforms = this.block.transformRootInstance.trail.nodes.length < this.instance.trail.nodes.length;

      // we won't listen for filter changes (or set filters, like opacity or visibility) if our node is beneath a filter root
      this.willApplyFilters = this.block.filterRootInstance.trail.nodes.length < this.instance.trail.nodes.length;

      // transform handling
      this.transformDirty = true;
      this.hasTransform = this.hasTransform !== undefined ? this.hasTransform : false; // persists across disposal
      this.transformDirtyListener = this.transformDirtyListener || this.markTransformDirty.bind( this );
      if ( this.willApplyTransforms ) {
        this.node.onStatic( 'transform', this.transformDirtyListener );
      }

      // filter handling
      this.opacityDirty = true;
      this.visibilityDirty = true;
      this.clipDirty = true;
      this.hasOpacity = this.hasOpacity !== undefined ? this.hasOpacity : false; // persists across disposal
      this.clipDefinition = this.clipDefinition !== undefined ? this.clipDefinition : null; // persists across disposal
      this.clipPath = this.clipPath !== undefined ? this.clipPath : null; // persists across disposal
      this.opacityDirtyListener = this.opacityDirtyListener || this.markOpacityDirty.bind( this );
      this.visibilityDirtyListener = this.visibilityDirtyListener || this.markVisibilityDirty.bind( this );
      this.clipDirtyListener = this.clipDirtyListener || this.markClipDirty.bind( this );
      this.node.onStatic( 'visibility', this.visibilityDirtyListener );
      if ( this.willApplyFilters ) {
        this.node.onStatic( 'opacity', this.opacityDirtyListener );
      }
      //OHTWO TODO: remove clip workaround
      this.node.onStatic( 'clip', this.clipDirtyListener );

      // for tracking the order of child groups, we use a flag and update (reorder) once per updateDisplay if necessary.
      this.orderDirty = true;
      this.orderDirtyListener = this.orderDirtyListener || this.markOrderDirty.bind( this );
      this.node.onStatic( 'childInserted', this.orderDirtyListener );
      this.node.onStatic( 'childRemoved', this.orderDirtyListener );

      if ( !this.svgGroup ) {
        this.svgGroup = document.createElementNS( scenery.svgns, 'g' );
      }

      this.instance.addSVGGroup( this );

      this.block.markDirtyGroup( this ); // so we are marked and updated properly

      return this;
    },

    addSelfDrawable: function( drawable ) {
      this.selfDrawable = drawable;
      this.svgGroup.insertBefore( drawable.svgElement, this.children.length ? this.children[ 0 ].svgGroup : null );
      this.hasSelfDrawable = true;
    },

    removeSelfDrawable: function( drawable ) {
      this.hasSelfDrawable = false;
      this.svgGroup.removeChild( drawable.svgElement );
      this.selfDrawable = null;
    },

    addChildGroup: function( group ) {
      this.markOrderDirty();

      group.parent = this;
      this.children.push( group );
      this.svgGroup.appendChild( group.svgGroup );
    },

    removeChildGroup: function( group ) {
      this.markOrderDirty();

      group.parent = null;
      this.children.splice( _.indexOf( this.children, group ), 1 );
      this.svgGroup.removeChild( group.svgGroup );
    },

    markDirty: function() {
      if ( !this.dirty ) {
        this.dirty = true;

        this.block.markDirtyGroup( this );
      }
    },

    /*---------------------------------------------------------------------------*
     * TODO: reduce filesize by creating these methods programatically. not done yet since I want to ensure correctness and make refactoring easier right now.
     *----------------------------------------------------------------------------*/

    markOrderDirty: function() {
      if ( !this.orderDirty ) {
        this.orderDirty = true;
        this.markDirty();
      }
    },

    markTransformDirty: function() {
      if ( !this.transformDirty ) {
        this.transformDirty = true;
        this.markDirty();
      }
    },

    markOpacityDirty: function() {
      if ( !this.opacityDirty ) {
        this.opacityDirty = true;
        this.markDirty();
      }
    },

    markVisibilityDirty: function() {
      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },

    markClipDirty: function() {
      if ( !this.clipDirty ) {
        this.clipDirty = true;
        this.markDirty();
      }
    },

    update: function() {
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'update: ' + this.toString() );

      // we may have been disposed since being marked dirty on our block. we won't have a reference if we are disposed
      if ( !this.block ) {
        return;
      }

      sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();

      var svgGroup = this.svgGroup;

      this.dirty = false;

      if ( this.transformDirty ) {
        this.transformDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'transform update: ' + this.toString() );

        if ( this.willApplyTransforms ) {

          var isIdentity = this.node.transform.isIdentity();

          if ( !isIdentity ) {
            this.hasTransform = true;
            svgGroup.setAttribute( 'transform', this.node.transform.getMatrix().getSVGTransform() );
          }
          else if ( this.hasTransform ) {
            this.hasTransform = false;
            // IE guard needed since removeAttribute fails, see https://github.com/phetsims/scenery/issues/395
            ( platform.ie9 || platform.ie10 ) ? svgGroup.setAttribute( 'transform', '' ) : svgGroup.removeAttribute( 'transform' );
          }
        }
        else {
          // we want no transforms if we won't be applying transforms
          if ( this.hasTransform ) {
            this.hasTransform = false;
            // IE guard needed since removeAttribute fails, see https://github.com/phetsims/scenery/issues/395
            ( platform.ie9 || platform.ie10 ) ? svgGroup.setAttribute( 'transform', '' ) : svgGroup.removeAttribute( 'transform' );
          }
        }
      }

      if ( this.visibilityDirty ) {
        this.visibilityDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'visibility update: ' + this.toString() );

        svgGroup.style.display = this.node.isVisible() ? '' : 'none';
      }


      if ( this.opacityDirty ) {
        this.opacityDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'opacity update: ' + this.toString() );

        if ( this.willApplyFilters && this.node.opacity !== 1 ) {
          this.hasOpacity = true;
          svgGroup.setAttribute( 'opacity', this.node.opacity );
        }
        else if ( this.hasOpacity ) {
          this.hasOpacity = false;
          svgGroup.removeAttribute( 'opacity' );
        }
      }

      if ( this.clipDirty ) {
        this.clipDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'clip update: ' + this.toString() );

        //OHTWO TODO: remove clip workaround (use this.willApplyFilters)
        if ( this.node.clipArea ) {
          if ( !this.clipDefinition ) {
            var clipId = 'clip' + this.node.getId();

            this.clipDefinition = document.createElementNS( scenery.svgns, 'clipPath' );
            this.clipDefinition.setAttribute( 'id', clipId );
            this.clipDefinition.setAttribute( 'clipPathUnits', 'userSpaceOnUse' );
            this.block.defs.appendChild( this.clipDefinition ); // TODO: method? evaluate with future usage of defs (not done yet)

            this.clipPath = document.createElementNS( scenery.svgns, 'path' );
            this.clipDefinition.appendChild( this.clipPath );

            svgGroup.setAttribute( 'clip-path', 'url(#' + clipId + ')' );
          }

          this.clipPath.setAttribute( 'd', this.node.clipArea.getSVGPath() );
        }
        else if ( this.clipDefinition ) {
          svgGroup.removeAttribute( 'clip-path' );
          this.block.defs.removeChild( this.clipDefinition ); // TODO: method? evaluate with future usage of defs (not done yet)

          // TODO: consider pooling these?
          this.clipDefinition = null;
          this.clipPath = null;
        }
      }

      if ( this.orderDirty ) {
        this.orderDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'order update: ' + this.toString() );
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();

        // our instance should have the proper order of children. we check that way.
        var idx = this.children.length - 1;
        var instanceChildren = this.instance.children;
        // iterate backwards, since DOM's insertBefore makes forward iteration more complicated (no insertAfter)
        for ( var i = instanceChildren.length - 1; i >= 0; i-- ) {
          var group = instanceChildren[ i ].lookupSVGGroup( this.block );
          if ( group ) {
            // ensure that the spot in our array (and in the DOM) at [idx] is correct
            if ( this.children[ idx ] !== group ) {
              // out of order, rearrange
              sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'group out of order: ' + idx + ' for ' + group.toString() );

              // in the DOM first (since we reference the children array to know what to insertBefore)
              // see http://stackoverflow.com/questions/9732624/how-to-swap-dom-child-nodes-in-javascript
              svgGroup.insertBefore( group.svgGroup, idx + 1 >= this.children.length ? null : this.children[ idx + 1 ].svgGroup );

              // then in our children array
              var oldIndex = _.indexOf( this.children, group );
              assert && assert( oldIndex < idx, 'The item we are moving backwards to location [idx] should not have an index greater than that' );
              this.children.splice( oldIndex, 1 );
              this.children.splice( idx, 0, group );
            }
            else {
              sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'group in place: ' + idx + ' for ' + group.toString() );
            }

            // if there was a group for that instance, we move on to the next spot
            idx--;
          }
        }

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
      }

      sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
    },

    isReleasable: function() {
      // if we have no parent, we are the rootGroup (the block is responsible for disposing that one)
      return !this.hasSelfDrawable && !this.children.length && this.parent;
    },

    dispose: function() {
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();

      assert && assert( this.children.length === 0, 'Should be empty by now' );

      if ( this.willApplyTransforms ) {
        this.node.offStatic( 'transform', this.transformDirtyListener );
      }
      this.node.offStatic( 'visibility', this.visibilityDirtyListener );
      if ( this.willApplyFilters ) {
        this.node.offStatic( 'opacity', this.opacityDirtyListener );
      }
      //OHTWO TODO: remove clip workaround
      this.node.offStatic( 'clip', this.clipDirtyListener );

      this.node.offStatic( 'childInserted', this.orderDirtyListener );
      this.node.offStatic( 'childRemoved', this.orderDirtyListener );

      // if our Instance has been disposed, it has already had the reference removed
      if ( this.instance.active ) {
        this.instance.removeSVGGroup( this );
      }

      // remove clipping, since it is defs-based (and we want to keep our defs block clean - could be another layer!)
      if ( this.clipDefinition ) {
        this.svgGroup.removeAttribute( 'clip-path' );
        this.block.defs.removeChild( this.clipDefinition );
        this.clipDefinition = null;
        this.clipPath = null;
      }

      // clear references
      this.parent = null;
      this.block = null;
      this.instance = null;
      this.node = null;
      cleanArray( this.children );
      this.selfDrawable = null;

      // for now
      this.freeToPool();

      sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
    },

    toString: function() {
      return 'SVGGroup:' + this.block.toString() + '_' + this.instance.toString();
    }
  } );

  // @public
  SVGGroup.addDrawable = function( block, drawable ) {
    assert && assert( drawable.instance, 'Instance is required for a drawable to be grouped correctly in SVG' );

    var group = SVGGroup.ensureGroupsToInstance( block, drawable.instance );
    group.addSelfDrawable( drawable );
  };

  // @public
  SVGGroup.removeDrawable = function( block, drawable ) {
    drawable.instance.lookupSVGGroup( block ).removeSelfDrawable( drawable );

    SVGGroup.releaseGroupsToInstance( block, drawable.instance );
  };

  // @private
  SVGGroup.ensureGroupsToInstance = function( block, instance ) {
    // TODO: assertions here

    var group = instance.lookupSVGGroup( block );

    if ( !group ) {
      assert && assert( instance !== block.rootGroup.instance, 'Making sure we do not walk past our rootGroup' );

      var parentGroup = SVGGroup.ensureGroupsToInstance( block, instance.parent );

      group = SVGGroup.createFromPool( block, instance, parentGroup );
      parentGroup.addChildGroup( group );
    }

    return group;
  };

  // @private
  SVGGroup.releaseGroupsToInstance = function( block, instance ) {
    var group = instance.lookupSVGGroup( block );

    if ( group.isReleasable() ) {
      var parentGroup = group.parent;
      parentGroup.removeChildGroup( group );

      SVGGroup.releaseGroupsToInstance( block, parentGroup.instance );

      group.dispose();
    }
  };

  Poolable.mixin( SVGGroup, {
    constructorDuplicateFactory: function( pool ) {
      return function( block, instance, parent ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'new from pool' );
          return pool.pop().initialize( block, instance, parent );
        }
        else {
          sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'new from constructor' );
          return new SVGGroup( block, instance, parent );
        }
      };
    }
  } );

  return SVGGroup;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Handles a visual SVG layer of drawables.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/FittedBlock','SCENERY/display/SVGGroup','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var SVGGroup = require( 'SCENERY/display/SVGGroup' );
  var Util = require( 'SCENERY/util/Util' );

  /**
   * Main constructor for SVGBlock.
   *
   * @param {Display} display - the scenery Display this SVGBlock will appear in
   * @param {number} renderer - the bitmask for the renderer, see Renderer.js
   * @param {Instance} transformRootInstance - TODO: Documentation
   * @param {Instance} filterRootInstance - TODO: Documentation
   * @constructor
   */
  function SVGBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }

  scenery.register( 'SVGBlock', SVGBlock );

  inherit( FittedBlock, SVGBlock, {

    /**
     * Initialize function, which is required since SVGBlock instances are pooled by scenery.
     *
     * @param {Display} display - the scenery Display this SVGBlock will appear in
     * @param {number} renderer - the bitmask for the renderer, see Renderer.js
     * @param {Instance} transformRootInstance - TODO: Documentation
     * @param {Instance} filterRootInstance - TODO: Documentation
     * @returns {FittedBlock}
     */
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.COMMON_ANCESTOR );

      this.filterRootInstance = filterRootInstance;

      this.dirtyGroups = cleanArray( this.dirtyGroups );
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );

      // Keep track of how many times each Paint is used in this SVGBlock so that when all usages have been eliminated
      // we can remove the SVG def from our SVG tree to prevent memory leaks, etc.
      // maps {string} paint.id => { count: {number}, paint: {Paint}, def: {SVGElement} }
      // @private
      this.paintMap = {};

      if ( !this.domElement ) {

        // main SVG element
        this.svg = document.createElementNS( scenery.svgns, 'svg' );
        this.svg.style.position = 'absolute';
        this.svg.style.left = '0';
        this.svg.style.top = '0';

        //OHTWO TODO: why would we clip the individual layers also? Seems like a potentially useless performance loss
        // this.svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
        this.svg.style[ 'pointer-events' ] = 'none';

        // the <defs> block that we will be stuffing gradients and patterns into
        this.defs = document.createElementNS( scenery.svgns, 'defs' );
        this.svg.appendChild( this.defs );

        this.baseTransformGroup = document.createElementNS( scenery.svgns, 'g' );
        this.svg.appendChild( this.baseTransformGroup );

        this.domElement = this.svg;
      }

      // reset what layer fitting can do (this.forceAcceleration set in fitted block initialization)
      Util.prepareForTransform( this.svg, this.forceAcceleration );

      Util.unsetTransform( this.svg ); // clear out any transforms that could have been previously applied
      this.baseTransformGroup.setAttribute( 'transform', '' ); // no base transform

      var instanceClosestToRoot = transformRootInstance.trail.nodes.length > filterRootInstance.trail.nodes.length ?
                                  filterRootInstance : transformRootInstance;

      this.rootGroup = SVGGroup.createFromPool( this, instanceClosestToRoot, null );
      this.baseTransformGroup.appendChild( this.rootGroup.svgGroup );

      // TODO: dirty list of nodes (each should go dirty only once, easier than scanning all?)

      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'initialized #' + this.id );

      return this;
    },

    /*
     * Increases our reference count for the specified {Paint}. If it didn't exist before, we'll add the SVG def to the
     * paint can be referenced by SVG id.
     *
     * @param {Paint} paint
     */
    incrementPaint: function( paint ) {
      assert && assert( paint.isPaint );

      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'incrementPaint ' + this.toString() + ' ' + paint.id );

      if ( this.paintMap.hasOwnProperty( paint.id ) ) {
        this.paintMap[ paint.id ].count++;
      }
      else {
        var def = paint.getSVGDefinition();
        def.setAttribute( 'id', paint.id + '-' + this.id );

        // TODO: reduce allocations?
        this.paintMap[ paint.id ] = {
          count: 1,
          paint: paint,
          def: def
        };

        this.defs.appendChild( def );
      }
    },

    /*
     * Decreases our reference count for the specified {Paint}. If this was the last reference, we'll remove the SVG def
     * from our SVG tree to prevent memory leaks, etc.
     *
     * @param {Paint} paint
     */
    decrementPaint: function( paint ) {
      assert && assert( paint.isPaint );

      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'decrementPaint ' + this.toString() + ' ' + paint.id );

      // since the block may have been disposed (yikes!), we have a defensive set-up here
      if ( this.paintMap.hasOwnProperty( paint.id ) ) {
        var entry = this.paintMap[ paint.id ];
        assert && assert( entry.count >= 1 );

        if ( entry.count === 1 ) {
          this.defs.removeChild( entry.def );
          delete this.paintMap[ paint.id ]; // delete, so we don't memory leak if we run through MANY paints
        }
        else {
          entry.count--;
        }
      }
    },

    markDirtyGroup: function( block ) {
      this.dirtyGroups.push( block );
      this.markDirty();
    },

    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on SVGBlock#' + this.id + ' with ' + drawable.toString() );
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },

    setSizeFullDisplay: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'setSizeFullDisplay #' + this.id );

      var size = this.display.getSize();
      this.svg.setAttribute( 'width', size.width );
      this.svg.setAttribute( 'height', size.height );
    },

    setSizeFitBounds: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'setSizeFitBounds #' + this.id + ' with ' + this.fitBounds.toString() );

      var x = this.fitBounds.minX;
      var y = this.fitBounds.minY;

      assert && assert( isFinite( x ) && isFinite( y ), 'Invalid SVG transform for SVGBlock' );
      assert && assert( this.fitBounds.isValid(), 'Invalid fitBounds' );

      this.baseTransformGroup.setAttribute( 'transform', 'translate(' + (-x) + ',' + (-y) + ')' ); // subtract off so we have a tight fit
      Util.setTransform( 'matrix(1,0,0,1,' + x + ',' + y + ')', this.svg, this.forceAcceleration ); // reapply the translation as a CSS transform
      this.svg.setAttribute( 'width', this.fitBounds.width );
      this.svg.setAttribute( 'height', this.fitBounds.height );
    },

    /**
     * Update the SVGBlock as part of a render step.  Called from Display.updateDisplay => BackboneDrawable.updateDisplay
     */
    update: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'update #' + this.id );

      // TODO: Shouldn't calling update on a disposed SVGBlock be an assertion error?
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        //OHTWO TODO: call here!
        // TODO: What does the above TODO mean?
        while ( this.dirtyGroups.length ) {
          var group = this.dirtyGroups.pop();

          // if this group has been disposed or moved to another block, don't mess with it
          if ( group.block === this ) {
            group.update();
          }
        }
        while ( this.dirtyDrawables.length ) {
          var drawable = this.dirtyDrawables.pop();

          // if this drawable has been disposed or moved to another block, don't mess with it
          // TODO: If it was moved to another block, why might it still appear in our list?  Shouldn't that be an assertion check?
          if ( drawable.parentDrawable === this ) {
            drawable.update();
          }
        }

        // checks will be done in updateFit() to see whether it is needed
        this.updateFit();
      }
    },

    dispose: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'dispose #' + this.id );

      // make it take up zero area, so that we don't use up excess memory
      this.svg.setAttribute( 'width', 0 );
      this.svg.setAttribute( 'height', 0 );

      // clear references
      this.filterRootInstance = null;
      cleanArray( this.dirtyGroups );
      cleanArray( this.dirtyDrawables );
      this.paintMap = {};

      this.baseTransformGroup.removeChild( this.rootGroup.svgGroup );
      this.rootGroup.dispose();
      this.rootGroup = null;

      // since we may not properly remove all defs yet
      while ( this.defs.childNodes.length ) {
        this.defs.removeChild( this.defs.childNodes[ 0 ] );
      }

      FittedBlock.prototype.dispose.call( this );
    },

    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );

      FittedBlock.prototype.addDrawable.call( this, drawable );

      SVGGroup.addDrawable( this, drawable );
      drawable.updateSVGBlock( this );
    },

    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );

      SVGGroup.removeDrawable( this, drawable );

      FittedBlock.prototype.removeDrawable.call( this, drawable );

      // NOTE: we don't unset the drawable's defs here, since it will either be disposed (will clear it)
      // or will be added to another SVGBlock (which will overwrite it)
    },

    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );

      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );
    },

    toString: function() {
      return 'SVGBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );

  Poolable.mixin( SVGBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'new from constructor' );
          return new SVGBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );

  return SVGBlock;
} );

// Copyright 2014-2015, University of Colorado Boulder


/**
 * DOM Drawable wrapper for another DOM Drawable. Used so that we can have our own independent siblings, generally as part
 * of a Backbone's layers/blocks.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/DOMBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Block'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Block = require( 'SCENERY/display/Block' );

  function DOMBlock( display, domDrawable ) {
    this.initialize( display, domDrawable );
  }

  scenery.register( 'DOMBlock', DOMBlock );

  inherit( Block, DOMBlock, {
    initialize: function( display, domDrawable ) {
      // TODO: is it bad to pass the acceleration flags along?
      this.initializeBlock( display, domDrawable.renderer );

      this.domDrawable = domDrawable;
      this.domElement = domDrawable.domElement;

      return this;
    },

    dispose: function() {
      this.domDrawable = null;
      this.domElement = null;

      // super call
      Block.prototype.dispose.call( this );
    },

    update: function() {
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        this.domDrawable.update();
      }
    },

    markDirtyDrawable: function( drawable ) {
      this.markDirty();
    },

    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.DOMBlock && sceneryLog.DOMBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );
      assert && assert( this.domDrawable === drawable, 'DOMBlock should only be used with one drawable for now (the one it was initialized with)' );

      Block.prototype.addDrawable.call( this, drawable );
    },

    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.DOMBlock && sceneryLog.DOMBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );
      assert && assert( this.domDrawable === drawable, 'DOMBlock should only be used with one drawable for now (the one it was initialized with)' );

      Block.prototype.removeDrawable.call( this, drawable );
    }
  } );

  Poolable.mixin( DOMBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, domDrawable ) {
        if ( pool.length ) {
          return pool.pop().initialize( display, domDrawable );
        }
        else {
          return new DOMBlock( display, domDrawable );
        }
      };
    }
  } );

  return DOMBlock;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Given a rectangular containing area, takes care of allocating and deallocating smaller rectangular "bins" that fit
 * together inside the area and do not overlap. Optimized more for runtime CPU usage than space currently.
 *
 * For example:
 * #begin canvasExample binPacker 256x256
 * #on
 * var binPacker = new dot.BinPacker( new dot.Bounds2( 0, 0, 256, 256 ) );
 * var bins = [];
 * for ( var i = 0; i < 100; i++ ) {
 *   var bin = binPacker.allocate( Math.random() * 64, Math.random() * 64 );
 *   if ( bin ) {
 *     bins.push( bin );
 *   }
 * }
 * #off
 *
 * context.strokeStyle = '#000';
 * bins.forEach( function( bin ) {
 *   var bounds = bin.bounds;
 *   context.strokeRect( bounds.x, bounds.y, bounds.width, bounds.height );
 * } );
 * #end canvasExample
 *
 * @author Sharfudeen Ashraf
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'DOT/BinPacker',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
  'use strict';

  // modules
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );

  /**
   * Creates a BinPacker with the specified containing bounds.
   * @public
   * @constructor
   *
   * @param {Bounds2} bounds - The available bounds to pack bins inside.
   */
  function BinPacker( bounds ) {
    this.rootBin = new dot.BinPacker.Bin( bounds, null );
  }

  dot.register( 'BinPacker', BinPacker );

  inherit( Object, BinPacker, {
    /**
     * Allocates a bin with the specified width and height if possible (returning a {Bin}), otherwise returns null.
     * @public
     *
     * @param {number} width
     * @param {number} height
     * @returns {Bin|null}
     */
    allocate: function( width, height ) {
      // find a leaf bin that has available room (or null)
      var bin = this.rootBin.findAvailableBin( width, height );

      if ( bin ) {
        // split it into a sized sub-bin for our purpose that we will use, and other bins for future allocations
        var sizedBin = bin.split( width, height );

        // mark our bin as used
        sizedBin.use();

        return sizedBin;
      }
      else {
        return null;
      }
    },

    /**
     * Deallocates a bin, so that its area can be reused by future allocations.
     * @public
     *
     * @param {Bin} bin - The bin that was returned from allocate().
     */
    deallocate: function( bin ) {
      bin.unuse();
    },

    // @private, for debugging purposes
    toString: function() {
      var result = '';

      var padding = '';

      function binTree( bin ) {
        result += padding + bin.toString() + '\n';
        padding = padding + '  ';
        _.each( bin.children, binTree );
        padding = padding.substring( 2 );
      }

      binTree( this.rootBin );

      return result;
    }
  } );

  /**
   * A rectangular bin that can be used itself or split into sub-bins.
   * @public
   * @constructor
   *
   * @param {Bounds2} bounds
   * @param {Bin|null} parent
   */
  BinPacker.Bin = function Bin( bounds, parent ) {
    // @public {Bounds2} - Our containing bounds
    this.bounds = bounds;

    // @private {Bin|null} - Parent bin, if applicable
    this.parent = parent;

    // @private {boolean} - Whether our children are responsible for our area
    this.isSplit = false;

    // @private {boolean} - Whether we are marked as a bin that is used
    this.isUsed = false;

    // @private {Array.<Bin>}
    this.children = [];
  };
  inherit( Object, BinPacker.Bin, {

    /**
     * Finds an unused bin with open area that is at least width-x-height in size.
     * @private
     *
     * @param {number} width
     * @param {number} height
     * @returns {Bin|null}
     */
    findAvailableBin: function( width, height ) {
      assert && assert( width > 0 && height > 0, 'Empty bin requested?' );

      // If we are marked as used ourself, we can't be used
      if ( this.isUsed ) {
        return null;
      }
      // If our bounds can't fit it, skip this entire sub-tree
      else if ( this.bounds.width < width || this.bounds.height < height ) {
        return null;
      }
      // If we have been split, check our children
      else if ( this.isSplit ) {
        for ( var i = 0; i < this.children.length; i++ ) {
          var result = this.children[ i ].findAvailableBin( width, height );
          if ( result ) {
            return result;
          }
        }
        // No child can fit the area
        return null;
      }
      // Otherwise we are free and our dimensions are compatible (checked above)
      else {
        return this;
      }
    },

    /**
     * Splits this bin into multiple child bins, and returns the child with the dimensions (width,height).
     * @private
     *
     * @param {number} width
     * @param {number} height
     */
    split: function( width, height ) {
      assert && assert( this.bounds.width >= width && this.bounds.height >= height,
        'Bin does not have space' );
      assert && assert( !this.isSplit, 'Bin should not be re-split' );
      assert && assert( !this.isUsed, 'Bin should not be split when used' );
      assert && assert( width > 0 && height > 0, 'Empty bin requested?' );

      // if our dimensions match exactly, don't split (return ourself)
      if ( width === this.bounds.width && height === this.bounds.height ) {
        return this;
      }

      // mark as split
      this.isSplit = true;

      // locations of the split
      var splitX = this.bounds.minX + width;
      var splitY = this.bounds.minY + height;

      /*
       * How an area is split (for now). In the future, splitting more after determining what we need to fit next would
       * potentially be better, but this preserves the width better (which many times we need).
       *
       *   ************************************
       *   *                  *               *
       *   *                  *               *
       *   *       main       *     right     *
       *   * (width x height) *               *
       *   *                  *               *
       *   ************************************
       *   *                                  *
       *   *              bottom              *
       *   *                                  *
       *   ************************************
       */
      var mainBounds = new Bounds2( this.bounds.minX, this.bounds.minY, splitX, splitY );
      var rightBounds = new Bounds2( splitX, this.bounds.minY, this.bounds.maxX, splitY );
      var bottomBounds = new Bounds2( this.bounds.minX, splitY, this.bounds.maxX, this.bounds.maxY );

      var mainBin = new dot.BinPacker.Bin( mainBounds, this );
      this.children.push( mainBin );

      // only add right/bottom if they take up area
      if ( rightBounds.hasNonzeroArea() ) {
        this.children.push( new dot.BinPacker.Bin( rightBounds, this ) );
      }
      if ( bottomBounds.hasNonzeroArea() ) {
        this.children.push( new dot.BinPacker.Bin( bottomBounds, this ) );
      }

      return mainBin;
    },

    /**
     * Mark this bin as used.
     * @private
     */
    use: function() {
      assert && assert( !this.isSplit, 'Should not mark a split bin as used' );
      assert && assert( !this.isUsed, 'Should not mark a used bin as used' );

      this.isUsed = true;
    },

    /**
     * Mark this bin as not used, and attempt to collapse split parents if all children are unused.
     * @private
     */
    unuse: function() {
      assert && assert( this.isUsed, 'Can only unuse a used instance' );

      this.isUsed = false;

      this.parent && this.parent.attemptToCollapse();
    },

    /**
     * If our bin can be collapsed (it is split and has children that are not used AND not split), then we will become
     * not split, and will remove our children. If successful, it will also call this on our parent, fully attempting
     * to clean up unused data structures.
     * @private
     */
    attemptToCollapse: function() {
      assert && assert( this.isSplit, 'Should only attempt to collapse split bins' );

      // Bail out if a single child isn't able to be collapsed. If it is not split or used, it won't have any children
      // or needs.
      for ( var i = 0; i < this.children.length; i++ ) {
        var child = this.children[ i ];

        if ( child.isSplit || child.isUsed ) {
          return;
        }
      }

      // We can now collapse ourselves neatly
      this.children = [];
      this.isSplit = false;

      // And attempt to collapse our parent
      this.parent && this.parent.attemptToCollapse();
    },

    // @private for debugging purposes
    toString: function() {
      return this.bounds.toString() + ( this.isUsed ? ' used' : '' );
    }
  } );

  return BinPacker;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * A single Canvas/texture with multiple different images (sprites) drawn internally. During rendering, this texture
 * can be used in one draw call to render multiple different images by providing UV coordinates to each quad for each
 * image to be drawn.
 *
 * Note that the WebGL texture part is not required to be run - the Canvas-only part can be used functionally without
 * any WebGL dependencies.
 *
 * TODO: Add padding around sprites, otherwise interpolation could cause issues!
 * TODO: How to use custom mipmap levels?
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SCENERY/util/SpriteSheet',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/BinPacker','DOT/Bounds2'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );
  var inherit = require( 'PHET_CORE/inherit' );
  var BinPacker = require( 'DOT/BinPacker' );
  var Bounds2 = require( 'DOT/Bounds2' );

  /**
   * @constructor
   *
   * @param {boolean} useMipmaps - Whether built-in WebGL mipmapping should be used. Higher quality, but may be slower
   *                               to add images (since mipmaps need to be updated).
   */
  function SpriteSheet( useMipmaps ) {
    this.useMipmaps = useMipmaps;

    this.gl = null; // assume later creation of context for now

    // Use the max supported texture size (according to http://codeflow.org/entries/2013/feb/22/how-to-write-portable-webgl/ )
    // TODO: potentially support larger texture sizes based on reported capabilities (could cause fewer draw calls?)
    this.bounds = new Bounds2( 0, 0, 2048, 2048 );
    assert && assert( this.bounds.minX === 0 && this.bounds.minY === 0, 'Assumed constraint later on for transforms' );
    this.width = this.bounds.width;
    this.height = this.bounds.height;

    this.canvas = document.createElement( 'canvas' );
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.context = this.canvas.getContext( '2d' );

    this.binPacker = new BinPacker( this.bounds );

    this.dirty = true; // @public [read-only] - Used to check if we need to updateTexture()

    this.usedSprites = [];
    this.unusedSprites = []; // works as a LRU cache for removing items when we need to allocate new space
  }

  scenery.register( 'SpriteSheet', SpriteSheet );

  inherit( Object, SpriteSheet, {
    /**
     * Initialize (or reinitialize) ourself with a new GL context. Should be called at least once before updateTexture()
     */
    initializeContext: function( gl ) {
      this.gl = gl;

      this.createTexture();
    },

    /**
     * Allocates and creates a GL texture, configures it, and initializes it with our current Canvas.
     */
    createTexture: function() {
      var gl = this.gl;

      this.texture = gl.createTexture();
      gl.bindTexture( gl.TEXTURE_2D, this.texture );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.useMipmaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR );
      gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
      gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas );
      if ( this.useMipmaps ) {
        gl.hint( gl.GENERATE_MIPMAP_HINT, gl.NICEST );
        gl.generateMipmap( gl.TEXTURE_2D );
      }
      gl.bindTexture( gl.TEXTURE_2D, null );

      this.dirty = false;
    },

    /**
     * Updates a pre-existing texture with our current Canvas.
     */
    updateTexture: function() {
      assert && assert( this.gl, 'SpriteSheet needs context to updateTexture()' );

      if ( this.dirty ) {
        this.dirty = false;

        var gl = this.gl;

        gl.bindTexture( gl.TEXTURE_2D, this.texture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas );
        if ( this.useMipmaps ) {
          gl.generateMipmap( gl.TEXTURE_2D );
        }
        gl.bindTexture( gl.TEXTURE_2D, null );
      }
    },

    /**
     * Adds an image (if possible) to our sprite sheet. If successful, will return a {Sprite}, otherwise null.
     *
     * @param {HTMLCanvasElement | HTMLImageElement} image
     * @param {number} width
     * @param {number} height
     *
     * @returns {Sprite | null}
     */
    addImage: function( image, width, height ) {
      var i;

      // check used cache
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        var usedSprite = this.usedSprites[ i ];
        if ( usedSprite.image === image ) {
          usedSprite.count++;
          return usedSprite;
        }
      }

      // check unused cache
      for ( i = 0; i < this.unusedSprites.length; i++ ) {
        var unusedSprite = this.unusedSprites[ i ];
        if ( unusedSprite.image === image ) {
          unusedSprite.count++;
          assert && assert( unusedSprite.count === 1, 'Count should be exactly 1 after coming back from being unused' );
          this.unusedSprites.splice( i, 1 ); // remove it from the unused array
          this.usedSprites.push( unusedSprite ); // add it to the used array
          return unusedSprite;
        }
      }

      // Not in any caches, let's try to find space. If we can't find space at first, we start removing unused sprites
      // one-by-one.
      var bin;
      // Enters 'while' loop only if allocate() returns null and we have unused sprites (i.e. conditions where we will
      // want to deallocate the least recently used (LRU) unused sprite and then check for allocation again).
      while ( !( bin = this.binPacker.allocate( width, height ) ) && this.unusedSprites.length ) {
        var ejectedSprite = this.unusedSprites.shift(); // LRU policy by taking first item

        // clear its space in the Canvas
        this.dirty = true;
        var ejectedBounds = ejectedSprite.bin.bounds;
        this.context.clearRect( ejectedBounds.x, ejectedBounds.y, ejectedBounds.width, ejectedBounds.height );

        // deallocate its area in the bin packer
        this.binPacker.deallocate( ejectedSprite.bin );
      }

      if ( bin ) {
        // WebGL will want UV coordinates in the [0,1] range
        var uvBounds = new Bounds2( bin.bounds.minX / this.width, bin.bounds.minY / this.height,
          bin.bounds.maxX / this.width, bin.bounds.maxY / this.height );
        var sprite = new SpriteSheet.Sprite( this, bin, uvBounds, image, 1 );
        this.context.drawImage( image, bin.bounds.x, bin.bounds.y );
        this.dirty = true;
        this.usedSprites.push( sprite );
        return sprite;
      }
      // no space, even after clearing out our unused sprites
      else {
        return null;
      }
    },

    removeImage: function( image ) {
      // find the used sprite (and its index)
      var usedSprite;
      var i;
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        if ( this.usedSprites[ i ].image === image ) {
          usedSprite = this.usedSprites[ i ];
          break;
        }
      }
      assert && assert( usedSprite, 'Sprite not found for removeImage' );

      // if we have no more references to the image/sprite
      if ( --usedSprite.count <= 0 ) {
        this.usedSprites.splice( i, 1 ); // remove it from the used list
        this.unusedSprites.push( usedSprite ); // add it to the unused list
      }

      // NOTE: no modification to the Canvas/texture is made, since we can leave it drawn there and unreferenced.
      // If addImage( image ) is called for the same image, we can 'resurrect' it without any further Canvas/texture
      // changes being made.
    },

    /**
     * Whether the sprite for the specified image is handled by this spritesheet. It can be either used or unused, but
     * addImage() calls with the specified image should be extremely fast (no need to modify the Canvas or texture).
     *
     * @returns {boolean}
     */
    containsImage: function( image ) {
      var i;

      // check used cache
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        if ( this.usedSprites[ i ].image === image ) {
          return true;
        }
      }

      // check unused cache
      for ( i = 0; i < this.unusedSprites.length; i++ ) {
        if ( this.unusedSprites[ i ].image === image ) {
          return true;
        }
      }

      return false;
    }
  } );

  /**
   * A reference to a specific part of the texture that can be used.
   *
   * @constructor
   */
  SpriteSheet.Sprite = function( spriteSheet, bin, uvBounds, image, initialCount ) {
    // @public [read-only] {SpriteSheet} - The containing SpriteSheet
    this.spriteSheet = spriteSheet;

    // @private [read-only] {BinPacker.Bin} - Contains the actual image bounds in our Canvas, and is used to deallocate.
    this.bin = bin;

    // @public [read-only] {Bounds2} - Normalized bounds between [0,1] for the full texture (for GLSL texture lookups).
    this.uvBounds = uvBounds;

    // @private [read-only] {HTMLCanvasElement | HTMLImageElement} - Image element used.
    this.image = image;

    // @private [read-write] {number} - Reference count for number of addChild() calls minus removeChild() calls. If
    // the count is 0, it should be in the 'unusedSprites' array, otherwise it should be in the 'usedSprites' array.
    this.count = initialCount;
  };

  return SpriteSheet;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Abstraction over the shader program
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/ShaderProgram',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Util = require( 'SCENERY/util/Util' );

  function ShaderProgram( gl, vertexSource, fragmentSource, options ) {
    options = _.extend( {
      attributes: [], // {Array.<string>} (vertex) attribute names in the shader source
      uniforms: [] // {Array.<string>} uniform names in the shader source
    }, options );

    // store parameters so that we can recreate the shader program on context loss
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
    this.attributeNames = options.attributes;
    this.uniformNames = options.uniforms;

    this.initialize( gl );
  }

  scenery.register( 'ShaderProgram', ShaderProgram );

  return inherit( Object, ShaderProgram, {
    // initializes (or reinitializes) the WebGL state and uniform/attribute references.
    initialize: function( gl ) {
      var self = this;
      this.gl = gl; // TODO: create them with separate contexts

      this.used = false;

      this.program = this.gl.createProgram();

      this.vertexShader = Util.createShader( this.gl, this.vertexSource, this.gl.VERTEX_SHADER );
      this.fragmentShader = Util.createShader( this.gl, this.fragmentSource, this.gl.FRAGMENT_SHADER );

      this.gl.attachShader( this.program, this.vertexShader );
      this.gl.attachShader( this.program, this.fragmentShader );

      this.gl.linkProgram( this.program );

      if ( !this.gl.getProgramParameter( this.program, this.gl.LINK_STATUS ) ) {
        console.log( 'GLSL link error:' );
        console.log( this.gl.getProgramInfoLog( this.program ) );
        console.log( 'for vertex shader' );
        console.log( this.vertexSource );
        console.log( 'for fragment shader' );
        console.log( this.fragmentSource );

        // Normally it would be best to throw an exception here, but a context loss could cause the shader parameter check
        // to fail, and we must handle context loss gracefully between any adjacent pair of gl calls.
        // Therefore, we simply report the errors to the console.  See #279
      }

      // clean these up, they aren't needed after the link
      this.gl.deleteShader( this.vertexShader );
      this.gl.deleteShader( this.fragmentShader );

      this.uniformLocations = {}; // map name => uniform location for program
      this.attributeLocations = {}; // map name => attribute location for program
      this.activeAttributes = {}; // map name => boolean (enabled)

      _.each( this.attributeNames, function( attributeName ) {
        self.attributeLocations[ attributeName ] = self.gl.getAttribLocation( self.program, attributeName );
        self.activeAttributes[ attributeName ] = true; // default to enabled
      } );
      _.each( this.uniformNames, function( uniformName ) {
        self.uniformLocations[ uniformName ] = self.gl.getUniformLocation( self.program, uniformName );
      } );

      this.isInitialized = true;
    },

    use: function() {
      if ( this.used ) { return; }

      var self = this;

      this.used = true;

      this.gl.useProgram( this.program );

      // enable the active attributes
      _.each( this.attributeNames, function( attributeName ) {
        if ( self.activeAttributes[ attributeName ] ) {
          self.enableVertexAttribArray( attributeName );
        }
      } );
    },

    activateAttribute: function( attributeName ) {
      // guarded so we don't enable twice
      if ( !this.activeAttributes[ attributeName ] ) {
        this.activeAttributes[ attributeName ] = true;

        if ( this.used ) {
          this.enableVertexAttribArray( attributeName );
        }
      }
    },

    enableVertexAttribArray: function( attributeName ) {
      this.gl.enableVertexAttribArray( this.attributeLocations[ attributeName ] );
    },

    unuse: function() {
      if ( !this.used ) { return; }

      var self = this;

      this.used = false;

      _.each( this.attributeNames, function( attributeName ) {
        if ( self.activeAttributes[ attributeName ] ) {
          self.disableVertexAttribArray( attributeName );
        }
      } );
    },

    disableVertexAttribArray: function( attributeName ) {
      this.gl.disableVertexAttribArray( this.attributeLocations[ attributeName ] );
    },

    deactivateAttribute: function( attributeName ) {
      // guarded so we don't disable twice
      if ( this.activeAttributes[ attributeName ] ) {
        this.activeAttributes[ attributeName ] = false;

        if ( this.used ) {
          this.disableVertexAttribArray( attributeName );
        }
      }
    },

    dispose: function() {
      this.gl.deleteProgram( this.program );
    }
  } );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Renders a visual layer of WebGL drawables.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Sharfudeen Ashraf (For Ghent University)
 */
define( 'SCENERY/display/WebGLBlock',['require','SCENERY/scenery','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','DOT/Matrix3','SCENERY/display/FittedBlock','SCENERY/display/Renderer','SCENERY/util/Util','SCENERY/util/SpriteSheet','SCENERY/util/ShaderProgram'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Util = require( 'SCENERY/util/Util' );
  var SpriteSheet = require( 'SCENERY/util/SpriteSheet' );
  var ShaderProgram = require( 'SCENERY/util/ShaderProgram' );

  function WebGLBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }

  scenery.register( 'WebGLBlock', WebGLBlock );

  inherit( FittedBlock, WebGLBlock, {
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {

      // WebGLBlocks are hard-coded to take the full display size (as opposed to svg and canvas)
      // Since we saw some jitter on iPad, see #318 and generally expect WebGL layers to span the entire display
      // In the future, it would be good to understand what was causing the problem and make webgl consistent
      // with svg and canvas again.
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.FULL_DISPLAY );

      this.filterRootInstance = filterRootInstance;

      // {boolean} - Whether we pass this flag to the WebGL Context. It will store the contents displayed on the screen,
      // so that canvas.toDataURL() will work. It also requires clearing the context manually ever frame. Both incur
      // performance costs, so it should be false by default.
      // TODO: This block can be shared across displays, so we need to handle preserveDrawingBuffer separately?
      this.preserveDrawingBuffer = display.options.preserveDrawingBuffer;

      // list of {Drawable}s that need to be updated before we update
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );

      // {Array.<SpriteSheet>}, permanent list of spritesheets for this block
      this.spriteSheets = this.spriteSheets || [];

      if ( !this.domElement ) {
        this.canvas = document.createElement( 'canvas' );
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = '0';
        this.canvas.style.top = '0';
        this.canvas.style.pointerEvents = 'none';

        // unique ID so that we can support rasterization with Display.foreignObjectRasterization
        this.canvasId = this.canvas.id = 'scenery-webgl' + this.id;

        var contextOptions = {
          antialias: true,
          preserveDrawingBuffer: this.preserveDrawingBuffer
        };

        // we've already committed to using a WebGLBlock, so no use in a try-catch around our context attempt
        this.gl = this.canvas.getContext( 'webgl', contextOptions ) || this.canvas.getContext( 'experimental-webgl', contextOptions );
        assert && assert( this.gl, 'We should have a context by now' );
        var gl = this.gl;

        // {number} - How much larger our Canvas will be compared to the CSS pixel dimensions, so that our Canvas maps
        // one of its pixels to a physical pixel (for Retina devices, etc.).
        this.backingScale = this.originalBackingScale = Util.backingScale( gl );

        // What color gets set when we call gl.clear()
        gl.clearColor( 0, 0, 0, 0 );

        // Blending similar to http://localhost/phet/git/webgl-blendfunctions/blendfuncseparate.html
        gl.enable( gl.BLEND );
        gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
        gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

        this.domElement = this.canvas;

        // processor for custom WebGL drawables (e.g. WebGLNode)
        this.customProcessor = new WebGLBlock.CustomProcessor( this );

        // processor for drawing vertex-colored triangles (e.g. Path types)
        this.vertexColorPolygonsProcessor = new WebGLBlock.VertexColorPolygons( this );

        // processor for drawing textured triangles (e.g. Image)
        this.texturedTrianglesProcessor = new WebGLBlock.TexturedTrianglesProcessor( this );
      }

      // clear buffers when we are reinitialized
      this.gl.clear( this.gl.COLOR_BUFFER_BIT );

      // reset any fit transforms that were applied
      Util.prepareForTransform( this.canvas, false );
      Util.unsetTransform( this.canvas ); // clear out any transforms that could have been previously applied

      // Projection {Matrix3} that maps from Scenery's global coordinate frame to normalized device coordinates,
      // where x,y are both in the range [-1,1] from one side of the Canvas to the other.
      this.projectionMatrix = this.projectionMatrix || new Matrix3().setTo32Bit();
      // a column-major 3x3 array specifying our projection matrix for 2D points (homogenized to (x,y,1))
      this.projectionMatrixArray = this.projectionMatrix.entries;

      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'initialized #' + this.id );

      return this;
    },

    setSizeFullDisplay: function() {
      var size = this.display.getSize();
      this.canvas.width = Math.ceil( size.width * this.backingScale );
      this.canvas.height = Math.ceil( size.height * this.backingScale );
      this.canvas.style.width = size.width + 'px';
      this.canvas.style.height = size.height + 'px';
    },

    setSizeFitBounds: function() {
      throw new Error( 'setSizeFitBounds unimplemented for WebGLBlock' );
    },

    update: function() {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'update #' + this.id );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

      var gl = this.gl;

      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        // update drawables, so that they have vertex arrays up to date, etc.
        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }

        // ensure sprite sheet textures are up-to-date
        var numSpriteSheets = this.spriteSheets.length;
        for ( var i = 0; i < numSpriteSheets; i++ ) {
          this.spriteSheets[ i ].updateTexture();
        }

        // temporary hack for supporting webglScale
        if ( this.firstDrawable &&
             this.firstDrawable === this.lastDrawable &&
             this.firstDrawable.node &&
             this.firstDrawable.node._hints.webglScale !== null &&
             this.backingScale !== this.originalBackingScale * this.firstDrawable.node._hints.webglScale ) {
          this.backingScale = this.originalBackingScale * this.firstDrawable.node._hints.webglScale;
          this.dirtyFit = true;
        }

        // udpate the fit BEFORE drawing, since it may change our offset
        this.updateFit();

        // finalX = 2 * x / display.width - 1
        // finalY = 1 - 2 * y / display.height
        // result = matrix * ( x, y, 1 )
        this.projectionMatrix.rowMajor(
          2 / this.display.width, 0, -1,
          0, -2 / this.display.height, 1,
          0, 0, 1 );

        // if we created the context with preserveDrawingBuffer, we need to clear before rendering
        if ( this.preserveDrawingBuffer ) {
          gl.clear( gl.COLOR_BUFFER_BIT );
        }

        gl.viewport( 0.0, 0.0, this.canvas.width, this.canvas.height );

        // We switch between processors for drawables based on each drawable's webglRenderer property. Each processor
        // will be activated, will process a certain number of adjacent drawables with that processor's webglRenderer,
        // and then will be deactivated. This allows us to switch back-and-forth between different shader programs,
        // and allows us to trigger draw calls for each grouping of drawables in an efficient way.
        var currentProcessor = null;
        // How many draw calls have been executed. If no draw calls are executed while updating, it means nothing should
        // be drawn, and we'll have to manually clear the Canvas if we are not preserving the drawing buffer.
        var cumulativeDrawCount = 0;
        // Iterate through all of our drawables (linked list)
        //OHTWO TODO: PERFORMANCE: create an array for faster drawable iteration (this is probably a hellish memory access pattern)
        for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
          // ignore invisible drawables
          if ( drawable.visible ) {
            // select our desired processor
            var desiredProcessor = null;
            if ( drawable.webglRenderer === Renderer.webglTexturedTriangles ) {
              desiredProcessor = this.texturedTrianglesProcessor;
            }
            else if ( drawable.webglRenderer === Renderer.webglCustom ) {
              desiredProcessor = this.customProcessor;
            }
            else if ( drawable.webglRenderer === Renderer.webglVertexColorPolygons ) {
              desiredProcessor = this.vertexColorPolygonsProcessor;
            }
            assert && assert( desiredProcessor );

            // swap processors if necessary
            if ( desiredProcessor !== currentProcessor ) {
              // deactivate any old processors
              if ( currentProcessor ) {
                cumulativeDrawCount += currentProcessor.deactivate();
              }
              // activate the new processor
              currentProcessor = desiredProcessor;
              currentProcessor.activate();
            }

            // process our current drawable with the current processor
            currentProcessor.processDrawable( drawable );
          }

          // exit loop end case
          if ( drawable === this.lastDrawable ) { break; }
        }
        // deactivate any processor that still has drawables that need to be handled
        if ( currentProcessor ) {
          cumulativeDrawCount += currentProcessor.deactivate();
        }

        // If we executed no draw calls AND we aren't preserving the drawing buffer, we'll need to manually clear the
        // drawing buffer ourself.
        if ( cumulativeDrawCount === 0 && !this.preserveDrawingBuffer ) {
          gl.clear( gl.COLOR_BUFFER_BIT );
        }

        gl.flush();
      }

      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
    },

    dispose: function() {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'dispose #' + this.id );

      // TODO: many things to dispose!?

      // clear references
      cleanArray( this.dirtyDrawables );

      FittedBlock.prototype.dispose.call( this );
    },

    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on WebGLBlock#' + this.id + ' with ' + drawable.toString() );

      assert && assert( drawable );

      // TODO: instance check to see if it is a canvas cache (usually we don't need to call update on our drawables)
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },

    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );

      FittedBlock.prototype.addDrawable.call( this, drawable );

      // will trigger changes to the spritesheets for images, or initialization for others
      drawable.onAddToBlock( this );
    },

    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );

      // wil trigger removal from spritesheets
      drawable.onRemoveFromBlock( this );

      FittedBlock.prototype.removeDrawable.call( this, drawable );
    },

    /**
     * Ensures we have an allocated part of a SpriteSheet for this image. If a SpriteSheet already contains this image,
     * we'll just increase the reference count. Otherwise, we'll attempt to add it into one of our SpriteSheets. If
     * it doesn't fit, we'll add a new SpriteSheet and add the image to it.
     *
     * @param {HTMLImageElement | HTMLCanvasElement} image
     * @param {number} width
     * @param {number} height
     *
     * @returns {Sprite} - Throws an error if we can't accommodate the image
     */
    addSpriteSheetImage: function( image, width, height ) {
      var sprite = null;
      var numSpriteSheets = this.spriteSheets.length;
      // TODO: check for SpriteSheet containment first?
      for ( var i = 0; i < numSpriteSheets; i++ ) {
        var spriteSheet = this.spriteSheets[ i ];
        sprite = spriteSheet.addImage( image, width, height );
        if ( sprite ) {
          break;
        }
      }
      if ( !sprite ) {
        var newSpriteSheet = new SpriteSheet( true ); // use mipmaps for now?
        sprite = newSpriteSheet.addImage( image, width, height );
        newSpriteSheet.initializeContext( this.gl );
        newSpriteSheet.createTexture();
        this.spriteSheets.push( newSpriteSheet );
        if ( !sprite ) {
          // TODO: renderer flags should change for very large images
          throw new Error( 'Attempt to load image that is too large for sprite sheets' );
        }
      }
      return sprite;
    },

    /**
     * Removes the reference to the sprite in our spritesheets.
     *
     * @param {Sprite} sprite
     */
    removeSpriteSheetImage: function( sprite ) {
      sprite.spriteSheet.removeImage( sprite.image );
    },

    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );

      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );

      this.markDirty();
    },

    onPotentiallyMovedDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.onPotentiallyMovedDrawable ' + drawable.toString() );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

      assert && assert( drawable.parentDrawable === this );

      this.markDirty();

      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
    },

    toString: function() {
      return 'WebGLBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );

  /*---------------------------------------------------------------------------*
   * Processors rely on the following lifecycle:
   * 1. activate()
   * 2. processDrawable() - 0 or more times
   * 3. deactivate()
   * Once deactivated, they should have executed all of the draw calls they need to make.
   *---------------------------------------------------------------------------*/

  // TODO: Processor super-type?

  WebGLBlock.CustomProcessor = function( webglBlock ) {
    this.webglBlock = webglBlock;

    this.drawable = null;
  };
  inherit( Object, WebGLBlock.CustomProcessor, {
    activate: function() {
      this.drawCount = 0;
    },

    processDrawable: function( drawable ) {
      assert && assert( drawable.webglRenderer === Renderer.webglCustom );

      this.drawable = drawable;
      this.draw();
    },

    deactivate: function() {
      return this.drawCount;
    },

    // @private
    draw: function() {
      if ( this.drawable ) {
        this.drawable.draw();
        this.drawCount++;
        this.drawable = null;
      }
    }
  } );

  WebGLBlock.VertexColorPolygons = function( webglBlock ) {
    this.webglBlock = webglBlock;
    var gl = this.gl = webglBlock.gl;

    assert && assert( webglBlock.gl );
    this.shaderProgram = new ShaderProgram( gl, [
      // vertex shader
      'attribute vec2 aVertex;',
      'attribute vec4 aColor;',
      'varying vec4 vColor;',
      'uniform mat3 uProjectionMatrix;',

      'void main() {',
      '  vColor = aColor;',
      '  vec3 ndc = uProjectionMatrix * vec3( aVertex, 1.0 );', // homogeneous map to to normalized device coordinates
      '  gl_Position = vec4( ndc.xy, 0.0, 1.0 );',
      '}'
    ].join( '\n' ), [
      // fragment shader
      'precision mediump float;',
      'varying vec4 vColor;',

      'void main() {',
      // '  gl_FragColor = vec4( 0.0, 1.0, 0.0, 1.0 );',
      '  gl_FragColor = vColor;',
      '}'
    ].join( '\n' ), {
      attributes: [ 'aVertex', 'aColor' ],
      uniforms: [ 'uProjectionMatrix' ]
    } );

    this.vertexBuffer = gl.createBuffer();
    this.lastArrayLength = 128; // initial vertex buffer array length
    this.vertexArray = new Float32Array( this.lastArrayLength );

    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
  };
  inherit( Object, WebGLBlock.VertexColorPolygons, {
    activate: function() {
      this.shaderProgram.use();

      this.vertexArrayIndex = 0;
      this.drawCount = 0;
    },

    processDrawable: function( drawable ) {
      if ( drawable.includeVertices ) {
        var vertexData = drawable.vertexArray;

        // if our vertex data won't fit, keep doubling the size until it fits
        while ( vertexData.length + this.vertexArrayIndex > this.vertexArray.length ) {
          var newVertexArray = new Float32Array( this.vertexArray.length * 2 );
          newVertexArray.set( this.vertexArray );
          this.vertexArray = newVertexArray;
        }

        // copy our vertex data into the main array
        this.vertexArray.set( vertexData, this.vertexArrayIndex );
        this.vertexArrayIndex += vertexData.length;

        this.drawCount++;
      }
    },

    deactivate: function() {
      if ( this.drawCount ) {
        this.draw();
      }

      this.shaderProgram.unuse();

      return this.drawCount;
    },

    // @private
    draw: function() {
      var gl = this.gl;

      // (uniform) projection transform into normalized device coordinates
      gl.uniformMatrix3fv( this.shaderProgram.uniformLocations.uProjectionMatrix, false, this.webglBlock.projectionMatrixArray );

      gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
      // if we increased in length, we need to do a full bufferData to resize it on the GPU side
      if ( this.vertexArray.length > this.lastArrayLength ) {
        gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
      }
      // otherwise do a more efficient update that only sends part of the array over
      else {
        gl.bufferSubData( gl.ARRAY_BUFFER, 0, this.vertexArray.subarray( 0, this.vertexArrayIndex ) );
      }
      var sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;
      var stride = 6 * sizeOfFloat;
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aVertex, 2, gl.FLOAT, false, stride, 0 * sizeOfFloat );
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aColor, 4, gl.FLOAT, false, stride, 2 * sizeOfFloat );

      gl.drawArrays( gl.TRIANGLES, 0, this.vertexArrayIndex / 6 );

      this.vertexArrayIndex = 0;
    }
  } );

  WebGLBlock.TexturedTrianglesProcessor = function( webglBlock ) {
    this.webglBlock = webglBlock;
    var gl = this.gl = webglBlock.gl;

    assert && assert( webglBlock.gl );
    this.shaderProgram = new ShaderProgram( gl, [
      // vertex shader
      'attribute vec4 aVertex;',
      // 'attribute vec2 aTextureCoord;',
      'varying vec2 vTextureCoord;',
      'uniform mat3 uProjectionMatrix;',

      'void main() {',
      '  vTextureCoord = aVertex.zw;',
      '  vec3 ndc = uProjectionMatrix * vec3( aVertex.xy, 1.0 );', // homogeneous map to to normalized device coordinates
      '  gl_Position = vec4( ndc.xy, 0.0, 1.0 );',
      '}'
    ].join( '\n' ), [
      // fragment shader
      'precision mediump float;',
      'varying vec2 vTextureCoord;',
      'uniform sampler2D uTexture;',

      'void main() {',
      '  gl_FragColor = texture2D( uTexture, vTextureCoord, -0.7 );', // mipmap LOD bias of -0.7 (for now)
      '}'
    ].join( '\n' ), {
      // attributes: [ 'aVertex', 'aTextureCoord' ],
      attributes: [ 'aVertex' ],
      uniforms: [ 'uTexture', 'uProjectionMatrix' ]
    } );

    this.vertexBuffer = gl.createBuffer();
    this.lastArrayLength = 128; // initial vertex buffer array length
    this.vertexArray = new Float32Array( this.lastArrayLength );

    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
  };
  inherit( Object, WebGLBlock.TexturedTrianglesProcessor, {
    activate: function() {
      this.shaderProgram.use();

      this.currentSpriteSheet = null;
      this.vertexArrayIndex = 0;
      this.drawCount = 0;
    },

    processDrawable: function( drawable ) {
      // skip unloaded images or sprites
      if ( !drawable.sprite ) {
        return;
      }

      assert && assert( drawable.webglRenderer === Renderer.webglTexturedTriangles );
      if ( this.currentSpriteSheet && drawable.sprite.spriteSheet !== this.currentSpriteSheet ) {
        this.draw();
      }
      this.currentSpriteSheet = drawable.sprite.spriteSheet;

      var vertexData = drawable.vertexArray;

      // if our vertex data won't fit, keep doubling the size until it fits
      while ( vertexData.length + this.vertexArrayIndex > this.vertexArray.length ) {
        var newVertexArray = new Float32Array( this.vertexArray.length * 2 );
        newVertexArray.set( this.vertexArray );
        this.vertexArray = newVertexArray;
      }

      // copy our vertex data into the main array
      this.vertexArray.set( vertexData, this.vertexArrayIndex );
      this.vertexArrayIndex += vertexData.length;
    },

    deactivate: function() {
      if ( this.currentSpriteSheet ) {
        this.draw();
      }

      this.shaderProgram.unuse();

      return this.drawCount;
    },

    // @private
    draw: function() {
      assert && assert( this.currentSpriteSheet );
      var gl = this.gl;

      // (uniform) projection transform into normalized device coordinates
      gl.uniformMatrix3fv( this.shaderProgram.uniformLocations.uProjectionMatrix, false, this.webglBlock.projectionMatrixArray );

      gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
      // if we increased in length, we need to do a full bufferData to resize it on the GPU side
      if ( this.vertexArray.length > this.lastArrayLength ) {
        gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
      }
      // otherwise do a more efficient update that only sends part of the array over
      else {
        gl.bufferSubData( gl.ARRAY_BUFFER, 0, this.vertexArray.subarray( 0, this.vertexArrayIndex ) );
      }
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aVertex, 4, gl.FLOAT, false, 0, 0 );
      // TODO: test striping
      // var sizeOfFloat = 4;
      // gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aVertex, 2, gl.FLOAT, false, 4 * sizeOfFloat, 0 * sizeOfFloat );
      // gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aTextureCoord, 2, gl.FLOAT, false, 4 * sizeOfFloat, 2 * sizeOfFloat );

      gl.activeTexture( gl.TEXTURE0 );
      gl.bindTexture( gl.TEXTURE_2D, this.currentSpriteSheet.texture );
      gl.uniform1i( this.shaderProgram.uniformLocations.uTexture, 0 );

      gl.drawArrays( gl.TRIANGLES, 0, this.vertexArrayIndex / 4 );

      gl.bindTexture( gl.TEXTURE_2D, null );

      this.drawCount++;

      this.currentSpriteSheet = null;
      this.vertexArrayIndex = 0;
    }
  } );


  Poolable.mixin( WebGLBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'new from constructor' );
          return new WebGLBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );

  return WebGLBlock;
} );

// Copyright 2014-2015, University of Colorado Boulder


/**
 * Abstract base type (and API) for stitching implementations. Stitching is:
 * A method of updating the blocks for a backbone (the changes from the previous frame to the current frame), and
 * setting up the drawables to be attached/detached from blocks. At a high level:
 *   - We have an ordered list of blocks displayed in the last frame.
 *   - We have an ordered list of drawables displayed in the last frame (and what block they are part of).
 *   - We have an ordered list of drawables that will be displayed in the next frame (and whether they were part of our
 *     backbone, and if so what block they were in).
 *   - We need to efficiently create/dispose required blocks, add/remove drawables from blocks, notify blocks of their
 *     drawable range, and ensure blocks are displayed back-to-front.
 *
 * Since stitching usually only involves one or a few small changes (except for on sim initialization), the stitch
 * method is provided with a list of intervals that were (potentially) changed. This consists of a linked-list of
 * intervals (it is constructed during recursion through a tree that skips known-unchanged subtrees). The intervals
 * are completely disjoint (don't overlap, and aren't adjacent - there is at least one drawable that is unchanged
 * in-between change intervals).
 *
 * Assumes the same object instance will be reused multiple times, possibly for different backbones.
 *
 * Any stitcher implementations should always call initialize() first and clean() at the end, so that we can set up
 * and then clean up any object references (allowing them to be garbage-collected or pooled more safely).
 *
 * Stitcher responsibilities:
 *   1. Blocks used in the previous frame but not used in the current frame (no drawables, not attached) should be
 *      marked for disposal.
 *   2. Blocks should be created as necessary.
 *   3. If a changed drawable is removed from a block, it should have notePendingRemoval called on it.
 *   4. If a changed drawable is added to a block, it should have notePendingAddition called on it.
 *   5. If an unchanged drawable is to have a block change, it should have notePendingMove called on it.
 *   6. New blocks should be added to the DOM (appendChild presumably)
 *   7. Removed blocks should be removed from the DOM (removeChild)
 *      NOTE: check for child-parent relationship, since DOM blocks (wrappers) may have been
 *      added to the DOM elsewhere in another backbone's stitch already (which in the DOM
 *      automatically removes it from our backbone's div)
 *   8. If a block's first or last drawable changes, it should have notifyInterval called on it.
 *   9. At the end of the stitch, the backbone should have a way of iterating over its blocks in order (preferably an
 *      Array for fast repaint iteration)
 *   10. New blocks should have setBlockBackbone( backbone ) called on them
 *   11. Blocks with any drawable change should have backbone.markDirtyDrawable( block ) called so it can be visited
 *       in the repaint phase.
 *   12. Blocks should have z-indices set in the proper stacking order (back to front), using backbone.reindexBlocks()
 *       or equivalent (it tries to change as few z-indices as possible).
 *
 * Stitcher desired behavior and optimizations:
 *   1. Reuse blocks of the same renderer type, instead of removing one and creating another.
 *   2. Minimize (as much as is possible) how many drawables are added and removed from blocks (try not to remove 1000
 *      drawables from A and add them to B if we could instead just add/remove 5 drawables from C to D)
 *   3. No more DOM manipulation than necessary
 *   4. Optimize first for "one or a few small change intervals" that only cause local changes (no blocks created,
 *      removed or reordered). It would be ideal to do this very quickly, so it could be done every frame in
 *      simulations.
 *
 * Current constraints:
 *   1. DOM drawables should be paired with exactly one block (basically a wrapper, they are inserted directly into the
 *      DOM, and a DOM block should only ever be given the same drawable.
 *   2. Otherwise, consecutive drawables with the same renderer should be part of the same block. In the future we will
 *      want to allow "gaps" to form between (if something with a different renderer gets added and removed a lot
 *      in-between), but we'll need to figure out performance-sensitive flags to indicate when this needs to not be
 *      done (opacity and types of blending require no gaps between same-renderer drawables).
 *
 * Gluing: consequences of "no gaps"
 * There are two (important) implications:
 * Gluing
 *   If we have the following blocks:
 *     … A (SVG), B (Canvas), C (SVG) ...
 *   and all drawables for for B are removed, the following would be invalid ("has a gap"):
 *     … A (SVG), C (SVG) …
 *   so we need to glue them together, usually either resulting in:
 *     … A (SVG) …
 *   or
 *     … C (SVG) …
 *   with A or C including all of the drawables that were in A and C.
 *   More generally:
 *     If a change interval used to have its before/after (unchanged) drawables on two
 *     different blocks and for the current frame there will be no blocks in-between,
 *     we will need to "glue".
 *   Additionally, note the case:
 *     … A (SVG), B (Canvas), C (DOM), D (SVG), E (Canvas), F (SVG).
 *   If B,C,E are all removed, the results of A,D,F will have to all be combined into one layer
 * Un-gluing
 *   If we have the following drawables, all part of one block:
 *     … a (svg), b (svg) …
 *   and we insert a drawable with a different renderer:
 *     … a (svg), c (canvas), b (svg) ...
 *   we will need to split them into to SVG blocks
 *   More generally:
 *     If a change interval used to have its before/after (unchanged) drawables included
 *     in the same block, and the current frame requires a block to be inserted
 *     in-between, we will need to "un-glue".
 * These consequences mean that "unchanged" drawables (outside of change intervals) may need to have their block changed
 * (with notePendingMove). For performance, please consider which "end" should keep its drawables (the other end's
 * drawables will ALL have to be added/removed, which can be a major performance loss if we choose the wrong one).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Stitcher',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable','SCENERY/display/Renderer','SCENERY/display/CanvasBlock','SCENERY/display/SVGBlock','SCENERY/display/DOMBlock','SCENERY/display/WebGLBlock'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var CanvasBlock = require( 'SCENERY/display/CanvasBlock' );
  var SVGBlock = require( 'SCENERY/display/SVGBlock' );
  var DOMBlock = require( 'SCENERY/display/DOMBlock' );
  var WebGLBlock = require( 'SCENERY/display/WebGLBlock' );

  function Stitcher( display, renderer ) {
    throw new Error( 'We are too abstract for that!' );
  }

  scenery.register( 'Stitcher', Stitcher );

  inherit( Object, Stitcher, {
    // Main stitch entry point, called directly from the backbone or cache. We are modifying our backbone's blocks and
    // their attached drawables.
    // @param {Drawable | null} firstStitchDrawable: What our backbone's first drawable will be after this stitch
    // @param {Drawable | null} lastStitchDrawable: What our backbone's last drawable will be after this stitch
    // @param {Drawable | null} oldFirstStitchDrawable: What our backbone's first drawable was before this stitch
    // @param {Drawable | null} oldLastStitchDrawable: What our backbone's last drawable was before this stitch
    // @param {ChangeInterval} firstChangeInterval: The first change interval of our interval linked-list
    // @param {ChangeInterval} lastChangeInterval: The last change interval of our interval linked-list
    // The change-interval pair denotes a linked-list of change intervals that we will need to stitch across (they
    // contain drawables that need to be removed and added, and it may affect how we lay out blocks in the stacking
    // order).
    initialize: function( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval ) {
      assert && assert( firstChangeInterval && lastChangeInterval, 'We are guaranteed at least one change interval' );
      assert && assert( !firstDrawable || firstDrawable.previousDrawable === null,
        'End boundary of drawable linked list should link to null' );
      assert && assert( !lastDrawable || lastDrawable.nextDrawable === null,
        'End boundary of drawable linked list should link to null' );

      if ( sceneryLog && sceneryLog.Stitch ) {
        sceneryLog.Stitch( 'stitch ' + backbone.toString() +
                           ' first:' + ( firstDrawable ? firstDrawable.toString() : 'null' ) +
                           ' last:' + ( lastDrawable ? lastDrawable.toString() : 'null' ) +
                           ' oldFirst:' + ( oldFirstDrawable ? oldFirstDrawable.toString() : 'null' ) +
                           ' oldLast:' + ( oldLastDrawable ? oldLastDrawable.toString() : 'null' ) );
        sceneryLog.push();
      }
      if ( sceneryLog && sceneryLog.StitchDrawables ) {
        sceneryLog.StitchDrawables( 'Before:' );
        sceneryLog.push();
        Stitcher.debugDrawables( oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval, false );
        sceneryLog.pop();

        sceneryLog.StitchDrawables( 'After:' );
        sceneryLog.push();
        Stitcher.debugDrawables( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval, true );
        sceneryLog.pop();
      }

      this.backbone = backbone;
      this.firstDrawable = firstDrawable;
      this.lastDrawable = lastDrawable;

      // list of blocks that have their pendingFirstDrawable or pendingLastDrawable set, and need updateInterval() called
      this.touchedBlocks = cleanArray( this.touchedBlocks );

      if ( assertSlow ) {
        assertSlow( !this.initialized, 'We should not be already initialized (clean should be called)' );
        this.initialized = true;
        this.reindexed = false;

        this.pendingAdditions = [];
        this.pendingRemovals = [];
        this.pendingMoves = [];
        this.createdBlocks = [];
        this.disposedBlocks = [];
        this.intervalsNotified = [];
        this.boundariesRecorded = false;

        this.previousBlocks = backbone.blocks.slice( 0 ); // copy of previous blocks
      }
    },

    // Removes object references
    clean: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'clean' );
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( '-----------------------------------' );

      if ( assertSlow ) {
        this.auditStitch();

        this.initialized = false;
      }

      this.backbone = null;
      this.firstDrawable = null;
      this.lastDrawable = null;

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Writes the first/last drawables for the entire backbone into its memory. We want to wait to do this until we have
    // read from its previous values.
    recordBackboneBoundaries: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'recording backbone boundaries: ' +
                                                            ( this.firstDrawable ? this.firstDrawable.toString() : 'null' ) +
                                                            ' to ' +
                                                            ( this.lastDrawable ? this.lastDrawable.toString() : 'null' ) );
      this.backbone.previousFirstDrawable = this.firstDrawable;
      this.backbone.previousLastDrawable = this.lastDrawable;

      if ( assertSlow ) {
        this.boundariesRecorded = true;
      }
    },

    // Records that this {Drawable} drawable should be added/moved to the {Block} at a later time
    notePendingAddition: function( drawable, block ) {
      assert && assert( drawable.renderer === block.renderer );

      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending add: ' + drawable.toString() + ' to ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      drawable.notePendingAddition( this.backbone.display, block, this.backbone );

      if ( assertSlow ) {
        this.pendingAdditions.push( {
          drawable: drawable,
          block: block
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Records that this {Drawable} drawable should be moved to the {Block} at a later time (called only on external
    // drawables). notePendingAddition and notePendingRemoval should not be called on a drawable that had
    // notePendingMove called on it during the same stitch, and vice versa.
    notePendingMove: function( drawable, block ) {
      assert && assert( drawable.renderer === block.renderer );

      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending move: ' + drawable.toString() + ' to ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      drawable.notePendingMove( this.backbone.display, block );

      if ( assertSlow ) {
        this.pendingMoves.push( {
          drawable: drawable,
          block: block
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Records that this {Drawable} drawable should be removed/moved from the {Block} at a later time
    notePendingRemoval: function( drawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending remove: ' + drawable.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      drawable.notePendingRemoval( this.backbone.display );

      if ( assertSlow ) {
        this.pendingRemovals.push( {
          drawable: drawable
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Records that this {Block} block should be disposed at a later time. It should not be in the blocks array at the
    // end of the stitch.
    markBlockForDisposal: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'block for disposal: ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      //TODO: PERFORMANCE: does this cause reflows / style calculation
      if ( block.domElement.parentNode === this.backbone.domElement ) {
        // guarded, since we may have a (new) child drawable add it before we can remove it
        this.backbone.domElement.removeChild( block.domElement );
      }
      block.markForDisposal( this.backbone.display );

      if ( assertSlow ) {
        this.disposedBlocks.push( {
          block: block
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    removeAllBlocks: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking all blocks for disposal (count ' + this.backbone.blocks.length + ')' );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      while ( this.backbone.blocks.length ) {
        var block = this.backbone.blocks[ 0 ];

        this.removeBlock( block );
        this.markBlockForDisposal( block );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Immediately notify a block of its first/last drawable.
    notifyInterval: function( block, firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'notify interval: ' + block.toString() + ' ' +
                                                            firstDrawable.toString() + ' to ' + lastDrawable.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      block.notifyInterval( firstDrawable, lastDrawable );

      // mark it dirty, since its drawables probably changed?
      //OHTWO TODO: is this necessary? What is this doing?
      this.backbone.markDirtyDrawable( block );

      if ( assertSlow ) {
        this.intervalsNotified.push( {
          block: block,
          firstDrawable: firstDrawable,
          lastDrawable: lastDrawable
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Note a block's tentative first drawable and block before (should be flushed later with updateBlockIntervals())
    markBeforeBlock: function( block, firstDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking block first drawable ' + block.toString() + ' with ' + firstDrawable.toString() );

      block.pendingFirstDrawable = firstDrawable;
      this.touchedBlocks.push( block );
    },
    // Note a block's tentative last drawable and block after (should be flushed later with updateBlockIntervals())
    markAfterBlock: function( block, lastDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking block last drawable ' + block.toString() + ' with ' + lastDrawable.toString() );

      block.pendingLastDrawable = lastDrawable;
      this.touchedBlocks.push( block );
    },
    // Flushes markBeforeBlock/markAfterBlock changes to notifyInterval on blocks themselves.
    updateBlockIntervals: function() {
      while ( this.touchedBlocks.length ) {
        var block = this.touchedBlocks.pop();

        if ( block.used ) {
          sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'update interval: ' + block.toString() + ' ' +
                                                                block.pendingFirstDrawable.toString() + ' to ' + block.pendingLastDrawable.toString() );

          block.updateInterval();

          // mark it dirty, since its drawables probably changed?
          //OHTWO TODO: is this necessary? What is this doing?
          this.backbone.markDirtyDrawable( block );

          if ( assertSlow ) {
            this.intervalsNotified.push( {
              block: block,
              firstDrawable: block.pendingFirstDrawable,
              lastDrawable: block.pendingLastDrawable
            } );
          }
        }
        else {
          sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'skipping update interval: ' + block.toString() + ', unused' );
        }
      }
    },

    // Creates a fresh block with the desired renderer and {Drawable} arbitrary drawable included, and adds it to
    // our DOM.
    createBlock: function( renderer, drawable ) {
      var backbone = this.backbone;
      var block;

      if ( Renderer.isCanvas( renderer ) ) {
        block = CanvasBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else if ( Renderer.isSVG( renderer ) ) {
        //OHTWO TODO: handle filter root separately from the backbone instance?
        block = SVGBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else if ( Renderer.isDOM( renderer ) ) {
        block = DOMBlock.createFromPool( backbone.display, drawable );
      }
      else if ( Renderer.isWebGL( renderer ) ) {
        block = WebGLBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else {
        throw new Error( 'unsupported renderer for createBlock: ' + renderer );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'created block: ' + block.toString() +
                                                            ' with renderer: ' + renderer +
                                                            ' for drawable: ' + drawable.toString() );

      block.setBlockBackbone( backbone );

      //OHTWO TODO: minor speedup by appending only once its fragment is constructed? or use DocumentFragment?
      backbone.domElement.appendChild( block.domElement );

      // mark it dirty for now, so we can check
      backbone.markDirtyDrawable( block );

      if ( assertSlow ) {
        this.createdBlocks.push( {
          block: block,
          renderer: renderer,
          drawable: drawable
        } );
      }

      return block;
    },

    // Immediately appends a block to our blocks array
    appendBlock: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'appending block: ' + block.toString() );

      this.backbone.blocks.push( block );

      if ( assertSlow ) {
        this.reindexed = false;
      }
    },

    // Immediately removes a block to our blocks array
    removeBlock: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'removing block: ' + block.toString() );

      // remove the block from our internal list
      var blockIndex = _.indexOf( this.backbone.blocks, block );
      assert && assert( blockIndex >= 0, 'Cannot remove block, not attached: ' + block.toString() );
      this.backbone.blocks.splice( blockIndex, 1 );

      if ( assertSlow ) {
        this.reindexed = false;
      }
    },

    useNoBlocks: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'using no blocks' );

      // i.e. we will not use any blocks
      cleanArray( this.backbone.blocks );
    },

    // Triggers all blocks in the blocks array to have their z-index properties set so that they visually stack
    // correctly.
    reindex: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'reindexing blocks' );

      this.backbone.reindexBlocks();

      if ( assertSlow ) {
        this.reindexed = true;
      }
    },

    // An audit for testing assertions
    auditStitch: function() {
      if ( assertSlow ) {
        var stitcher = this;

        var blocks = stitcher.backbone.blocks;
        var previousBlocks = stitcher.previousBlocks;

        assertSlow( stitcher.initialized, 'We seem to have finished a stitch without proper initialization' );
        assertSlow( stitcher.boundariesRecorded, 'Our stitch API requires recordBackboneBoundaries() to be called before' +
                                                 ' it is finished.' );

        // ensure our indices are up-to-date (reindexed, or did not change)
        assertSlow( stitcher.reindexed || blocks.length === 0 ||
                    // array equality of previousBlocks and blocks
                    ( previousBlocks.length === blocks.length &&
                      _.every( _.zip( previousBlocks, blocks ), function( arr ) {
                        return arr[ 0 ] === arr[ 1 ];
                      } ) ),
          'Did not reindex on a block change where we are left with blocks' );

        // all created blocks had intervals notified
        _.each( stitcher.createdBlocks, function( blockData ) {
          assertSlow( _.some( stitcher.intervalsNotified, function( intervalData ) {
            return blockData.block === intervalData.block;
          } ), 'Created block does not seem to have an interval notified: ' + blockData.block.toString() );
        } );

        // no disposed blocks had intervals notified
        _.each( stitcher.disposedBlocks, function( blockData ) {
          assertSlow( !_.some( stitcher.intervalsNotified, function( intervalData ) {
            return blockData.block === intervalData.block;
          } ), 'Removed block seems to have an interval notified: ' + blockData.block.toString() );
        } );

        // all drawables for disposed blocks have been marked as pending removal (or moved)
        _.each( stitcher.disposedBlocks, function( blockData ) {
          var block = blockData.block;
          _.each( Drawable.oldListToArray( block.firstDrawable, block.lastDrawable ), function( drawable ) {
            assertSlow( _.some( stitcher.pendingRemovals, function( removalData ) {
                return removalData.drawable === drawable;
              } ) || _.some( stitcher.pendingMoves, function( moveData ) {
                return moveData.drawable === drawable;
              } ), 'Drawable ' + drawable.toString() + ' originally listed for disposed block ' + block.toString() +
                   ' does not seem to be marked for pending removal or move!' );
          } );
        } );

        // all drawables for created blocks have been marked as pending addition or moved for our block
        _.each( stitcher.createdBlocks, function( blockData ) {
          var block = blockData.block;
          _.each( Drawable.listToArray( block.pendingFirstDrawable, block.pendingLastDrawable ), function( drawable ) {
            assertSlow( _.some( stitcher.pendingAdditions, function( additionData ) {
                return additionData.drawable === drawable && additionData.block === block;
              } ) || _.some( stitcher.pendingMoves, function( moveData ) {
                return moveData.drawable === drawable && moveData.block === block;
              } ), 'Drawable ' + drawable.toString() + ' now listed for created block ' + block.toString() +
                   ' does not seem to be marked for pending addition or move!' );
          } );
        } );

        // all disposed blocks should have been removed
        _.each( stitcher.disposedBlocks, function( blockData ) {
          var blockIdx = _.indexOf( blocks, blockData.block );
          assertSlow( blockIdx < 0, 'Disposed block ' + blockData.block.toString() + ' still present at index ' + blockIdx );
        } );

        // all created blocks should have been added
        _.each( stitcher.createdBlocks, function( blockData ) {
          var blockIdx = _.indexOf( blocks, blockData.block );
          assertSlow( blockIdx >= 0, 'Created block ' + blockData.block.toString() + ' is not in the blocks array' );
        } );

        // all current blocks should be marked as used
        _.each( blocks, function( block ) {
          assertSlow( block.used, 'All current blocks should be marked as used' );
        } );

        assertSlow( blocks.length - previousBlocks.length === stitcher.createdBlocks.length - stitcher.disposedBlocks.length,
          'The count of unmodified blocks should be constant (equal differences):\n' +
          'created: ' + _.map( stitcher.createdBlocks, function( n ) { return n.block.id; } ).join( ',' ) + '\n' +
          'disposed: ' + _.map( stitcher.disposedBlocks, function( n ) { return n.block.id; } ).join( ',' ) + '\n' +
          'before: ' + _.map( previousBlocks, function( n ) { return n.id; } ).join( ',' ) + '\n' +
          'after: ' + _.map( blocks, function( n ) { return n.id; } ).join( ',' ) );

        assertSlow( this.touchedBlocks.length === 0,
          'If we marked any blocks for changes, we should have called updateBlockIntervals' );

        if ( blocks.length ) {

          assertSlow( stitcher.backbone.previousFirstDrawable !== null &&
                      stitcher.backbone.previousLastDrawable !== null,
            'If we are left with at least one block, we must be tracking at least one drawable' );

          assertSlow( blocks[ 0 ].pendingFirstDrawable === stitcher.backbone.previousFirstDrawable,
            'Our first drawable should match the first drawable of our first block' );

          assertSlow( blocks[ blocks.length - 1 ].pendingLastDrawable === stitcher.backbone.previousLastDrawable,
            'Our last drawable should match the last drawable of our last block' );

          for ( var i = 0; i < blocks.length - 1; i++ ) {
            // [i] and [i+1] are a pair of consecutive blocks
            assertSlow( blocks[ i ].pendingLastDrawable.nextDrawable === blocks[ i + 1 ].pendingFirstDrawable &&
                        blocks[ i ].pendingLastDrawable === blocks[ i + 1 ].pendingFirstDrawable.previousDrawable,
              'Consecutive blocks should have boundary drawables that are also consecutive in the linked list' );
          }
        }
        else {
          assertSlow( stitcher.backbone.previousFirstDrawable === null &&
                      stitcher.backbone.previousLastDrawable === null,
            'If we are left with no blocks, it must mean we are tracking precisely zero drawables' );
        }
      }
    }
  } );

  Stitcher.debugIntervals = function( firstChangeInterval ) {
    if ( sceneryLog && sceneryLog.Stitch ) {
      for ( var debugInterval = firstChangeInterval; debugInterval !== null; debugInterval = debugInterval.nextChangeInterval ) {
        sceneryLog.Stitch( '  interval: ' +
                           ( debugInterval.isEmpty() ? '(empty) ' : '' ) +
                           ( debugInterval.drawableBefore ? debugInterval.drawableBefore.toString() : '-' ) + ' to ' +
                           ( debugInterval.drawableAfter ? debugInterval.drawableAfter.toString() : '-' ) );
      }
    }
  };

  // logs a bunch of information about the old (useCurrent===false) or new (useCurrent===true) drawable linked list.
  Stitcher.debugDrawables = function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval, useCurrent ) {
    if ( sceneryLog && sceneryLog.StitchDrawables ) {
      if ( firstDrawable === null ) {
        sceneryLog.StitchDrawables( 'nothing', 'color: #666;' );
        return;
      }

      var isChanged = firstChangeInterval.drawableBefore === null;
      var currentInterval = firstChangeInterval;

      for ( var drawable = firstDrawable; ; drawable = ( useCurrent ? drawable.nextDrawable : drawable.oldNextDrawable ) ) {
        if ( isChanged && drawable === currentInterval.drawableAfter ) {
          isChanged = false;
          currentInterval = currentInterval.nextChangeInterval;
        }

        var drawableString = drawable.renderer + ' ' + ( ( !useCurrent && drawable.parentDrawable ) ? drawable.parentDrawable.toString() : '' ) + ' ' + drawable.toDetailedString();
        sceneryLog.StitchDrawables( drawableString, isChanged ? ( useCurrent ? 'color: #0a0;' : 'color: #a00;' ) : 'color: #666' );

        if ( !isChanged && currentInterval && currentInterval.drawableBefore === drawable ) {
          isChanged = true;
        }

        if ( drawable === lastDrawable ) {
          break;
        }
      }
    }
  };

  return Stitcher;
} );

// Copyright 2014-2015, University of Colorado Boulder


/**
 * Stitcher that only rebuilds the parts necessary, and attempts greedy block matching as an optimization.
 *
 * Given a list of change intervals, our greedy stitcher breaks it down into 'sub-blocks' consisting of
 * drawables that are 'internal' to the change interval that all have the same renderer, and handles the
 * glue/unglue/matching situations in a greedy way by always using the first possible (allowing only one sweep
 * instead of multiple ones over the drawable linked list for this process).
 *
 * Conceptually, we break down drawables into groups that are 'internal' to each change interval (inside, not
 * including the un-changed ends), and 'external' (that are not internal to any intervals).
 *
 * For each interval, we first make sure that the next 'external' group of drawables has the proper blocks (for
 * instance, this can change with a glue/unglue operation, with processEdgeCases), then proceed to break the 'internal'
 * drawables into sub-blocks and process those with processSubBlock.
 *
 * Our stitcher has a list of blocks noted as 'reusable' that we use for two purposes:
 *   1. So that we can shift blocks to where they are needed, instead of removing (e.g.) an SVG block and
 *      creating another.
 *   2. So that blocks that are unused at the end of our stitch can be removed, and marked for disposal.
 * At the start of the stitch, we mark completely 'internal' blocks as reusable, so they can be shifted around as
 * necessary (used in a greedy way which may not be optimal). It's also possible during later phases for blocks that
 * also contain 'external' drawables to be marked as reusable, due to glue cases where before we needed multiple
 * blocks and now we only need one.
 *
 * We also use a linked-list of blocks during stitch operations (that then re-builds an array of blocks on any changes
 * after all stitching is done) for simplicity, and to avoid O(n^2) cases that would result from having to look up
 * indices in the block array during stitching.
 *
 * NOTE: Stitcher instances may be reused many times, even with different backbones. It should always release any
 * object references that it held after usage.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/GreedyStitcher',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/display/Stitcher'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );

  // Returns whether the consecutive {Drawable}s 'a' and 'b' should be put into separate blocks
  function hasGapBetweenDrawables( a, b ) {
    return a.renderer !== b.renderer || Renderer.isDOM( a.renderer ) || Renderer.isDOM( b.renderer );
  }

  // Whether the drawable and its previous sibling should be in the same block. Will be false if there is no sibling
  function isOpenBefore( drawable ) {
    return drawable.previousDrawable !== null && !hasGapBetweenDrawables( drawable.previousDrawable, drawable );
  }

  // Whether the drawable and its next sibling should be in the same block. Will be false if there is no sibling
  function isOpenAfter( drawable ) {
    return drawable.nextDrawable !== null && !hasGapBetweenDrawables( drawable, drawable.nextDrawable );
  }

  // If the change interval will contain any new (added) drawables
  function intervalHasNewInternalDrawables( interval, firstStitchDrawable, lastStitchDrawable ) {
    if ( interval.drawableBefore ) {
      return interval.drawableBefore.nextDrawable !== interval.drawableAfter; // OK for after to be null
    }
    else if ( interval.drawableAfter ) {
      return interval.drawableAfter.previousDrawable !== interval.drawableBefore; // OK for before to be null
    }
    else {
      return firstStitchDrawable !== null;
    }
  }

  // If the change interval contained any drawables that are to be removed
  function intervalHasOldInternalDrawables( interval, oldFirstStitchDrawable, oldLastStitchDrawable ) {
    if ( interval.drawableBefore ) {
      return interval.drawableBefore.oldNextDrawable !== interval.drawableAfter; // OK for after to be null
    }
    else if ( interval.drawableAfter ) {
      return interval.drawableAfter.oldPreviousDrawable !== interval.drawableBefore; // OK for before to be null
    }
    else {
      return oldFirstStitchDrawable !== null;
    }
  }

  // Whether there are blocks that consist of drawables that are ALL internal to the {ChangeInterval} interval.
  function intervalHasOldInternalBlocks( interval, firstStitchBlock, lastStitchBlock ) {
    var beforeBlock = interval.drawableBefore ? interval.drawableBefore.parentDrawable : null;
    var afterBlock = interval.drawableAfter ? interval.drawableAfter.parentDrawable : null;

    if ( beforeBlock && afterBlock && beforeBlock === afterBlock ) {
      return false;
    }

    if ( beforeBlock ) {
      return beforeBlock.nextBlock !== afterBlock; // OK for after to be null
    }
    else if ( afterBlock ) {
      return afterBlock.previousBlock !== beforeBlock; // OK for before to be null
    }
    else {
      return firstStitchBlock !== null;
    }
  }

  /**
   * Finds the furthest external drawable that:
   * (a) Before the next change interval (if we have a next change interval)
   * (b) Has the same renderer as the interval's drawableAfter
   */
  function getLastCompatibleExternalDrawable( interval ) {
    var firstDrawable = interval.drawableAfter;

    if ( firstDrawable ) {
      var renderer = firstDrawable.renderer;

      // we stop our search before we reach this (null is acceptable), ensuring we don't go into the next change interval
      var cutoffDrawable = interval.nextChangeInterval ? interval.nextChangeInterval.drawableBefore.nextDrawable : null;

      var drawable = firstDrawable;

      while ( true ) { //eslint-disable-line no-constant-condition
        var nextDrawable = drawable.nextDrawable;

        // first comparison also does null check when necessary
        if ( nextDrawable !== cutoffDrawable && nextDrawable.renderer === renderer ) {
          drawable = nextDrawable;
        }
        else {
          break;
        }
      }

      return drawable;
    }
    else {
      return null; // with no drawableAfter, we don't have any external drawables after our interval
    }
  }

  var prototype = {
    // Main stitch entry point, called directly from the backbone or cache. We are modifying our backbone's blocks and
    // their attached drawables.
    // @param {Drawable | null} firstStitchDrawable: What our backbone's first drawable will be after this stitch
    // @param {Drawable | null} lastStitchDrawable: What our backbone's last drawable will be after this stitch
    // @param {Drawable | null} oldFirstStitchDrawable: What our backbone's first drawable was before this stitch
    // @param {Drawable | null} oldLastStitchDrawable: What our backbone's last drawable was before this stitch
    // @param {ChangeInterval} firstChangeInterval: The first change interval of our interval linked-list
    // @param {ChangeInterval} lastChangeInterval: The last change interval of our interval linked-list
    // The change-interval pair denotes a linked-list of change intervals that we will need to stitch across (they
    // contain drawables that need to be removed and added, and it may affect how we lay out blocks in the stacking
    // order).
    stitch: function( backbone, firstStitchDrawable, lastStitchDrawable, oldFirstStitchDrawable, oldLastStitchDrawable, firstChangeInterval, lastChangeInterval ) {
      // required call to the Stitcher interface (see Stitcher.initialize()).
      this.initialize( backbone, firstStitchDrawable, lastStitchDrawable, oldFirstStitchDrawable, oldLastStitchDrawable, firstChangeInterval, lastChangeInterval );

      // Tracks whether our order of blocks changed. If it did, we'll need to rebuild our blocks array. This flag is
      // set if we remove any blocks, create any blocks, or change the order between two blocks (via linkBlocks).
      // It does NOT occur in unuseBlock, since we may reuse the same block in the same position (thus not having an
      // order change).
      this.blockOrderChanged = false;

      // List of blocks that (in the current part of the stitch being processed) are not set to be used by any
      // drawables. Blocks are added to here when they are fully internal to a change interval, and when we glue
      // blocks together. They can be reused through the block-matching process. If they are not reused at the end of
      // this stitch, they will be marked for removal.
      this.reusableBlocks = cleanArray( this.reusableBlocks ); // re-use instance, since we are effectively pooled

      // To properly handle glue/unglue situations with external blocks (ones that aren't reusable after phase 1),
      // we need some extra tracking for our inner sub-block edge case loop.
      this.blockWasAdded = false; // we need to know if a previously-existing block was added, and remove it otherwise.

      var interval;

      // record current first/last drawables for the entire backbone
      this.recordBackboneBoundaries();

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 1: old linked list' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      // Handle pending removal of old blocks/drawables. First, we need to mark all 'internal' drawables with
      // notePendingRemoval(), so that if they aren't added back in this backbone, that they are removed from their
      // old block. Note that later we will add the ones that stay on this backbone, so that they only either change
      // blocks, or stay on the same block.
      if ( backbone.blocks.length ) {
        var veryFirstBlock = backbone.blocks[ 0 ];
        var veryLastBlock = backbone.blocks[ backbone.blocks.length - 1 ];

        for ( interval = firstChangeInterval; interval !== null; interval = interval.nextChangeInterval ) {
          assert && assert( !interval.isEmpty(), 'We now guarantee that the intervals are non-empty' );

          // First, we need to mark all old 'internal' drawables with notePendingRemoval(), so that if they aren't added
          // back in this backbone, that they are removed from their old block. Note that later we will add the ones
          // that stay on this backbone, so that they only either change blocks, or stay on the same block.
          if ( intervalHasOldInternalDrawables( interval, oldFirstStitchDrawable, oldLastStitchDrawable ) ) {
            var firstRemoval = interval.drawableBefore ?
                               interval.drawableBefore.oldNextDrawable :
                               oldFirstStitchDrawable;
            var lastRemoval = interval.drawableAfter ?
                              interval.drawableAfter.oldPreviousDrawable :
                              oldLastStitchDrawable;

            // drawable iteration on the 'old' linked list
            for ( var removedDrawable = firstRemoval; ; removedDrawable = removedDrawable.oldNextDrawable ) {
              this.notePendingRemoval( removedDrawable );
              if ( removedDrawable === lastRemoval ) { break; }
            }
          }

          // Blocks totally contained within the change interval are marked as reusable (doesn't include end blocks).
          if ( intervalHasOldInternalBlocks( interval, veryFirstBlock, veryLastBlock ) ) {
            var firstBlock = interval.drawableBefore === null ? backbone.blocks[ 0 ] : interval.drawableBefore.parentDrawable.nextBlock;
            var lastBlock = interval.drawableAfter === null ? backbone.blocks[ backbone.blocks.length - 1 ] : interval.drawableAfter.parentDrawable.previousBlock;

            for ( var markedBlock = firstBlock; ; markedBlock = markedBlock.nextBlock ) {
              this.unuseBlock( markedBlock );
              if ( markedBlock === lastBlock ) { break; }
            }
          }
        }
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 2: new linked list' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      // Don't process the single interval left if we aren't left with any drawables (thus left with no blocks)
      if ( firstStitchDrawable ) {
        for ( interval = firstChangeInterval; interval !== null; interval = interval.nextChangeInterval ) {
          this.processInterval( backbone, interval, firstStitchDrawable, lastStitchDrawable );
        }
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 3: cleanup' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      // Anything in our 'reusable' blocks array should be removed from our DOM and marked for disposal.
      this.removeUnusedBlocks();

      // Fire off notifyInterval calls to blocks if their boundaries (first/last drawables) have changed. This is
      // a necessary call since we used markBeforeBlock/markAfterBlock to record block boundaries as we went along.
      // We don't want to do this synchronously, because then you could update a block's boundaries multiple times,
      // which may be expensive.
      this.updateBlockIntervals();

      if ( firstStitchDrawable === null ) {
        // i.e. clear our blocks array
        this.useNoBlocks();
      }
      else if ( this.blockOrderChanged ) {
        // Rebuild our blocks array from the linked list format we used for recording our changes (avoids O(n^2)
        // situations since we don't need to do array index lookups while making changes, but only at the end).
        this.processBlockLinkedList( backbone, firstStitchDrawable.pendingParentDrawable, lastStitchDrawable.pendingParentDrawable );

        // Actually reindex the DOM elements of the blocks (changing as necessary)
        this.reindex();
      }

      // required call to the Stitcher interface (see Stitcher.clean()).
      this.clean();

      // release the references we made in this type
      cleanArray( this.reusableBlocks );

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },

    // does the main bulk of the work for each change interval
    processInterval: function( backbone, interval, firstStitchDrawable, lastStitchDrawable ) {
      assert && assert( interval instanceof scenery.ChangeInterval );
      assert && assert( firstStitchDrawable instanceof scenery.Drawable, 'We assume we have a non-null remaining section' );
      assert && assert( lastStitchDrawable instanceof scenery.Drawable, 'We assume we have a non-null remaining section' );
      assert && assert( !interval.isEmpty(), 'We now guarantee that the intervals are non-empty' );

      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'interval: ' +
                                                                          ( interval.drawableBefore ? interval.drawableBefore.toString() : 'null' ) +
                                                                          ' to ' +
                                                                          ( interval.drawableAfter ? interval.drawableAfter.toString() : 'null' ) );
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();

      // check if our interval removes everything, we may need a glue
      if ( !intervalHasNewInternalDrawables( interval, firstStitchDrawable, lastStitchDrawable ) ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'no current internal drawables in interval' );

        // separate if, last condition above would cause issues with the normal operation branch
        if ( interval.drawableBefore && interval.drawableAfter ) {
          assert && assert( interval.drawableBefore.nextDrawable === interval.drawableAfter );

          // if we removed everything (no new internal drawables), our drawableBefore is open 'after', if our
          // drawableAfter is open 'before' since they are siblings (only one flag needed).
          var isOpen = !hasGapBetweenDrawables( interval.drawableBefore, interval.drawableAfter );

          // handle glue/unglue or any other 'external' changes
          this.processEdgeCases( interval, isOpen, isOpen );
        }

        if ( interval.drawableBefore && !isOpenAfter( interval.drawableBefore ) ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-after collapsed link:' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.linkAfterDrawable( interval.drawableBefore );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }
        else if ( interval.drawableAfter && !isOpenBefore( interval.drawableAfter ) ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-before collapsed link:' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.linkBeforeDrawable( interval.drawableAfter );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }
      }
      // otherwise normal operation
      else {
        var drawable = interval.drawableBefore ? interval.drawableBefore.nextDrawable : firstStitchDrawable;

        // if we have any current drawables at all
        var subBlockFirstDrawable = null;
        var matchedBlock = null;
        var isFirst = true;

        // separate our new-drawable linked-list into sub-blocks that we will process individually
        while ( true ) { //eslint-disable-line no-constant-condition
          var nextDrawable = drawable.nextDrawable;
          var isLast = nextDrawable === interval.drawableAfter;

          assert && assert( nextDrawable !== null || isLast, 'If our nextDrawable is null, isLast must be true' );

          if ( !subBlockFirstDrawable ) {
            subBlockFirstDrawable = drawable;
          }

          // See if any of our 'new' drawables were part of a block that we've marked as reusable. If this is the case,
          // we'll greedily try to use this block for matching if possible (ignoring the other potential matches for
          // other drawables after in the same sub-block).
          if ( matchedBlock === null && drawable.parentDrawable && !drawable.parentDrawable.used && drawable.backbone === backbone &&
               drawable.parentDrawable.parentDrawable === backbone ) {
            matchedBlock = drawable.parentDrawable;
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'matching at ' + drawable.toString() + ' with ' + matchedBlock );
          }

          if ( isLast || hasGapBetweenDrawables( drawable, nextDrawable ) ) {
            if ( isFirst ) {
              // we'll handle any glue/unglue at the start, so every processSubBlock can be set correctly.
              this.processEdgeCases( interval, isOpenBefore( subBlockFirstDrawable ), isOpenAfter( drawable ) );
            }

            // do the necessary work for each sub-block (adding drawables, linking, using matched blocks)
            this.processSubBlock( interval, subBlockFirstDrawable, drawable, matchedBlock, isFirst, isLast );

            subBlockFirstDrawable = null;
            matchedBlock = null;
            isFirst = false;
          }

          if ( isLast ) {
            break;
          }
          else {
            drawable = nextDrawable;
          }
        }
      }


      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
    },

    // firstDrawable and lastDrawable refer to the specific sub-block
    processSubBlock: function( interval, firstDrawable, lastDrawable, matchedBlock, isFirst, isLast ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose(
        'sub-block: ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() + ' ' +
        ( matchedBlock ? 'with matched: ' + matchedBlock.toString() : 'with no match' ) );
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();

      var openBefore = isOpenBefore( firstDrawable );
      var openAfter = isOpenAfter( lastDrawable );

      assert && assert( !openBefore || isFirst, 'openBefore implies isFirst' );
      assert && assert( !openAfter || isLast, 'openAfter implies isLast' );

      assert && assert( !openBefore || !openAfter || firstDrawable.previousDrawable.pendingParentDrawable === lastDrawable.nextDrawable.pendingParentDrawable,
        'If we would use both the before and after blocks, make sure any gluing ' );

      // if our sub-block gets combined into the previous block, use its block instead of any match-scanned blocks
      if ( openBefore ) {
        matchedBlock = firstDrawable.previousDrawable.pendingParentDrawable;
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'combining into before block: ' + matchedBlock.toString() );
      }

      // if our sub-block gets combined into the next block, use its block instead of any match-scanned blocks
      if ( openAfter ) {
        matchedBlock = lastDrawable.nextDrawable.pendingParentDrawable;
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'combining into after block: ' + matchedBlock.toString() );
      }

      // create a block if matchedBlock is null, otherwise mark it as used (if it is in reusableBlocks)
      matchedBlock = this.ensureUsedBlock( matchedBlock, firstDrawable );

      // add internal drawables
      for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
        this.notePendingAddition( drawable, matchedBlock );
        if ( drawable === lastDrawable ) { break; }
      }

      // link our blocks (and set pending block boundaries) as needed. assumes glue/unglue has already been performed
      if ( !openBefore ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-before link:' );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
        this.linkBeforeDrawable( firstDrawable );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }
      if ( isLast && !openAfter ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'last closed-after link:' );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
        this.linkAfterDrawable( lastDrawable );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }

      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
    },

    // firstDrawable and lastDrawable refer to the specific sub-block (if it exists), isLast refers to if it's the
    // last sub-block
    processEdgeCases: function( interval, openBefore, openAfter ) {
      // this test passes for glue and unglue cases
      if ( interval.drawableBefore !== null && interval.drawableAfter !== null ) {
        var beforeBlock = interval.drawableBefore.pendingParentDrawable;
        var afterBlock = interval.drawableAfter.pendingParentDrawable;
        var nextAfterBlock = ( interval.nextChangeInterval && interval.nextChangeInterval.drawableAfter ) ?
                             interval.nextChangeInterval.drawableAfter.pendingParentDrawable :
                             null;

        // Since we want to remove any afterBlock at the end of its run if we don't have blockWasAdded set, this check
        // is necessary to see if we have already used this specific block.
        // Otherwise, we would remove our (potentially very-first) block when it has already been used externally.
        if ( beforeBlock === afterBlock ) {
          this.blockWasAdded = true;
        }

        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose(
          'edge case: ' +
          ( openBefore ? 'open-before ' : '' ) +
          ( openAfter ? 'open-after ' : '' ) +
          beforeBlock.toString() + ' to ' + afterBlock.toString() );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();

        // deciding what new block should be used for the external group of drawables after our change interval
        var newAfterBlock;
        // if we have no gaps/boundaries, we should not have two different blocks
        if ( openBefore && openAfter ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'glue using ' + beforeBlock.toString() );
          newAfterBlock = beforeBlock;
        }
        else {
          // if we can't use our afterBlock, since it was used before, or wouldn't create a split
          if ( this.blockWasAdded || beforeBlock === afterBlock ) {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'split with fresh block' );
            // for simplicity right now, we always create a fresh block (to avoid messing up reused blocks) after, and
            // always change everything after (instead of before), so we don't have to jump across multiple previous
            // change intervals
            newAfterBlock = this.createBlock( interval.drawableAfter.renderer, interval.drawableAfter );
            this.blockOrderChanged = true; // needs to be done on block creation
          }
          // otherwise we can use our after block
          else {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'split with same afterBlock ' + afterBlock.toString() );
            newAfterBlock = afterBlock;
          }
        }

        // If we didn't change our block, mark it as added so we don't remove it.
        if ( afterBlock === newAfterBlock ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'no externals change here (blockWasAdded => true)' );
          this.blockWasAdded = true;
        }
        // Otherwise if we changed the block, move over only the external drawables between this interval and the next
        // interval.
        else {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'moving externals' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.changeExternals( interval, newAfterBlock );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }

        // If the next interval's old afterBlock isn't the same as our old afterBlock, we need to make our decision
        // about whether to mark our old afterBlock as reusable, or whether it was used.
        if ( nextAfterBlock !== afterBlock ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'end of afterBlock stretch' );

          // If our block wasn't added yet, it wouldn't ever be added later naturally (so we mark it as reusable).
          if ( !this.blockWasAdded ) {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'unusing ' + afterBlock.toString() );
            this.unuseBlock( afterBlock );
          }
          this.blockWasAdded = false;
        }

        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }
    },

    // Marks all 'external' drawables from the end (drawableAfter) of the {ChangeInterval} interval to either the end
    // of their old block or the drawableAfter of the next interval (whichever is sooner) as being needed to be moved to
    // our {Block} newBlock. The next processInterval will both handle the drawables inside that next interval, and
    // will be responsible for the 'external' drawables after that.
    changeExternals: function( interval, newBlock ) {
      var lastExternalDrawable = getLastCompatibleExternalDrawable( interval );
      this.notePendingMoves( newBlock, interval.drawableAfter, lastExternalDrawable );

      // If we didn't make it all the way to the next change interval's drawableBefore (there was another block
      // starting before the next interval), we need to link our new block to that next block.
      if ( !interval.nextChangeInterval || interval.nextChangeInterval.drawableBefore !== lastExternalDrawable ) {
        this.linkAfterDrawable( lastExternalDrawable );
      }
    },

    // Given a {Drawable} firstDrawable and {Drawable} lastDrawable, we mark all drawables in-between (inclusively) as
    // needing to be moved to our {Block} newBlock. This should only be called on external drawables, and should only
    // occur as needed with glue/unglue cases in the stitch.
    notePendingMoves: function( newBlock, firstDrawable, lastDrawable ) {
      for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
        assert && assert( !drawable.pendingAddition && !drawable.pendingRemoval,
          'Moved drawables should be thought of as unchanged, and thus have nothing pending yet' );

        this.notePendingMove( drawable, newBlock );
        if ( drawable === lastDrawable ) { break; }
      }
    },

    // If there is no currentBlock, we create one to match. Otherwise if the currentBlock is marked as 'unused' (i.e.
    // it is in the reusableBlocks array), we mark it as used so it won't me matched elsewhere.
    ensureUsedBlock: function( currentBlock, someIncludedDrawable ) {
      // if we have a matched block (or started with one)
      if ( currentBlock ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'using existing block: ' + currentBlock.toString() );
        // since our currentBlock may be from reusableBlocks, we will need to mark it as used now.
        if ( !currentBlock.used ) {
          this.useBlock( currentBlock );
        }
      }
      else {
        // need to create one
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'searching for block' );
        currentBlock = this.getBlockForRenderer( someIncludedDrawable.renderer, someIncludedDrawable );
      }
      return currentBlock;
    },

    // Attemps to find an unused block with the same renderer if possible, otherwise creates a
    // compatible block.
    // NOTE: this doesn't handle hooking up the block linked list
    getBlockForRenderer: function( renderer, drawable ) {
      var block;

      // If it's not a DOM block, scan our reusable blocks for one with the same renderer.
      // If it's DOM, it should be processed correctly in reusableBlocks, and will never reach this point.
      if ( !Renderer.isDOM( renderer ) ) {
        // backwards scan, hopefully it's faster?
        for ( var i = this.reusableBlocks.length - 1; i >= 0; i-- ) {
          var tmpBlock = this.reusableBlocks[ i ];
          assert && assert( !tmpBlock.used );
          if ( tmpBlock.renderer === renderer ) {
            this.useBlockAtIndex( tmpBlock, i );
            block = tmpBlock;
            break;
          }
        }
      }

      if ( !block ) {
        // Didn't find it in our reusable blocks, create a fresh one from scratch
        block = this.createBlock( renderer, drawable );
      }

      this.blockOrderChanged = true; // we created a new block, this will always happen

      return block;
    },

    // Marks a block as unused, moving it to the reusableBlocks array.
    unuseBlock: function( block ) {
      if ( block.used ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'unusing block: ' + block.toString() );
        block.used = false; // mark it as unused until we pull it out (so we can reuse, or quickly identify)
        this.reusableBlocks.push( block );
      }
      else {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'not using already-unused block: ' + block.toString() );
      }
    },

    // Removes a block from the list of reused blocks (done during matching)
    useBlock: function( block ) {
      this.useBlockAtIndex( block, _.indexOf( this.reusableBlocks, block ) );
    },

    useBlockAtIndex: function( block, index ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'using reusable block: ' + block.toString() + ' with renderer: ' + block.renderer );

      assert && assert( index >= 0 && this.reusableBlocks[ index ] === block, 'bad index for useBlockAtIndex: ' + index );

      assert && assert( !block.used, 'Should be called on an unused (reusable) block' );

      // remove it
      this.reusableBlocks.splice( index, 1 );

      // mark it as used
      block.used = true;
    },

    // Removes all of our unused blocks from our domElement, and marks them for disposal.
    removeUnusedBlocks: function() {
      sceneryLog && sceneryLog.GreedyStitcher && this.reusableBlocks.length && sceneryLog.GreedyStitcher( 'removeUnusedBlocks' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();
      while ( this.reusableBlocks.length ) {
        var block = this.reusableBlocks.pop();
        this.markBlockForDisposal( block );
        this.blockOrderChanged = true;
      }
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },

    // links blocks before a drawable (whether it is the first drawable or not)
    linkBeforeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'link before ' + drawable.toString() );
      var beforeDrawable = drawable.previousDrawable;
      this.linkBlocks( beforeDrawable ? beforeDrawable.pendingParentDrawable : null,
        drawable.pendingParentDrawable,
        beforeDrawable,
        drawable );
    },

    // links blocks after a drawable (whether it is the last drawable or not)
    linkAfterDrawable: function( drawable ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'link after ' + drawable.toString() );
      var afterDrawable = drawable.nextDrawable;
      this.linkBlocks( drawable.pendingParentDrawable,
        afterDrawable ? afterDrawable.pendingParentDrawable : null,
        drawable,
        afterDrawable );
    },

    // Called to mark a boundary between blocks, or at the end of our list of blocks (one block/drawable pair being
    // null notes that it is the start/end, and there is no previous/next block).
    // This updates the block linked-list as necessary (noting changes when they occur) so that we can rebuild an array
    // at the end of the stitch, avoiding O(n^2) issues if we were to do block-array-index lookups during linking
    // operations (this results in linear time for blocks).
    // It also marks block boundaries as dirty when necessary, so that we can make one pass through with
    // updateBlockIntervals() that updates all of the block's boundaries (avoiding more than one update per block per
    // frame).
    linkBlocks: function( beforeBlock, afterBlock, beforeDrawable, afterDrawable ) {
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'linking blocks: ' +
                                                                            ( beforeBlock ? ( beforeBlock.toString() + ' (' + beforeDrawable.toString() + ')' ) : 'null' ) +
                                                                            ' to ' +
                                                                            ( afterBlock ? ( afterBlock.toString() + ' (' + afterDrawable.toString() + ')' ) : 'null' ) );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      assert && assert( ( beforeBlock === null && beforeDrawable === null ) ||
                        ( beforeBlock instanceof scenery.Block && beforeDrawable instanceof scenery.Drawable ) );
      assert && assert( ( afterBlock === null && afterDrawable === null ) ||
                        ( afterBlock instanceof scenery.Block && afterDrawable instanceof scenery.Drawable ) );

      if ( beforeBlock ) {
        if ( beforeBlock.nextBlock !== afterBlock ) {
          this.blockOrderChanged = true;

          // disconnect from the previously-connected block (if any)
          if ( beforeBlock.nextBlock ) {
            beforeBlock.nextBlock.previousBlock = null;
          }

          beforeBlock.nextBlock = afterBlock;
        }
        this.markAfterBlock( beforeBlock, beforeDrawable );
      }
      if ( afterBlock ) {
        if ( afterBlock.previousBlock !== beforeBlock ) {
          this.blockOrderChanged = true;

          // disconnect from the previously-connected block (if any)
          if ( afterBlock.previousBlock ) {
            afterBlock.previousBlock.nextBlock = null;
          }

          afterBlock.previousBlock = beforeBlock;
        }
        this.markBeforeBlock( afterBlock, afterDrawable );
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },

    // Rebuilds the backbone's block array from our linked-list data.
    processBlockLinkedList: function( backbone, firstBlock, lastBlock ) {
      // for now, just clear out the array first
      while ( backbone.blocks.length ) {
        backbone.blocks.pop();
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'processBlockLinkedList: ' + firstBlock.toString() + ' to ' + lastBlock.toString() );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      // leave the array as-is if there are no blocks
      if ( firstBlock ) {

        // rewrite it starting with the first block
        for ( var block = firstBlock; ; block = block.nextBlock ) {
          sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( block.toString() );

          backbone.blocks.push( block );

          if ( block === lastBlock ) { break; }
        }
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    }
  };

  var GreedyStitcher = inherit( Stitcher, function GreedyStitcher() {
    // nothing done
  }, prototype );
  scenery.register( 'GreedyStitcher', GreedyStitcher );

  GreedyStitcher.stitchPrototype = prototype;

  return GreedyStitcher;
} );

// Copyright 2014, University of Colorado Boulder


/**
 * @deprecated Stitcher that rebuilds all of the blocks and reattaches drawables. Simple, but inefficient.
 *
 * Kept for now as a run-time comparison and baseline for the GreedyStitcher or any other more advanced (but
 * more error-prone) stitching process.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/RebuildStitcher',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/display/Stitcher'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );

  var prototype = {
    stitch: function( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval ) {
      this.initialize( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval );

      for ( var d = backbone.previousFirstDrawable; d !== null; d = d.oldNextDrawable ) {
        this.notePendingRemoval( d );
        if ( d === backbone.previousLastDrawable ) { break; }
      }

      this.recordBackboneBoundaries();

      this.removeAllBlocks();

      var currentBlock = null;
      var currentRenderer = 0;
      var firstDrawableForBlock = null;

      // linked-list iteration inclusively from firstDrawable to lastDrawable
      for ( var drawable = firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {

        // if we need to switch to a new block, create it
        if ( !currentBlock || drawable.renderer !== currentRenderer ) {
          if ( currentBlock ) {
            this.notifyInterval( currentBlock, firstDrawableForBlock, drawable.previousDrawable );
          }

          currentRenderer = drawable.renderer;

          currentBlock = this.createBlock( currentRenderer, drawable );
          if ( Renderer.isDOM( currentRenderer ) ) {
            currentRenderer = 0;
          }

          this.appendBlock( currentBlock );

          firstDrawableForBlock = drawable;
        }

        this.notePendingAddition( drawable, currentBlock );

        // don't cause an infinite loop!
        if ( drawable === lastDrawable ) { break; }
      }
      if ( currentBlock ) {
        this.notifyInterval( currentBlock, firstDrawableForBlock, lastDrawable );
      }

      this.reindex();

      this.clean();
    }
  };

  var RebuildStitcher = inherit( Stitcher, function RebuildStitcher() {
    // nothing done
  }, prototype );
  scenery.register( 'RebuildStitcher', RebuildStitcher );

  RebuildStitcher.stitchPrototype = prototype;

  return RebuildStitcher;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A DOM drawable (div element) that contains child blocks (and is placed in the main DOM tree when visible). It should
 * use z-index for properly ordering its blocks in the correct stacking order.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/BackboneDrawable',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable','SCENERY/display/Stitcher','SCENERY/display/GreedyStitcher','SCENERY/display/RebuildStitcher','SCENERY/util/Util'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );
  var GreedyStitcher = require( 'SCENERY/display/GreedyStitcher' );
  var RebuildStitcher = require( 'SCENERY/display/RebuildStitcher' );
  var Util = require( 'SCENERY/util/Util' );

  // constants
  var useGreedyStitcher = true;

  /**
   * @param {Display} display
   * @param {Instance} backboneInstance
   * @param {Instance} transformRootInstance
   * @param {number} renderer
   * @param {boolean} isDisplayRoot
   * @constructor
   */
  function BackboneDrawable( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
    this.initialize( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
  }

  scenery.register( 'BackboneDrawable', BackboneDrawable );

  inherit( Drawable, BackboneDrawable, {

    /**
     * @param {Display} display
     * @param {Instance} backboneInstance
     * @param {Instance} transformRootInstance
     * @param {number} renderer
     * @param {boolean} isDisplayRoot
     */
    initialize: function( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
      Drawable.call( this, renderer );

      this.display = display;

      this.forceAcceleration = false;

      // reference to the instance that controls this backbone
      this.backboneInstance = backboneInstance;

      // where is the transform root for our generated blocks?
      this.transformRootInstance = transformRootInstance;

      // where have filters been applied to up? our responsibility is to apply filters between this and our backboneInstance
      this.filterRootAncestorInstance = backboneInstance.parent ? backboneInstance.parent.getFilterRootInstance() : backboneInstance;

      // where have transforms been applied up to? our responsibility is to apply transforms between this and our backboneInstance
      this.transformRootAncestorInstance = backboneInstance.parent ? backboneInstance.parent.getTransformRootInstance() : backboneInstance;

      this.willApplyTransform = this.transformRootAncestorInstance !== this.transformRootInstance;
      this.willApplyFilters = this.filterRootAncestorInstance !== this.backboneInstance;

      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );
      if ( this.willApplyTransform ) {
        this.backboneInstance.relativeTransform.addListener( this.transformListener ); // when our relative transform changes, notify us in the pre-repaint phase
        this.backboneInstance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated
      }

      this.backboneVisibilityListener = this.backboneVisibilityListener || this.updateBackboneVisibility.bind( this );
      this.backboneInstance.onStatic( 'relativeVisibility', this.backboneVisibilityListener );
      this.updateBackboneVisibility();
      this.visibilityDirty = true;

      this.renderer = renderer;
      this.domElement = isDisplayRoot ? display._domElement : BackboneDrawable.createDivBackbone();
      this.isDisplayRoot = isDisplayRoot;
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );

      Util.prepareForTransform( this.domElement, this.forceAcceleration );

      // if we need to, watch nodes below us (and including us) and apply their filters (opacity/visibility/clip) to the backbone.
      this.watchedFilterNodes = cleanArray( this.watchedFilterNodes );
      this.opacityDirty = true;
      this.clipDirty = true;
      this.opacityDirtyListener = this.opacityDirtyListener || this.markOpacityDirty.bind( this );
      this.clipDirtyListener = this.clipDirtyListener || this.markClipDirty.bind( this );
      if ( this.willApplyFilters ) {
        assert && assert( this.filterRootAncestorInstance.trail.nodes.length < this.backboneInstance.trail.nodes.length,
          'Our backboneInstance should be deeper if we are applying filters' );

        // walk through to see which instances we'll need to watch for filter changes
        for ( var instance = this.backboneInstance; instance !== this.filterRootAncestorInstance; instance = instance.parent ) {
          var node = instance.node;

          this.watchedFilterNodes.push( node );
          node.onStatic( 'opacity', this.opacityDirtyListener );
          node.onStatic( 'clip', this.clipDirtyListener );
        }
      }

      this.lastZIndex = 0; // our last zIndex is stored, so that overlays can be added easily

      this.blocks = this.blocks || []; // we are responsible for their disposal

      // the first/last drawables for the last the this backbone was stitched
      this.previousFirstDrawable = null;
      this.previousLastDrawable = null;

      // We track whether our drawables were marked for removal (in which case, they should all be removed by the time we dispose).
      // If removedDrawables = false during disposal, it means we need to remove the drawables manually (this should only happen if an instance tree is removed)
      this.removedDrawables = false;

      this.stitcher = this.stitcher || ( useGreedyStitcher ? new GreedyStitcher() : new RebuildStitcher() );

      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'initialized ' + this.toString() );

      return this; // chaining
    },

    dispose: function() {
      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.push();


      while ( this.watchedFilterNodes.length ) {
        var node = this.watchedFilterNodes.pop();

        node.offStatic( 'opacity', this.opacityDirtyListener );
        node.offStatic( 'clip', this.clipDirtyListener );
      }

      this.backboneInstance.offStatic( 'relativeVisibility', this.backboneVisibilityListener );

      // if we need to remove drawables from the blocks, do so
      if ( !this.removedDrawables ) {
        for ( var d = this.previousFirstDrawable; d !== null; d = d.nextDrawable ) {
          d.parentDrawable.removeDrawable( d );
          if ( d === this.previousLastDrawable ) { break; }
        }
      }

      this.markBlocksForDisposal();

      if ( this.willApplyTransform ) {
        this.backboneInstance.relativeTransform.removeListener( this.transformListener );
        this.backboneInstance.relativeTransform.removePrecompute();
      }

      this.backboneInstance = null;
      this.transformRootInstance = null;
      this.filterRootAncestorInstance = null;
      this.transformRootAncestorInstance = null;
      cleanArray( this.dirtyDrawables );
      cleanArray( this.watchedFilterNodes );

      this.previousFirstDrawable = null;
      this.previousLastDrawable = null;

      Drawable.prototype.dispose.call( this );

      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.pop();
    },

    // dispose all of the blocks while clearing our references to them
    markBlocksForDisposal: function() {
      while ( this.blocks.length ) {
        var block = this.blocks.pop();
        sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( this.toString() + ' removing block: ' + block.toString() );
        //TODO: PERFORMANCE: does this cause reflows / style calculation
        if ( block.domElement.parentNode === this.domElement ) {
          // guarded, since we may have a (new) child drawable add it before we can remove it
          this.domElement.removeChild( block.domElement );
        }
        block.markForDisposal( this.display );
      }
    },

    updateBackboneVisibility: function() {
      this.visible = this.backboneInstance.relativeVisible;

      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },

    // should be called during syncTree
    markForDisposal: function( display ) {
      for ( var d = this.previousFirstDrawable; d !== null; d = d.oldNextDrawable ) {
        d.notePendingRemoval( this.display );
        if ( d === this.previousLastDrawable ) { break; }
      }
      this.removedDrawables = true;

      // super call
      Drawable.prototype.markForDisposal.call( this, display );
    },

    markDirtyDrawable: function( drawable ) {
      if ( assert ) {
        // Catch infinite loops
        this.display.ensureNotPainting();
      }

      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },

    markTransformDirty: function() {
      assert && assert( this.willApplyTransform, 'Sanity check for willApplyTransform' );

      // relative matrix on backbone instance should be up to date, since we added the compute flags
      scenery.Util.applyPreparedTransform( this.backboneInstance.relativeTransform.matrix, this.domElement, this.forceAcceleration );
    },

    markOpacityDirty: function() {
      if ( !this.opacityDirty ) {
        this.opacityDirty = true;
        this.markDirty();
      }
    },

    markClipDirty: function() {
      if ( !this.clipDirty ) {
        this.clipDirty = true;
        this.markDirty();
      }
    },

    update: function() {
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }

        if ( this.opacityDirty ) {
          this.opacityDirty = false;

          var filterOpacity = this.willApplyFilters ? this.getFilterOpacity() : 1;
          this.domElement.style.opacity = ( filterOpacity !== 1 ) ? filterOpacity : '';
        }

        if ( this.visibilityDirty ) {
          this.visibilityDirty = false;

          this.domElement.style.display = this.visible ? '' : 'none';
        }

        if ( this.clipDirty ) {
          this.clipDirty = false;

          var clip = this.willApplyFilters ? this.getFilterClip() : '';

          //OHTWO TODO: CSS clip-path/mask support here. see http://www.html5rocks.com/en/tutorials/masking/adobe/
          this.domElement.style.clipPath = clip; // yikes! temporary, since we already threw something?
        }
      }
    },

    getFilterOpacity: function() {
      var opacity = 1;

      var len = this.watchedFilterNodes.length;
      for ( var i = 0; i < len; i++ ) {
        opacity *= this.watchedFilterNodes[ i ].getOpacity();
      }

      return opacity;
    },

    getFilterVisibility: function() {
      var len = this.watchedFilterNodes.length;
      for ( var i = 0; i < len; i++ ) {
        if ( !this.watchedFilterNodes[ i ].isVisible() ) {
          return false;
        }
      }

      return true;
    },

    getFilterClip: function() {
      var clip = '';

      //OHTWO TODO: proper clipping support
      // var len = this.watchedFilterNodes.length;
      // for ( var i = 0; i < len; i++ ) {
      //   if ( this.watchedFilterNodes[i].clipArea ) {
      //     throw new Error( 'clip-path for backbones unimplemented, and with questionable browser support!' );
      //   }
      // }

      return clip;
    },

    // ensures that z-indices are strictly increasing, while trying to minimize the number of times we must change it
    reindexBlocks: function() {
      // full-pass change for zindex.
      var zIndex = 0; // don't start below 1 (we ensure > in loop)
      for ( var k = 0; k < this.blocks.length; k++ ) {
        var block = this.blocks[ k ];
        if ( block.zIndex <= zIndex ) {
          var newIndex = ( k + 1 < this.blocks.length && this.blocks[ k + 1 ].zIndex - 1 > zIndex ) ?
                         Math.ceil( ( zIndex + this.blocks[ k + 1 ].zIndex ) / 2 ) :
                         zIndex + 20;

          // NOTE: this should give it its own stacking index (which is what we want)
          block.domElement.style.zIndex = block.zIndex = newIndex;
        }
        zIndex = block.zIndex;

        if ( assert ) {
          assert( this.blocks[ k ].zIndex % 1 === 0, 'z-indices should be integers' );
          assert( this.blocks[ k ].zIndex > 0, 'z-indices should be greater than zero for our needs (see spec)' );
          if ( k > 0 ) {
            assert( this.blocks[ k - 1 ].zIndex < this.blocks[ k ].zIndex, 'z-indices should be strictly increasing' );
          }
        }
      }

      // sanity check
      this.lastZIndex = zIndex + 1;
    },

    stitch: function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval ) {
      // no stitch necessary if there are no change intervals
      if ( firstChangeInterval === null || lastChangeInterval === null ) {
        assert && assert( firstChangeInterval === null );
        assert && assert( lastChangeInterval === null );
        return;
      }

      assert && assert( lastChangeInterval.nextChangeInterval === null, 'This allows us to have less checks in the loop' );

      if ( sceneryLog && sceneryLog.Stitch ) {
        sceneryLog.Stitch( 'Stitch intervals before constricting: ' + this.toString() );
        sceneryLog.push();
        Stitcher.debugIntervals( firstChangeInterval );
        sceneryLog.pop();
      }

      // Make the intervals as small as possible by skipping areas without changes, and collapse the interval
      // linked list
      var lastNonemptyInterval = null;
      var interval = firstChangeInterval;
      var intervalsChanged = false;
      while ( interval ) {
        intervalsChanged = interval.constrict() || intervalsChanged;

        if ( interval.isEmpty() ) {
          assert && assert( intervalsChanged );

          if ( lastNonemptyInterval ) {
            // skip it, hook the correct reference
            lastNonemptyInterval.nextChangeInterval = interval.nextChangeInterval;
          }
        }
        else {
          // our first non-empty interval will be our new firstChangeInterval
          if ( !lastNonemptyInterval ) {
            firstChangeInterval = interval;
          }
          lastNonemptyInterval = interval;
        }
        interval = interval.nextChangeInterval;
      }

      if ( !lastNonemptyInterval ) {
        // eek, no nonempty change intervals. do nothing (good to catch here, but ideally there shouldn't be change
        // intervals that all collapse).
        return;
      }

      lastChangeInterval = lastNonemptyInterval;
      lastChangeInterval.nextChangeInterval = null;

      if ( sceneryLog && sceneryLog.Stitch && intervalsChanged ) {
        sceneryLog.Stitch( 'Stitch intervals after constricting: ' + this.toString() );
        sceneryLog.push();
        Stitcher.debugIntervals( firstChangeInterval );
        sceneryLog.pop();
      }

      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.display.perfStitchCount++;

        var dInterval = firstChangeInterval;

        while ( dInterval ) {
          this.display.perfIntervalCount++;

          this.display.perfDrawableOldIntervalCount += dInterval.getOldInternalDrawableCount( this.previousFirstDrawable, this.previousLastDrawable );
          this.display.perfDrawableNewIntervalCount += dInterval.getNewInternalDrawableCount( firstDrawable, lastDrawable );

          dInterval = dInterval.nextChangeInterval;
        }
      }

      this.stitcher.stitch( this, firstDrawable, lastDrawable, this.previousFirstDrawable, this.previousLastDrawable, firstChangeInterval, lastChangeInterval );
    },

    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        Drawable.prototype.audit.call( this, allowPendingBlock, allowPendingList, allowDirty );

        assertSlow && assertSlow( this.backboneInstance.isBackbone, 'We should reference an instance that requires a backbone' );
        assertSlow && assertSlow( this.transformRootInstance.isTransformed, 'Transform root should be transformed' );

        for ( var i = 0; i < this.blocks.length; i++ ) {
          this.blocks[ i ].audit( allowPendingBlock, allowPendingList, allowDirty );
        }
      }
    }
  } );

  BackboneDrawable.createDivBackbone = function() {
    var div = document.createElement( 'div' );
    div.style.position = 'absolute';
    div.style.left = '0';
    div.style.top = '0';
    div.style.width = '0';
    div.style.height = '0';
    return div;
  };

  BackboneDrawable.repurposeBackboneContainer = function( element ) {
    if ( element.style.position !== 'relative' || element.style.position !== 'absolute' ) {
      element.style.position = 'relative';
    }
    element.style.left = '0';
    element.style.top = '0';
    return element;
  };

  Poolable.mixin( BackboneDrawable, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'new from pool' );
          return pool.pop().initialize( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
        }
        else {
          sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'new from constructor' );
          return new BackboneDrawable( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
        }
      };
    }
  } );

  return BackboneDrawable;
} );

// Copyright 2014-2015, University of Colorado Boulder


/**
 * A drawable that will paint a single instance.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SelfDrawable',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  function SelfDrawable( renderer, instance ) {
    this.initializeSelfDrawable( renderer, instance );
  }

  scenery.register( 'SelfDrawable', SelfDrawable );

  inherit( scenery.Drawable, SelfDrawable, {
    initializeSelfDrawable: function( renderer, instance ) {
      this.drawableVisibilityListener = this.drawableVisibilityListener || this.updateSelfVisibility.bind( this );

      // super initialization
      this.initializeDrawable( renderer );

      this.instance = instance;
      this.node = instance.trail.lastNode();
      this.node.attachDrawable( this );

      this.instance.onStatic( 'selfVisibility', this.drawableVisibilityListener );

      this.updateSelfVisibility();

      return this;
    },

    // @public
    dispose: function() {
      this.instance.offStatic( 'selfVisibility', this.drawableVisibilityListener );

      this.node.detachDrawable( this );

      // free references
      this.instance = null;
      this.node = null;

      Drawable.prototype.dispose.call( this );
    },

    updateSelfVisibility: function() {
      // hide our drawable if it is not relatively visible
      this.visible = this.instance.selfVisible;
    },

    toDetailedString: function() {
      return this.toString() + ' (' + this.instance.trail.toPathString() + ')';
    }
  } );

  SelfDrawable.Poolable = {
    mixin: function( selfDrawableType ) {
      // for pooling, allow <SelfDrawableType>.createFromPool( renderer, instance ) and drawable.freeToPool(). Creation will initialize the drawable to an initial state
      Poolable.mixin( selfDrawableType, {
        defaultFactory: function() {
          return new selfDrawableType();
        },
        constructorDuplicateFactory: function( pool ) {
          return function( renderer, instance ) {
            if ( pool.length ) {
              return pool.pop().initialize( renderer, instance );
            }
            else {
              return new selfDrawableType( renderer, instance );
            }
          };
        }
      } );
    }
  };

  return SelfDrawable;
} );

// Copyright 2012-2015, University of Colorado Boulder

/**
 * A color with RGBA values, assuming the sRGB color space is used.
 *
 * See http://www.w3.org/TR/css3-color/
 *
 * TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Color',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Util','DOT/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var clamp = require( 'DOT/Util' ).clamp;
  var linear = require( 'DOT/Util' ).linear;

  /**
   * Creates a Color with an initial value. Multiple different types of parameters are supported:
   * - new Color( color ) is a copy constructor, for a {Color}
   * - new Color( string ) will parse the string assuming it's a CSS-compatible color, e.g. set( 'red' )
   * - new Color( r, g, b ) is equivalent to setRGBA( r, g, b, 1 ), e.g. set( 255, 0, 128 )
   * - new Color( r, g, b, a ) is equivalent to setRGBA( r, g, b, a ), e.g. set( 255, 0, 128, 0.5 )
   * - new Color( hex ) will set RGB with alpha=1, e.g. set( 0xFF0000 )
   * - new Color( hex, a ) will set RGBA, e.g. set( 0xFF0000, 1 )
   *
   * The 'r', 'g', and 'b' values stand for red, green and blue respectively, and will be clamped to integers in 0-255.
   * The 'a' value stands for alpha, and will be clamped to 0-1 (floating point)
   * 'hex' indicates a 6-decimal-digit format hex number, for example 0xFFAA00 is equivalent to r=255, g=170, b=0.
   */
  function Color( r, g, b, a ) {

    // allow listeners to be notified on any changes. called with listener()
    this.listeners = [];

    this.set( r, g, b, a );

    phetAllocation && phetAllocation( 'Color' );
  }

  scenery.register( 'Color', Color );

  // regex utilities
  var rgbNumber = '(-?\\d{1,3}%?)'; // syntax allows negative integers and percentages
  var aNumber = '(\\d+|\\d*\\.\\d+)'; // decimal point number. technically we allow for '255', even though this will be clamped to 1.
  var rawNumber = '(\\d{1,3})'; // a 1-3 digit number

  // handles negative and percentage values
  function parseRGBNumber( str ) {
    var multiplier = 1;

    // if it's a percentage, strip it off and handle it that way
    if ( str.charAt( str.length - 1 ) === '%' ) {
      multiplier = 2.55;
      str = str.slice( 0, str.length - 1 );
    }

    return Math.round( parseInt( str, 10 ) * multiplier );
  }

  Color.formatParsers = [
    {
      // 'transparent'
      regexp: /^transparent$/,
      apply: function( color, matches ) {
        color.setRGBA( 0, 0, 0, 0 );
      }
    },
    {
      // short hex form, a la '#fff'
      regexp: /^#(\w{1})(\w{1})(\w{1})$/,
      apply: function( color, matches ) {
        color.setRGBA(
          parseInt( matches[ 1 ] + matches[ 1 ], 16 ),
          parseInt( matches[ 2 ] + matches[ 2 ], 16 ),
          parseInt( matches[ 3 ] + matches[ 3 ], 16 ),
          1 );
      }
    },
    {
      // long hex form, a la '#ffffff'
      regexp: /^#(\w{2})(\w{2})(\w{2})$/,
      apply: function( color, matches ) {
        color.setRGBA(
          parseInt( matches[ 1 ], 16 ),
          parseInt( matches[ 2 ], 16 ),
          parseInt( matches[ 3 ], 16 ),
          1 );
      }
    },
    {
      // rgb(...)
      regexp: new RegExp( '^rgb\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setRGBA(
          parseRGBNumber( matches[ 1 ] ),
          parseRGBNumber( matches[ 2 ] ),
          parseRGBNumber( matches[ 3 ] ),
          1 );
      }
    },
    {
      // rgba(...)
      regexp: new RegExp( '^rgba\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + ',' + aNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setRGBA(
          parseRGBNumber( matches[ 1 ] ),
          parseRGBNumber( matches[ 2 ] ),
          parseRGBNumber( matches[ 3 ] ),
          parseFloat( matches[ 4 ] ) );
      }
    },
    {
      // hsl(...)
      regexp: new RegExp( '^hsl\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%\\)$' ),
      apply: function( color, matches ) {
        color.setHSLA(
          parseInt( matches[ 1 ], 10 ),
          parseInt( matches[ 2 ], 10 ),
          parseInt( matches[ 3 ], 10 ),
          1 );
      }
    },
    {
      // hsla(...)
      regexp: new RegExp( '^hsla\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%,' + aNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setHSLA(
          parseInt( matches[ 1 ], 10 ),
          parseInt( matches[ 2 ], 10 ),
          parseInt( matches[ 3 ], 10 ),
          parseFloat( matches[ 4 ] ) );
      }
    }
  ];

  // see http://www.w3.org/TR/css3-color/
  Color.hueToRGB = function( m1, m2, h ) {
    if ( h < 0 ) {
      h = h + 1;
    }
    if ( h > 1 ) {
      h = h - 1;
    }
    if ( h * 6 < 1 ) {
      return m1 + ( m2 - m1 ) * h * 6;
    }
    if ( h * 2 < 1 ) {
      return m2;
    }
    if ( h * 3 < 2 ) {
      return m1 + ( m2 - m1 ) * ( 2 / 3 - h ) * 6;
    }
    return m1;
  };

  /**
   * Convenience function that converts a color spec to a color object if
   * necessary, or simply returns the color object if not.
   * @param {String|Color} colorSpec
   */
  Color.toColor = function( colorSpec ) {
    return colorSpec instanceof Color ? colorSpec : new Color( colorSpec );
  };

  inherit( Object, Color, {
    copy: function() {
      return new Color( this.r, this.g, this.b, this.a );
    },

    /**
     * Sets the values of this Color. Supported styles:
     * - set( color ) is a copy constructor
     * - set( string ) will parse the string assuming it's a CSS-compatible color, e.g. set( 'red' )
     * - set( r, g, b ) is equivalent to setRGBA( r, g, b, 1 ), e.g. set( 255, 0, 128 )
     * - set( r, g, b, a ) is equivalent to setRGBA( r, g, b, a ), e.g. set( 255, 0, 128, 0.5 )
     * - set( hex ) will set RGB with alpha=1, e.g. set( 0xFF0000 )
     * - set( hex, alpha ) will set RGBA, e.g. set( 0xFF0000, 1 )
     */
    set: function( r, g, b, a ) {
      assert && assert( r !== undefined, 'Can\'t call Color.set( undefined )' );

      // support for set( string )
      if ( typeof r === 'string' ) {
        this.setCSS( r );
      }
      // support for set( color )
      else if ( r instanceof Color ) {
        this.setRGBA( r.r, r.g, r.b, r.a );
      }
      // support for set( hex ) and set( hex, alpha )
      else if ( b === undefined ) {
        assert && assert( typeof r === 'number' );
        assert && assert( g === undefined || typeof g === 'number' );

        var red = ( r >> 16 ) & 0xFF;
        var green = ( r >> 8 ) & 0xFF;
        var blue = ( r >> 0 ) & 0xFF;
        var alpha = ( g === undefined ) ? 1 : g;
        this.setRGBA( red, green, blue, alpha );
      }
      // support for set( r, g, b ) and set( r, g, b, a )
      else {
        assert && assert( typeof r === 'number' );
        assert && assert( typeof g === 'number' );
        assert && assert( typeof b === 'number' );
        assert && assert( a === undefined || typeof a === 'number' );
        this.setRGBA( r, g, b, ( a === undefined ) ? 1 : a );
      }

      return this; // support chaining
    },

    // red, integral 0-255
    getRed: function() { return this.r; },
    setRed: function( value ) { return this.setRGBA( value, this.g, this.b, this.a ); },
    get red() { return this.getRed(); },
    set red( value ) { return this.setRed( value ); },

    // green, integral 0-255
    getGreen: function() { return this.g; },
    setGreen: function( value ) { return this.setRGBA( this.r, value, this.b, this.a ); },
    get green() { return this.getGreen(); },
    set green( value ) { return this.setGreen( value ); },

    // blue, integral 0-255
    getBlue: function() { return this.b; },
    setBlue: function( value ) { return this.setRGBA( this.r, this.g, value, this.a ); },
    get blue() { return this.getBlue(); },
    set blue( value ) { return this.setBlue( value ); },

    // alpha, floating 0-1
    getAlpha: function() { return this.a; },
    setAlpha: function( value ) { return this.setRGBA( this.r, this.g, this.b, value ); },
    get alpha() { return this.getAlpha(); },
    set alpha( value ) { return this.setAlpha( value ); },

    // RGB integral between 0-255, alpha (float) between 0-1
    setRGBA: function( red, green, blue, alpha ) {
      this.r = Math.round( clamp( red, 0, 255 ) );
      this.g = Math.round( clamp( green, 0, 255 ) );
      this.b = Math.round( clamp( blue, 0, 255 ) );
      this.a = clamp( alpha, 0, 1 );

      this.updateColor(); // update the cached value

      return this; // allow chaining
    },

    computeCSS: function() {
      if ( this.a === 1 ) {
        return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
      }
      else {
        // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
        // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
        // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
        // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
        var alpha = this.a.toFixed( 20 );
        while ( alpha.length >= 2 && alpha[ alpha.length - 1 ] === '0' && alpha[ alpha.length - 2 ] !== '.' ) {
          alpha = alpha.slice( 0, alpha.length - 1 );
        }

        var alphaString = this.a === 0 || this.a === 1 ? this.a : alpha;
        return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + alphaString + ')';
      }
    },

    toCSS: function() {
      // verify that the cached value is correct (in debugging builds only, defeats the point of caching otherwise)
      assert && assert( this._css === this.computeCSS(), 'CSS cached value is ' + this._css + ', but the computed value appears to be ' + this.computeCSS() );

      return this._css;
    },

    setCSS: function( cssString ) {
      var str = cssString.replace( / /g, '' ).toLowerCase();
      var success = false;

      // replace colors based on keywords
      var keywordMatch = Color.colorKeywords[ str ];
      if ( keywordMatch ) {
        str = '#' + keywordMatch;
      }

      // run through the available text formats
      for ( var i = 0; i < Color.formatParsers.length; i++ ) {
        var parser = Color.formatParsers[ i ];

        var matches = parser.regexp.exec( str );
        if ( matches ) {
          parser.apply( this, matches );
          success = true;
          break;
        }
      }

      if ( !success ) {
        throw new Error( 'scenery.Color unable to parse color string: ' + cssString );
      }

      this.updateColor(); // update the cached value
    },

    // e.g. 0xFF00FF
    toNumber: function() {
      return ( this.r << 16 ) + ( this.g << 8 ) + this.b;
    },

    // called to update the internally cached CSS value
    updateColor: function() {
      assert && assert( !this.immutable, 'Cannot modify an immutable color' );

      assert && assert( isFinite( this.red ) && isFinite( this.green ) && isFinite( this.blue ) && isFinite( this.alpha ),
        'Ensure color components are finite and not NaN' );

      var oldCSS = this._css;
      this._css = this.computeCSS();

      // notify listeners if it changed
      if ( oldCSS !== this._css && this.listeners.length ) {
        var listeners = this.listeners.slice( 0 ); // defensive copy. consider removing if it's a performance bottleneck?
        var length = listeners.length;

        for ( var i = 0; i < length; i++ ) {
          listeners[ i ]();
        }
      }
    },

    // allow setting this Color to be immutable when assertions are disabled. any change will throw an error
    setImmutable: function() {
      if ( assert ) {
        this.immutable = true;
      }

      return this; // allow chaining
    },

    // to what value a Canvas's context.fillStyle should be set
    getCanvasStyle: function() {
      return this.toCSS(); // should be inlined, leave like this for future maintainability
    },

    // TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!
    setHSLA: function( hue, saturation, lightness, alpha ) {
      hue = ( hue % 360 ) / 360;                    // integer modulo 360
      saturation = clamp( saturation / 100, 0, 1 ); // percentage
      lightness = clamp( lightness / 100, 0, 1 );   // percentage

      // see http://www.w3.org/TR/css3-color/
      var m1;
      var m2;
      if ( lightness < 0.5 ) {
        m2 = lightness * ( saturation + 1 );
      }
      else {
        m2 = lightness + saturation - lightness * saturation;
      }
      m1 = lightness * 2 - m2;

      this.r = Math.round( Color.hueToRGB( m1, m2, hue + 1 / 3 ) * 255 );
      this.g = Math.round( Color.hueToRGB( m1, m2, hue ) * 255 );
      this.b = Math.round( Color.hueToRGB( m1, m2, hue - 1 / 3 ) * 255 );
      this.a = clamp( alpha, 0, 1 );

      this.updateColor(); // update the cached value

      return this; // allow chaining
    },

    equals: function( color ) {
      return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
    },

    withAlpha: function( alpha ) {
      return new Color( this.r, this.g, this.b, alpha );
    },

    checkFactor: function( factor ) {
      if ( factor < 0 || factor > 1 ) {
        throw new Error( 'factor must be between 0 and 1: ' + factor );
      }
      return ( factor === undefined ) ? 0.7 : factor;
    },

    // matches Java's Color.brighter()
    brighterColor: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.min( 255, Math.floor( this.r / factor ) );
      var green = Math.min( 255, Math.floor( this.g / factor ) );
      var blue = Math.min( 255, Math.floor( this.b / factor ) );
      return new Color( red, green, blue, this.a );
    },

    /**
     * Brightens a color in RGB space. Useful when creating gradients from a
     * single base color.
     *
     * @param color
     * @param factor 0 (no change) to 1 (white)
     * @return lighter (closer to white) version of the original color.
     */
    colorUtilsBrighter: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.min( 255, this.getRed() + Math.floor( factor * ( 255 - this.getRed() ) ) );
      var green = Math.min( 255, this.getGreen() + Math.floor( factor * ( 255 - this.getGreen() ) ) );
      var blue = Math.min( 255, this.getBlue() + Math.floor( factor * ( 255 - this.getBlue() ) ) );
      return new Color( red, green, blue, this.getAlpha() );
    },

    // matches Java's Color.darker()
    darkerColor: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.max( 0, Math.floor( factor * this.r ) );
      var green = Math.max( 0, Math.floor( factor * this.g ) );
      var blue = Math.max( 0, Math.floor( factor * this.b ) );
      return new Color( red, green, blue, this.a );
    },

    /**
     * Darken a color in RGB space. Useful when creating gradients from a single
     * base color.
     *
     * @param color  the original color
     * @param factor 0 (no change) to 1 (black)
     * @return darker (closer to black) version of the original color.
     */
    colorUtilsDarker: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.max( 0, this.getRed() - Math.floor( factor * this.getRed() ) );
      var green = Math.max( 0, this.getGreen() - Math.floor( factor * this.getGreen() ) );
      var blue = Math.max( 0, this.getBlue() - Math.floor( factor * this.getBlue() ) );
      return new Color( red, green, blue, this.getAlpha() );
    },

    /*
     * Like colorUtilsBrighter/Darker, however factor should be in the range -1 to 1, and it will call:
     *   colorUtilsBrighter( factor )   for factor >  0
     *   this                           for factor == 0
     *   colorUtilsDarker( -factor )    for factor <  0
     * Thus:
     * @param factor from -1 (black), to 0 (no change), to 1 (white)
     */
    colorUtilsBrightness: function( factor ) {
      if ( factor === 0 ) {
        return this;
      }
      else if ( factor > 0 ) {
        return this.colorUtilsBrighter( factor );
      }
      else {
        return this.colorUtilsDarker( -factor );
      }
    },

    /*---------------------------------------------------------------------------*
     * listeners TODO: consider mixing in this behavior, it's common
     *----------------------------------------------------------------------------*/

    // listener should be a callback expecting no arguments, listener() will be called when the color changes
    addChangeListener: function( listener ) {
      assert && assert( listener !== undefined && listener !== null, 'Verify that the listener exists' );
      assert && assert( !_.contains( this.listeners, listener ) );
      this.listeners.push( listener );
    },

    removeChangeListener: function( listener ) {
      assert && assert( _.contains( this.listeners, listener ) );
      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );
    },

    getListenerCount: function() {
      return this.listeners.length;
    },

    toString: function() {
      return this.constructor.name + '[r:' + this.r + ' g:' + this.g + ' b:' + this.b + ' a:' + this.a + ']';
    },

    toStateObject: function() {
      return {
        r: this.r,
        g: this.g,
        b: this.b,
        a: this.a
      };
    }
  } );

  Color.basicColorKeywords = {
    aqua: '00ffff',
    black: '000000',
    blue: '0000ff',
    fuchsia: 'ff00ff',
    gray: '808080',
    green: '008000',
    lime: '00ff00',
    maroon: '800000',
    navy: '000080',
    olive: '808000',
    purple: '800080',
    red: 'ff0000',
    silver: 'c0c0c0',
    teal: '008080',
    white: 'ffffff',
    yellow: 'ffff00'
  };

  Color.colorKeywords = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '00ffff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '00ffff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'ff00ff',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '778899',
    lightslategrey: '778899',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '00ff00',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'ff00ff',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    red: 'ff0000',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'ffffff',
    whitesmoke: 'f5f5f5',
    yellow: 'ffff00',
    yellowgreen: '9acd32'
  };

  // Java compatibility
  Color.BLACK = Color.black = new Color( 0, 0, 0 ).setImmutable();
  Color.BLUE = Color.blue = new Color( 0, 0, 255 ).setImmutable();
  Color.CYAN = Color.cyan = new Color( 0, 255, 255 ).setImmutable();
  Color.DARK_GRAY = Color.darkGray = new Color( 64, 64, 64 ).setImmutable();
  Color.GRAY = Color.gray = new Color( 128, 128, 128 ).setImmutable();
  Color.GREEN = Color.green = new Color( 0, 255, 0 ).setImmutable();
  Color.LIGHT_GRAY = Color.lightGray = new Color( 192, 192, 192 ).setImmutable();
  Color.MAGENTA = Color.magenta = new Color( 255, 0, 255 ).setImmutable();
  Color.ORANGE = Color.orange = new Color( 255, 200, 0 ).setImmutable();
  Color.PINK = Color.pink = new Color( 255, 175, 175 ).setImmutable();
  Color.RED = Color.red = new Color( 255, 0, 0 ).setImmutable();
  Color.WHITE = Color.white = new Color( 255, 255, 255 ).setImmutable();
  Color.YELLOW = Color.yellow = new Color( 255, 255, 0 ).setImmutable();

  /**
   * Interpolates between 2 colors in RGBA space. When distance is 0, color1
   * is returned. When distance is 1, color2 is returned. Other values of
   * distance return a color somewhere between color1 and color2. Each color
   * component is interpolated separately.
   *
   * @param {Color} color1
   * @param {Color} color2
   * @param {Number} distance distance between color1 and color2, 0 <= distance <= 1
   * @return {Color}
   */
  Color.interpolateRGBA = function( color1, color2, distance ) {
    if ( distance < 0 || distance > 1 ) {
      throw new Error( 'distance must be between 0 and 1: ' + distance );
    }
    var r = Math.floor( linear( 0, 1, color1.r, color2.r, distance ) );
    var g = Math.floor( linear( 0, 1, color1.g, color2.g, distance ) );
    var b = Math.floor( linear( 0, 1, color1.b, color2.b, distance ) );
    var a = linear( 0, 1, color1.a, color2.a, distance );
    return new Color( r, g, b, a );
  };

  Color.fromStateObject = function( stateObject ) {
    return new Color( stateObject.r, stateObject.g, stateObject.b, stateObject.a );
  };

  return Color;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Removes a single (the first) matching object from an Array.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/arrayRemove',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  /*
   * @param {Array} arr
   * @param {*} item - The item to remove from the array
   */
  function arrayRemove( arr, item ) {
    assert && assert( arr instanceof Array, 'arrayRemove either takes an Array' );

    var index = _.indexOf( arr, item );
    assert && assert( index >= 0, 'item not found in Array' );

    arr.splice( index, 1 );
  }

  phetCore.register( 'arrayRemove', arrayRemove );

  return arrayRemove;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Mix-in for nodes that support a standard fill and/or stroke.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Paintable',['require','SCENERY/scenery','SCENERY/util/Color','KITE/util/LineStyles','SCENERY/display/Renderer','PHET_CORE/inherit','PHET_CORE/extend','PHET_CORE/platform','PHET_CORE/arrayRemove','AXON/Property'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var Color = require( 'SCENERY/util/Color' );
  var LineStyles = require( 'KITE/util/LineStyles' );
  var Renderer = require( 'SCENERY/display/Renderer' );

  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var platform = require( 'PHET_CORE/platform' );
  var arrayRemove = require( 'PHET_CORE/arrayRemove' );

  var Property = require( 'AXON/Property' );

  var isSafari5 = platform.safari5;
  var isIE9 = platform.ie9;

  /*
   * Applies the mix-in to a subtype of Node.
   * @public
   *
   * @param {constructor} type - A constructor that inherits from Node
   */
  var Paintable = {
    mixin: function( type ) {
      var proto = type.prototype;

      extend( proto, {
        /**
         * This should be called in the constructor to initialize the paint-specific parts of the Node.
         * @protected
         */
        initializePaintable: function() {
          this._fill = null;
          this._fillPickable = true;

          this._stroke = null;
          this._strokePickable = false;

          this._cachedPaints = [];
          this._lineDrawingStyles = new LineStyles();
        },

        /**
         * Returns whether there is a fill applied to this Node.
         * @public
         *
         * @returns {boolean}
         */
        hasFill: function() {
          return this._fill !== null;
        },

        /**
         * Returns whether there is a stroke applied to this Node.
         * @public
         *
         * @returns {boolean}
         */
        hasStroke: function() {
          return this._stroke !== null;
        },

        /**
         * Returns the fill (if any) for this Node.
         * @public
         *
         * @returns {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern}
         */
        getFill: function() {
          return this._fill;
        },
        get fill() { return this.getFill(); },

        /**
         * Sets the fill color for the node.
         * @public
         *
         * Please use null for indicating "no fill" (that is the default). Strings and Scenery Color objects can be
         * provided for a single-color flat appearance, and can be wrapped with an Axon Property. Gradients and patterns
         * can also be provided.
         *
         * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} fill
         */
        setFill: function( fill ) {
          assert && assert( fill === null ||
                            typeof fill === 'string' ||
                            fill instanceof Color ||
                            fill.isPaint ||
                            ( ( fill instanceof Property ) && (
                              typeof fill.value === 'string' ||
                              fill.value instanceof Color
                            ) ),
            'Invalid fill type' );

          // Instance equality used here since it would be more expensive to parse all CSS
          // colors and compare every time the fill changes. Right now, usually we don't have
          // to parse CSS colors. See https://github.com/phetsims/scenery/issues/255
          if ( this._fill !== fill ) {
            this._fill = fill;

            this.invalidateFill();
          }
          return this;
        },
        set fill( value ) { this.setFill( value ); },

        /**
         * Returns the stroke (if any) for this Node.
         * @public
         *
         * @returns {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern}
         */
        getStroke: function() {
          return this._stroke;
        },
        get stroke() { return this.getStroke(); },

        /**
         * Sets the stroke color for the node.
         * @public
         *
         * Please use null for indicating "no stroke" (that is the default). Strings and Scenery Color objects can be
         * provided for a single-color flat appearance, and can be wrapped with an Axon Property. Gradients and patterns
         * can also be provided.
         *
         * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} stroke
         */
        setStroke: function( stroke ) {
          assert && assert( stroke === null ||
                            typeof stroke === 'string' ||
                            stroke instanceof Color ||
                            stroke.isPaint ||
                            ( ( stroke instanceof Property ) && (
                              typeof stroke.value === 'string' ||
                              stroke.value instanceof Color
                            ) ),
            'Invalid stroke type' );

          // Instance equality used here since it would be more expensive to parse all CSS
          // colors and compare every time the fill changes. Right now, usually we don't have
          // to parse CSS colors. See https://github.com/phetsims/scenery/issues/255
          if ( this._stroke !== stroke ) {
            this._stroke = stroke;

            this.invalidateStroke();
          }
          return this;
        },
        set stroke( value ) { this.setStroke( value ); },

        /**
         * Returns a property-unwrapped fill if applicable.
         * @public
         *
         * @returns {null|string|Color|LinearGradient|RadialGradient|Pattern}
         */
        getFillValue: function() {
          var fill = this.getFill();

          // Property lookup
          if ( fill instanceof Property ) {
            fill = fill.get();
          }

          return fill;
        },
        get fillValue() { return this.getFillValue(); },

        /**
         * Returns a property-unwrapped stroke if applicable.
         * @public
         *
         * @returns {null|string|Color|LinearGradient|RadialGradient|Pattern}
         */
        getStrokeValue: function() {
          var stroke = this.getStroke();

          // Property lookup
          if ( stroke instanceof Property ) {
            stroke = stroke.get();
          }

          return stroke;
        },
        get strokeValue() { return this.getStrokeValue(); },

        /**
         * Returns whether the fill is marked as pickable.
         * @public
         *
         * @returns {boolean}
         */
        isFillPickable: function() {
          return this._fillPickable;
        },
        get fillPickable() { return this.isFillPickable(); },

        /**
         * Sets whether the fill is marked as pickable.
         * @public
         *
         * @param {boolean} pickable
         */
        setFillPickable: function( pickable ) {
          assert && assert( typeof pickable === 'boolean' );
          if ( this._fillPickable !== pickable ) {
            this._fillPickable = pickable;

            // TODO: better way of indicating that only the node under pointers could have changed, but no paint change is needed?
            this.invalidateFill();
          }
          return this;
        },
        set fillPickable( value ) { this.setFillPickable( value ); },

        /**
         * Returns whether the stroke is marked as pickable.
         * @public
         *
         * @returns {boolean}
         */
        isStrokePickable: function() {
          return this._strokePickable;
        },
        get strokePickable() { return this.isStrokePickable(); },

        /**
         * Sets whether the stroke is marked as pickable.
         * @public
         *
         * @param {boolean} pickable
         */
        setStrokePickable: function( pickable ) {
          assert && assert( typeof pickable === 'boolean', 'strokePickable should be a boolean, not ' + pickable );

          if ( this._strokePickable !== pickable ) {
            this._strokePickable = pickable;

            // TODO: better way of indicating that only the node under pointers could have changed, but no paint change is needed?
            this.invalidateStroke();
          }
          return this;
        },
        set strokePickable( value ) { this.setStrokePickable( value ); },

        /**
         * Returns the line width that would be applied to strokes.
         * @public
         *
         * @returns {number}
         */
        getLineWidth: function() {
          return this._lineDrawingStyles.lineWidth;
        },
        get lineWidth() { return this.getLineWidth(); },

        /**
         * Sets the line width that will be applied to strokes on this Node.
         * @public
         *
         * @param {number} lineWidth
         */
        setLineWidth: function( lineWidth ) {
          assert && assert( typeof lineWidth === 'number', 'lineWidth should be a number, not ' + lineWidth );
          assert && assert( lineWidth >= 0, 'lineWidth should be non-negative instead of ' + lineWidth );

          if ( this.getLineWidth() !== lineWidth ) {
            this._lineDrawingStyles.lineWidth = lineWidth;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineWidth();
            }
          }
          return this;
        },
        set lineWidth( value ) { this.setLineWidth( value ); },

        /**
         * Returns the line cap style (controls appearance at the start/end of paths)
         * @public
         *
         * @returns {string}
         */
        getLineCap: function() {
          return this._lineDrawingStyles.lineCap;
        },
        get lineCap() { return this.getLineCap(); },

        /**
         * Sets the line cap style. There are three options:
         * - 'butt' (the default) stops the line at the end point
         * - 'round' draws a semicircular arc around the end point
         * - 'square' draws a square outline around the end point (like butt, but extended by 1/2 line width out)
         * @public
         *
         * @param {string} lineCap
         */
        setLineCap: function( lineCap ) {
          assert && assert( lineCap === 'butt' || lineCap === 'round' || lineCap === 'square',
            'lineCap should be one of "butt", "round" or "square", not ' + lineCap );

          if ( this._lineDrawingStyles.lineCap !== lineCap ) {
            this._lineDrawingStyles.lineCap = lineCap;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineCap( value ) { this.setLineCap( value ); },

        /**
         * Returns the current line join style (controls join appearance between drawn segments).
         * @public
         *
         * @returns {string}
         */
        getLineJoin: function() {
          return this._lineDrawingStyles.lineJoin;
        },
        get lineJoin() { return this.getLineJoin(); },

        /**
         * Sets the line join style. There are three options:
         * - 'miter' (default) joins by extending the segments out in a line until they meet. For very sharp
         *           corners, they will be chopped off and will act like 'bevel', depending on what the miterLimit is.
         * - 'round' draws a circular arc to connect the two stroked areas.
         * - 'bevel' connects with a single line segment.
         * @public
         *
         * @param {string} lineJoin
         */
        setLineJoin: function( lineJoin ) {
          assert && assert( lineJoin === 'miter' || lineJoin === 'round' || lineJoin === 'bevel',
            'lineJoin should be one of "miter", "round" or "bevel", not ' + lineJoin );

          if ( this._lineDrawingStyles.lineJoin !== lineJoin ) {
            this._lineDrawingStyles.lineJoin = lineJoin;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineJoin( value ) { this.setLineJoin( value ); },

        /**
         * Returns the miterLimit value.
         * @public
         *
         * @returns {number}
         */
        getMiterLimit: function() {
          return this._lineDrawingStyles.miterLimit;
        },
        get miterLimit() { return this.getMiterLimit(); },

        /**
         * Sets the miterLimit value. This determines how sharp a corner with lineJoin: 'miter' will need to be before
         * it gets cut off to the 'bevel' behavior.
         * @public
         *
         * @param {number} miterLimit
         */
        setMiterLimit: function( miterLimit ) {
          assert && assert( typeof miterLimit === 'number' );

          if ( this._lineDrawingStyles.miterLimit !== miterLimit ) {
            this._lineDrawingStyles.miterLimit = miterLimit;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set miterLimit( value ) { this.setMiterLimit( value ); },

        /**
         * Returns whether the stroke will be dashed.
         * @public
         *
         * @returns {boolean}
         */
        hasLineDash: function() {
          return !!this._lineDrawingStyles.lineDash.length;
        },

        /**
         * Gets the line dash pattern. An empty array is the default, indicating no dashing.
         * @public
         *
         * @returns {Array.<number>}
         */
        getLineDash: function() {
          return this._lineDrawingStyles.lineDash;
        },
        get lineDash() { return this.getLineDash(); },

        /**
         * Sets the line dash pattern. Should be an array of numbers "on" and "off" alternating. An empty array
         * indicates no dashing.
         * @public
         *
         * @param {Array.<number>} lineDash
         */
        setLineDash: function( lineDash ) {
          if ( this._lineDrawingStyles.lineDash !== lineDash ) {
            this._lineDrawingStyles.lineDash = lineDash || [];
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineDash( value ) { this.setLineDash( value ); },

        /**
         * Returns the offset of the line dash pattern from the start of the stroke.
         * @public
         *
         * @returns {number}
         */
        getLineDashOffset: function() {
          return this._lineDrawingStyles.lineDashOffset;
        },
        get lineDashOffset() { return this.getLineDashOffset(); },

        /**
         * Sets the offset of the line dash pattern from the start of the stroke. Defaults to 0.
         * @public
         *
         * @param {number} lineDashOffset
         */
        setLineDashOffset: function( lineDashOffset ) {
          assert && assert( typeof lineDashOffset === 'number', 'lineDashOffset should be a number, not ' + lineDashOffset );

          if ( this._lineDrawingStyles.lineDashOffset !== lineDashOffset ) {
            this._lineDrawingStyles.lineDashOffset = lineDashOffset;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineDashOffset( value ) { this.setLineDashOffset( value ); },

        /**
         * Returns the composite {LineStyles} object, that determines stroke appearance.
         * @public
         *
         * @returns {LineStyles}
         */
        getLineStyles: function() {
          return this._lineDrawingStyles;
        },
        get lineStyles() { return this.getLineStyles(); },

        /**
         * Sets the LineStyles object (it determines stroke appearance). The passed-in object will be mutated as needed.
         * @public
         *
         * @param {LineStyles} lineStyles
         */
        setLineStyles: function( lineStyles ) {
          this._lineDrawingStyles = lineStyles;
          this.invalidateStroke();
          return this;
        },
        set lineStyles( value ) { this.setLineStyles( value ); },

        /**
         * Returns the cached paints.
         * @public
         *
         * @returns {Array.<string|Color|LinearGradient|RadialGradient|Pattern|null}
         */
        getCachedPaints: function() {
          return this._cachedPaints;
        },
        get cachedPaints() { return this.getCachedPaints(); },

        /**
         * Sets the cached paints to the input array (a defensive copy). Note that it also filters out fills that are
         * not considered paints (e.g. strings, Colors, etc.).
         * @public
         *
         * When this node is displayed in SVG, it will force the presence of the cached paint to be stored in the SVG's
         * <defs> element, so that we can switch quickly to use the given paint (instead of having to create it on the
         * SVG-side whenever the switch is made).
         *
         * Also note that duplicate paints are acceptible, and don't need to be filtered out before-hand.
         *
         * @param {Array.<string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern|null>} paints
         */
        setCachedPaints: function( paints ) {
          this._cachedPaints = paints.filter( function( paint ) { return paint && paint.isPaint; } );

          var stateLen = this._drawables.length;
          for ( var i = 0; i < stateLen; i++ ) {
            this._drawables[ i ].markDirtyCachedPaints();
          }

          return this;
        },
        set cachedPaints( value ) { this.setCachedPaints( value ); },

        /**
         * Adds a cached paint. Does nothing if paint is just a normal fill (string, Color), but for gradients and
         * patterns, it will be made faster to switch to.
         *
         * When this node is displayed in SVG, it will force the presence of the cached paint to be stored in the SVG's
         * <defs> element, so that we can switch quickly to use the given paint (instead of having to create it on the
         * SVG-side whenever the switch is made).
         *
         * Also note that duplicate paints are acceptible, and don't need to be filtered out before-hand.
         *
         * @param {string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern|null} paint
         */
        addCachedPaint: function( paint ) {
          if ( paint && paint.isPaint ) {
            this._cachedPaints.push( paint );

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyCachedPaints();
            }
          }
        },

        /**
         * Removes a cached paint. Does nothing if paint is just a normal fill (string, Color), but for gradients and
         * patterns it will remove any existing cached paint. If it was added more than once, it will need to be removed
         * more than once.
         *
         * When this node is displayed in SVG, it will force the presence of the cached paint to be stored in the SVG's
         * <defs> element, so that we can switch quickly to use the given paint (instead of having to create it on the
         * SVG-side whenever the switch is made).
         *
         * @param {string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern|null} paint
         */
        removeCachedPaint: function( paint ) {
          if ( paint && paint.isPaint ) {
            assert && assert( _.contains( this._cachedPaints, paint ) );

            arrayRemove( this._cachedPaints, paint );

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyCachedPaints();
            }
          }
        },

        /**
         * Applies the fill to a Canvas context wrapper, before filling.
         * @public (scenery-internal)
         *
         * @param {CanvasContextWrapper} wrapper
         */
        beforeCanvasFill: function( wrapper ) {
          var fillValue = this.getFillValue();

          wrapper.setFillStyle( fillValue );
          if ( fillValue.transformMatrix ) {
            wrapper.context.save();
            fillValue.transformMatrix.canvasAppendTransform( wrapper.context );
          }
        },

        /**
         * Unapplies the fill to a Canvas context wrapper, after filling.
         * @public (scenery-internal)
         *
         * @param {CanvasContextWrapper} wrapper
         */
        afterCanvasFill: function( wrapper ) {
          var fillValue = this.getFillValue();

          if ( fillValue.transformMatrix ) {
            wrapper.context.restore();
          }
        },

        /**
         * Applies the stroke to a Canvas context wrapper, before stroking.
         * @public (scenery-internal)
         *
         * @param {CanvasContextWrapper} wrapper
         */
        beforeCanvasStroke: function( wrapper ) {
          var strokeValue = this.getStrokeValue();

          // TODO: is there a better way of not calling so many things on each stroke?
          wrapper.setStrokeStyle( this._stroke );
          wrapper.setLineWidth( this.getLineWidth() );
          wrapper.setLineCap( this.getLineCap() );
          wrapper.setLineJoin( this.getLineJoin() );
          wrapper.setMiterLimit( this.getMiterLimit() );
          wrapper.setLineDash( this.getLineDash() );
          wrapper.setLineDashOffset( this.getLineDashOffset() );
          if ( strokeValue.transformMatrix ) {
            wrapper.context.save();
            strokeValue.transformMatrix.canvasAppendTransform( wrapper.context );
          }
        },

        /**
         * Unapplies the stroke to a Canvas context wrapper, after stroking.
         * @public (scenery-internal)
         *
         * @param {CanvasContextWrapper} wrapper
         */
        afterCanvasStroke: function( wrapper ) {
          var strokeValue = this.getStrokeValue();

          if ( strokeValue.transformMatrix ) {
            wrapper.context.restore();
          }
        },

        /**
         * If applicable, returns the CSS color for the fill.
         * @public
         *
         * @returns {string}
         */
        getCSSFill: function() {
          var fillValue = this.getFillValue();
          // if it's a Color object, get the corresponding CSS
          // 'transparent' will make us invisible if the fill is null
          return fillValue ? ( fillValue.toCSS ? fillValue.toCSS() : fillValue ) : 'transparent';
        },

        /**
         * If applicable, returns the CSS color for the stroke.
         * @public
         *
         * @returns {string}
         */
        getSimpleCSSStroke: function() {
          var strokeValue = this.getStrokeValue();
          // if it's a Color object, get the corresponding CSS
          // 'transparent' will make us invisible if the fill is null
          return strokeValue ? ( strokeValue.toCSS ? strokeValue.toCSS() : strokeValue ) : 'transparent';
        },

        appendFillablePropString: function( spaces, result ) {
          if ( this._fill ) {
            if ( result ) {
              result += ',\n';
            }
            if ( typeof this.getFillValue() === 'string' ) {
              result += spaces + 'fill: \'' + this.getFillValue() + '\'';
            }
            else {
              result += spaces + 'fill: ' + this.getFillValue().toString();
            }
          }

          return result;
        },

        appendStrokablePropString: function( spaces, result ) {
          var self = this;

          function addProp( key, value, nowrap ) {
            if ( result ) {
              result += ',\n';
            }
            if ( !nowrap && typeof value === 'string' ) {
              result += spaces + key + ': \'' + value + '\'';
            }
            else {
              result += spaces + key + ': ' + value;
            }
          }

          if ( this._stroke ) {
            var defaultStyles = new LineStyles();
            if ( typeof this.getStrokeValue() === 'string' ) {
              addProp( 'stroke', this.getStrokeValue() );
            }
            else {
              addProp( 'stroke', this.getStrokeValue().toString(), true );
            }

            _.each( [ 'lineWidth', 'lineCap', 'miterLimit', 'lineJoin', 'lineDashOffset' ], function( prop ) {
              if ( self[ prop ] !== defaultStyles[ prop ] ) {
                addProp( prop, self[ prop ] );
              }
            } );

            if ( this.lineDash.length ) {
              addProp( 'lineDash', JSON.stringify( this.lineDash ), true );
            }
          }

          return result;
        },

        getFillRendererBitmask: function() {
          var bitmask = 0;

          // Safari 5 has buggy issues with SVG gradients
          if ( !( isSafari5 && this._fill && this._fill.isGradient ) ) {
            bitmask |= Renderer.bitmaskSVG;
          }

          // we always have Canvas support?
          bitmask |= Renderer.bitmaskCanvas;

          if ( !this.hasFill() ) {
            // if there is no fill, it is supported by DOM and WebGL
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }
          else if ( this._fill.isPattern ) {
            // no pattern support for DOM or WebGL (for now!)
          }
          else if ( this._fill.isGradient ) {
            // no gradient support for DOM or WebGL (for now!)
          }
          else {
            // solid fills always supported for DOM and WebGL
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }

          return bitmask;
        },

        getStrokeRendererBitmask: function() {
          var bitmask = 0;

          if ( !( isIE9 && this.hasStroke() && this.hasLineDash() ) ) {
            bitmask |= Renderer.bitmaskCanvas;
          }

          // always have SVG support (for now?)
          bitmask |= Renderer.bitmaskSVG;

          if ( !this.hasStroke() ) {
            // allow DOM support if there is no stroke
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }

          return bitmask;
        }
      } );

      // on mutation, set the stroke parameters first since they may affect the bounds (and thus later operations)
      proto._mutatorKeys = [
        'fill', 'fillPickable', 'stroke', 'lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'lineDash',
        'lineDashOffset', 'strokePickable', 'cachedPaints'
      ].concat( proto._mutatorKeys );

      // Paintable's version of invalidateFill()
      function invalidateFill() {
        this.invalidateSupportedRenderers();

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyFill();
        }
      }

      // Patch in a sub-type call if it already exists on the prototype
      if ( proto.invalidateFill ) {
        var subtypeInvalidateFill = proto.invalidateFill;
        proto.invalidateFill = function() {
          subtypeInvalidateFill.call( this );
          invalidateFill.call( this );
        };
      }
      else {
        proto.invalidateFill = invalidateFill;
      }

      // Paintable's version of invalidateStroke()
      function invalidateStroke() {
        this.invalidateSupportedRenderers();

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyStroke();
        }
      }

      if ( proto.invalidateStroke ) {
        var subtypeInvalidateStroke = proto.invalidateStroke;
        proto.invalidateStroke = function() {
          subtypeInvalidateStroke.call( this );
          invalidateStroke.call( this );
        };
      }
      else {
        proto.invalidateStroke = invalidateStroke;
      }
    }
  };
  scenery.register( 'Paintable', Paintable );

  /**
   * An observer for a fill or stroke, that will be able to trigger notifications when it changes.
   */
  Paintable.PaintObserver = function PaintObserver( type, changeCallback ) {
    assert && assert( type === 'fill' || type === 'stroke' );
    this.type = type;
    this.name = '_' + type;
    this.changeCallback = changeCallback;
    this.primary = null;
    this.secondary = null;
    this.updateListener = this.update.bind( this );
  };
  inherit( Object, Paintable.PaintObserver, {
    initialize: function( node ) {
      assert && assert( node !== null );
      this.node = node;

      this.update();
    },

    update: function() {
      var primary = this.node[ this.name ];
      if ( primary !== this.primary ) {
        this.detachPrimary( this.primary );
        this.attachPrimary( primary );
        this.changeCallback();
      }
      else if ( primary instanceof Property ) {
        var secondary = primary.get();
        if ( secondary !== this.secondary ) {
          this.detachSecondary( this.secondary );
          this.attachSecondary( secondary );
          this.changeCallback();
        }
      }
    },

    attachPrimary: function( paint ) {
      this.primary = paint;
      if ( paint instanceof Property ) {
        paint.lazyLink( this.updateListener );
        this.attachSecondary( paint.get() );
      }
      else if ( paint instanceof Color ) {
        paint.addChangeListener( this.changeCallback );
      }
    },

    detachPrimary: function( paint ) {
      if ( paint instanceof Property ) {
        paint.unlink( this.updateListener );
        this.detachSecondary( paint.get() );
        this.secondary = null;
      }
      else if ( paint instanceof Color ) {
        paint.removeChangeListener( this.changeCallback );
      }
      this.primary = null;
    },

    attachSecondary: function( paint ) {
      this.secondary = paint;
      if ( paint instanceof Color ) {
        paint.addChangeListener( this.changeCallback );
      }
    },

    detachSecondary: function( paint ) {
      if ( paint instanceof Color ) {
        paint.removeChangeListener( this.changeCallback );
      }
      this.secondary = null;
    },

    clean: function() {
      this.detachPrimary( this.primary );
      this.node = null;
    }
  } );

  // mix-in base for DOM and SVG drawables
  // NOTE: requires state.node to be defined
  Paintable.PaintableStatefulDrawable = {
    mixin: function PaintableStatefulDrawable( drawableType ) {
      var proto = drawableType.prototype;

      proto.initializePaintableState = function( renderer, instance ) {
        this.lastFill = undefined;
        this.dirtyFill = true;

        this.lastStroke = undefined;
        this.dirtyStroke = true;
        this.dirtyLineWidth = true;
        this.dirtyLineOptions = true; // e.g. cap, join, dash, dashoffset, miterlimit
        this.dirtyCachedPaints = true;
        this.lastCachedPaints = [];

        this.fillCallback = this.fillCallback || this.markDirtyFill.bind( this );
        this.strokeCallback = this.strokeCallback || this.markDirtyStroke.bind( this );
        this.fillObserver = this.fillObserver || new Paintable.PaintObserver( 'fill', this.fillCallback );
        this.strokeObserver = this.strokeObserver || new Paintable.PaintObserver( 'stroke', this.strokeCallback );

        this.fillObserver.initialize( instance.node );
        this.strokeObserver.initialize( instance.node );

        return this;
      };

      proto.cleanPaintableState = function() {
        this.dirtyFill = false;
        this.lastFill = this.node.getFill();

        this.dirtyStroke = false;
        this.dirtyLineWidth = false;
        this.dirtyLineOptions = false;
        this.dirtyCachedPaints = false;
        this.lastStroke = this.node.getStroke();
      };

      proto.disposePaintableState = function() {
        this.fillObserver.clean();
        this.strokeObserver.clean();
      };

      proto.markDirtyFill = function() {
        this.dirtyFill = true;
        this.markPaintDirty();
        this.fillObserver.update(); // TODO: look into having the fillObserver be notified of Node changes as our source
      };

      proto.markDirtyStroke = function() {
        this.dirtyStroke = true;
        this.markPaintDirty();
        this.strokeObserver.update(); // TODO: look into having the strokeObserver be notified of Node changes as our source
      };

      proto.markDirtyLineWidth = function() {
        this.dirtyLineWidth = true;
        this.markPaintDirty();
      };

      proto.markDirtyLineOptions = function() {
        this.dirtyLineOptions = true;
        this.markPaintDirty();
      };

      proto.markDirtyCachedPaints = function() {
        this.dirtyCachedPaints = true;
        this.markPaintDirty();
      };
    }
  };

  // mix-in for Canvas drawables
  Paintable.PaintableStatelessDrawable = {
    mixin: function PaintableStatelessDrawable( drawableType ) {
      var proto = drawableType.prototype;

      proto.initializePaintableStateless = function( renderer, instance ) {
        this.fillCallback = this.fillCallback || this.markDirtyFill.bind( this );
        this.strokeCallback = this.strokeCallback || this.markDirtyStroke.bind( this );
        this.fillObserver = this.fillObserver || new Paintable.PaintObserver( 'fill', this.fillCallback );
        this.strokeObserver = this.strokeObserver || new Paintable.PaintObserver( 'stroke', this.strokeCallback );

        this.fillObserver.initialize( instance.node );
        this.strokeObserver.initialize( instance.node );

        return this;
      };

      proto.disposePaintableStateless = function() {
        this.fillObserver.clean();
        this.strokeObserver.clean();
      };

      proto.markDirtyFill = function() {
        this.markPaintDirty();
        this.fillObserver.update(); // TODO: look into having the fillObserver be notified of Node changes as our source
      };

      proto.markDirtyStroke = function() {
        this.markPaintDirty();
        this.strokeObserver.update(); // TODO: look into having the strokeObserver be notified of Node changes as our source
      };

      proto.markDirtyLineWidth = function() {
        this.markPaintDirty();
      };

      proto.markDirtyLineOptions = function() {
        this.markPaintDirty();
      };

      proto.markDirtyCachedPaints = function() {
        this.markPaintDirty();
      };
    }
  };

  /**
   * Returns the SVG style string used to represent a paint.
   *
   * @param {null|string|Color|LinearGradient|RadialGradient|Pattern} paint
   * @param {SVGBlock} svgBlock
   */
  function paintToSVGStyle( paint, svgBlock ) {
    if ( !paint ) {
      // no paint
      return 'none';
    }
    else if ( paint.toCSS ) {
      // Color object paint
      return paint.toCSS();
    }
    else if ( paint.isPaint ) {
      // reference the SVG definition with a URL
      return 'url(#' + paint.id + '-' + ( svgBlock ? svgBlock.id : 'noblock' ) + ')';
    }
    else {
      // plain CSS color
      return paint;
    }
  }

  // handles SVG defs and fill/stroke style for SVG elements (by composition, not a mix-in or for inheritance)
  Paintable.PaintSVGState = function PaintSVGState() {
    this.initialize();
  };
  inherit( Object, Paintable.PaintSVGState, {
    initialize: function() {
      this.svgBlock = null; // {SVGBlock | null}

      // {string} fill/stroke style fragments that are currently used
      this.fillStyle = 'none';
      this.strokeStyle = 'none';

      // current reference-counted fill/stroke paints (gradients and fills) that will need to be released on changes
      // or disposal
      this.fillPaint = null;
      this.strokePaint = null;

      // these are used by the actual SVG element
      this.updateBaseStyle(); // the main style CSS
      this.strokeDetailStyle = ''; // width/dash/cap/join CSS
    },

    dispose: function() {
      // be cautious, release references
      this.releaseFillPaint();
      this.releaseStrokePaint();
    },

    releaseFillPaint: function() {
      if ( this.fillPaint ) {
        this.svgBlock.decrementPaint( this.fillPaint );
        this.fillPaint = null;
      }
    },

    releaseStrokePaint: function() {
      if ( this.strokePaint ) {
        this.svgBlock.decrementPaint( this.strokePaint );
        this.strokePaint = null;
      }
    },

    /**
     * Called when the fill needs to be updated, with the latest defs SVG block
     * @public (scenery-internal)
     *
     * @param {SVGBlock} svgBlock
     * @param {null|string|Color|LinearGradient|RadialGradient|Pattern} fill
     */
    updateFill: function( svgBlock, fill ) {
      assert && assert( this.svgBlock === svgBlock );

      // NOTE: If fill.isPaint === true, this should be different if we switched to a different SVG block.
      var fillStyle = paintToSVGStyle( fill, svgBlock );

      // If our fill paint reference changed
      if ( fill !== this.fillPaint ) {
        // release the old reference
        this.releaseFillPaint();

        // only store a new reference if our new fill is a paint
        if ( fill && fill.isPaint ) {
          this.fillPaint = fill;
          svgBlock.incrementPaint( fill );
        }
      }

      // If we need to update the SVG style of our fill
      if ( fillStyle !== this.fillStyle ) {
        this.fillStyle = fillStyle;
        this.updateBaseStyle();
      }
    },

    /**
     * Called when the stroke needs to be updated, with the latest defs SVG block
     * @public (scenery-internal)
     *
     * @param {SVGBlock} svgBlock
     * @param {null|string|Color|LinearGradient|RadialGradient|Pattern} fill
     */
    updateStroke: function( svgBlock, stroke ) {
      assert && assert( this.svgBlock === svgBlock );

      // NOTE: If stroke.isPaint === true, this should be different if we switched to a different SVG block.
      var strokeStyle = paintToSVGStyle( stroke, svgBlock );

      // If our stroke paint reference changed
      if ( stroke !== this.strokePaint ) {
        // release the old reference
        this.releaseStrokePaint();

        // only store a new reference if our new stroke is a paint
        if ( stroke && stroke.isPaint ) {
          this.strokePaint = stroke;
          svgBlock.incrementPaint( stroke );
        }
      }

      // If we need to update the SVG style of our stroke
      if ( strokeStyle !== this.strokeStyle ) {
        this.strokeStyle = strokeStyle;
        this.updateBaseStyle();
      }
    },

    updateBaseStyle: function() {
      this.baseStyle = 'fill: ' + this.fillStyle + '; stroke: ' + this.strokeStyle + ';';
    },

    updateStrokeDetailStyle: function( node ) {
      var strokeDetailStyle = '';

      var lineWidth = node.getLineWidth();
      if ( lineWidth !== 1 ) {
        strokeDetailStyle += 'stroke-width: ' + lineWidth + ';';
      }

      var lineCap = node.getLineCap();
      if ( lineCap !== 'butt' ) {
        strokeDetailStyle += 'stroke-linecap: ' + lineCap + ';';
      }

      var lineJoin = node.getLineJoin();
      if ( lineJoin !== 'miter' ) {
        strokeDetailStyle += 'stroke-linejoin: ' + lineJoin + ';';
      }

      var miterLimit = node.getMiterLimit();
      strokeDetailStyle += 'stroke-miterlimit: ' + miterLimit + ';';

      if ( node.hasLineDash() ) {
        strokeDetailStyle += 'stroke-dasharray: ' + node.getLineDash().join( ',' ) + ';';
        strokeDetailStyle += 'stroke-dashoffset: ' + node.getLineDashOffset() + ';';
      }

      this.strokeDetailStyle = strokeDetailStyle;
    },

    // called when the defs SVG block is switched (our SVG element was moved to another SVG top-level context)
    updateSVGBlock: function( svgBlock ) {
      // remove paints from the old svgBlock
      var oldSvgBlock = this.svgBlock;
      if ( oldSvgBlock ) {
        if ( this.fillPaint ) {
          oldSvgBlock.decrementPaint( this.fillPaint );
        }
        if ( this.strokePaint ) {
          oldSvgBlock.decrementPaint( this.strokePaint );
        }
      }

      this.svgBlock = svgBlock;

      // add paints to the new svgBlock
      if ( this.fillPaint ) {
        svgBlock.incrementPaint( this.fillPaint );
      }
      if ( this.strokePaint ) {
        svgBlock.incrementPaint( this.strokePaint );
      }
    }
  } );

  return Paintable;
} );
// Copyright 2013-2015, University of Colorado Boulder


/**
 * TODO docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/CanvasSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/nodes/Paintable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );

  function CanvasSelfDrawable( renderer, instance ) {
    this.initializeCanvasSelfDrawable( renderer, instance );

    throw new Error( 'Should use initialization and pooling' );
  }

  scenery.register( 'CanvasSelfDrawable', CanvasSelfDrawable );

  inherit( SelfDrawable, CanvasSelfDrawable, {
    initializeCanvasSelfDrawable: function( renderer, instance ) {
      // super initialization
      this.initializeSelfDrawable( renderer, instance );

      // this is the same across lifecycles
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );

      instance.relativeTransform.addListener( this.transformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
      instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated

      return this;
    },

    markTransformDirty: function() {
      this.markDirty();
    },

    // general flag set on the state, which we forward directly to the drawable's paint flag
    markPaintDirty: function() {
      this.markDirty();
    },

    update: function() {
      this.dirty = false;
    },

    // @override
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );

      // mark us as dirty when our self visibility changes
      this.markDirty();
    },

    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();

      SelfDrawable.prototype.dispose.call( this );
    }
  } );

  // methods for forwarding dirty messages
  function canvasSelfDirty() {
    // we pass this method and it is only called with blah.call( ... ), where the 'this' reference is set.
    this.markDirty();
  }

  // options takes: type, paintCanvas( wrapper ), usesPaint, and dirtyMethods (array of string names of methods that make the state dirty)
  CanvasSelfDrawable.createDrawable = function( options ) {
    var type = options.type;
    var paintCanvas = options.paintCanvas;
    var usesPaint = options.usesPaint;

    assert && assert( typeof type === 'function' );
    assert && assert( typeof paintCanvas === 'function' );
    assert && assert( typeof usesPaint === 'boolean' );

    inherit( CanvasSelfDrawable, type, {
      initialize: function( renderer, instance ) {
        this.initializeCanvasSelfDrawable( renderer, instance );

        if ( usesPaint ) {
          this.initializePaintableStateless( renderer, instance );
        }

        return this; // allow for chaining
      },

      paintCanvas: paintCanvas,

      update: function() {
        // no action directly needed for the self-drawable case, as we will be repainted in the block
        this.dirty = false;
      },

      dispose: function() {
        CanvasSelfDrawable.prototype.dispose.call( this );

        if ( usesPaint ) {
          this.disposePaintableStateless();
        }
      }
    } );

    // include stubs (stateless) for marking dirty stroke and fill (if necessary). we only want one dirty flag, not multiple ones, for Canvas (for now)
    if ( usesPaint ) {
      Paintable.PaintableStatelessDrawable.mixin( type );
    }

    // set up pooling
    SelfDrawable.Poolable.mixin( type );

    if ( options.dirtyMethods ) {
      for ( var i = 0; i < options.dirtyMethods.length; i++ ) {
        type.prototype[ options.dirtyMethods[ i ] ] = canvasSelfDirty;
      }
    }

    return type;
  };

  return CanvasSelfDrawable;
} );

// Copyright 2014-2015, University of Colorado Boulder


/**
 * An interval (implicit consecutive sequence of drawables) that has a recorded change in-between the two ends.
 * We store the closest drawables to the interval that aren't changed, or null itself to indicate "to the end".
 *
 * isEmpty() should be used before checking the endpoints, since it could have a null-to-null state but be empty,
 * since we arrived at that state from constriction.
 *
 * For documentation purposes, an 'internal' drawable is one that is in-between (but not including) our un-changed ends
 * (drawableBefore and drawableAfter), and 'external' drawables are outside (or including) the un-changed ends.
 *
 * For stitching purposes, a ChangeInterval effectively represents two linked lists: the "old" one that was displayed
 * in the previous frame (using oldNextDrawable for iteration across the drawable linked-list), or the "new" one that
 * will be displayed in the next frame (using nextDrawable for iteration).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/ChangeInterval',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  function ChangeInterval( drawableBefore, drawableAfter ) {
    this.initialize( drawableBefore, drawableAfter );
  }

  scenery.register( 'ChangeInterval', ChangeInterval );

  inherit( Object, ChangeInterval, {
    initialize: function( drawableBefore, drawableAfter ) {
      assert && assert( drawableBefore === null || ( drawableBefore instanceof Drawable ),
        'drawableBefore can either be null to indicate that there is no un-changed drawable before our changes, ' +
        'or it can reference an un-changed drawable' );
      assert && assert( drawableAfter === null || ( drawableAfter instanceof Drawable ),
        'drawableAfter can either be null to indicate that there is no un-changed drawable after our changes, ' +
        'or it can reference an un-changed drawable' );

      /*---------------------------------------------------------------------------*
       * All @public properties
       *----------------------------------------------------------------------------*/

      // {ChangeInterval|null}, singly-linked list
      this.nextChangeInterval = null;

      // {Drawable|null}, the drawable before our ChangeInterval that is not modified. null indicates that we don't yet
      // have a "before" boundary, and should be connected to the closest drawable that is unchanged.
      this.drawableBefore = drawableBefore;

      // {Drawable|null}, the drawable after our ChangeInterval that is not modified. null indicates that we don't yet
      // have a "after" boundary, and should be connected to the closest drawable that is unchanged.
      this.drawableAfter = drawableAfter;

      // {Boolean} If a null-to-X interval gets collapsed all the way, we want to have a flag that indicates that.
      // Otherwise, it would be interpreted as a null-to-null change interval ("change everything"), instead of the
      // correct "change nothing".
      this.collapsedEmpty = false;

      // chaining for PoolableMixin
      return this;
    },

    dispose: function() {
      // release our references
      this.nextChangeInterval = null;
      this.drawableBefore = null;
      this.drawableAfter = null;

      this.freeToPool();
    },

    // Make our interval as tight as possible (we may have over-estimated it before)
    constrict: function() {
      var changed = false;

      if ( this.isEmpty() ) { return true; }

      // Notes: We don't constrict null boundaries, and we should never constrict a non-null boundary to a null
      // boundary (this the this.drawableX.Xdrawable truthy check), since going from a null-to-X interval to
      // null-to-null has a completely different meaning. This should be checked by a client of this API.

      while ( this.drawableBefore && this.drawableBefore.nextDrawable === this.drawableBefore.oldNextDrawable ) {
        this.drawableBefore = this.drawableBefore.nextDrawable;
        changed = true;

        // check for a totally-collapsed state
        if ( !this.drawableBefore ) {
          assert && assert( !this.drawableAfter );
          this.collapsedEmpty = true;
        }

        // if we are empty, bail out before continuing
        if ( this.isEmpty() ) { return true; }
      }

      while ( this.drawableAfter && this.drawableAfter.previousDrawable === this.drawableAfter.oldPreviousDrawable ) {
        this.drawableAfter = this.drawableAfter.previousDrawable;
        changed = true;

        // check for a totally-collapsed state
        if ( !this.drawableAfter ) {
          assert && assert( !this.drawableBefore );
          this.collapsedEmpty = true;
        }

        // if we are empty, bail out before continuing
        if ( this.isEmpty() ) { return true; }
      }

      return changed;
    },

    isEmpty: function() {
      return this.collapsedEmpty || ( this.drawableBefore !== null && this.drawableBefore === this.drawableAfter );
    },

    // {Number} The quantity of "old" internal drawables. Requires the old first/last drawables for the backbone, since
    // we need that information for null-before/after boundaries.
    getOldInternalDrawableCount: function( oldStitchFirstDrawable, oldStitchLastDrawable ) {
      var firstInclude = this.drawableBefore ? this.drawableBefore.oldNextDrawable : oldStitchFirstDrawable;
      var lastExclude = this.drawableAfter; // null is OK here

      var count = 0;
      for ( var drawable = firstInclude; drawable !== lastExclude; drawable = drawable.oldNextDrawable ) {
        count++;
      }

      return count;
    },

    // {Number} The quantity of "new" internal drawables. Requires the old first/last drawables for the backbone, since
    // we need that information for null-before/after boundaries.
    getNewInternalDrawableCount: function( newStitchFirstDrawable, newStitchLastDrawable ) {
      var firstInclude = this.drawableBefore ? this.drawableBefore.nextDrawable : newStitchFirstDrawable;
      var lastExclude = this.drawableAfter; // null is OK here

      var count = 0;
      for ( var drawable = firstInclude; drawable !== lastExclude; drawable = drawable.nextDrawable ) {
        count++;
      }

      return count;
    }
  } );

  Poolable.mixin( ChangeInterval, {
    constructorDuplicateFactory: function( pool ) {
      return function( drawableBefore, drawableAfter ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'new from pool' );
          return pool.pop().initialize( drawableBefore, drawableAfter );
        }
        else {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'new from constructor' );
          return new ChangeInterval( drawableBefore, drawableAfter );
        }
      };
    }
  } );

  // creates a ChangeInterval that will be disposed after syncTree is complete (see Display phases)
  ChangeInterval.newForDisplay = function( drawableBefore, drawableAfter, display ) {
    var changeInterval = ChangeInterval.createFromPool( drawableBefore, drawableAfter );
    display.markChangeIntervalToDispose( changeInterval );
    return changeInterval;
  };

  return ChangeInterval;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * DOM drawable for a single painted node.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/DOMSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/display/Renderer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  require( 'SCENERY/display/Renderer' );

  function DOMSelfDrawable( renderer, instance ) {
    this.initializeDOMSelfDrawable( renderer, instance );

    throw new Error( 'Should use initialization and pooling' );
  }

  scenery.register( 'DOMSelfDrawable', DOMSelfDrawable );

  inherit( SelfDrawable, DOMSelfDrawable, {
    initializeDOMSelfDrawable: function( renderer, instance ) {
      // this is the same across lifecycles
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );

      // super initialization
      this.initializeSelfDrawable( renderer, instance );

      this.forceAcceleration = false; // TODO: for now, check to see if this is used and how to use it
      this.markTransformDirty();

      this.visibilityDirty = true;

      // handle transform changes
      instance.relativeTransform.addListener( this.transformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
      instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated

      return this;
    },

    markTransformDirty: function() {
      // update the visual state available to updateDOM, so that it will update the transform (Text needs to change the transform, so it is included)
      this.transformDirty = true;

      this.markDirty();
    },

    // called from the Node, probably during updateDOM
    getTransformMatrix: function() {
      this.instance.relativeTransform.validate();
      return this.instance.relativeTransform.matrix;
    },

    // called from elsewhere to update the DOM element
    update: function() {
      if ( this.dirty ) {
        this.dirty = false;
        this.updateDOM();

        if ( this.visibilityDirty ) {
          this.visibilityDirty = false;

          this.domElement.style.visibility = this.visible ? '' : 'hidden';
        }

        this.cleanPaintableState && this.cleanPaintableState();
      }
    },

    // @protected: called to update the visual appearance of our domElement
    updateDOM: function() {
      // should generally be overridden by drawable subtypes to implement the update
    },

    // @override
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );

      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },

    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();

      // super call
      SelfDrawable.prototype.dispose.call( this );
    }
  } );

  return DOMSelfDrawable;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * RelativeTransform is a component of an Instance. It is responsible for tracking changes to "relative" transforms, and
 * computing them in an efficient manner.
 *
 * A "relative" transform here is the transform that a Trail would have, not necessarily rooted at the display's root.
 * Imagine we have a CSS-transformed backbone div, and nodes underneath that render to Canvas. On the Canvas, we will
 * need to set the context's transform to the matrix that will transform from the displayed instances' local coordinates
 * frames to the CSS-transformed backbone instance. Notably, transforming the backbone instance or any of its ancestors
 * does NOT affect this "relative" transform from the instance to the displayed instances, while any Node transform
 * changes between (not including) the backbone instance and (including) the displayed instance WILL affect that
 * relative transform. This is key to setting the CSS transform on backbones, DOM nodes, having the transforms necessary
 * for the fastest Canvas display, and determining fitting bounds for layers.
 *
 * Each Instance has its own "relative trail", although these aren't stored. We use implicit hierarchies in the Instance
 * tree for this purpose. If an Instance is a CSS-transformed backbone, or any other case that requires drawing beneath
 * to be done relative to its local coordinate frame, we call it a transform "root", and it has instance.isTransformed
 * set to true. This should NEVER change for an instance (any changes that would do this require reconstructing the
 * instance tree).
 *
 * There are implicit hierarchies for each root, with trails starting from that root's children (they won't apply that
 * root's transform since we assume we are working within that root's local coordinate frame). These should be
 * effectively independent (if there are no bugs), so that flags affecting one implicit hierarchy will not affect the
 * other (dirty flags, etc.), and traversals should not cross these boundaries.
 *
 * For various purposes, we want a system that can:
 * - every frame before repainting: notify listeners on instances whether its relative transform has changed
 *                                  (add|removeListener)
 * - every frame before repainting: precompute relative transforms on instances where we know this is required
 *                                  (add|removePrecompute)
 * - any time during repainting:    provide an efficient way to lazily compute relative transforms when needed
 *
 * This is done by first having one step in the pre-repaint phase that traverses the tree where necessary, notifying
 * relative transform listeners, and precomputing relative transforms when they have changed (and precomputation is
 * requested). This traversal leaves metadata on the instances so that we can (fairly) efficiently force relative
 * transform "validation" any time afterwards that makes sure the matrix property is up-to-date.
 *
 * First of all, to ensure we traverse the right parts of the tree, we need to keep metadata on what needs to be
 * traversed. This is done by tracking counts of listeners/precompution needs, both on the instance itself, and how many
 * children have these needs. We use counts instead of boolean flags so that we can update this quickly while (a) never
 * requiring full children scans to update this metadata, and (b) minimizing the need to traverse all the way up to the
 * root to update the metadata. The end result is hasDescendantListenerNeed and hasDescendantComputeNeed which compute,
 * respectively, whether we need to traverse this instance for listeners and precomputation. Additionally,
 * hasAncestorListenerNeed and hasAncestorComputeNeed compute whether our parent needs to traverse up to us.
 *
 * The other tricky bits to remember for this traversal are the flags it sets, and how later validation uses and updates
 * these flags. First of all, we have relativeSelfDirty and relativeChildDirtyFrame. When a node's transform changes,
 * we mark relativeSelfDirty on the node, and relativeChildDirtyFrame for all ancestors up to (and including) the
 * transform root. relativeChildDirtyFrame allows us to prune our traversal to only modified subtrees. Additionally, so
 * that we can retain the invariant that it is "set" parent node if it is set on a child, we store the rendering frame
 * ID (unique to traversals) instead of a boolean true/false. Our traversal may skip subtrees where
 * relativeChildDirtyFrame is "set" due to no listeners or precomputation needed for that subtree, so if we used
 * booleans this would be violated. Violating that invariant would prevent us from "bailing out" when setting the
 * relativeChildDirtyFrame flag, and on EVERY transform change we would have to traverse ALL of the way to the root
 * (instead of the efficient "stop at the ancestor where it is also set").
 *
 * relativeSelfDirty is initially set on instances whose nodes had transform changes (they mark that this relative
 * transform, and all transforms beneath, are dirty). We maintain the invariant that if a relative transform needs to be
 * recomputed, it or one of its ancestors WILL ALWAYS have this flag set. This is required so that later validation of
 * the relative transform can verify whether it has been changed in an efficient way. When we recompute the relative
 * transform for one instance, we have to set this flag on all children to maintain this invariant.
 *
 * Additionally, so that we can have fast "validation" speed, we also store into relativeFrameId the last rendering
 * frame ID (counter) where we either verified that the relative transform is up to date, or we have recomputed it. Thus
 * when "validating" a relative transform that wasn't precomputed, we only need to scan up the ancestors to the first
 * one that was verified OK this frame (boolean flags are insufficient for this, since we would have to clear them all
 * to false on every frame, requiring a full tree traversal). In the future, we may set this flag to the frame
 * proactively during traversal to speed up validation, but that is not done at the time of this writing.
 *
 * Some helpful notes for the scope of various relativeTransform bits:
 *                         (transformRoot) (regular) (regular) (transformRoot)
 * relativeChildDirtyFrame [---------------------------------]                 (int)
 * relativeSelfDirty                       [---------------------------------]
 * matrix                                  [---------------------------------] (transform on root applies to
 *                                                                             its parent context)
 * relativeFrameId                         [---------------------------------] (int)
 * child counts            [---------------------------------]                 (e.g. relativeChildrenListenersCount,
 *                                                                             relativeChildrenPrecomputeCount)
 * self counts                             [---------------------------------] (e.g. relativePrecomputeCount,
 *                                                                             relativeTransformListeners.length)
 **********************
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/RelativeTransform',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','DOT/Matrix3','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var scenery = require( 'SCENERY/scenery' );

  function RelativeTransform( instance ) {
    this.instance = instance;
  }

  scenery.register( 'RelativeTransform', RelativeTransform );

  inherit( Object, RelativeTransform, {
    /**
     * Responsible for initialization and cleaning of this. If the parameters are both null, we'll want to clean our
     * external references (like Instance does).
     *
     * @param {Display|null} display
     * @param {Trail|null} trail
     * @returns {RelativeTransform} - Returns this, to allow chaining.
     */
    initialize: function( display, trail ) {
      this.display = display;
      this.trail = trail;
      this.node = trail && trail.lastNode();

      // properties relevant to the node's direct transform
      this.transformDirty = true; // whether the node's transform has changed (until the pre-repaint phase)
      this.nodeTransformListener = this.nodeTransformListener || this.onNodeTransformDirty.bind( this );

      // the actual cached transform to the root
      this.matrix = this.matrix || Matrix3.identity();

      // whether our matrix is dirty
      this.relativeSelfDirty = true;

      // how many children have (or have descendants with) relativeTransformListeners
      this.relativeChildrenListenersCount = 0;

      // if >0, indicates this should be precomputed in the pre-repaint phase
      this.relativePrecomputeCount = 0;

      // how many children have (or have descendants with) >0 relativePrecomputeCount
      this.relativeChildrenPrecomputeCount = 0;

      // used to mark what frame the transform was updated in (to accelerate non-precomputed relative transform access)
      this.relativeFrameId = -1;

      // Whether children have dirty transforms (if it is the current frame) NOTE: used only for pre-repaint traversal,
      // and can be ignored if it has a value less than the current frame ID. This allows us to traverse and hit all
      // listeners for this particular traversal, without leaving an invalid subtree (a boolean flag here is
      // insufficient, since our traversal handling would validate our invariant of
      // this.relativeChildDirtyFrame => parent.relativeChildDirtyFrame). In this case, they are both effectively
      // "false" unless they are the current frame ID, in which case that invariant holds.
      this.relativeChildDirtyFrame = display ? display._frameId : 0;

      // will be notified in pre-repaint phase that our relative transform has changed (but not computed by default)
      //OHTWO TODO: should we rely on listeners removing themselves?
      this.relativeTransformListeners = cleanArray( this.relativeTransformListeners );

      return this; // allow chaining
    },

    get parent() {
      return this.instance.parent ? this.instance.parent.relativeTransform : null;
    },

    // NOTE: different parameter order compared to Node
    insertInstance: function( instance, index ) {
      if ( instance.stateless ) {
        assert && assert( !instance.relativeTransform.hasAncestorListenerNeed(),
          'We only track changes properly if stateless instances do not have needs' );
        assert && assert( !instance.relativeTransform.hasAncestorComputeNeed(),
          'We only track changes properly if stateless instances do not have needs' );
      }
      else {
        if ( instance.relativeTransform.hasAncestorListenerNeed() ) {
          this.incrementTransformListenerChildren();
        }
        if ( instance.relativeTransform.hasAncestorComputeNeed() ) {
          this.incrementTransformPrecomputeChildren();
        }
      }

      // mark the instance's transform as dirty, so that it will be reachable in the pre-repaint traversal pass
      instance.relativeTransform.forceMarkTransformDirty();
    },

    removeInstanceWithIndex: function( instance, index ) {
      if ( instance.relativeTransform.hasAncestorListenerNeed() ) {
        this.decrementTransformListenerChildren();
      }
      if ( instance.relativeTransform.hasAncestorComputeNeed() ) {
        this.decrementTransformPrecomputeChildren();
      }
    },

    attachNodeListeners: function() {
      this.node.onStatic( 'transform', this.nodeTransformListener );
    },

    detachNodeListeners: function() {
      this.node.offStatic( 'transform', this.nodeTransformListener );
    },

    /*---------------------------------------------------------------------------*
     * Relative transform listener count recursive handling
     *----------------------------------------------------------------------------*/

    // @private: Only for descendants need, ignores 'self' need on isTransformed
    hasDescendantListenerNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeChildrenListenersCount > 0;
      }
      else {
        return this.relativeChildrenListenersCount > 0 || this.relativeTransformListeners.length > 0;
      }
      return;
    },
    // @private: Only for ancestors need, ignores child need on isTransformed
    hasAncestorListenerNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeTransformListeners.length > 0;
      }
      else {
        return this.relativeChildrenListenersCount > 0 || this.relativeTransformListeners.length > 0;
      }
    },
    // @private
    hasSelfListenerNeed: function() {
      return this.relativeTransformListeners.length > 0;
    },
    // @private (called on the ancestor of the instance with the need)
    incrementTransformListenerChildren: function() {
      var before = this.hasAncestorListenerNeed();

      this.relativeChildrenListenersCount++;
      if ( before !== this.hasAncestorListenerNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );

        this.parent && this.parent.incrementTransformListenerChildren();
      }
    },
    // @private (called on the ancestor of the instance with the need)
    decrementTransformListenerChildren: function() {
      var before = this.hasAncestorListenerNeed();

      this.relativeChildrenListenersCount--;
      if ( before !== this.hasAncestorListenerNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );

        this.parent && this.parent.decrementTransformListenerChildren();
      }
    },

    // @public (called on the instance itself)
    addListener: function( listener ) {
      var before = this.hasAncestorListenerNeed();

      this.relativeTransformListeners.push( listener );
      if ( before !== this.hasAncestorListenerNeed() ) {
        this.parent && this.parent.incrementTransformListenerChildren();

        // if we just went from "not needing to be traversed" to "needing to be traversed", mark ourselves as dirty so
        // that we for-sure get future updates
        if ( !this.hasAncestorComputeNeed() ) {
          // TODO: can we do better than this?
          this.forceMarkTransformDirty();
        }
      }
    },

    // @public (called on the instance itself)
    removeListener: function( listener ) {
      var before = this.hasAncestorListenerNeed();

      // TODO: replace with a 'remove' function call
      this.relativeTransformListeners.splice( _.indexOf( this.relativeTransformListeners, listener ), 1 );
      if ( before !== this.hasAncestorListenerNeed() ) {
        this.parent && this.parent.decrementTransformListenerChildren();
      }
    },

    /*---------------------------------------------------------------------------*
     * Relative transform precompute flag recursive handling
     *----------------------------------------------------------------------------*/

    // @private: Only for descendants need, ignores 'self' need on isTransformed
    hasDescendantComputeNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeChildrenPrecomputeCount > 0;
      }
      else {
        return this.relativeChildrenPrecomputeCount > 0 || this.relativePrecomputeCount > 0;
      }
      return;
    },
    // @private: Only for ancestors need, ignores child need on isTransformed
    hasAncestorComputeNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativePrecomputeCount > 0;
      }
      else {
        return this.relativeChildrenPrecomputeCount > 0 || this.relativePrecomputeCount > 0;
      }
    },
    // @private
    hasSelfComputeNeed: function() {
      return this.relativePrecomputeCount > 0;
    },
    // @private (called on the ancestor of the instance with the need)
    incrementTransformPrecomputeChildren: function() {
      var before = this.hasAncestorComputeNeed();

      this.relativeChildrenPrecomputeCount++;
      if ( before !== this.hasAncestorComputeNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );

        this.parent && this.parent.incrementTransformPrecomputeChildren();
      }
    },
    // @private (called on the ancestor of the instance with the need)
    decrementTransformPrecomputeChildren: function() {
      var before = this.hasAncestorComputeNeed();

      this.relativeChildrenPrecomputeCount--;
      if ( before !== this.hasAncestorComputeNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );

        this.parent && this.parent.decrementTransformPrecomputeChildren();
      }
    },

    // @public (called on the instance itself)
    addPrecompute: function() {
      var before = this.hasAncestorComputeNeed();

      this.relativePrecomputeCount++;
      if ( before !== this.hasAncestorComputeNeed() ) {
        this.parent && this.parent.incrementTransformPrecomputeChildren();

        // if we just went from "not needing to be traversed" to "needing to be traversed", mark ourselves as dirty so
        // that we for-sure get future updates
        if ( !this.hasAncestorListenerNeed() ) {
          // TODO: can we do better than this?
          this.forceMarkTransformDirty();
        }
      }
    },

    // @public (called on the instance itself)
    removePrecompute: function() {
      var before = this.hasAncestorComputeNeed();

      this.relativePrecomputeCount--;
      if ( before !== this.hasAncestorComputeNeed() ) {
        this.parent && this.parent.decrementTransformPrecomputeChildren();
      }
    },

    /*---------------------------------------------------------------------------*
     * Relative transform handling
     *----------------------------------------------------------------------------*/

    // called immediately when the corresponding node has a transform change (can happen multiple times between renders)
    onNodeTransformDirty: function() {
      if ( !this.transformDirty ) {
        this.forceMarkTransformDirty();
      }
    },

    forceMarkTransformDirty: function() {
      this.transformDirty = true;
      this.relativeSelfDirty = true;

      var frameId = this.display._frameId;

      // mark all ancestors with relativeChildDirtyFrame, bailing out when possible
      var instance = this.instance.parent;
      while ( instance && instance.relativeTransform.relativeChildDirtyFrame !== frameId ) {
        var parentInstance = instance.parent;
        var isTransformed = instance.isTransformed;

        // NOTE: our while loop guarantees that it wasn't frameId
        instance.relativeTransform.relativeChildDirtyFrame = frameId;

        // always mark an instance without a parent (root instance!)
        if ( parentInstance === null ) {
          // passTransform depends on whether it is marked as a transform root
          this.display.markTransformRootDirty( instance, isTransformed );
          break;
        }
        else if ( isTransformed ) {
          this.display.markTransformRootDirty( instance, true ); // passTransform true
          break;
        }

        instance = parentInstance;
      }
    },

    // @private, updates our matrix based on any parents, and the node's current transform
    computeRelativeTransform: function() {
      var nodeMatrix = this.node.getMatrix();

      if ( this.instance.parent && !this.instance.parent.isTransformed ) {
        // mutable form of parentMatrix * nodeMatrix
        this.matrix.set( this.parent.matrix );
        this.matrix.multiplyMatrix( nodeMatrix );
      }
      else {
        // we are the first in the trail transform, so we just directly copy the matrix over
        this.matrix.set( nodeMatrix );
      }

      // mark the frame where this transform was updated, to accelerate non-precomputed access
      this.relativeFrameId = this.display._frameId;
      this.relativeSelfDirty = false;
    },

    // @public
    isValidationNotNeeded: function() {
      return this.hasAncestorComputeNeed() || this.relativeFrameId === this.display._frameId;
    },

    // Called from any place in the rendering process where we are not guaranteed to have a fresh relative transform.
    // needs to scan up the tree, so it is more expensive than precomputed transforms.
    // @returns Whether we had to update this transform
    validate: function() {
      // if we are clean, bail out. If we have a compute "need", we will always be clean here since this is after the
      // traversal step. If we did not have a compute "need", we check whether we were already updated this frame by
      // computeRelativeTransform.
      if ( this.isValidationNotNeeded() ) {
        return;
      }

      // if we are not the first transform from the root, validate our parent. isTransform check prevents us from
      // passing a transform root.
      if ( this.instance.parent && !this.instance.parent.isTransformed ) {
        this.parent.validate();
      }

      // validation of the parent may have changed our relativeSelfDirty flag to true, so we check now (could also have
      // been true before)
      if ( this.relativeSelfDirty ) {
        // compute the transform, and mark us as not relative-dirty
        this.computeRelativeTransform();

        // mark all children now as dirty, since we had to update (marked so that other children from the one we are
        // validating will know that they need updates)
        // if we were called from a child's validate(), they will now need to compute their transform
        var len = this.instance.children.length;
        for ( var i = 0; i < len; i++ ) {
          this.instance.children[ i ].relativeTransform.relativeSelfDirty = true;
        }
      }
    },

    // called during the pre-repaint phase to (a) fire off all relative transform listeners that should be fired, and
    // (b) precompute transforms were desired
    updateTransformListenersAndCompute: function( ancestorWasDirty, ancestorIsDirty, frameId, passTransform ) {
      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.RelativeTransform(
        'update/compute: ' + this.toString() + ' ' + ancestorWasDirty + ' => ' + ancestorIsDirty +
        ( passTransform ? ' passTransform' : '' ) );
      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.push();

      var len;
      var i;

      if ( passTransform ) {
        // if we are passing isTransform, just apply this to the children
        len = this.instance.children.length;
        for ( i = 0; i < len; i++ ) {
          this.instance.children[ i ].relativeTransform.updateTransformListenersAndCompute( false, false, frameId, false );
        }
      }
      else {
        var wasDirty = ancestorWasDirty || this.relativeSelfDirty;
        var wasSubtreeDirty = wasDirty || this.relativeChildDirtyFrame === frameId;
        var hasComputeNeed = this.hasDescendantComputeNeed();
        var hasListenerNeed = this.hasDescendantListenerNeed();
        var hasSelfComputeNeed = this.hasSelfComputeNeed();
        var hasSelfListenerNeed = this.hasSelfListenerNeed();

        // if our relative transform will be dirty but our parents' transform will be clean, we need to mark ourselves
        // as dirty (so that later access can identify we are dirty).
        if ( !hasComputeNeed && wasDirty && !ancestorIsDirty ) {
          this.relativeSelfDirty = true;
        }

        // check if traversal isn't needed (no instances marked as having listeners or needing computation)
        // either the subtree is clean (no traversal needed for compute/listeners), or we have no compute/listener needs
        if ( !wasSubtreeDirty || ( !hasComputeNeed && !hasListenerNeed && !hasSelfComputeNeed && !hasSelfListenerNeed ) ) {
          sceneryLog && sceneryLog.RelativeTransform && sceneryLog.pop();
          return;
        }

        // if desired, compute the transform
        if ( wasDirty && ( hasComputeNeed || hasSelfComputeNeed ) ) {
          // compute this transform in the pre-repaint phase, so it is cheap when always used/
          // we update when the child-precompute count >0, since those children will need
          this.computeRelativeTransform();
        }

        if ( this.transformDirty ) {
          this.transformDirty = false;
        }

        // no hasListenerNeed guard needed?
        this.notifyRelativeTransformListeners();

        // only update children if we aren't transformed (completely other context)
        if ( !this.instance.isTransformed || passTransform ) {

          var isDirty = wasDirty && !( hasComputeNeed || hasSelfComputeNeed );

          // continue the traversal
          len = this.instance.children.length;
          for ( i = 0; i < len; i++ ) {
            this.instance.children[ i ].relativeTransform.updateTransformListenersAndCompute( wasDirty, isDirty, frameId, false );
          }
        }
      }

      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.pop();
    },

    // @private
    notifyRelativeTransformListeners: function() {
      var len = this.relativeTransformListeners.length;
      for ( var i = 0; i < len; i++ ) {
        this.relativeTransformListeners[ i ]();
      }
    },

    audit: function( frameId, allowValidationNotNeededChecks ) {
      // get the relative matrix, computed to be up-to-date, and ignores any flags/counts so we can check whether our
      // state is consistent
      function currentRelativeMatrix( instance ) {
        var resultMatrix = Matrix3.dirtyFromPool();
        var nodeMatrix = instance.node.getMatrix();

        if ( !instance.parent ) {
          // if our instance has no parent, ignore its transform
          resultMatrix.set( Matrix3.IDENTITY );
        }
        else if ( !instance.parent.isTransformed ) {
          // mutable form of parentMatrix * nodeMatrix
          resultMatrix.set( currentRelativeMatrix( instance.parent ) );
          resultMatrix.multiplyMatrix( nodeMatrix );
        }
        else {
          // we are the first in the trail transform, so we just directly copy the matrix over
          resultMatrix.set( nodeMatrix );
        }

        return resultMatrix;
      }

      function hasRelativeSelfDirty( instance ) {
        // if validation isn't needed, act like nothing is dirty (matching our validate behavior)
        if ( allowValidationNotNeededChecks && instance.isValidationNotNeeded() ) {
          return false;
        }

        return instance.relativeSelfDirty || ( instance.parent && hasRelativeSelfDirty( instance.parent ) );
      }

      if ( assertSlow ) {
        // count verification for invariants
        var notifyRelativeCount = 0;
        var precomputeRelativeCount = 0;
        for ( var i = 0; i < this.instance.children.length; i++ ) {
          var childInstance = this.instance.children[ i ];

          if ( childInstance.relativeTransform.hasAncestorListenerNeed() ) {
            notifyRelativeCount++;
          }
          if ( childInstance.relativeTransform.hasAncestorComputeNeed() ) {
            precomputeRelativeCount++;
          }
        }
        assertSlow( notifyRelativeCount === this.relativeChildrenListenersCount,
          'Relative listener count invariant' );
        assertSlow( precomputeRelativeCount === this.relativeChildrenPrecomputeCount,
          'Relative precompute count invariant' );

        assertSlow( !this.parent || this.instance.isTransformed || ( this.relativeChildDirtyFrame !== frameId ) ||
                    ( this.parent.relativeChildDirtyFrame === frameId ),
          'If we have a parent, we need to hold the invariant ' +
          'this.relativeChildDirtyFrame => parent.relativeChildDirtyFrame' );

        if ( !hasRelativeSelfDirty( this ) ) {
          var matrix = currentRelativeMatrix( this );
          assertSlow( matrix.equals( this.matrix ), 'If there is no relativeSelfDirty flag set here or in our' +
                                                    ' ancestors, our matrix should be up-to-date' );
        }
      }
    }
  } );

  return RelativeTransform;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * A sub-component of an Instance that handles matters relating to whether fitted blocks should not fit if possible.
 * We mostly mark our own drawables as fittable, and track whether our subtree is all fittable (so that common-ancestor
 * fits can determine if their bounds will change).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Fittability',['require','PHET_CORE/inherit','AXON/Emitter','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @constructor
   *
   * @param {Instance} instance - Our Instance, never changes.
   */
  function Fittability( instance ) {
    // @private {Instance}
    this.instance = instance;
  }

  scenery.register( 'Fittability', Fittability );

  inherit( Object, Fittability, {
    /**
     * Responsible for initialization and cleaning of this. If the parameters are both null, we'll want to clean our
     * external references (like Instance does).
     *
     * @param {Display|null} display
     * @param {Trail|null} trail
     * @returns {Fittability} - Returns this, to allow chaining.
     */
    initialize: function( display, trail ) {
      this.display = display; // @private {Display}
      this.trail = trail; // @private {Trail}
      this.node = trail && trail.lastNode(); // @private {Node}

      // @public {boolean} - When our instance's node has a particular combination of features and/or flags (like
      // preventDefault:true) that should make any FittedBlock containing drawables under that node OR that would
      // include the bounds of the node in its FittedBlock to not compute the relevant fit (e.g. have it take up the
      // full display instead).
      this.selfFittable = !!trail && this.isSelfFitSupported();

      // @public {boolean} - Whether this instance AND all of its ancestor instances (down to the root instance for the
      // display) all are self-fittable.
      this.ancestorsFittable = this.selfFittable;

      // @public {number} - The number of children whose subtrees have an unfittable instance, plus 1 if this instance
      // itself is unfittable. Using a number allows us to quickly increment/decrement when a particular child changes
      // its fittability (so we don't have to check other subtrees or traverse further up the tree). For a more
      // complete description of this technique, see RendererSummary.
      // This is important, since if it's 0, it indicates that this entire subtree has NO unfittable content. Thus if
      // a FittedBlock's common ancestor (for the common-ancestor fit) is this instance, we shouldn't have issues
      // updating our bounds.
      this.subtreeUnfittableCount = this.selfFittable ? 0 : 1;

      // @public {Emitter} - Called with no arguments when the subtree fittability changes (whether
      // subtreeUnfittableCount is greater than zero or not).
      this.subtreeFittabilityChange = this.subtreeFittabilityChange || new Emitter();

      return this; // allow chaining
    },

    /**
     * Easy access to our parent Instance's Fittability, if it exists.
     * @private
     *
     * @returns {Fittability|null}
     */
    get parent() {
      return this.instance.parent ? this.instance.parent.fittability : null;
    },

    /**
     * Called when the instance is updating its rendering state (as any fittability changes to existing instances will
     * trigger an update there).
     * @public
     */
    checkSelfFittability: function() {
      var newSelfFittable = this.isSelfFitSupported();
      if ( this.selfFittable !== newSelfFittable ) {
        this.updateSelfFittable();
      }
    },

    /**
     * Whether our node's performance flags allows the subtree to be fitted.
     * @private
     *
     * Any updates to flags (for instance, a 'dynamic' flag perhaps?) should be added here.
     *
     * @returns {boolean}
     */
    isSelfFitSupported: function() {
      return !this.node.isPreventFit();
    },

    /**
     * Called when our parent just became fittable. Responsible for flagging subtrees with the ancestorsFittable flag,
     * up to the point where they are fittable.
     * @private
     */
    markSubtreeFittable: function() {
      // Bail if we can't be fittable ourselves
      if ( !this.selfFittable ) {
        return;
      }

      this.ancestorsFittable = true;

      var children = this.instance.children;
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].fittability.markSubtreeFittable();
      }

      // Update the Instance's drawables, so that their blocks can potentially now be fitted.
      this.instance.updateDrawableFittability( true );
    },

    /**
     * Called when our parent just became unfittable and we are fittable. Responsible for flagging subtrees with
     * the !ancestorsFittable flag, up to the point where they are unfittable.
     * @private
     */
    markSubtreeUnfittable: function() {
      // Bail if we are already unfittable
      if ( !this.ancestorsFittable ) {
        return;
      }

      this.ancestorsFittable = false;

      var children = this.instance.children;
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].markSubtreeUnfittable();
      }

      // Update the Instance's drawables, so that their blocks can potentially now be prevented from being fitted.
      this.instance.updateDrawableFittability( false );
    },

    /**
     * Called when our Node's self fit-ability has changed.
     * @private
     */
    updateSelfFittable: function() {
      var newSelfFittable = this.isSelfFitSupported();
      assert && assert( this.selfFittable !== newSelfFittable );

      this.selfFittable = newSelfFittable;

      if ( this.selfFittable && ( !this.parent || this.parent.ancestorsFittable ) ) {
        this.markSubtreeFittable();
      }
      else if ( !this.selfFittable ) {
        this.markSubtreeUnfittable();
      }

      if ( this.selfFittable ) {
        this.decrementSubtreeUnfittableCount();
      }
      else {
        this.incrementSubtreeUnfittableCount();
      }
    },

    /**
     * A child instance's subtree became unfittable, OR our 'self' became unfittable. This is responsible for updating
     * the subtreeFittableCount for this instance AND up to all ancestors that would be affected by the change.
     * @private
     */
    incrementSubtreeUnfittableCount: function() {
      this.subtreeUnfittableCount++;

      // If now something in our subtree can't be fitted, we need to notify our parent
      if ( this.subtreeUnfittableCount === 1 ) {
        this.parent && this.parent.incrementSubtreeUnfittableCount();

        // Notify anything listening that the condition ( this.subtreeUnfittableCount > 0 ) changed.
        this.subtreeFittabilityChange.emit();
      }
    },

    /**
     * A child instance's subtree became fittable, OR our 'self' became fittable. This is responsible for updating
     * the subtreeFittableCount for this instance AND up to all ancestors that would be affected by the change.
     * @private
     */
    decrementSubtreeUnfittableCount: function() {
      this.subtreeUnfittableCount--;

      // If now our subtree can all be fitted, we need to notify our parent
      if ( this.subtreeUnfittableCount === 0 ) {
        this.parent && this.parent.decrementSubtreeUnfittableCount();

        // Notify anything listening that the condition ( this.subtreeUnfittableCount > 0 ) changed.
        this.subtreeFittabilityChange.emit();
      }
    },

    /**
     * Called when an instance is added as a child to our instance. Updates necessary counts.
     * @public
     *
     * @param {Fittability} childFittability - The Fittability of the new child instance.
     */
    onInsert: function( childFittability ) {
      if ( !this.ancestorsFittable ) {
        childFittability.markSubtreeUnfittable();
      }

      if ( childFittability.subtreeUnfittableCount > 0 ) {
        this.incrementSubtreeUnfittableCount();
      }
    },

    /**
     * Called when a child instance is removed from our instance. Updates necessary counts.
     * @public
     *
     * @param {Fittability} childFittability - The Fittability of the old child instance.
     */
    onRemove: function( childFittability ) {
      if ( !this.ancestorsFittable ) {
        childFittability.markSubtreeFittable();
      }

      if ( childFittability.subtreeUnfittableCount > 0 ) {
        this.decrementSubtreeUnfittableCount();
      }
    },

    /**
     * Sanity checks that run when slow assertions are enabled. Enforces the invariants of the Fittability subsystem.
     * @public
     */
    audit: function() {
      if ( assertSlow ) {
        assertSlow( this.selfFittable === this.isSelfFitSupported(),
          'selfFittable diverged from isSelfFitSupported()' );

        assertSlow( this.ancestorsFittable === ( ( this.parent ? this.parent.ancestorsFittable : true ) && this.selfFittable ),
          'Our ancestorsFittable should be false if our parent or our self is not fittable.' );

        // Our subtree unfittable count should be the sum of children that have a non-zero count, plus 1 if our self
        // is not fittable
        var subtreeUnfittableCount = 0;
        if ( !this.selfFittable ) {
          subtreeUnfittableCount++;
        }
        _.each( this.instance.children, function( instance ) {
          if ( instance.fittability.subtreeUnfittableCount > 0 ) {
            subtreeUnfittableCount++;
          }
        } );
        assertSlow( this.subtreeUnfittableCount === subtreeUnfittableCount, 'Incorrect subtreeUnfittableCount' );
      }
    }
  } );

  return Fittability;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * An instance that is specific to the display (not necessarily a global instance, could be in a Canvas cache, etc),
 * that is needed to tracking instance-specific display information, and signals to the display system when other
 * changes are necessary.
 *
 * Instances generally form a true tree, as opposed to the DAG of nodes. The one exception is for shared Canvas caches,
 * where multiple instances can point to one globally-stored (shared) cache instance.
 *
 * An Instance is pooled, but when constructed will not automatically create children, drawables, etc.
 * syncTree() is responsible for synchronizing the instance itself and its entire subtree.
 *
 * Instances are created as 'stateless' instances, but during syncTree the rendering state (properties to determine
 * how to construct the drawable tree for this instance and its subtree) are set.
 *
 * While Instances are considered 'stateful', they will have listeners added to their Node which records actions taken
 * in-between Display.updateDisplay().
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Instance',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/ChangeInterval','SCENERY/display/Drawable','SCENERY/display/Renderer','SCENERY/display/RelativeTransform','SCENERY/display/Fittability','SCENERY/util/Util','AXON/Events'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var ChangeInterval = require( 'SCENERY/display/ChangeInterval' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var RelativeTransform = require( 'SCENERY/display/RelativeTransform' );
  var Fittability = require( 'SCENERY/display/Fittability' );
  var Util = require( 'SCENERY/util/Util' );
  var Events = require( 'AXON/Events' );

  var globalIdCounter = 1;

  var isWebGLSupported = Util.isWebGLSupported;

  // preferences top to bottom in general
  var defaultPreferredRenderers = Renderer.createOrderBitmask(
    Renderer.bitmaskSVG, Renderer.bitmaskCanvas, Renderer.bitmaskDOM, Renderer.bitmaskWebGL );

  // see initialize() for documentation
  function Instance( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
    Events.call( this );

    this.active = false;

    this.initialize( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
  }

  scenery.register( 'Instance', Instance );

  inherit( Events, Instance, {
    /*
     * @param {Display} display - Instances are bound to a single display
     * @param {Trail} trail - The list of ancestors going back up to our root instance (for the display, or for a cache)
     * @param {boolean} isDisplayRoot - Whether our instance is for the root node provided to the Display.
     * @param {boolean} isSharedCanvasCacheRoot - Whether our instance is the root for a shared Canvas cache (which can
     *                                            be used multiple places in the main instance tree)
     */
    initialize: function( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
      assert && assert( !this.active,
        'We should never try to initialize an already active object' );

      // prevent the trail passed in from being mutated after this point (we want a consistent trail)
      trail.setImmutable();

      this.id = this.id || globalIdCounter++;

      // {RelativeTransform}, provides high-performance access to 'relative' transforms (from our nearest
      // transform root), and allows for listening to when our relative transform changes (called during
      // a phase of Display.updateDisplay()).
      this.relativeTransform = ( this.relativeTransform || new RelativeTransform( this ) );

      // {Fittability}, provides logic for whether our drawables (or common-fit ancestors) will support fitting for
      // FittedBlock subtypes. See https://github.com/phetsims/scenery/issues/406.
      this.fittability = ( this.fittability || new Fittability( this ) );

      // Tracking of visibility {boolean} and associated boolean flags.
      this.visible = true; // global visibility (whether this instance will end up appearing on the display)
      this.relativeVisible = true; // relative visibility (ignores the closest ancestral visibility root and below)
      this.selfVisible = true; // like relative visibility, but is always true if we are a visibility root
      this.visibilityDirty = true; // entire subtree of visibility will need to be updated
      this.childVisibilityDirty = true; // an ancestor needs its visibility updated

      // In the range (-1,0), to help us track insertions and removals of this instance's node to its parent
      // (did we get removed but added back?).
      // If it's -1 at its parent's syncTree, we'll end up removing our reference to it.
      // We use an integer just for sanity checks (if it ever reaches -2 or 1, we've reached an invalid state)
      this.addRemoveCounter = 0;

      // If equal to the current frame ID (it is initialized as such), then it is treated during the change interval
      // waterfall as "completely changed", and an interval for the entire instance is used.
      this.stitchChangeFrame = display._frameId;

      // If equal to the current frame ID, an instance was removed from before or after this instance, so we'll want to
      // add in a proper change interval (related to siblings)
      this.stitchChangeBefore = 0;
      this.stitchChangeAfter = 0;

      // If equal to the current frame ID, child instances were added or removed from this instance.
      this.stitchChangeOnChildren = 0;

      // whether we have been included in our parent's drawables the previous frame
      this.stitchChangeIncluded = false;

      // Node listeners for tracking children. Listeners should be added only when we become stateful
      this.childInsertedListener = this.childInsertedListener || this.onChildInserted.bind( this );
      this.childRemovedListener = this.childRemovedListener || this.onChildRemoved.bind( this );
      this.visibilityListener = this.visibilityListener || this.onVisibilityChange.bind( this );
      this.markRenderStateDirtyListener = this.markRenderStateDirtyListener || this.markRenderStateDirty.bind( this );

      this.cleanInstance( display, trail );

      // We need to add this reference on stateless instances, so that we can find out if it was removed before our
      // syncTree was called.
      this.node.addInstance( this );

      // Outstanding external references. used for shared cache instances, where multiple instances can point to us.
      this.externalReferenceCount = 0;

      this.stateless = true; // {boolean} - Whether we have had our state initialized yet

      // Rendering state constants (will not change over the life of an instance)
      this.isDisplayRoot = isDisplayRoot; // {boolean} - Whether we are the root instance for a Display
      this.isSharedCanvasCacheRoot = isSharedCanvasCacheRoot; // {boolean} - Whether we are the root of a Canvas cache

      // 'Cascading' render state for the instance tree. These are properties that can affect the entire subtree when set
      this.preferredRenderers = 0; // {number} - Packed renderer order bitmask (what our renderer preferences are)
      this.isUnderCanvasCache = isSharedCanvasCacheRoot; // {boolean} - Whether we are beneath a Canvas cache (Canvas required)

      // Render state exports for this instance.
      this.isBackbone = false; // {boolean} - Whether we will have a BackboneDrawable group drawable
      this.isTransformed = false;  // {boolean} - Whether this instance creates a new "root" for the relative trail transforms
      this.isVisibilityApplied = false; // {boolean} - Whether this instance handles visibility with a group drawable
      this.isInstanceCanvasCache = false; // {boolean} - Whether we have a Canvas cache specific to this instance's position
      this.isSharedCanvasCachePlaceholder = false; // {boolean}
      this.isSharedCanvasCacheSelf = isSharedCanvasCacheRoot; // {boolean}
      this.selfRenderer = 0; // {number} Renderer bitmask for the 'self' drawable (if our Node is painted)
      this.groupRenderer = 0; // {number} Renderer bitmask for the 'group' drawable (if applicable)
      this.sharedCacheRenderer = 0; // {number} Renderer bitmask for the cache drawable (if applicable)

      // pruning flags (whether we need to be visited, whether updateRenderingState is required, and whether to visit children)
      this.renderStateDirtyFrame = display._frameId; // {number} - When equal to the current frame it is considered "dirty"
      this.skipPruningFrame = display._frameId; // {number} - When equal to the current frame we can't prune at this instance

      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'initialized ' + this.toString() );

      // Whether we have been instantiated. false if we are in a pool waiting to be instantiated.
      this.active = true;

      return this;
    },

    /*
     * Called for initialization of properties (via initialize(), via constructor), and to clean the instance for
     * placement in the pool (don't leak memory).
     *
     * If the parameters are null, we remove all external references so that we don't leak memory.
     *
     * @param {Display|null} display - Instances are bound to a single display
     * @param {Trail|null} trail - The list of ancestors going back up to our root instance (for the display, or for a cache)
     */
    cleanInstance: function( display, trail ) {
      this.display = display;
      this.trail = trail;
      this.node = trail ? trail.lastNode() : null;
      this.parent = null; // will be set as needed
      this.oldParent = null; // set when removed from us, so that we can easily reattach it when necessary
      // NOTE: reliance on correct order after syncTree by at least SVGBlock/SVGGroup
      this.children = cleanArray( this.children ); // Array[Instance].
      this.sharedCacheInstance = null; // reference to a shared cache instance (different than a child)

      // initialize/clean sub-components
      this.relativeTransform.initialize( display, trail );
      this.fittability.initialize( display, trail );

      // {Instance[]} - Child instances are pushed to here when their node is removed from our node.
      // We don't immediately dispose, since it may be added back.
      this.instanceRemovalCheckList = cleanArray( this.instanceRemovalCheckList );

      // {Drawable} - references to our drawables in the drawable tree
      this.selfDrawable = null;
      this.groupDrawable = null; // e.g. backbone or non-shared cache
      this.sharedCacheDrawable = null; // our drawable if we are a shared cache

      // {Drawable} - references into the linked list of drawables (null if nothing is drawable under this)
      this.firstDrawable = null;
      this.lastDrawable = null;

      // {Drawable} - references into the linked list of drawables (excludes any group drawables handling)
      this.firstInnerDrawable = null;
      this.lastInnerDrawable = null;

      // {SVGGroup[]} - List of SVG groups associated with this display instance
      this.svgGroups = cleanArray( this.svgGroups );

      this.cleanSyncTreeResults();
    },

    /*
     * Initializes or clears properties that are all set as pseudo 'return values' of the syncTree() method. It is the
     * responsibility of the caller of syncTree() to afterwards (optionally read these results and) clear the references
     * using this method to prevent memory leaks.
     *
     * TODO: consider a pool of (or a single global) typed return object(s), since setting these values on the instance
     * generally means hitting the heap, and can slow us down.
     */
    cleanSyncTreeResults: function() {
      // Tracking bounding indices / drawables for what has changed, so we don't have to over-stitch things.

      // if (not iff) child's index <= beforeStableIndex, it hasn't been added/removed. relevant to current children.
      this.beforeStableIndex = this.children.length;

      // if (not iff) child's index >= afterStableIndex, it hasn't been added/removed. relevant to current children.
      this.afterStableIndex = -1;

      // NOTE: both of these being null indicates "there are no change intervals", otherwise it assumes it points to
      // a linked-list of change intervals. We use {ChangeInterval}s to hold this information, see ChangeInterval to see
      // the individual properties that are considered part of a change interval.

      // {ChangeInterval}, first change interval (should have nextChangeInterval linked-list to lastChangeInterval)
      this.firstChangeInterval = null;

      // {ChangeInterval}, last change interval
      this.lastChangeInterval = null;

      // {boolean} - render state change flags, all set in updateRenderingState()
      this.incompatibleStateChange = false; // {boolean} - Whether we need to recreate the instance tree
      this.groupChanged = false; // {boolean} - Whether we need to force a rebuild of the group drawable
      this.cascadingStateChange = false; // {boolean} - Whether we had a render state change that requires visiting all children
      this.anyStateChange = false; // {boolean} - Whether there was any change of rendering state with the last updateRenderingState()
    },

    /*
     * Updates the rendering state properties, and returns a {boolean} flag of whether it was successful if we were
     * already stateful.
     *
     * Rendering state properties determine how we construct the drawable tree from our instance tree (e.g. do we
     * create an SVG or Canvas rectangle, where to place CSS transforms, how to handle opacity, etc.)
     *
     * Instances start out as 'stateless' until updateRenderingState() is called the first time.
     *
     * Node changes that can cause a potential state change (using Node event listeners):
     * - hints
     * - opacity
     * - clipArea
     * - _rendererSummary
     * - _rendererBitmask
     *
     * State changes that can cause cascading state changes in descendants:
     * - isUnderCanvasCache
     * - preferredRenderers
     */
    updateRenderingState: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'updateRenderingState ' + this.toString() +
                                                                ( this.stateless ? ' (stateless)' : '' ) );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'old: ' + this.getStateString() );

      // old state information, so we can compare what was changed
      var wasBackbone = this.isBackbone;
      var wasTransformed = this.isTransformed;
      var wasVisibilityApplied = this.isVisibilityApplied;
      var wasInstanceCanvasCache = this.isInstanceCanvasCache;
      var wasSharedCanvasCacheSelf = this.isSharedCanvasCacheSelf;
      var wasSharedCanvasCachePlaceholder = this.isSharedCanvasCachePlaceholder;
      var wasUnderCanvasCache = this.isUnderCanvasCache;
      var oldSelfRenderer = this.selfRenderer;
      var oldGroupRenderer = this.groupRenderer;
      var oldSharedCacheRenderer = this.sharedCacheRenderer;
      var oldPreferredRenderers = this.preferredRenderers;

      // default values to set (makes the logic much simpler)
      this.isBackbone = false;
      this.isTransformed = false;
      this.isVisibilityApplied = false;
      this.isInstanceCanvasCache = false;
      this.isSharedCanvasCacheSelf = false;
      this.isSharedCanvasCachePlaceholder = false;
      this.selfRenderer = 0;
      this.groupRenderer = 0;
      this.sharedCacheRenderer = 0;

      var hints = this.node._hints;

      this.isUnderCanvasCache = this.isSharedCanvasCacheRoot ||
                                ( this.parent ? ( this.parent.isUnderCanvasCache || this.parent.isInstanceCanvasCache || this.parent.isSharedCanvasCacheSelf ) : false );

      // set up our preferred renderer list (generally based on the parent)
      this.preferredRenderers = this.parent ? this.parent.preferredRenderers : defaultPreferredRenderers;
      // allow the node to modify its preferred renderers (and those of its descendants)
      if ( hints.renderer ) {
        this.preferredRenderers = Renderer.pushOrderBitmask( this.preferredRenderers, hints.renderer );
      }

      var hasClip = this.node.hasClipArea();
      var hasTransparency = this.node.opacity !== 1 || hints.usesOpacity;
      var requiresSplit = hints.requireElement || hints.cssTransform || hints.layerSplit;
      var backboneRequired = this.isDisplayRoot || ( !this.isUnderCanvasCache && requiresSplit );
      var applyTransparencyWithSVG = !backboneRequired &&
                                     ( hasTransparency || hasClip ) &&
                                     this.node._rendererSummary.isSubtreeRenderedExclusivelySVG( this.preferredRenderers );
      var useBackbone = applyTransparencyWithSVG ? false : ( backboneRequired || hasTransparency || hasClip );

      // check if we need a backbone or cache
      // if we are under a canvas cache, we will NEVER have a backbone
      // splits are accomplished just by having a backbone
      // NOTE: If changing, check RendererSummary.summaryBitmaskForNodeSelf
      //OHTWO TODO: Update this to properly identify when backbones are necessary/and-or when we forward opacity/clipping
      if ( useBackbone ) {
        this.isBackbone = true;
        this.isVisibilityApplied = true;
        this.isTransformed = this.isDisplayRoot || !!hints.cssTransform; // for now, only trigger CSS transform if we have the specific hint
        //OHTWO TODO: check whether the force acceleration hint is being used by our DOMBlock
        this.groupRenderer = Renderer.bitmaskDOM; // probably won't be used
      }
      else if ( !applyTransparencyWithSVG && ( hasTransparency || hasClip || hints.canvasCache ) ) {
        // everything underneath needs to be renderable with Canvas, otherwise we cannot cache
        assert && assert( this.node._rendererSummary.isSingleCanvasSupported(),
          'hints.canvasCache provided, but not all node contents can be rendered with Canvas under ' +
          this.node.constructor.name );

        if ( hints.singleCache ) {
          // TODO: scale options - fixed size, match highest resolution (adaptive), or mipmapped
          if ( this.isSharedCanvasCacheRoot ) {
            this.isSharedCanvasCacheSelf = true;

            this.sharedCacheRenderer = isWebGLSupported ? Renderer.bitmaskWebGL : Renderer.bitmaskCanvas;
          }
          else {
            // everything underneath needs to guarantee that its bounds are valid
            //OHTWO TODO: We'll probably remove this if we go with the "safe bounds" approach
            assert && assert( this.node._rendererSummary.areBoundsValid(),
              'hints.singleCache provided, but not all node contents have valid bounds under ' +
              this.node.constructor.name );

            this.isSharedCanvasCachePlaceholder = true;
          }
        }
        else {
          this.isInstanceCanvasCache = true;
          this.isUnderCanvasCache = true;
          this.groupRenderer = isWebGLSupported ? Renderer.bitmaskWebGL : Renderer.bitmaskCanvas;
        }
      }

      if ( this.node.isPainted() ) {
        if ( this.isUnderCanvasCache ) {
          this.selfRenderer = Renderer.bitmaskCanvas;
        }
        else {
          var supportedNodeBitmask = this.node._rendererBitmask;
          if ( !isWebGLSupported ) {
            var invalidBitmasks = Renderer.bitmaskWebGL;
            supportedNodeBitmask = supportedNodeBitmask ^ ( supportedNodeBitmask & invalidBitmasks );
          }

          // use the preferred rendering order if specified, otherwise use the default
          this.selfRenderer = ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 0 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 1 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 2 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 3 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskSVG ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskCanvas ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskDOM ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskWebGL ) ||
                              0;

          assert && assert( this.selfRenderer, 'setSelfRenderer failure?' );
        }
      }

      // whether we need to force rebuilding the group drawable
      this.groupChanged = ( wasBackbone !== this.isBackbone ) ||
                          ( wasInstanceCanvasCache !== this.isInstanceCanvasCache ) ||
                          ( wasSharedCanvasCacheSelf !== this.isSharedCanvasCacheSelf );

      // whether any of our render state changes can change descendant render states
      this.cascadingStateChange = ( wasUnderCanvasCache !== this.isUnderCanvasCache ) ||
                                  ( oldPreferredRenderers !== this.preferredRenderers );

      /*
       * Whether we can just update the state on an Instance when changing from this state => otherState.
       * This is generally not possible if there is a change in whether the instance should be a transform root
       * (e.g. backbone/single-cache), so we will have to recreate the instance and its subtree if that is the case.
       *
       * Only relevant if we were previously stateful, so it can be ignored if this is our first updateRenderingState()
       */
      this.incompatibleStateChange = ( this.isTransformed !== wasTransformed ) ||
                                     ( this.isSharedCanvasCachePlaceholder !== wasSharedCanvasCachePlaceholder );

      // whether there was any render state change
      this.anyStateChange = this.groupChanged || this.cascadingStateChange || this.incompatibleStateChange ||
                            ( oldSelfRenderer !== this.selfRenderer ) ||
                            ( oldGroupRenderer !== this.groupRenderer ) ||
                            ( oldSharedCacheRenderer !== this.sharedCacheRenderer );

      // if our visibility applications changed, update the entire subtree
      if ( wasVisibilityApplied !== this.isVisibilityApplied ) {
        this.visibilityDirty = true;
        this.parent && this.parent.markChildVisibilityDirty();
      }

      // If our fittability has changed, propagate those changes. (It's generally a hint change which will trigger an
      // update of rendering state).
      this.fittability.checkSelfFittability();

      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new: ' + this.getStateString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },

    /*
     * @returns A short string that contains a summary of the rendering state, for debugging/logging purposes.
     */
    getStateString: function() {
      var result = 'S[ ' +
                   ( this.isDisplayRoot ? 'displayRoot ' : '' ) +
                   ( this.isBackbone ? 'backbone ' : '' ) +
                   ( this.isInstanceCanvasCache ? 'instanceCache ' : '' ) +
                   ( this.isSharedCanvasCachePlaceholder ? 'sharedCachePlaceholder ' : '' ) +
                   ( this.isSharedCanvasCacheSelf ? 'sharedCacheSelf ' : '' ) +
                   ( this.isTransformed ? 'TR ' : '' ) +
                   ( this.isVisibilityApplied ? 'VIS ' : '' ) +
                   ( this.selfRenderer ? this.selfRenderer.toString( 16 ) : '-' ) + ',' +
                   ( this.groupRenderer ? this.groupRenderer.toString( 16 ) : '-' ) + ',' +
                   ( this.sharedCacheRenderer ? this.sharedCacheRenderer.toString( 16 ) : '-' ) + ' ';
      return result + ']';
    },

    /*
     * The main entry point for syncTree(), called on the root instance. See syncTree() for more information.
     */
    baseSyncTree: function() {
      assert && assert( this.isDisplayRoot, 'baseSyncTree() should only be called on the root instance' );

      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( '-------- START baseSyncTree ' + this.toString() + ' --------' );
      this.syncTree();
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( '-------- END baseSyncTree ' + this.toString() + ' --------' );
      this.cleanSyncTreeResults();
    },

    /*
     * Updates the rendering state, synchronizes the instance sub-tree (so that our instance tree matches
     * the Node tree the client provided), and back-propagates {ChangeInterval} information for stitching backbones
     * and/or caches.
     *
     * syncTree() also sets a number of pseudo 'return values' (documented in cleanSyncTreeResults()). After calling
     * syncTree() and optionally reading those results, cleanSyncTreeResults() should be called on the same instance
     * in order to prevent memory leaks.
     *
     * @returns {boolean} - Whether the sync was possible. If it wasn't, a new instance subtree will need to be created.
     */
    syncTree: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'syncTree ' + this.toString() + ' ' + this.getStateString() +
                                                                ( this.stateless ? ' (stateless)' : '' ) );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.display.perfSyncTreeCount++;
      }

      // may access isTransformed up to root to determine relative trails
      assert && assert( !this.parent || !this.parent.stateless, 'We should not have a stateless parent instance' );

      var wasStateless = this.stateless;
      if ( wasStateless ||
           ( this.parent && this.parent.cascadingStateChange ) || // if our parent had cascading state changes, we need to recompute
           ( this.renderStateDirtyFrame === this.display._frameId ) ) { // if our render state is dirty
        this.updateRenderingState();
      }
      else {
        // we can check whether updating state would have made any changes when we skip it (for slow assertions)
        if ( assertSlow ) {
          this.updateRenderingState();
          assertSlow( !this.anyStateChange );
        }
      }

      if ( !wasStateless && this.incompatibleStateChange ) {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'incompatible instance ' + this.toString() + ' ' + this.getStateString() + ', aborting' );
        sceneryLog && sceneryLog.Instance && sceneryLog.pop();

        // The false return will signal that a new instance needs to be used. our tree will be disposed soon.
        return false;
      }
      this.stateless = false;

      // no need to overwrite, should always be the same
      assert && assert( !wasStateless || this.children.length === 0,
        'We should not have child instances on an instance without state' );

      if ( wasStateless ) {
        // If we are a transform root, notify the display that we are dirty. We'll be validated when it's at that phase
        // at the next updateDisplay().
        if ( this.isTransformed ) {
          this.display.markTransformRootDirty( this, true );
        }

        this.attachNodeListeners();
      }

      // TODO: pruning of shared caches
      if ( this.isSharedCanvasCachePlaceholder ) {
        this.sharedSyncTree();
      }
      // pruning so that if no changes would affect a subtree it is skipped
      else if ( wasStateless || this.skipPruningFrame === this.display._frameId || this.anyStateChange ) {

        // mark fully-removed instances for disposal, and initialize child instances if we were stateless
        this.prepareChildInstances( wasStateless );

        var oldFirstDrawable = this.firstDrawable;
        var oldLastDrawable = this.lastDrawable;
        var oldFirstInnerDrawable = this.firstInnerDrawable;
        var oldLastInnerDrawable = this.lastInnerDrawable;

        var selfChanged = this.updateSelfDrawable();

        // Synchronizes our children and self, with the drawables and change intervals of both combined
        this.localSyncTree( selfChanged );

        if ( assertSlow ) {
          // before and after first/last drawables (inside any potential group drawable)
          this.auditChangeIntervals( oldFirstInnerDrawable, oldLastInnerDrawable, this.firstInnerDrawable, this.lastInnerDrawable );
        }

        // If we use a group drawable (backbone, etc.), we'll collapse our drawables and change intervals to reference
        // the group drawable (as applicable).
        this.groupSyncTree( wasStateless );

        if ( assertSlow ) {
          // before and after first/last drawables (outside of any potential group drawable)
          this.auditChangeIntervals( oldFirstDrawable, oldLastDrawable, this.firstDrawable, this.lastDrawable );
        }
      }
      else {
        // our sub-tree was not visited, since there were no relevant changes to it (that need instance synchronization
        // or drawable changes)
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'pruned' );
      }

      sceneryLog && sceneryLog.Instance && sceneryLog.pop();

      return true;
    },

    /*
     * Responsible for syncing children, connecting the drawable linked list as needed, and outputting change intervals
     * and first/last drawable information.
     */
    localSyncTree: function( selfChanged ) {
      var frameId = this.display._frameId;

      // local variables, since we can't overwrite our instance properties yet
      var firstDrawable = this.selfDrawable; // possibly null
      var currentDrawable = firstDrawable; // possibly null

      assert && assert( this.firstChangeInterval === null && this.lastChangeInterval === null,
        'sanity checks that cleanSyncTreeResults were called' );

      var firstChangeInterval = null;
      if ( selfChanged ) {
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'self' );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();
        firstChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
      }
      var currentChangeInterval = firstChangeInterval;
      var lastUnchangedDrawable = selfChanged ? null : this.selfDrawable; // possibly null

      for ( var i = 0; i < this.children.length; i++ ) {
        var childInstance = this.children[ i ];

        var isCompatible = childInstance.syncTree();
        if ( !isCompatible ) {
          childInstance = this.updateIncompatibleChildInstance( childInstance, i );
          childInstance.syncTree();
        }

        var includeChildDrawables = childInstance.shouldIncludeInParentDrawables();

        //OHTWO TODO: only strip out invisible Canvas drawables, while leaving SVG (since we can more efficiently hide
        // SVG trees, memory-wise)
        // here we strip out invisible drawable sections out of the drawable linked list
        if ( includeChildDrawables ) {
          // if there are any drawables for that child, link them up in our linked list
          if ( childInstance.firstDrawable ) {
            if ( currentDrawable ) {
              // there is already an end of the linked list, so just append to it
              Drawable.connectDrawables( currentDrawable, childInstance.firstDrawable, this.display );
            }
            else {
              // start out the linked list
              firstDrawable = childInstance.firstDrawable;
            }
            // update the last drawable of the linked list
            currentDrawable = childInstance.lastDrawable;
          }
        }

        /*---------------------------------------------------------------------------*
         * Change intervals
         *----------------------------------------------------------------------------*/

        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'changes for ' + childInstance.toString() +
                                                                              ' in ' + this.toString() );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();

        var wasIncluded = childInstance.stitchChangeIncluded;
        var isIncluded = includeChildDrawables;
        childInstance.stitchChangeIncluded = isIncluded;

        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'included: ' + wasIncluded + ' => ' + isIncluded );

        // check for forcing full change-interval on child
        if ( childInstance.stitchChangeFrame === frameId ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'stitchChangeFrame full change interval' );
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();

          // e.g. it was added, moved, or had visibility changes. requires full change interval
          childInstance.firstChangeInterval = childInstance.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );

          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
        }
        else {
          assert && assert( wasIncluded === isIncluded,
            'If we do not have stitchChangeFrame activated, our inclusion should not have changed' );
        }

        var firstChildChangeInterval = childInstance.firstChangeInterval;
        var isBeforeOpen = currentChangeInterval && currentChangeInterval.drawableAfter === null;
        var isAfterOpen = firstChildChangeInterval && firstChildChangeInterval.drawableBefore === null;
        var needsBridge = childInstance.stitchChangeBefore === frameId && !isBeforeOpen && !isAfterOpen;

        // We need to insert an additional change interval (bridge) when we notice a link in the drawable linked list
        // where there were nodes that needed stitch changes that aren't still children, or were moved. We create a
        // "bridge" change interval to span the gap where nodes were removed.
        if ( needsBridge ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'bridge' );
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();

          var bridge = ChangeInterval.newForDisplay( lastUnchangedDrawable, null, this.display );
          if ( currentChangeInterval ) {
            currentChangeInterval.nextChangeInterval = bridge;
          }
          currentChangeInterval = bridge;
          firstChangeInterval = firstChangeInterval || currentChangeInterval; // store if it is the first
          isBeforeOpen = true;

          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
        }

        // Exclude child instances that are now (and were before) not included. NOTE: We still need to include those in
        // bridge calculations, since a removed (before-included) instance could be between two still-invisible
        // instances.
        if ( wasIncluded || isIncluded ) {
          if ( isBeforeOpen ) {
            // we want to try to glue our last ChangeInterval up
            if ( firstChildChangeInterval ) {
              if ( firstChildChangeInterval.drawableBefore === null ) {
                // we want to glue from both sides

                // basically have our current change interval replace the child's first change interval
                currentChangeInterval.drawableAfter = firstChildChangeInterval.drawableAfter;
                currentChangeInterval.nextChangeInterval = firstChildChangeInterval.nextChangeInterval;

                currentChangeInterval = childInstance.lastChangeInterval === firstChildChangeInterval ?
                                        currentChangeInterval : // since we are replacing, don't give an origin reference
                                        childInstance.lastChangeInterval;
              }
              else {
                // only a desire to glue from before
                currentChangeInterval.drawableAfter = childInstance.firstDrawable; // either null or the correct drawable
                currentChangeInterval.nextChangeInterval = firstChildChangeInterval;
                currentChangeInterval = childInstance.lastChangeInterval;
              }
            }
            else {
              // no changes to the child. grabs the first drawable reference it can
              currentChangeInterval.drawableAfter = childInstance.firstDrawable; // either null or the correct drawable
            }
          }
          else if ( firstChildChangeInterval ) {
            firstChangeInterval = firstChangeInterval || firstChildChangeInterval; // store if it is the first
            if ( firstChildChangeInterval.drawableBefore === null ) {
              assert && assert( !currentChangeInterval || lastUnchangedDrawable,
                'If we have a current change interval, we should be guaranteed a non-null ' +
                'lastUnchangedDrawable' );
              firstChildChangeInterval.drawableBefore = lastUnchangedDrawable; // either null or the correct drawable
            }
            if ( currentChangeInterval ) {
              currentChangeInterval.nextChangeInterval = firstChildChangeInterval;
            }
            currentChangeInterval = childInstance.lastChangeInterval;
          }
          lastUnchangedDrawable = ( currentChangeInterval && currentChangeInterval.drawableAfter === null ) ?
                                  null :
                                  ( childInstance.lastDrawable ?
                                    childInstance.lastDrawable :
                                    lastUnchangedDrawable );
        }

        // if the last instance, check for post-bridge
        if ( i === this.children.length - 1 ) {
          if ( childInstance.stitchChangeAfter === frameId && !( currentChangeInterval && currentChangeInterval.drawableAfter === null ) ) {
            var endingBridge = ChangeInterval.newForDisplay( lastUnchangedDrawable, null, this.display );
            if ( currentChangeInterval ) {
              currentChangeInterval.nextChangeInterval = endingBridge;
            }
            currentChangeInterval = endingBridge;
            firstChangeInterval = firstChangeInterval || currentChangeInterval; // store if it is the first
          }
        }

        // clean up the metadata on our child (can't be done in the child call, since we use these values like a
        // composite return value)
        //OHTWO TODO: only do this on instances that were actually traversed
        childInstance.cleanSyncTreeResults();

        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
      }

      // it's really the easiest way to compare if two things (casted to booleans) are the same?
      assert && assert( !!firstChangeInterval === !!currentChangeInterval,
        'Presence of first and current change intervals should be equal' );

      // Check to see if we are emptied and marked as changed (but without change intervals). This should imply we have
      // no children (and thus no stitchChangeBefore / stitchChangeAfter to use), so we'll want to create a change
      // interval to cover our entire range.
      if ( !firstChangeInterval && this.stitchChangeOnChildren === this.display._frameId && this.children.length === 0 ) {
        firstChangeInterval = currentChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }

      // store our results
      // NOTE: these may get overwritten with the group change intervals (in that case, groupSyncTree will read from these)
      this.firstChangeInterval = firstChangeInterval;
      this.lastChangeInterval = currentChangeInterval;

      // NOTE: these may get overwritten with the group drawable (in that case, groupSyncTree will read from these)
      this.firstDrawable = this.firstInnerDrawable = firstDrawable;
      this.lastDrawable = this.lastInnerDrawable = currentDrawable; // either null, or the drawable itself

      // ensure that our firstDrawable and lastDrawable are correct
      if ( assertSlow ) {
        var firstDrawableCheck = null;
        for ( var j = 0; j < this.children.length; j++ ) {
          if ( this.children[ j ].shouldIncludeInParentDrawables() && this.children[ j ].firstDrawable ) {
            firstDrawableCheck = this.children[ j ].firstDrawable;
            break;
          }
        }
        if ( this.selfDrawable ) {
          firstDrawableCheck = this.selfDrawable;
        }

        var lastDrawableCheck = this.selfDrawable;
        for ( var k = this.children.length - 1; k >= 0; k-- ) {
          if ( this.children[ k ].shouldIncludeInParentDrawables() && this.children[ k ].lastDrawable ) {
            lastDrawableCheck = this.children[ k ].lastDrawable;
            break;
          }
        }

        assertSlow( firstDrawableCheck === this.firstDrawable );
        assertSlow( lastDrawableCheck === this.lastDrawable );
      }
    },

    /*
     * If necessary, create/replace/remove our selfDrawable.
     *
     * @returns whether the selfDrawable changed
     */
    updateSelfDrawable: function() {
      if ( this.node.isPainted() ) {
        var selfRenderer = this.selfRenderer; // our new self renderer bitmask

        // bitwise trick, since only one of Canvas/SVG/DOM/WebGL/etc. flags will be chosen, and bitmaskRendererArea is
        // the mask for those flags. In English, "Is the current selfDrawable compatible with our selfRenderer (if any),
        // or do we need to create a selfDrawable?"
        //OHTWO TODO: For Canvas, we won't care about anything else for the drawable, but for DOM we care about the
        // force-acceleration flag! That's stripped out here.
        if ( !this.selfDrawable || ( ( this.selfDrawable.renderer & selfRenderer & Renderer.bitmaskRendererArea ) === 0 ) ) {
          if ( this.selfDrawable ) {
            sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing old drawable ' + this.selfDrawable.toString() + ' with new renderer' );

            // scrap the previous selfDrawable, we need to create one with a different renderer.
            this.selfDrawable.markForDisposal( this.display );
          }

          this.selfDrawable = Renderer.createSelfDrawable( this, this.node, selfRenderer, this.fittability.ancestorsFittable );
          assert && assert( this.selfDrawable );

          return true;
        }
      }
      else {
        assert && assert( this.selfDrawable === null, 'Non-painted nodes should not have a selfDrawable' );
      }

      return false;
    },

    // returns the up-to-date instance
    updateIncompatibleChildInstance: function( childInstance, index ) {
      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        var affectedInstanceCount = childInstance.getDescendantCount() + 1; // +1 for itself

        if ( affectedInstanceCount > 100 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
        else if ( affectedInstanceCount > 40 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
        else if ( affectedInstanceCount > 0 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
      }

      // mark it for disposal
      this.display.markInstanceRootForDisposal( childInstance );

      // swap in a new instance
      var replacementInstance = Instance.createFromPool( this.display, this.trail.copy().addDescendant( childInstance.node, index ), false, false );
      this.replaceInstanceWithIndex( childInstance, replacementInstance, index );
      return replacementInstance;
    },

    groupSyncTree: function( wasStateless ) {
      var groupRenderer = this.groupRenderer;
      assert && assert( ( this.isBackbone ? 1 : 0 ) +
                        ( this.isInstanceCanvasCache ? 1 : 0 ) +
                        ( this.isSharedCanvasCacheSelf ? 1 : 0 ) === ( groupRenderer ? 1 : 0 ),
        'We should have precisely one of these flags set for us to have a groupRenderer' );

      // if we switched to/away from a group, our group type changed, or our group renderer changed
      var groupChanged = ( !!groupRenderer !== !!this.groupDrawable ) ||
                         ( !wasStateless && this.groupChanged ) ||
                         ( this.groupDrawable && this.groupDrawable.renderer !== groupRenderer );

      // if there is a change, prepare
      if ( groupChanged ) {
        if ( this.groupDrawable ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing group drawable ' + this.groupDrawable.toString() );

          this.groupDrawable.markForDisposal( this.display );
          this.groupDrawable = null;
        }

        // change everything, since we may need a full restitch
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }

      if ( groupRenderer ) {
        // ensure our linked list is fully disconnected from others
        this.firstDrawable && Drawable.disconnectBefore( this.firstDrawable, this.display );
        this.lastDrawable && Drawable.disconnectAfter( this.lastDrawable, this.display );

        if ( this.isBackbone ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.BackboneDrawable.createFromPool( this.display, this, this.getTransformRootInstance(), groupRenderer, this.isDisplayRoot );

            if ( this.isTransformed ) {
              this.display.markTransformRootDirty( this, true );
            }
          }

          if ( this.firstChangeInterval ) {
            this.groupDrawable.stitch( this.firstDrawable, this.lastDrawable, this.firstChangeInterval, this.lastChangeInterval );
          }
        }
        else if ( this.isInstanceCanvasCache ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.InlineCanvasCacheDrawable.createFromPool( groupRenderer, this );
          }
          if ( this.firstChangeInterval ) {
            this.groupDrawable.stitch( this.firstDrawable, this.lastDrawable, this.firstChangeInterval, this.lastChangeInterval );
          }
        }
        else if ( this.isSharedCanvasCacheSelf ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.CanvasBlock.createFromPool( groupRenderer, this );
          }
          //OHTWO TODO: restitch here??? implement it
        }
        // Update the fittable flag
        this.groupDrawable.setFittable( this.fittability.ancestorsFittable );

        this.firstDrawable = this.lastDrawable = this.groupDrawable;
      }

      // change interval handling
      if ( groupChanged ) {
        // if our group status changed, mark EVERYTHING as potentially changed
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }
      else if ( groupRenderer ) {
        // our group didn't have to change at all, so we prevent any change intervals
        this.firstChangeInterval = this.lastChangeInterval = null;
      }
    },

    sharedSyncTree: function() {
      //OHTWO TODO: we are probably missing syncTree for shared trees properly with pruning. investigate!!

      this.ensureSharedCacheInitialized();

      var sharedCacheRenderer = this.sharedCacheRenderer;

      if ( !this.sharedCacheDrawable || this.sharedCacheDrawable.renderer !== sharedCacheRenderer ) {
        //OHTWO TODO: mark everything as changed (big change interval)

        if ( this.sharedCacheDrawable ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing shared cache drawable ' + this.sharedCacheDrawable.toString() );

          this.sharedCacheDrawable.markForDisposal( this.display );
        }

        //OHTWO TODO: actually create the proper shared cache drawable depending on the specified renderer
        // (update it if necessary)
        this.sharedCacheDrawable = new scenery.SharedCanvasCacheDrawable( this.trail, sharedCacheRenderer, this, this.sharedCacheInstance );
        this.firstDrawable = this.sharedCacheDrawable;
        this.lastDrawable = this.sharedCacheDrawable;

        // basically everything changed now, and won't from now on
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }
    },

    prepareChildInstances: function( wasStateless ) {
      // mark all removed instances to be disposed (along with their subtrees)
      while ( this.instanceRemovalCheckList.length ) {
        var instanceToMark = this.instanceRemovalCheckList.pop();
        if ( instanceToMark.addRemoveCounter === -1 ) {
          instanceToMark.addRemoveCounter = 0; // reset it, so we don't mark it for disposal more than once
          this.display.markInstanceRootForDisposal( instanceToMark );
        }
      }

      if ( wasStateless ) {
        // we need to create all of the child instances
        for ( var k = 0; k < this.node.children.length; k++ ) {
          // create a child instance
          var child = this.node.children[ k ];
          this.appendInstance( Instance.createFromPool( this.display, this.trail.copy().addDescendant( child, k ), false, false ) );
        }
      }
    },

    ensureSharedCacheInitialized: function() {
      // we only need to initialize this shared cache reference once
      if ( !this.sharedCacheInstance ) {
        var instanceKey = this.node.getId();
        // TODO: have this abstracted away in the Display?
        this.sharedCacheInstance = this.display._sharedCanvasInstances[ instanceKey ];

        // TODO: increment reference counting?
        if ( !this.sharedCacheInstance ) {
          this.sharedCacheInstance = Instance.createFromPool( this.display, new scenery.Trail( this.node ), false, true );
          this.sharedCacheInstance.syncTree();
          this.display._sharedCanvasInstances[ instanceKey ] = this.sharedCacheInstance;
          // TODO: reference counting?

          // TODO: this.sharedCacheInstance.isTransformed?

          //OHTWO TODO: is this necessary?
          this.display.markTransformRootDirty( this.sharedCacheInstance, true );
        }

        this.sharedCacheInstance.externalReferenceCount++;

        //OHTWO TODO: is this necessary?
        if ( this.isTransformed ) {
          this.display.markTransformRootDirty( this, true );
        }
      }
    },

    // @private, whether out drawables (from firstDrawable to lastDrawable) should be included in our parent's drawables
    shouldIncludeInParentDrawables: function() {
      return this.node.isVisible() || !this.node.isExcludeInvisible();
    },

    // @private, finds the closest drawable (not including the child instance at childIndex) using lastDrawable, or null
    findPreviousDrawable: function( childIndex ) {
      for ( var i = childIndex - 1; i >= 0; i-- ) {
        var option = this.children[ i ].lastDrawable;
        if ( option !== null ) {
          return option;
        }
      }

      return null;
    },

    // @private, finds the closest drawable (not including the child instance at childIndex) using nextDrawable, or null
    findNextDrawable: function( childIndex ) {
      var len = this.children.length;
      for ( var i = childIndex + 1; i < len; i++ ) {
        var option = this.children[ i ].firstDrawable;
        if ( option !== null ) {
          return option;
        }
      }

      return null;
    },

    /*---------------------------------------------------------------------------*
     * Children handling
     *----------------------------------------------------------------------------*/

    appendInstance: function( instance ) {
      this.insertInstance( instance, this.children.length );
    },

    // NOTE: different parameter order compared to Node
    insertInstance: function( instance, index ) {
      assert && assert( instance instanceof Instance );
      assert && assert( index >= 0 && index <= this.children.length,
        'Instance insertion bounds check for index ' + index + ' with previous children length ' +
        this.children.length );

      sceneryLog && sceneryLog.InstanceTree && sceneryLog.InstanceTree(
        'inserting ' + instance.toString() + ' into ' + this.toString() );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.push();

      // mark it as changed during this frame, so that we can properly set the change interval
      instance.stitchChangeFrame = this.display._frameId;
      this.stitchChangeOnChildren = this.display._frameId;

      this.children.splice( index, 0, instance );
      instance.parent = this;
      instance.oldParent = this;

      // maintain our stitch-change interval
      if ( index <= this.beforeStableIndex ) {
        this.beforeStableIndex = index - 1;
      }
      if ( index > this.afterStableIndex ) {
        this.afterStableIndex = index + 1;
      }
      else {
        this.afterStableIndex++;
      }

      // maintain fittable flags
      this.fittability.onInsert( instance.fittability );

      this.relativeTransform.insertInstance( instance, index );

      this.markChildVisibilityDirty();

      sceneryLog && sceneryLog.InstanceTree && sceneryLog.pop();
    },

    removeInstance: function( instance ) {
      return this.removeInstanceWithIndex( instance, _.indexOf( this.children, instance ) );
    },

    removeInstanceWithIndex: function( instance, index ) {
      assert && assert( instance instanceof Instance );
      assert && assert( index >= 0 && index < this.children.length,
        'Instance removal bounds check for index ' + index + ' with previous children length ' +
        this.children.length );

      sceneryLog && sceneryLog.InstanceTree && sceneryLog.InstanceTree(
        'removing ' + instance.toString() + ' from ' + this.toString() );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.push();

      var frameId = this.display._frameId;

      // mark it as changed during this frame, so that we can properly set the change interval
      instance.stitchChangeFrame = frameId;
      this.stitchChangeOnChildren = frameId;

      // mark neighbors so that we can add a change interval for our removal area
      if ( index - 1 >= 0 ) {
        this.children[ index - 1 ].stitchChangeAfter = frameId;
      }
      if ( index + 1 < this.children.length ) {
        this.children[ index + 1 ].stitchChangeBefore = frameId;
      }

      this.children.splice( index, 1 ); // TODO: replace with a 'remove' function call
      instance.parent = null;
      instance.oldParent = this;

      // maintain our stitch-change interval
      if ( index <= this.beforeStableIndex ) {
        this.beforeStableIndex = index - 1;
      }
      if ( index >= this.afterStableIndex ) {
        this.afterStableIndex = index;
      }
      else {
        this.afterStableIndex--;
      }

      // maintain fittable flags
      this.fittability.onRemove( instance.fittability );

      this.relativeTransform.removeInstanceWithIndex( instance, index );

      sceneryLog && sceneryLog.InstanceTree && sceneryLog.pop();
    },

    replaceInstanceWithIndex: function( childInstance, replacementInstance, index ) {
      // TODO: optimization? hopefully it won't happen often, so we just do this for now
      this.removeInstanceWithIndex( childInstance, index );
      this.insertInstance( replacementInstance, index );
    },

    // if we have a child instance that corresponds to this node, return it (otherwise null)
    findChildInstanceOnNode: function( node ) {
      var instances = node.getInstances();
      for ( var i = 0; i < instances.length; i++ ) {
        if ( instances[ i ].oldParent === this ) {
          return instances[ i ];
        }
      }
      return null;
    },

    // event callback for Node's 'childInserted' event, used to track children
    onChildInserted: function( childNode, index ) {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance(
        'inserting child node ' + childNode.constructor.name + '#' + childNode.id + ' into ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );

      var instance = this.findChildInstanceOnNode( childNode );

      if ( instance ) {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'instance already exists' );
        // it must have been added back. increment its counter
        instance.addRemoveCounter += 1;
        assert && assert( instance.addRemoveCounter === 0 );
      }
      else {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'creating stub instance' );
        sceneryLog && sceneryLog.Instance && sceneryLog.push();
        instance = Instance.createFromPool( this.display, this.trail.copy().addDescendant( childNode, index ), false, false );
        sceneryLog && sceneryLog.Instance && sceneryLog.pop();
      }

      this.insertInstance( instance, index );

      // make sure we are visited for syncTree()
      this.markSkipPruning();

      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },

    // event callback for Node's 'childRemoved' event, used to track children
    onChildRemoved: function( childNode, index ) {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance(
        'removing child node ' + childNode.constructor.name + '#' + childNode.id + ' from ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );
      assert && assert( this.children[ index ].node === childNode, 'Ensure that our instance matches up' );

      var instance = this.findChildInstanceOnNode( childNode );
      assert && assert( instance !== null, 'We should always have a reference to a removed instance' );

      instance.addRemoveCounter -= 1;
      assert && assert( instance.addRemoveCounter === -1 );

      // track the removed instance here. if it doesn't get added back, this will be the only reference we have (we'll
      // need to dispose it)
      this.instanceRemovalCheckList.push( instance );

      this.removeInstanceWithIndex( instance, index );

      // make sure we are visited for syncTree()
      this.markSkipPruning();

      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },

    // event callback for Node's 'visibility' event, used to notify about stitch changes
    onVisibilityChange: function() {
      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );

      // for now, just mark which frame we were changed for our change interval
      this.stitchChangeFrame = this.display._frameId;

      // make sure we aren't pruned in the next syncTree()
      this.parent && this.parent.markSkipPruning();

      // mark visibility changes
      this.visibilityDirty = true;
      this.parent && this.parent.markChildVisibilityDirty();
    },

    // event callback for Node's 'opacity' change event
    onOpacityChange: function() {
      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );

      this.markRenderStateDirty();
    },

    markChildVisibilityDirty: function() {
      if ( !this.childVisibilityDirty ) {
        this.childVisibilityDirty = true;
        this.parent && this.parent.markChildVisibilityDirty();
      }
    },

    /**
     * Updates the currently fittability for all of the drawables attached to this instance.
     * @public
     *
     * @param {boolean} fittable
     */
    updateDrawableFittability: function( fittable ) {
      this.selfDrawable && this.selfDrawable.setFittable( fittable );
      this.groupDrawable && this.groupDrawable.setFittable( fittable );
      // this.sharedCacheDrawable && this.sharedCacheDrawable.setFittable( fittable );
    },

    /**
     * Updates the visible/relativeVisible flags on the Instance and its entire subtree.
     *
     * @param {boolean} parentGloballyVisible - Whether our parent (if any) is globally visible
     * @param {boolean} parentRelativelyVisible - Whether our parent (if any) is relatively visible
     * @param {boolean} updateFullSubtree - If true, we will visit the entire subtree to ensure visibility is correct.
     */
    updateVisibility: function( parentGloballyVisible, parentRelativelyVisible, updateFullSubtree ) {
      // If our visibility flag for ourself is dirty, we need to update our entire subtree
      if ( this.visibilityDirty ) {
        updateFullSubtree = true;
      }

      // calculate our visibilities
      var nodeVisible = this.node.isVisible();
      var wasVisible = this.visible;
      var wasRelativeVisible = this.relativeVisible;
      var wasSelfVisible = this.selfVisible;
      this.visible = parentGloballyVisible && nodeVisible;
      this.relativeVisible = parentRelativelyVisible && nodeVisible;
      this.selfVisible = this.isVisibilityApplied ? true : this.relativeVisible;

      var len = this.children.length;
      for ( var i = 0; i < len; i++ ) {
        var child = this.children[ i ];

        if ( updateFullSubtree || child.visibilityDirty || child.childVisibilityDirty ) {
          // if we are a visibility root (isVisibilityApplied===true), disregard ancestor visibility
          child.updateVisibility( this.visible, this.isVisibilityApplied ? true : this.relativeVisible, updateFullSubtree );
        }
      }

      this.visibilityDirty = false;
      this.childVisibilityDirty = false;

      // trigger changes after we do the full visibility update
      if ( this.visible !== wasVisible ) {
        this.trigger0( 'visibility' );
      }
      if ( this.relativeVisible !== wasRelativeVisible ) {
        this.trigger0( 'relativeVisibility' );
      }
      if ( this.selfVisible !== wasSelfVisible ) {
        this.trigger0( 'selfVisibility' );
      }
    },

    getDescendantCount: function() {
      var count = this.children.length;
      for ( var i = 0; i < this.children.length; i++ ) {
        count += this.children[ i ].getDescendantCount();
      }
      return count;
    },

    /*---------------------------------------------------------------------------*
     * Miscellaneous
     *----------------------------------------------------------------------------*/

    // add a reference for an SVG group (fastest way to track them)
    addSVGGroup: function( group ) {
      this.svgGroups.push( group );
    },

    // remove a reference for an SVG group (fastest way to track them)
    removeSVGGroup: function( group ) {
      var index = _.indexOf( this.svgGroups, group );
      assert && assert( index >= 0, 'Tried to remove an SVGGroup from an Instance when it did not exist' );

      this.svgGroups.splice( index, 1 ); // TODO: remove function
    },

    // returns null when a lookup fails (which is legitimate)
    lookupSVGGroup: function( block ) {
      var len = this.svgGroups.length;
      for ( var i = 0; i < len; i++ ) {
        var group = this.svgGroups[ i ];
        if ( group.block === block ) {
          return group;
        }
      }
      return null;
    },

    // what instance have filters (opacity/visibility/clip) been applied up to?
    getFilterRootInstance: function() {
      if ( this.isBackbone || this.isInstanceCanvasCache || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getFilterRootInstance();
      }
    },

    // what instance transforms have been applied up to?
    getTransformRootInstance: function() {
      if ( this.isTransformed || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getTransformRootInstance();
      }
    },

    getVisibilityRootInstance: function() {
      if ( this.isVisibilityApplied || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getVisibilityRootInstance();
      }
    },

    attachNodeListeners: function() {
      // attach listeners to our node
      this.relativeTransform.attachNodeListeners();

      if ( !this.isSharedCanvasCachePlaceholder ) {
        this.node.onStatic( 'childInserted', this.childInsertedListener );
        this.node.onStatic( 'childRemoved', this.childRemovedListener );
        this.node.onStatic( 'visibility', this.visibilityListener );

        this.node.onStatic( 'opacity', this.markRenderStateDirtyListener );
        this.node.onStatic( 'hint', this.markRenderStateDirtyListener );
        this.node.onStatic( 'clip', this.markRenderStateDirtyListener );
        this.node.onStatic( 'rendererBitmask', this.markRenderStateDirtyListener );
        this.node.onStatic( 'rendererSummary', this.markRenderStateDirtyListener );
      }
    },

    detachNodeListeners: function() {
      this.relativeTransform.detachNodeListeners();

      if ( !this.isSharedCanvasCachePlaceholder ) {
        this.node.offStatic( 'childInserted', this.childInsertedListener );
        this.node.offStatic( 'childRemoved', this.childRemovedListener );
        this.node.offStatic( 'visibility', this.visibilityListener );

        this.node.offStatic( 'opacity', this.markRenderStateDirtyListener );
        this.node.offStatic( 'hint', this.markRenderStateDirtyListener );
        this.node.offStatic( 'clip', this.markRenderStateDirtyListener );
        this.node.offStatic( 'rendererBitmask', this.markRenderStateDirtyListener );
        this.node.offStatic( 'rendererSummary', this.markRenderStateDirtyListener );
      }
    },

    // ensure that the render state is updated in the next syncTree()
    markRenderStateDirty: function() {
      this.renderStateDirtyFrame = this.display._frameId;

      // ensure we aren't pruned (not set on this instance, since we may not need to visit our children)
      this.parent && this.parent.markSkipPruning();
    },

    // ensure that this instance and its children will be visited in the next syncTree()
    markSkipPruning: function() {
      this.skipPruningFrame = this.display._frameId;

      // walk it up to the root
      this.parent && this.parent.markSkipPruning();
    },

    // clean up listeners and garbage, so that we can be recycled (or pooled)
    dispose: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      assert && assert( this.active, 'Seems like we tried to dispose this Instance twice, it is not active' );

      this.active = false;

      // order is somewhat important
      this.groupDrawable && this.groupDrawable.disposeImmediately( this.display );
      this.sharedCacheDrawable && this.sharedCacheDrawable.disposeImmediately( this.display );
      this.selfDrawable && this.selfDrawable.disposeImmediately( this.display );

      // Dispose the rest of our subtree
      var numChildren = this.children.length;
      for ( var i = 0; i < numChildren; i++ ) {
        this.children[ i ].dispose();
      }
      // Check for child instances that were removed (we are still responsible for disposing them, since we didn't get
      // synctree to happen for them).
      while ( this.instanceRemovalCheckList.length ) {
        var child = this.instanceRemovalCheckList.pop();

        // they could have already been disposed, so we need a guard here
        if ( child.active ) {
          child.dispose();
        }
      }

      // we don't originally add in the listener if we are stateless
      if ( !this.stateless ) {
        this.detachNodeListeners();
      }

      this.node.removeInstance( this );

      // release our reference to a shared cache if applicable, and dispose if there are no other references
      if ( this.sharedCacheInstance ) {
        this.sharedCacheInstance.externalReferenceCount--;
        if ( this.sharedCacheInstance.externalReferenceCount === 0 ) {
          delete this.display._sharedCanvasInstances[ this.node.getId() ];
          this.sharedCacheInstance.dispose();
        }
      }

      // clean our variables out to release memory
      this.cleanInstance( null, null );

      this.removeAllEventListeners();

      this.freeToPool();

      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },

    audit: function( frameId, allowValidationNotNeededChecks ) {
      if ( assertSlow ) {
        if ( frameId === undefined ) {
          frameId = this.display._frameId;
        }

        assertSlow( !this.stateless,
          'State is required for all display instances' );

        assertSlow( ( this.firstDrawable === null ) === ( this.lastDrawable === null ),
          'First/last drawables need to both be null or non-null' );

        assertSlow( ( !this.isBackbone && !this.isSharedCanvasCachePlaceholder ) || this.groupDrawable,
          'If we are a backbone or shared cache, we need to have a groupDrawable reference' );

        assertSlow( !this.isSharedCanvasCachePlaceholder || !this.node.isPainted() || this.selfDrawable,
          'We need to have a selfDrawable if we are painted and not a shared cache' );

        assertSlow( ( !this.isTransformed && !this.isCanvasCache ) || this.groupDrawable,
          'We need to have a groupDrawable if we are a backbone or any type of canvas cache' );

        assertSlow( !this.isSharedCanvasCachePlaceholder || this.sharedCacheDrawable,
          'We need to have a sharedCacheDrawable if we are a shared cache' );

        assertSlow( this.addRemoveCounter === 0,
          'Our addRemoveCounter should always be 0 at the end of syncTree' );

        // validate the subtree
        for ( var i = 0; i < this.children.length; i++ ) {
          var childInstance = this.children[ i ];

          childInstance.audit( frameId, allowValidationNotNeededChecks );
        }

        this.relativeTransform.audit( frameId, allowValidationNotNeededChecks );

        this.fittability.audit();
      }
    },

    // @public (scenery-internal) - Applies checks to make sure our visibility tracking is working as expected.
    auditVisibility: function( parentVisible ) {
      if ( assertSlow ) {
        var visible = parentVisible && this.node.isVisible();
        var trailVisible = this.trail.isVisible();
        assertSlow( visible === trailVisible, 'Trail visibility failure' );
        assertSlow( visible === this.visible, 'Visible flag failure' );

        // validate the subtree
        for ( var i = 0; i < this.children.length; i++ ) {
          var childInstance = this.children[ i ];

          childInstance.auditVisibility( visible );
        }
      }
    },

    auditChangeIntervals: function( oldFirstDrawable, oldLastDrawable, newFirstDrawable, newLastDrawable ) {
      if ( oldFirstDrawable ) {
        var oldOne = oldFirstDrawable;

        // should hit, or will have NPE
        while ( oldOne !== oldLastDrawable ) {
          oldOne = oldOne.oldNextDrawable;
        }
      }

      if ( newFirstDrawable ) {
        var newOne = newFirstDrawable;

        // should hit, or will have NPE
        while ( newOne !== newLastDrawable ) {
          newOne = newOne.nextDrawable;
        }
      }

      function checkBetween( a, b ) {
        // have the body of the function stripped (it's not inside the if statement due to JSHint)
        if ( assertSlow ) {
          assertSlow( a !== null );
          assertSlow( b !== null );

          while ( a !== b ) {
            assertSlow( a.nextDrawable === a.oldNextDrawable, 'Change interval mismatch' );
            a = a.nextDrawable;
          }
        }
      }

      if ( assertSlow ) {
        var firstChangeInterval = this.firstChangeInterval;
        var lastChangeInterval = this.lastChangeInterval;

        if ( !firstChangeInterval || firstChangeInterval.drawableBefore !== null ) {
          assertSlow( oldFirstDrawable === newFirstDrawable,
            'If we have no changes, or our first change interval is not open, our firsts should be the same' );
        }
        if ( !lastChangeInterval || lastChangeInterval.drawableAfter !== null ) {
          assertSlow( oldLastDrawable === newLastDrawable,
            'If we have no changes, or our last change interval is not open, our lasts should be the same' );
        }

        if ( !firstChangeInterval ) {
          assertSlow( !lastChangeInterval, 'We should not be missing only one change interval' );

          // with no changes, everything should be identical
          oldFirstDrawable && checkBetween( oldFirstDrawable, oldLastDrawable );
        }
        else {
          assertSlow( lastChangeInterval, 'We should not be missing only one change interval' );

          // endpoints
          if ( firstChangeInterval.drawableBefore !== null ) {
            // check to the start if applicable
            checkBetween( oldFirstDrawable, firstChangeInterval.drawableBefore );
          }
          if ( lastChangeInterval.drawableAfter !== null ) {
            // check to the end if applicable
            checkBetween( lastChangeInterval.drawableAfter, oldLastDrawable );
          }

          // between change intervals (should always be guaranteed to be fixed)
          var interval = firstChangeInterval;
          while ( interval && interval.nextChangeInterval ) {
            var nextInterval = interval.nextChangeInterval;

            assertSlow( interval.drawableAfter !== null );
            assertSlow( nextInterval.drawableBefore !== null );

            checkBetween( interval.drawableAfter, nextInterval.drawableBefore );

            interval = nextInterval;
          }
        }
      }
    },

    toString: function() {
      return this.id + '#' + ( this.node ? ( this.node.constructor.name ? this.node.constructor.name : '?' ) + '#' + this.node.id : '-' );
    }
  } );

  // object pooling
  Poolable.mixin( Instance, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new from pool' );
          return pool.pop().initialize( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
        }
        else {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new from constructor' );
          return new Instance( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
        }
      };
    }
  } );

  return Instance;
} );

// Copyright 2013-2014, University of Colorado Boulder


/**
 * TODO docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/InlineCanvasCacheDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  function InlineCanvasCacheDrawable( renderer, instance ) {
    Drawable.call( this, renderer );


    //OHTWO TODO: pooling!

    // TODO: NOTE: may have to separate into separate drawables for separate group renderers

    this.instance = instance; // will need this so we can get bounds for layer fitting
  }

  scenery.register( 'InlineCanvasCacheDrawable', InlineCanvasCacheDrawable );

  inherit( Drawable, InlineCanvasCacheDrawable, {
    // TODO: support Canvas/SVG/DOM

    stitch: function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval ) {
      //OHTWO TODO: called when we have a change in our drawables
    }
  } );

  return InlineCanvasCacheDrawable;
} );

// Copyright 2013-2014, University of Colorado Boulder


/**
 * TODO docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SharedCanvasCacheDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  function SharedCanvasCacheDrawable( trail, renderer, instance, sharedInstance ) {
    Drawable.call( this, renderer );

    // TODO: NOTE: may have to separate into separate drawables for separate group renderers

    this.instance = instance; // will need this so we can get bounds for layer fitting
    this.sharedInstance = sharedInstance;
  }

  scenery.register( 'SharedCanvasCacheDrawable', SharedCanvasCacheDrawable );

  inherit( Drawable, SharedCanvasCacheDrawable, {
    // TODO: support Canvas/SVG/DOM
  } );

  return SharedCanvasCacheDrawable;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Represents an SVG visual element, and is responsible for tracking changes to the visual element, and then applying
 * any changes at a later time.
 *
 * Abstract methods to implement for concrete implementations:
 *   updateSVGSelf() - Update the SVG element's state to what the Node's self should display
 *   updateDefsSelf( block ) - Update defs on the given block (or if block === null, remove)
 *   initializeState( renderer, instance )
 *   disposeState()
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/nodes/Paintable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );

  function SVGSelfDrawable( renderer, instance ) {
    this.initializeSVGSelfDrawable( renderer, instance );

    throw new Error( 'Should use initialization and pooling' );
  }

  scenery.register( 'SVGSelfDrawable', SVGSelfDrawable );

  inherit( SelfDrawable, SVGSelfDrawable, {
    initializeSVGSelfDrawable: function( renderer, instance, usesPaint, keepElements ) {
      // super initialization
      this.initializeSelfDrawable( renderer, instance );

      this.usesPaint = usesPaint;
      this.keepElements = keepElements;

      this.svgElement = null; // should be filled in by subtype
      this.svgBlock = null; // will be updated by updateSVGBlock()

      this.initializeState( renderer, instance ); // assumes we have a state mixin

      if ( this.usesPaint ) {
        if ( !this.paintState ) {
          this.paintState = new Paintable.PaintSVGState();
        }
        else {
          this.paintState.initialize();
        }
      }

      return this; // allow chaining
    },

    // @public: called from elsewhere to update the SVG element
    update: function() {
      if ( this.dirty ) {
        this.dirty = false;
        this.updateSVG();
      }
    },

    // @protected: called to update the visual appearance of our svgElement
    updateSVG: function() {
      if ( this.paintDirty ) {
        this.updateSVGSelf( this.node, this.svgElement );
      }

      // sync the differences between the previously-recorded list of cached paints and the new list
      if ( this.usesPaint && this.dirtyCachedPaints ) {
        var newCachedPaints = this.node._cachedPaints.slice(); // defensive copy for now
        var i;
        var j;

        // scan for new cached paints (not in the old list)
        for ( i = 0; i < newCachedPaints.length; i++ ) {
          var newPaint = newCachedPaints[ i ];
          var isNew = true;
          for ( j = 0; j < this.lastCachedPaints.length; j++ ) {
            if ( newPaint === this.lastCachedPaints[ j ] ) {
              isNew = false;
              break;
            }
          }
          if ( isNew ) {
            this.svgBlock.incrementPaint( newPaint );
          }
        }
        // scan for removed cached paints (not in the new list)
        for ( i = 0; i < this.lastCachedPaints.length; i++ ) {
          var oldPaint = this.lastCachedPaints[ i ];
          var isRemoved = true;
          for ( j = 0; j < newCachedPaints.length; j++ ) {
            if ( oldPaint === newCachedPaints[ j ] ) {
              isRemoved = false;
              break;
            }
          }
          if ( isRemoved ) {
            this.svgBlock.decrementPaint( oldPaint );
          }
        }

        this.lastCachedPaints = newCachedPaints;
      }

      // clear all of the dirty flags
      this.setToClean();
    },

    // to be used by our passed in options.updateSVG
    updateFillStrokeStyle: function( element ) {
      if ( !this.usesPaint ) {
        return;
      }

      if ( this.dirtyFill ) {
        this.paintState.updateFill( this.svgBlock, this.node.getFillValue() );
      }
      if ( this.dirtyStroke ) {
        this.paintState.updateStroke( this.svgBlock, this.node.getStrokeValue() );
      }
      var strokeDetailDirty = this.dirtyLineWidth || this.dirtyLineOptions;
      if ( strokeDetailDirty ) {
        this.paintState.updateStrokeDetailStyle( this.node );
      }
      if ( this.dirtyFill || this.dirtyStroke || strokeDetailDirty ) {
        element.setAttribute( 'style', this.paintState.baseStyle + this.paintState.strokeDetailStyle );
      }

      this.cleanPaintableState();
    },

    updateSVGBlock: function( svgBlock ) {
      // remove cached paint references from the old svgBlock
      var oldSvgBlock = this.svgBlock;
      if ( this.usesPaint && oldSvgBlock ) {
        for ( var i = 0; i < this.lastCachedPaints.length; i++ ) {
          oldSvgBlock.decrementPaint( this.lastCachedPaints[ i ] );
        }
      }

      this.svgBlock = svgBlock;

      // add cached paint references from the new svgBlock
      if ( this.usesPaint ) {
        for ( var j = 0; j < this.lastCachedPaints.length; j++ ) {
          svgBlock.incrementPaint( this.lastCachedPaints[ j ] );
        }
      }

      this.updateDefsSelf && this.updateDefsSelf( svgBlock );

      this.usesPaint && this.paintState.updateSVGBlock( svgBlock );

      // since fill/stroke IDs may be block-specific, we need to mark them dirty so they will be updated
      this.usesPaint && this.markDirtyFill();
      this.usesPaint && this.markDirtyStroke();
    },

    dispose: function() {
      this.disposeState(); // assumes subtype existence

      if ( !this.keepElements ) {
        // clear the references
        this.svgElement = null;
      }

      // release any defs, and dispose composed state objects
      this.updateDefsSelf && this.updateDefsSelf( null );
      this.usesPaint && this.paintState.dispose();

      this.defs = null;

      this.svgBlock = null;

      SelfDrawable.prototype.dispose.call( this );
    },

    setToClean: function() {
      this.setToCleanState();
    }
  } );

  return SVGSelfDrawable;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Points to a specific node (with a trail), and whether it is conceptually before or after the node.
 *
 * There are two orderings:
 * - rendering order: the order that node selves would be rendered, matching the Trail implicit order
 * - nesting order:   the order in depth first with entering a node being "before" and exiting a node being "after"
 *
 * TODO: more seamless handling of the orders. or just exclusively use the nesting order
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/TrailPointer',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  /*
   * isBefore: whether this points to before the node (and its children) have been rendered, or after
   */
  //@deprecated
  function TrailPointer( trail, isBefore ) {
    assert && assert( trail instanceof scenery.Trail, 'trail is not a trail' );
    this.trail = trail;

    this.setBefore( isBefore );

    phetAllocation && phetAllocation( 'TrailPointer' );
  }

  scenery.register( 'TrailPointer', TrailPointer );

  inherit( Object, TrailPointer, {
    copy: function() {
      return new TrailPointer( this.trail.copy(), this.isBefore );
    },

    setBefore: function( isBefore ) {
      this.isBefore = isBefore;
      this.isAfter = !isBefore;
    },

    // return the equivalent pointer that swaps before and after (may return null if it doesn't exist)
    getRenderSwappedPointer: function() {
      var newTrail = this.isBefore ? this.trail.previous() : this.trail.next();

      if ( newTrail === null ) {
        return null;
      }
      else {
        return new TrailPointer( newTrail, !this.isBefore );
      }
    },

    getRenderBeforePointer: function() {
      return this.isBefore ? this : this.getRenderSwappedPointer();
    },

    getRenderAfterPointer: function() {
      return this.isAfter ? this : this.getRenderSwappedPointer();
    },

    /*
     * In the render order, will return 0 if the pointers are equivalent, -1 if this pointer is before the
     * other pointer, and 1 if this pointer is after the other pointer.
     */
    compareRender: function( other ) {
      assert && assert( other !== null );

      var a = this.getRenderBeforePointer();
      var b = other.getRenderBeforePointer();

      if ( a !== null && b !== null ) {
        // normal (non-degenerate) case
        return a.trail.compare( b.trail );
      }
      else {
        // null "before" point is equivalent to the "after" pointer on the last rendered node.
        if ( a === b ) {
          return 0; // uniqueness guarantees they were the same
        }
        else {
          return a === null ? 1 : -1;
        }
      }
    },

    /*
     * Like compareRender, but for the nested (depth-first) order
     *
     * TODO: optimization?
     */
    compareNested: function( other ) {
      assert && assert( other );

      var comparison = this.trail.compare( other.trail );

      if ( comparison === 0 ) {
        // if trails are equal, just compare before/after
        if ( this.isBefore === other.isBefore ) {
          return 0;
        }
        else {
          return this.isBefore ? -1 : 1;
        }
      }
      else {
        // if one is an extension of the other, the shorter isBefore flag determines the order completely
        if ( this.trail.isExtensionOf( other.trail ) ) {
          return other.isBefore ? 1 : -1;
        }
        else if ( other.trail.isExtensionOf( this.trail ) ) {
          return this.isBefore ? -1 : 1;
        }
        else {
          // neither is a subtrail of the other, so a straight trail comparison should give the answer
          return comparison;
        }
      }
    },

    equalsRender: function( other ) {
      return this.compareRender( other ) === 0;
    },

    equalsNested: function( other ) {
      return this.compareNested( other ) === 0;
    },

    // will return false if this pointer has gone off of the beginning or end of the tree (will be marked with isAfter or isBefore though)
    hasTrail: function() {
      return !!this.trail;
    },

    // TODO: refactor with "Side"-like handling
    // moves this pointer forwards one step in the nested order
    nestedForwards: function() {
      if ( this.isBefore ) {
        if ( this.trail.lastNode()._children.length > 0 ) {
          // stay as before, just walk to the first child
          this.trail.addDescendant( this.trail.lastNode()._children[ 0 ], 0 );
        }
        else {
          // stay on the same node, but switch to after
          this.setBefore( false );
        }
      }
      else {
        if ( this.trail.indices.length === 0 ) {
          // nothing else to jump to below, so indicate the lack of existence
          this.trail = null;
          // stays isAfter
          return null;
        }
        else {
          var index = this.trail.indices[ this.trail.indices.length - 1 ];
          this.trail.removeDescendant();

          if ( this.trail.lastNode()._children.length > index + 1 ) {
            // more siblings, switch to the beginning of the next one
            this.trail.addDescendant( this.trail.lastNode()._children[ index + 1 ], index + 1 );
            this.setBefore( true );
          }
          else {
            // no more siblings. exit on parent. nothing else needed since we're already isAfter
          }
        }
      }
      return this;
    },

    // moves this pointer backwards one step in the nested order
    nestedBackwards: function() {
      if ( this.isBefore ) {
        if ( this.trail.indices.length === 0 ) {
          // jumping off the front
          this.trail = null;
          // stays isBefore
          return null;
        }
        else {
          var index = this.trail.indices[ this.trail.indices.length - 1 ];
          this.trail.removeDescendant();

          if ( index - 1 >= 0 ) {
            // more siblings, switch to the beginning of the previous one and switch to isAfter
            this.trail.addDescendant( this.trail.lastNode()._children[ index - 1 ], index - 1 );
            this.setBefore( false );
          }
          else {
            // no more siblings. enter on parent. nothing else needed since we're already isBefore
          }
        }
      }
      else {
        if ( this.trail.lastNode()._children.length > 0 ) {
          // stay isAfter, but walk to the last child
          var children = this.trail.lastNode()._children;
          this.trail.addDescendant( children[ children.length - 1 ], children.length - 1 );
        }
        else {
          // switch to isBefore, since this is a leaf node
          this.setBefore( true );
        }
      }
      return this;
    },

    // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable
    eachNodeBetween: function( other, callback ) {
      this.eachTrailBetween( other, function( trail ) {
        return callback( trail.lastNode() );
      } );
    },

    // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable
    eachTrailBetween: function( other, callback ) {
      // this should trigger on all pointers that have the 'before' flag, except a pointer equal to 'other'.

      // since we exclude endpoints in the depthFirstUntil call, we need to fire this off first
      if ( this.isBefore ) {
        callback( this.trail );
      }

      this.depthFirstUntil( other, function( pointer ) {
        if ( pointer.isBefore ) {
          return callback( pointer.trail );
        }
      }, true ); // exclude the endpoints so we can ignore the ending 'before' case
    },

    /*
     * Recursively (depth-first) iterates over all pointers between this pointer and 'other', calling
     * callback( pointer ) for each pointer. If excludeEndpoints is truthy, the callback will not be
     * called if pointer is equivalent to this pointer or 'other'.
     *
     * If the callback returns a truthy value, the subtree for the current pointer will be skipped
     * (applies only to before-pointers)
     */
    depthFirstUntil: function( other, callback, excludeEndpoints ) {
      // make sure this pointer is before the other, but allow start === end if we are not excluding endpoints
      assert && assert( this.compareNested( other ) <= ( excludeEndpoints ? -1 : 0 ), 'TrailPointer.depthFirstUntil pointers out of order, possibly in both meanings of the phrase!' );
      assert && assert( this.trail.rootNode() === other.trail.rootNode(), 'TrailPointer.depthFirstUntil takes pointers with the same root' );

      // sanity check TODO: remove later
      this.trail.reindex();
      other.trail.reindex();

      var pointer = this.copy();
      pointer.trail.setMutable(); // this trail will be modified in the iteration, so references to it may be modified

      var first = true;

      while ( !pointer.equalsNested( other ) ) {
        assert && assert( pointer.compareNested( other ) !== 1, 'skipped in depthFirstUntil' );
        var skipSubtree = false;

        if ( first ) {
          // start point
          if ( !excludeEndpoints ) {
            skipSubtree = callback( pointer );
          }
          first = false;
        }
        else {
          // between point
          skipSubtree = callback( pointer );
        }

        if ( skipSubtree && pointer.isBefore ) {
          // to skip the subtree, we just change to isAfter
          pointer.setBefore( false );

          // if we skip a subtree, make sure we don't run past the ending pointer
          if ( pointer.compareNested( other ) === 1 ) {
            break;
          }
        }
        else {
          pointer.nestedForwards();
        }
      }

      // end point
      if ( !excludeEndpoints ) {
        callback( pointer );
      }
    },

    toString: function() {
      return '[' + ( this.isBefore ? 'before' : 'after' ) + ' ' + this.trail.toString().slice( 1 );
    }
  } );

  // same as new TrailPointer( trailA, isBeforeA ).compareNested( new TrailPointer( trailB, isBeforeB ) )
  TrailPointer.compareNested = function( trailA, isBeforeA, trailB, isBeforeB ) {
    var comparison = trailA.compare( trailB );

    if ( comparison === 0 ) {
      // if trails are equal, just compare before/after
      if ( isBeforeA === isBeforeB ) {
        return 0;
      }
      else {
        return isBeforeA ? -1 : 1;
      }
    }
    else {
      // if one is an extension of the other, the shorter isBefore flag determines the order completely
      if ( trailA.isExtensionOf( trailB ) ) {
        return isBeforeB ? 1 : -1;
      }
      else if ( trailB.isExtensionOf( trailA ) ) {
        return isBeforeA ? -1 : 1;
      }
      else {
        // neither is a subtrail of the other, so a straight trail comparison should give the answer
        return comparison;
      }
    }
  };

  return TrailPointer;
} );


// Copyright 2013-2015, University of Colorado Boulder


/**
 * Represents a trail (path in the graph) from a 'root' node down to a descendant node.
 * In a DAG, or with different views, there can be more than one trail up from a node,
 * even to the same root node!
 *
 * It has an array of nodes, in order from the 'root' down to the last node,
 * a length, and an array of indices such that node_i.children[index_i] === node_{i+1}.
 *
 * The indices can sometimes become stale when nodes are added and removed, so Trails
 * can have their indices updated with reindex(). It's designed to be as fast as possible
 * on Trails that are already indexed accurately.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Trail',['require','PHET_CORE/inherit','DOT/Matrix3','DOT/Transform3','SCENERY/scenery','SCENERY/util/TrailPointer','SCENERY/nodes/Node'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );

  var scenery = require( 'SCENERY/scenery' );

  require( 'SCENERY/util/TrailPointer' );

  require( 'SCENERY/nodes/Node' );
  // require( 'SCENERY/util/TrailPointer' );

  function Trail( nodes ) {
    /*
     * Controls the immutability of the trail.
     * If set to true, add/remove descendant/ancestor should fail if assertions are enabled
     * Use setImmutable() or setMutable() to signal a specific type of protection, so it cannot be changed later
     */
    if ( assert ) {
      // only do this if assertions are enabled, otherwise we won't access it at all
      this.immutable = undefined;
    }

    if ( nodes instanceof Trail ) {
      // copy constructor (takes advantage of already built index information)
      var otherTrail = nodes;

      this.nodes = otherTrail.nodes.slice( 0 );
      this.length = otherTrail.length;
      this.uniqueId = otherTrail.uniqueId;
      this.indices = otherTrail.indices.slice( 0 );
      return;
    }

    this.nodes = [];
    this.length = 0;
    this.uniqueId = '';

    // indices[x] stores the index of nodes[x] in nodes[x-1]'s children, e.g. nodes[i].children[ indices[i] ] === nodes[i+1]
    this.indices = [];

    var trail = this;
    if ( nodes ) {
      if ( nodes instanceof scenery.Node ) {
        var node = nodes;

        // add just a single node in
        trail.addDescendant( node );
      }
      else {
        // process it as an array
        var len = nodes.length;
        for ( var i = 0; i < len; i++ ) {
          trail.addDescendant( nodes[ i ] );
        }
      }
    }

    phetAllocation && phetAllocation( 'Trail' );
  }

  scenery.register( 'Trail', Trail );

  inherit( Object, Trail, {
    copy: function() {
      return new Trail( this );
    },

    // convenience function to determine whether this trail will render something
    isPainted: function() {
      return this.lastNode().isPainted();
    },

    // @returns whether all nodes in the trail are still connected from the trail's root to its leaf
    isValid: function() {
      this.reindex();

      var indexLength = this.indices.length;
      for ( var i = 0; i < indexLength; i++ ) {
        if ( this.indices[ i ] < 0 ) {
          return false;
        }
      }

      return true;
    },

    // this trail is visible only if all nodes on it are marked as visible
    isVisible: function() {
      var i = this.nodes.length;
      while ( i-- ) {
        if ( !this.nodes[ i ].isVisible() ) {
          return false;
        }
      }
      return true;
    },

    isFocusable: function() {
      return this.isVisible() && this.lastNode().focusable === true;
    },

    getOpacity: function() {
      var opacity = 1;
      var i = this.nodes.length;
      while ( i-- ) {
        opacity *= this.nodes[ i ].getOpacity();
      }
      return opacity;
    },

    // essentially whether this node is visited in the hit-testing operation
    isPickable: function() {
      // it won't be if it or any ancestor is pickable: false, or is invisible
      if ( _.some( this.nodes, function( node ) { return node.pickable === false || node.visible === false; } ) ) { return false; }

      // if there is any listener or pickable: true, it will be pickable
      if ( _.some( this.nodes, function( node ) { return node.hasInputListenerEquivalent(); } ) ) { return true; }

      if ( this.lastNode()._subtreePickableCount > 0 ) {
        return true;
      }

      // no listeners or pickable: true, so it will be pruned
      return false;
    },

    get: function( index ) {
      if ( index >= 0 ) {
        return this.nodes[ index ];
      }
      else {
        // negative index goes from the end of the array
        return this.nodes[ this.nodes.length + index ];
      }
    },

    slice: function( startIndex, endIndex ) {
      return new Trail( this.nodes.slice( startIndex, endIndex ) );
    },

    subtrailTo: function( node, excludeNode ) {
      return this.slice( 0, _.indexOf( this.nodes, node ) + ( excludeNode ? 0 : 1 ) );
    },

    isEmpty: function() {
      return this.nodes.length === 0;
    },

    // from local to global
    getMatrix: function() {
      // TODO: performance: can we cache this ever? would need the rootNode to not really change in between
      // this matrix will be modified in place, so always start fresh
      var matrix = Matrix3.identity();

      // from the root up
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 0; i < length; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },

    // from local to next-to-global (ignores root node matrix)
    getAncestorMatrix: function() {
      // TODO: performance: can we cache this ever? would need the rootNode to not really change in between
      // this matrix will be modified in place, so always start fresh
      var matrix = Matrix3.identity();

      // from the root up
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 1; i < length; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },

    // from parent to global
    getParentMatrix: function() {
      // this matrix will be modified in place, so always start fresh
      var matrix = Matrix3.identity();

      // from the root up
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 0; i < length - 1; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },

    // from local to global
    getTransform: function() {
      return new Transform3( this.getMatrix() );
    },

    // from parent to global
    getParentTransform: function() {
      return new Transform3( this.getParentMatrix() );
    },

    addAncestor: function( node, index ) {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with addAncestor' );
      assert && assert( node, 'cannot add falsy value to a Trail' );


      if ( this.nodes.length ) {
        var oldRoot = this.nodes[ 0 ];
        this.indices.unshift( index === undefined ? _.indexOf( node._children, oldRoot ) : index );
      }
      this.nodes.unshift( node );

      this.length++;
      // accelerated version of this.updateUniqueId()
      this.uniqueId = ( this.uniqueId ? node.id + '-' + this.uniqueId : node.id + '' );
      return this;
    },

    removeAncestor: function() {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeAncestor' );
      assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );

      this.nodes.shift();
      if ( this.indices.length ) {
        this.indices.shift();
      }

      this.length--;
      this.updateUniqueId();
      return this;
    },

    addDescendant: function( node, index ) {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with addDescendant' );
      assert && assert( node, 'cannot add falsy value to a Trail' );


      if ( this.nodes.length ) {
        var parent = this.lastNode();
        this.indices.push( index === undefined ? _.indexOf( parent._children, node ) : index );
      }
      this.nodes.push( node );

      this.length++;
      // accelerated version of this.updateUniqueId()
      this.uniqueId = ( this.uniqueId ? this.uniqueId + '-' + node.id : node.id + '' );
      return this;
    },

    removeDescendant: function() {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeDescendant' );
      assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );

      this.nodes.pop();
      if ( this.indices.length ) {
        this.indices.pop();
      }

      this.length--;
      this.updateUniqueId();
      return this;
    },

    addDescendantTrail: function( trail ) {
      var length = trail.length;
      if ( length ) {
        this.addDescendant( trail.nodes[ 0 ] );
      }
      for ( var i = 1; i < length; i++ ) {
        this.addDescendant( trail.nodes[ i ], this.indices[ i - 1 ] );
      }
    },

    removeDescendantTrail: function( trail ) {
      var length = trail.length;
      for ( var i = length - 1; i >= 0; i-- ) {
        assert && assert( this.lastNode() === trail.nodes[ i ] );

        this.removeDescendant();
      }
    },

    // refreshes the internal index references (important if any children arrays were modified!)
    reindex: function() {
      var length = this.length;
      for ( var i = 1; i < length; i++ ) {
        // only replace indices where they have changed (this was a performance hotspot)
        var currentIndex = this.indices[ i - 1 ];
        var baseNode = this.nodes[ i - 1 ];

        if ( baseNode._children[ currentIndex ] !== this.nodes[ i ] ) {
          this.indices[ i - 1 ] = _.indexOf( baseNode._children, this.nodes[ i ] );
        }
      }
    },

    setImmutable: function() {
      // if assertions are disabled, we hope this is inlined as a no-op
      if ( assert ) {
        assert( this.immutable !== false, 'A trail cannot be made immutable after being flagged as mutable' );
        this.immutable = true;
      }

      // TODO: consider setting mutators to null here instead of the function call check (for performance, and profile the differences)

      return this; // allow chaining
    },

    setMutable: function() {
      // if assertions are disabled, we hope this is inlined as a no-op
      if ( assert ) {
        assert( this.immutable !== true, 'A trail cannot be made mutable after being flagged as immutable' );
        this.immutable = false;
      }

      return this; // allow chaining
    },

    areIndicesValid: function() {
      for ( var i = 1; i < this.length; i++ ) {
        var currentIndex = this.indices[ i - 1 ];
        if ( this.nodes[ i - 1 ]._children[ currentIndex ] !== this.nodes[ i ] ) {
          return false;
        }
      }
      return true;
    },

    equals: function( other ) {
      if ( this.length !== other.length ) {
        return false;
      }

      for ( var i = 0; i < this.nodes.length; i++ ) {
        if ( this.nodes[ i ] !== other.nodes[ i ] ) {
          return false;
        }
      }

      return true;
    },

    // returns a new Trail from the root up to the parameter node.
    upToNode: function( node ) {
      var nodeIndex = _.indexOf( this.nodes, node );
      assert && assert( nodeIndex >= 0, 'Trail does not contain the node' );
      return this.slice( 0, _.indexOf( this.nodes, node ) + 1 );
    },

    // whether this trail contains the complete 'other' trail, but with added descendants afterwards
    isExtensionOf: function( other, allowSameTrail ) {
      if ( this.length <= other.length - ( allowSameTrail ? 1 : 0 ) ) {
        return false;
      }

      for ( var i = 0; i < other.nodes.length; i++ ) {
        if ( this.nodes[ i ] !== other.nodes[ i ] ) {
          return false;
        }
      }

      return true;
    },

    // a transform from our local coordinate frame to the other trail's local coordinate frame
    getTransformTo: function( otherTrail ) {
      return new Transform3( this.getMatrixTo( otherTrail ) );
    },

    // returns a matrix that transforms a point in our last node's local coordinate frame to the other trail's last node's local coordinate frame
    getMatrixTo: function( otherTrail ) {
      this.reindex();
      otherTrail.reindex();

      var branchIndex = this.getBranchIndexTo( otherTrail );
      var idx;

      var matrix = Matrix3.IDENTITY;

      // walk our transform down, prepending
      for ( idx = this.length - 1; idx >= branchIndex; idx-- ) {
        matrix = this.nodes[ idx ].getMatrix().timesMatrix( matrix );
      }

      // walk our transform up, prepending inverses
      for ( idx = branchIndex; idx < otherTrail.length; idx++ ) {
        matrix = otherTrail.nodes[ idx ].getTransform().getInverse().timesMatrix( matrix );
      }

      return matrix;
    },

    // the first index that is different between this trail and the other trail
    getBranchIndexTo: function( otherTrail ) {
      assert && assert( this.nodes[ 0 ] === otherTrail.nodes[ 0 ], 'To get a branch index, the trails must have the same root' );

      var branchIndex;

      for ( branchIndex = 0; branchIndex < Math.min( this.length, otherTrail.length ); branchIndex++ ) {
        if ( this.nodes[ branchIndex ] !== otherTrail.nodes[ branchIndex ] ) {
          break;
        }
      }

      return branchIndex;
    },

    // TODO: phase out in favor of get()
    nodeFromTop: function( offset ) {
      return this.nodes[ this.length - 1 - offset ];
    },

    lastNode: function() {
      return this.nodeFromTop( 0 );
    },

    rootNode: function() {
      return this.nodes[ 0 ];
    },

    // returns the previous graph trail in the order of self-rendering
    previous: function() {
      if ( this.nodes.length <= 1 ) {
        return null;
      }

      var top = this.nodeFromTop( 0 );
      var parent = this.nodeFromTop( 1 );

      var parentIndex = _.indexOf( parent._children, top );
      assert && assert( parentIndex !== -1 );
      var arr = this.nodes.slice( 0, this.nodes.length - 1 );
      if ( parentIndex === 0 ) {
        // we were the first child, so give it the trail to the parent
        return new Trail( arr );
      }
      else {
        // previous child
        arr.push( parent._children[ parentIndex - 1 ] );

        // and find its last terminal
        while ( arr[ arr.length - 1 ]._children.length !== 0 ) {
          var last = arr[ arr.length - 1 ];
          arr.push( last._children[ last._children.length - 1 ] );
        }

        return new Trail( arr );
      }
    },

    // like previous(), but keeps moving back until the trail goes to a node with isPainted() === true
    previousPainted: function() {
      var result = this.previous();
      while ( result && !result.isPainted() ) {
        result = result.previous();
      }
      return result;
    },

    // in the order of self-rendering
    next: function() {
      var arr = this.nodes.slice( 0 );

      var top = this.nodeFromTop( 0 );
      if ( top._children.length > 0 ) {
        // if we have children, return the first child
        arr.push( top._children[ 0 ] );
        return new Trail( arr );
      }
      else {
        // walk down and attempt to find the next parent
        var depth = this.nodes.length - 1;

        while ( depth > 0 ) {
          var node = this.nodes[ depth ];
          var parent = this.nodes[ depth - 1 ];

          arr.pop(); // take off the node so we can add the next sibling if it exists

          var index = _.indexOf( parent._children, node );
          if ( index !== parent._children.length - 1 ) {
            // there is another (later) sibling. use that!
            arr.push( parent._children[ index + 1 ] );
            return new Trail( arr );
          }
          else {
            depth--;
          }
        }

        // if we didn't reach a later sibling by now, it doesn't exist
        return null;
      }
    },

    // like next(), but keeps moving back until the trail goes to a node with isPainted() === true
    nextPainted: function() {
      var result = this.next();
      while ( result && !result.isPainted() ) {
        result = result.next();
      }
      return result;
    },

    // calls callback( trail ) for this trail, and each descendant trail. If callback returns true, subtree will be skipped
    eachTrailUnder: function( callback ) {
      // TODO: performance: should be optimized to be much faster, since we don't have to deal with the before/after
      new scenery.TrailPointer( this, true ).eachTrailBetween( new scenery.TrailPointer( this, false ), callback );
    },

    /*
     * Standard Java-style compare. -1 means this trail is before (under) the other trail, 0 means equal, and 1 means this trail is
     * after (on top of) the other trail.
     * A shorter subtrail will compare as -1.
     *
     * Assumes that the Trails are properly indexed. If not, please reindex them!
     *
     * Comparison is for the rendering order, so an ancestor is 'before' a descendant
     */
    compare: function( other ) {
      assert && assert( !this.isEmpty(), 'cannot compare with an empty trail' );
      assert && assert( !other.isEmpty(), 'cannot compare with an empty trail' );
      assert && assert( this.nodes[ 0 ] === other.nodes[ 0 ], 'for Trail comparison, trails must have the same root node' );
      assertSlow && assertSlow( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed on ' + this.toString() );
      assertSlow && assertSlow( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed on ' + other.toString() );

      var minNodeIndex = Math.min( this.indices.length, other.indices.length );
      for ( var i = 0; i < minNodeIndex; i++ ) {
        if ( this.indices[ i ] !== other.indices[ i ] ) {
          if ( this.indices[ i ] < other.indices[ i ] ) {
            return -1;
          }
          else {
            return 1;
          }
        }
      }

      // we scanned through and no nodes were different (one is a subtrail of the other)
      if ( this.nodes.length < other.nodes.length ) {
        return -1;
      }
      else if ( this.nodes.length > other.nodes.length ) {
        return 1;
      }
      else {
        return 0;
      }
    },

    isBefore: function( other ) {
      return this.compare( other ) === -1;
    },

    isAfter: function( other ) {
      return this.compare( other ) === 1;
    },

    localToGlobalPoint: function( point ) {
      // TODO: performance: multiple timesVector2 calls up the chain is probably faster
      return this.getMatrix().timesVector2( point );
    },

    localToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getMatrix() );
    },

    globalToLocalPoint: function( point ) {
      return this.getTransform().inversePosition2( point );
    },

    globalToLocalBounds: function( bounds ) {
      return this.getTransform().inverseBounds2( bounds );
    },

    parentToGlobalPoint: function( point ) {
      // TODO: performance: multiple timesVector2 calls up the chain is probably faster
      return this.getParentMatrix().timesVector2( point );
    },

    parentToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getParentMatrix() );
    },

    globalToParentPoint: function( point ) {
      return this.getParentTransform().inversePosition2( point );
    },

    globalToParentBounds: function( bounds ) {
      return this.getParentTransform().inverseBounds2( bounds );
    },

    updateUniqueId: function() {
      // string concatenation is faster, see http://jsperf.com/string-concat-vs-joins
      var result = '';
      var len = this.nodes.length;
      if ( len > 0 ) {
        result += this.nodes[ 0 ]._id;
      }
      for ( var i = 1; i < len; i++ ) {
        result += '-' + this.nodes[ i ]._id;
      }
      this.uniqueId = result;
      // this.uniqueId = _.map( this.nodes, function( node ) { return node.getId(); } ).join( '-' );
    },

    // concatenates the unique IDs of nodes in the trail, so that we can do id-based lookups
    getUniqueId: function() {
      // sanity checks
      if ( assert ) {
        var oldUniqueId = this.uniqueId;
        this.updateUniqueId();
        assert( oldUniqueId === this.uniqueId );
      }
      return this.uniqueId;
    },

    toString: function() {
      this.reindex();
      if ( !this.length ) {
        return 'Empty Trail';
      }
      return '[Trail ' + this.indices.join( '.' ) + ' ' + this.getUniqueId() + ']';
    },

    // not optimized by any means, meant for debugging.
    toPathString: function() {
      var specialNodes = _.filter( this.nodes, function( n ) { return n.constructor.name !== 'Node'; } );
      return _.map( specialNodes, function( n ) { return n.constructor.name; } ).join( '/' );
    }
  } );

  // like eachTrailBetween, but only fires for painted trails. If callback returns true, subtree will be skipped
  Trail.eachPaintedTrailBetween = function( a, b, callback, excludeEndTrails, rootNode ) {
    Trail.eachTrailBetween( a, b, function( trail ) {
      if ( trail && trail.isPainted() ) {
        return callback( trail );
      }
    }, excludeEndTrails, rootNode );
  };

  // global way of iterating across trails. when callback returns true, subtree will be skipped
  Trail.eachTrailBetween = function( a, b, callback, excludeEndTrails, rootNode ) {
    var aPointer = a ? new scenery.TrailPointer( a.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( rootNode ), true );
    var bPointer = b ? new scenery.TrailPointer( b.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( rootNode ), false );

    // if we are excluding endpoints, just bump the pointers towards each other by one step
    if ( excludeEndTrails ) {
      aPointer.nestedForwards();
      bPointer.nestedBackwards();

      // they were adjacent, so no callbacks will be executed
      if ( aPointer.compareNested( bPointer ) === 1 ) {
        return;
      }
    }

    aPointer.depthFirstUntil( bPointer, function( pointer ) {
      if ( pointer.isBefore ) {
        return callback( pointer.trail );
      }
    }, false );
  };

  // The index at which the two trails diverge. If a.length === b.length === branchIndex, the trails are identical
  Trail.branchIndex = function( a, b ) {
    assert && assert( a.nodes[ 0 ] === b.nodes[ 0 ], 'Branch changes require roots to be the same' );
    var branchIndex;
    var shortestLength = Math.min( a.length, b.length );
    for ( branchIndex = 0; branchIndex < shortestLength; branchIndex++ ) {
      if ( a.nodes[ branchIndex ] !== b.nodes[ branchIndex ] ) {
        break;
      }
    }
    return branchIndex;
  };

  // The subtrail from the root that both trails share
  Trail.sharedTrail = function( a, b ) {
    return a.slice( 0, Trail.branchIndex( a, b ) );
  };

  Trail.appendAncestorTrailsWithPredicate = function( trailResults, trail, predicate ) {
    var root = trail.rootNode();

    if ( predicate( root ) ) {
      trailResults.push( trail.copy() );
    }

    var parentCount = root._parents.length;
    for ( var i = 0; i < parentCount; i++ ) {
      var parent = root._parents[ i ];

      trail.addAncestor( parent );
      Trail.appendAncestorTrailsWithPredicate( trailResults, trail, predicate );
      trail.removeAncestor();
    }
  };

  Trail.appendDescendantTrailsWithPredicate = function( trailResults, trail, predicate ) {
    var lastNode = trail.lastNode();

    if ( predicate( lastNode ) ) {
      trailResults.push( trail.copy() );
    }

    var childCount = lastNode._children.length;
    for ( var i = 0; i < childCount; i++ ) {
      var child = lastNode._children[ i ];

      trail.addDescendant( child, i );
      Trail.appendDescendantTrailsWithPredicate( trailResults, trail, predicate );
      trail.removeDescendant();
    }
  };

  /*
   * Fires subtree(trail) or self(trail) on the callbacks to create disjoint subtrees (trails) that cover exactly the nodes
   * inclusively between a and b in rendering order.
   * We try to consolidate these as much as possible.
   *
   * "a" and "b" are treated like self painted trails in the rendering order
   *
   *
   * Example tree:
   *   a
   *   - b
   *   --- c
   *   --- d
   *   - e
   *   --- f
   *   ----- g
   *   ----- h
   *   ----- i
   *   --- j
   *   ----- k
   *   - l
   *   - m
   *   --- n
   *
   * spannedSubtrees( a, a ) -> self( a );
   * spannedSubtrees( c, n ) -> subtree( a ); NOTE: if b is painted, that wouldn't work!
   * spannedSubtrees( h, l ) -> subtree( h ); subtree( i ); subtree( j ); self( l );
   * spannedSubtrees( c, i ) -> [b,f] --- wait, include e self?
   */
  Trail.spannedSubtrees = function( a, b ) {
    // assert && assert( a.nodes[0] === b.nodes[0], 'Spanned subtrees for a and b requires that a and b have the same root' );

    // a.reindex();
    // b.reindex();

    // var subtrees = [];

    // var branchIndex = Trail.branchIndex( a, b );
    // assert && assert( branchIndex > 0, 'Branch index should always be > 0' );

    // if ( a.length === branchIndex && b.length === branchIndex ) {
    //   // the two trails are equal
    //   subtrees.push( a );
    // } else {
    //   // find the first place where our start isn't the first child
    //   for ( var before = a.length - 1; before >= branchIndex; before-- ) {
    //     if ( a.indices[before-1] !== 0 ) {
    //       break;
    //     }
    //   }

    //   // find the first place where our end isn't the last child
    //   for ( var after = a.length - 1; after >= branchIndex; after-- ) {
    //     if ( b.indices[after-1] !== b.nodes[after-1]._children.length - 1 ) {
    //       break;
    //     }
    //   }

    //   if ( before < branchIndex && after < branchIndex ) {
    //     // we span the entire tree up to nodes[branchIndex-1], so return only that subtree
    //     subtrees.push( a.slice( 0, branchIndex ) );
    //   } else {
    //     // walk the subtrees down from the start
    //     for ( var ia = before; ia >= branchIndex; ia-- ) {
    //       subtrees.push( a.slice( 0, ia + 1 ) );
    //     }

    //     // walk through the middle
    //     var iStart = a.indices[branchIndex-1];
    //     var iEnd = b.indices[branchIndex-1];
    //     var base = a.slice( 0, branchIndex );
    //     var children = base.lastNode()._children;
    //     for ( var im = iStart; im <= iEnd; im++ ) {
    //       subtrees.push( base.copy().addDescendant( children[im], im ) );
    //     }

    //     // walk the subtrees up to the end
    //     for ( var ib = branchIndex; ib <= after; ib++ ) {
    //       subtrees.push( b.slice( 0, ib + 1 ) );
    //     }
    //   }
    // }

    // return subtrees;
  };

  return Trail;
} );



// Copyright 2013-2015, University of Colorado Boulder


/*
 * A pointer is an abstraction that includes a mouse and touch points (and possibly keys).
 *
 * TODO: add state tracking (dragging/panning/etc.) to pointer for convenience
 * TODO: consider an 'active' flag?
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Pointer',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  function Pointer() {
    this.listeners = [];

    phetAllocation && phetAllocation( 'Pointer' );
  }

  scenery.register( 'Pointer', Pointer );

  inherit( Object, Pointer, {
    firesGenericEvent: true, // e.g. fires 'down' in addition to something like 'keydown'

    addInputListener: function( listener ) {
      assert && assert( !_.contains( this.listeners, listener ) );

      this.listeners.push( listener );
    },

    removeInputListener: function( listener ) {
      var index = _.indexOf( this.listeners, listener );
      assert && assert( index !== -1 );

      this.listeners.splice( index, 1 );
    },

    // for mouse/touch/pen
    hasPointChanged: function( point ) {
      return this.point !== point && ( !point || !this.point || !this.point.equals( point ) );
    }
  } );

  return Pointer;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Tracks the mouse state
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Mouse',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector3','SCENERY/input/Pointer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Vector3 = require( 'DOT/Vector3' );
  var Pointer = require( 'SCENERY/input/Pointer' ); // inherits from Pointer

  function Mouse() {
    Pointer.call( this );

    this.point = null;

    this.leftDown = false;
    this.middleDown = false;
    this.rightDown = false;

    this.isMouse = true;

    this.trail = null;

    this.isDown = false;

    // mouse wheel delta and mode for the last event, see https://developer.mozilla.org/en-US/docs/Web/Events/wheel
    this.wheelDelta = new Vector3();
    this.wheelDeltaMode = 0; // 0: pixels, 1: lines, 2: pages

    // overrides the cursor of whatever is under it when set
    this._cursor = null;

    this.type = 'mouse';
  }

  scenery.register( 'Mouse', Mouse );

  inherit( Pointer, Mouse, {
    set cursor( value ) { return this.setCursor( value ); },
    get cursor() { return this._cursor; },

    setCursor: function( value ) {
      this._cursor = value;
      return this; // allow chaining
    },

    clearCursor: function() {
      this.setCursor( null );
    },

    down: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse down at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = true;
      switch( event.button ) {
        case 0:
          this.leftDown = true;
          break;
        case 1:
          this.middleDown = true;
          break;
        case 2:
          this.rightDown = true;
          break;
      }
      return pointChanged;
    },

    up: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse up at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      switch( event.button ) {
        case 0:
          this.leftDown = false;
          break;
        case 1:
          this.middleDown = false;
          break;
        case 2:
          this.rightDown = false;
          break;
      }
      return pointChanged;
    },

    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse move at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },

    over: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse over at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },

    out: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse out at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      // TODO: how to handle the mouse out-of-bounds
      this.point = null;
      return pointChanged;
    },

    wheel: function( event ) {
      this.wheelDelta.setXYZ( event.deltaX, event.deltaY, event.deltaZ );
      this.wheelDeltaMode = event.deltaMode;
    },

    toString: function() {
      return 'Mouse';
    }
  } );

  return Mouse;
} );

// Copyright 2013-2014, University of Colorado Boulder


/**
 * Tracks a single touch point
 *
 * IE guidelines for Touch-friendly sites: http://blogs.msdn.com/b/ie/archive/2012/04/20/guidelines-for-building-touch-friendly-sites.aspx
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Touch',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer

  function Touch( id, point, event ) {
    Pointer.call( this );

    this.id = id;
    this.point = point;
    this.isTouch = true;
    this.trail = null;

    this.isDown = true; // touches always start down

    this.type = 'touch';
  }

  scenery.register( 'Touch', Touch );

  inherit( Pointer, Touch, {
    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },

    end: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },

    cancel: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },

    toString: function() {
      return 'Touch#' + this.id;
    }
  } );

  return Touch;
} );

// Copyright 2013-2014, University of Colorado Boulder


/**
 * Tracks a stylus ('pen') or something with tilt and pressure information
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Pen',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer

  function Pen( id, point, event ) {
    Pointer.call( this );

    this.id = id;
    this.point = point;
    this.isPen = true;
    this.trail = null;

    this.isDown = true; // pens always start down? TODO: is this true with pointer events?

    this.type = 'pen';
  }

  scenery.register( 'Pen', Pen );

  inherit( Pointer, Pen, {
    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },

    end: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },

    cancel: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },

    toString: function() {
      return 'Pen#' + this.id;
    }
  } );

  return Pen;
} );

// Copyright 2013-2014, University of Colorado Boulder


/*
 * An event in Scenery that has similar event-handling characteristics to DOM events.
 * The original DOM event (if any) is available as event.domEvent.
 *
 * Multiple events can be triggered by a single domEvent, so don't assume it is unique.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Event',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  function Event( args ) {
    // ensure that all of the required args are supplied
    assert && assert( args.trail && args.type && args.pointer && args.target,
      'Missing required scenery.Event argument' );

    this.handled = false;
    this.aborted = false;

    // {Trail} path to the leaf-most node, ordered list, from root to leaf
    this.trail = args.trail;

    // {String} what event was triggered on the listener
    this.type = args.type;

    // {Pointer}
    this.pointer = args.pointer;

    // raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)
    this.domEvent = args.domEvent;

    // {Node} whatever node you attached the listener to, or null when firing events on a Pointer
    this.currentTarget = args.currentTarget;

    // {Node} leaf-most node in trail
    this.target = args.target;

    // TODO: add extended information based on an event here?
  }

  scenery.register( 'Event', Event );

  inherit( Object, Event, {
    // like DOM Event.stopPropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event
    handle: function() {
      this.handled = true;
    },

    // like DOM Event.stopImmediatePropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event
    abort: function() {
      this.handled = true;
      this.aborted = true;
    }
  } );

  return Event;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Tracks a single key-press
 *
 * TODO: general key-press implementation
 * TODO: consider separate handling for keys in general.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/Key',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Pointer = require( 'SCENERY/input/Pointer' ); // Inherits from Pointer

  function Key( event ) {
    Pointer.call( this );

    this.event = event; // event.keyCode event.charCode
    this.isKey = true; // compared to isMouse/isPen/isTouch
    this.trail = null;
    this.type = 'key';
  }

  scenery.register( 'Key', Key );

  return inherit( Pointer, Key, {
    firesGenericEvent: false // don't fire 'down', 'up' and the other generic events
  } );
} );
// Copyright 2014-2015, University of Colorado Boulder


/**
 * Pooled structure to record batched events efficiently. How it calls the callback is based on the type
 * (pointer/mspointer/touch/mouse). There is one BatchedDOMEvent for each DOM Event (not for each touch).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/BatchedDOMEvent',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );

  function BatchedDOMEvent( domEvent, type, callback ) {
    assert && assert( domEvent, 'for some reason, there is no DOM event?' );

    // called multiple times due to pooling, this should be re-entrant
    this.domEvent = domEvent;
    this.type = type;
    this.callback = callback;
  }

  scenery.register( 'BatchedDOMEvent', BatchedDOMEvent );

  // enum for type
  BatchedDOMEvent.POINTER_TYPE = 1;
  BatchedDOMEvent.MS_POINTER_TYPE = 2;
  BatchedDOMEvent.TOUCH_TYPE = 3;
  BatchedDOMEvent.MOUSE_TYPE = 4;
  BatchedDOMEvent.KEY_TYPE = 5; //TODO: Or are Keys Pointers, as they were in previous sceneries?
  BatchedDOMEvent.WHEEL_TYPE = 6;

  inherit( Object, BatchedDOMEvent, {
    run: function( input ) {
      var domEvent = this.domEvent;
      var callback = this.callback;

      // process whether anything under the pointers changed before running additional input events
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'validatePointers from batched event' );
      input.validatePointers();
      if ( input.logEvents ) { input.emitter.emit1( 'validatePointers();' );}

      //OHTWO TODO: switch?
      if ( this.type === BatchedDOMEvent.POINTER_TYPE ) {
        callback.call( input, domEvent.pointerId, domEvent.pointerType, input.pointFromEvent( domEvent ), domEvent );
      }
      else if ( this.type === BatchedDOMEvent.MS_POINTER_TYPE ) {
        callback.call( input, domEvent.pointerId, scenery.Input.msPointerType( domEvent ), input.pointFromEvent( domEvent ), domEvent );
      }
      else if ( this.type === BatchedDOMEvent.TOUCH_TYPE ) {
        for ( var i = 0; i < domEvent.changedTouches.length; i++ ) {
          // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList
          var touch = domEvent.changedTouches.item( i );

          callback.call( input, touch.identifier, input.pointFromEvent( touch ), domEvent );
        }
      }
      else if ( this.type === BatchedDOMEvent.MOUSE_TYPE ) {
        callback.call( input, input.pointFromEvent( domEvent ), domEvent );
      }
      else if ( this.type === BatchedDOMEvent.KEY_TYPE ) { //TODO: or should keys be handled with the other Pointers?
        callback.call( input, domEvent );
      }
      else if ( this.type === BatchedDOMEvent.WHEEL_TYPE ) {
        callback.call( input, domEvent );
      }
      else {
        throw new Error( 'bad type value: ' + this.type );
      }
    },

    dispose: function() {
      // clear our references
      this.domEvent = null;
      this.callback = null;
      this.freeToPool();
    }
  } );

  BatchedDOMEvent.fromPointerEvent = function( domEvent, pointFromEvent ) {
    return BatchedDOMEvent.createFromPool( domEvent, pointFromEvent( domEvent ), domEvent.pointerId );
  };

  Poolable.mixin( BatchedDOMEvent, {
    constructorDuplicateFactory: function( pool ) {
      return function( domEvent, type, callback ) {
        if ( pool.length ) {
          var result = pool.pop();
          BatchedDOMEvent.call( result, domEvent, type, callback );
          return result;
        }
        else {
          return new BatchedDOMEvent( domEvent, type, callback );
        }
      };
    }
  } );

  return BatchedDOMEvent;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * API for handling mouse / touch / keyboard events.
 *
 * A 'pointer' is an abstract way of describing either the mouse, a single touch point, or a key being pressed.
 * touch points and key presses go away after being released, whereas the mouse 'pointer' is persistent.
 *
 * Events will be called on listeners with a single event object. Supported event types are:
 * 'up', 'down', 'out', 'over', 'enter', 'exit', 'move', and 'cancel'. Scenery also supports more specific event
 * types that constrain the type of pointer, so 'mouse' + type, 'touch' + type and 'pen' + type will fire
 * on each listener before the generic event would be fined. E.g. for mouse movement, listener.mousemove will be
 * fired before listener.move.
 *
 * DOM Level 3 events spec: http://www.w3.org/TR/DOM-Level-3-Events/
 * Touch events spec: http://www.w3.org/TR/touch-events/
 * Pointer events spec draft: https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid (PhET Interactive Simulations)
 */

define( 'SCENERY/input/Input',['require','PHET_CORE/inherit','PHET_CORE/platform','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Mouse','SCENERY/input/Touch','SCENERY/input/Pen','SCENERY/input/Event','SCENERY/input/Key','SCENERY/input/BatchedDOMEvent','AXON/Property','AXON/Emitter'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var platform = require( 'PHET_CORE/platform' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );

  require( 'SCENERY/util/Trail' );
  require( 'SCENERY/input/Mouse' );
  require( 'SCENERY/input/Touch' );
  require( 'SCENERY/input/Pen' );
  require( 'SCENERY/input/Event' );
  require( 'SCENERY/input/Key' );
  var BatchedDOMEvent = require( 'SCENERY/input/BatchedDOMEvent' );
  var Property = require( 'AXON/Property' );
  var Emitter = require( 'AXON/Emitter' );

  // Object literal makes it easy to check for the existence of an attribute (compared to [].indexOf()>=0)
  var domEventPropertiesToSerialize = {
    button: true, keyCode: true,
    deltaX: true, deltaY: true, deltaZ: true, deltaMode: true, pointerId: true,
    pointerType: true, charCode: true, which: true, clientX: true, clientY: true, changedTouches: true
  };

  /**
   * Find the index of the first occurrence of an element within an array, using equals() comparison.
   * @param array
   * @param element
   * @returns {number}
   */
  var indexOfUsingEquality = function( array, element ) {
    for ( var i = 0; i < array.length; i++ ) {
      var item = array[ i ];
      if ( item.equals( element ) ) {
        return i;
      }
    }
    return -1;
  };

  var globalDisplay = null;

  // listenerTarget is the DOM node (window/document/element) to which DOM event listeners will be attached
  function Input( display, listenerTarget, batchDOMEvents, enablePointerEvents, pointFromEvent ) {
    this.display = display;
    this.rootNode = display.rootNode;
    this.listenerTarget = listenerTarget;
    this.batchDOMEvents = batchDOMEvents;
    this.enablePointerEvents = enablePointerEvents;
    this.pointFromEvent = pointFromEvent;
    this.displayUpdateOnEvent = false;
    globalDisplay = display;

    this.batchedEvents = [];

    //Pointer for mouse, only created lazily on first mouse event, so no mouse is allocated on tablets
    this.mouse = null;

    this.pointers = [];

    // For PhET-iO
    this.emitter = new Emitter();

    this.pointerAddedListeners = [];

    var input = this;

    // unique to this input instance
    this.onpointerdown = function onpointerdown( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, input.pointerDown, false ); };
    this.onpointerup = function onpointerup( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, input.pointerUp, true ); };
    this.onpointermove = function onpointermove( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, input.pointerMove, false ); };
    this.onpointerover = function onpointerover( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, input.pointerOver, false ); };
    this.onpointerout = function onpointerout( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, input.pointerOut, false ); };
    this.onpointercancel = function onpointercancel( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, input.pointerCancel, false ); };
    this.onMSPointerDown = function onMSPointerDown( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, input.pointerDown, false ); };
    this.onMSPointerUp = function onMSPointerUp( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, input.pointerUp, true ); };
    this.onMSPointerMove = function onMSPointerMove( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, input.pointerMove, false ); };
    this.onMSPointerOver = function onMSPointerOver( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, input.pointerOver, false ); };
    this.onMSPointerOut = function onMSPointerOut( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, input.pointerOut, false ); };
    this.onMSPointerCancel = function onMSPointerCancel( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, input.pointerCancel, false ); };
    this.ontouchstart = function ontouchstart( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, input.touchStart, false ); };
    this.ontouchend = function ontouchend( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, input.touchEnd, true ); };
    this.ontouchmove = function ontouchmove( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, input.touchMove, false ); };
    this.ontouchcancel = function ontouchcancel( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, input.touchCancel, false ); };
    this.onmousedown = function onmousedown( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, input.mouseDown, false ); };
    this.onmouseup = function onmouseup( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, input.mouseUp, true ); };
    this.onmousemove = function onmousemove( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, input.mouseMove, false ); };
    this.onmouseover = function onmouseover( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, input.mouseOver, false ); };
    this.onmouseout = function onmouseout( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, input.mouseOut, false ); };
    this.onkeydown = function onkeydown( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.KEY_TYPE, input.keyDown, false ); };
    this.onkeyup = function onkeyup( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.KEY_TYPE, input.keyUp, false ); };
    this.onwheel = function onwheel( domEvent ) { input.batchEvent( domEvent, BatchedDOMEvent.WHEEL_TYPE, input.wheel, false ); };
    this.uselessListener = function uselessListener( domEvent ) {};
  }

  scenery.register( 'Input', Input );

  return inherit( Object, Input, {
      batchEvent: function( domEvent, batchType, callback, triggerImmediate ) {
        // If our display is not interactive, do not respond to any events (but still prevent default)
        if ( this.display.interactive ) {
          this.batchedEvents.push( BatchedDOMEvent.createFromPool( domEvent, batchType, callback ) );
          if ( triggerImmediate || !this.batchDOMEvents ) {
            this.fireBatchedEvents();
          }
          if ( this.displayUpdateOnEvent ) {
            //OHTWO TODO: update the display
          }
        }

        var isKey = batchType === BatchedDOMEvent.KEY_TYPE;

        // Don't preventDefault for key events, which often need to be handled by the browser
        // (such as F5, CMD+R, CMD+OPTION+J, etc), see #332
        if ( !isKey ) {
          // Always preventDefault on touch events, since we don't want mouse events triggered afterwards. See
          // http://www.html5rocks.com/en/mobile/touchandmouse/ for more information.
          // Additionally, IE had some issues with skipping prevent default, see
          // https://github.com/phetsims/scenery/issues/464 for mouse handling.
          if ( callback !== this.mouseDown || platform.ie || platform.edge ) {
            domEvent.preventDefault();
          }
        }
      },

      fireBatchedEvents: function() {
        if ( this.batchedEvents.length ) {
          sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'Input.fireBatchedEvents length:' + this.batchedEvents.length );

          // needs to be done in order
          var len = this.batchedEvents.length;
          for ( var i = 0; i < len; i++ ) {
            var batchedEvent = this.batchedEvents[ i ];
            batchedEvent.run( this );
            batchedEvent.dispose();
          }
          cleanArray( this.batchedEvents );
        }
      },

      clearBatchedEvents: function() {
        this.batchedEvents.length = 0;
      },

      pointerListenerTypes: [ 'pointerdown', 'pointerup', 'pointermove', 'pointerover', 'pointerout', 'pointercancel' ],
      msPointerListenerTypes: [ 'MSPointerDown', 'MSPointerUp', 'MSPointerMove', 'MSPointerOver', 'MSPointerOut', 'MSPointerCancel' ],
      touchListenerTypes: [ 'touchstart', 'touchend', 'touchmove', 'touchcancel' ],
      mouseListenerTypes: [ 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout' ],
      keyListenerTypes: [ 'keydown', 'keyup' ],
      wheelListenerTypes: [ 'wheel' ],

      // W3C spec for pointer events
      canUsePointerEvents: function() {
        return window.navigator && window.navigator.pointerEnabled && this.enablePointerEvents;
      },

      // MS spec for pointer event
      canUseMSPointerEvents: function() {
        return window.navigator && window.navigator.msPointerEnabled && this.enablePointerEvents;
      },

      getUsedEventTypes: function() {
        var eventTypes;

        if ( this.canUsePointerEvents() ) {
          // accepts pointer events corresponding to the spec at http://www.w3.org/TR/pointerevents/
          sceneryLog && sceneryLog.Input && sceneryLog.Input( 'Detected pointer events support, using that instead of mouse/touch events' );

          eventTypes = this.pointerListenerTypes;
        }
        else if ( this.canUseMSPointerEvents() ) {
          sceneryLog && sceneryLog.Input && sceneryLog.Input( 'Detected MS pointer events support, using that instead of mouse/touch events' );

          eventTypes = this.msPointerListenerTypes;
        }
        else {
          sceneryLog && sceneryLog.Input && sceneryLog.Input( 'No pointer events support detected, using mouse/touch events' );

          eventTypes = this.touchListenerTypes.concat( this.mouseListenerTypes );
        }

        eventTypes = eventTypes.concat( this.keyListenerTypes );
        eventTypes = eventTypes.concat( this.wheelListenerTypes );

        return eventTypes;
      },

      connectListeners: function() {
        this.processListeners( true );
      },

      disconnectListeners: function() {
        this.processListeners( false );
      },

      // @param addOrRemove: true if adding, false if removing
      processListeners: function( addOrRemove ) {
        var eventTypes = this.getUsedEventTypes();

        for ( var i = 0; i < eventTypes.length; i++ ) {
          var type = eventTypes[ i ];

          // work around iOS Safari 7 not sending touch events to Scenes contained in an iframe
          if ( this.listenerTarget === window ) {
            if ( addOrRemove ) {
              document.addEventListener( type, this.uselessListener );
            }
            else {
              document.removeEventListener( type, this.uselessListener );
            }
          }

          var callback = this[ 'on' + type ];
          assert && assert( !!callback );

          if ( addOrRemove ) {
            this.listenerTarget.addEventListener( type, callback, false ); // don't use capture for now
          }
          else {
            this.listenerTarget.removeEventListener( type, callback, false ); // don't use capture for now
          }
        }
      },

      addPointer: function( pointer ) {
        this.pointers.push( pointer );

        //Callback for showing pointer events.  Optimized for performance.
        if ( this.pointerAddedListeners.length ) {
          for ( var i = 0; i < this.pointerAddedListeners.length; i++ ) {
            this.pointerAddedListeners[ i ]( pointer );
          }
        }
      },

      addPointerAddedListener: function( listener ) {
        this.pointerAddedListeners.push( listener );
      },

      removePointerAddedListener: function( listener ) {
        var index = this.pointerAddedListeners.indexOf( listener );
        if ( index !== -1 ) {
          this.pointerAddedListeners.splice( index, index + 1 );
        }
      },

      removePointer: function( pointer ) {
        // sanity check version, will remove all instances
        for ( var i = this.pointers.length - 1; i >= 0; i-- ) {
          if ( this.pointers[ i ] === pointer ) {
            this.pointers.splice( i, 1 );
          }
        }
      },

      findTouchById: function( id ) {
        var i = this.pointers.length;
        while ( i-- ) {
          var pointer = this.pointers[ i ];
          if ( pointer.id === id ) {
            return pointer;
          }
        }
        return undefined;
      },

      findKeyByEvent: function( event ) {
        assert && assert( event.keyCode !== undefined && event.charCode !== undefined, 'Assumes the KeyboardEvent has keyCode and charCode properties' );
        var result = _.find( this.pointers, function( pointer ) {
          // TODO: also check location (if that exists), so we don't mix up left and right shift, etc.
          return pointer.event && pointer.event.keyCode === event.keyCode && pointer.event.charCode === event.charCode;
        } );
        // assert && assert( result, 'No key found for the combination of key:' + event.key + ' and location:' + event.location );
        return result;
      },

      //Init the mouse on the first mouse event (if any!)
      initMouse: function() {
        this.mouse = new scenery.Mouse();
        this.addPointer( this.mouse );
      },

      mouseDown: function( point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseDown(' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseDown(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        if ( !this.mouse ) { this.initMouse(); }
        var pointChanged = this.mouse.down( point, event );
        if ( pointChanged ) {
          this.moveEvent( this.mouse, event );
        }
        this.downEvent( this.mouse, event );
      },

      mouseUp: function( point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseUp(' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseUp(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        if ( !this.mouse ) { this.initMouse(); }
        var pointChanged = this.mouse.up( point, event );
        if ( pointChanged ) {
          this.moveEvent( this.mouse, event );
        }
        this.upEvent( this.mouse, event );
      },

      mouseMove: function( point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseMove(' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseMove(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        if ( !this.mouse ) { this.initMouse(); }
        this.mouse.move( point, event );
        this.moveEvent( this.mouse, event );
      },

      mouseOver: function( point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseOver(' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseOver(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        if ( !this.mouse ) { this.initMouse(); }
        this.mouse.over( point, event );
        // TODO: how to handle mouse-over (and log it)
      },

      mouseOut: function( point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseOut(' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseOut(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        if ( !this.mouse ) { this.initMouse(); }
        this.mouse.out( point, event );
        // TODO: how to handle mouse-out (and log it)
      },

      keyDown: function( event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'keyDown(' + Input.debugKeyEvent( event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'keyDown(' + Input.serializeDomEvent( event ) + ');' ); }

        // temporary disabling
        if ( true ) { //eslint-disable-line no-constant-condition
          // if ( !this.display.options.accessibility ) {
          return;
        }

        var code = event.which;

        if ( Input.pressedKeys.indexOf( code ) === -1 ) {
          Input.pressedKeys.push( code );
        }

        // Handle TAB key
        var shiftPressed = Input.pressedKeys.indexOf( Input.KEY_SHIFT ) >= 0;

        if ( code === Input.KEY_TAB ) {

          // Move the focus to the next item
          // TODO: More general focus order strategy
          var deltaIndex = shiftPressed ? -1 : +1;
          Input.moveFocus( deltaIndex );

          //TODO: Moving focus first then dispatching to focused node means newly focused node gets a fresh TAB event
          //TODO: That is probably undesirable
        }

        var key = new scenery.Key( event );
        this.addPointer( key );

        var focusedTrail = Input.focusedTrail;
        if ( focusedTrail ) {
          this.dispatchEvent( focusedTrail, 'down', key, event, true );
        }
      },

      keyUp: function( event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'keyUp(' + Input.debugKeyEvent( event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'keyUp(' + Input.serializeDomEvent( event ) + ');' ); }

        // temporary disabling
        if ( true ) { //eslint-disable-line no-constant-condition
          // if ( !this.display.options.accessibility ) {
          return;
        }

        var code = event.which;

        // Better remove all occurences, just in case!
        while ( true ) { //eslint-disable-line no-constant-condition
          var index = Input.pressedKeys.indexOf( code );

          if ( index > -1 ) {
            Input.pressedKeys.splice( index, 1 );
          }
          else {
            break;
          }
        }

        var key = this.findKeyByEvent( event );
        if ( key ) {
          this.removePointer( key );
          var focusedTrail = Input.focusedTrail;
          if ( focusedTrail ) {
            this.dispatchEvent( focusedTrail, 'up', key, event, true );
          }
        }
      },

      // called on mouse wheels
      wheel: function( event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'wheel(' + Input.debugKeyEvent( event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'wheel(' + Input.serializeDomEvent( event ) + ');' ); }
        if ( !this.mouse ) { this.initMouse(); }
        this.mouse.wheel( event );

        // don't send mouse-wheel events if we don't yet have a mouse location!
        // TODO: Can we set the mouse location based on the wheel event?
        if ( this.mouse.point ) {
          var trail = this.rootNode.trailUnderPointer( this.mouse ) || new scenery.Trail( this.rootNode );
          this.dispatchEvent( trail, 'wheel', this.mouse, event, true );
        }
      },

      // called for each touch point
      touchStart: function( id, point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchStart(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        var touch = new scenery.Touch( id, point, event );
        this.addPointer( touch );
        this.downEvent( touch, event );
      },

      touchEnd: function( id, point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchEnd(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        var touch = this.findTouchById( id );
        if ( touch ) {
          var pointChanged = touch.end( point, event );
          if ( pointChanged ) {
            this.moveEvent( touch, event );
          }
          this.removePointer( touch );
          this.upEvent( touch, event );
        }
        else {
          assert && assert( false, 'Touch not found for touchEnd: ' + id );
        }
      },

      touchMove: function( id, point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchMove(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        var touch = this.findTouchById( id );
        if ( touch ) {
          touch.move( point, event );
          this.moveEvent( touch, event );
        }
        else {
          assert && assert( false, 'Touch not found for touchMove: ' + id );
        }
      },

      touchCancel: function( id, point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchCancel(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        var touch = this.findTouchById( id );
        if ( touch ) {
          var pointChanged = touch.cancel( point, event );
          if ( pointChanged ) {
            this.moveEvent( touch, event );
          }
          this.removePointer( touch );
          this.cancelEvent( touch, event );
        }
        else {
          assert && assert( false, 'Touch not found for touchCancel: ' + id );
        }
      },

      // called for each touch point
      penStart: function( id, point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penStart(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        var pen = new scenery.Pen( id, point, event );
        this.addPointer( pen );
        this.downEvent( pen, event );
      },

      penEnd: function( id, point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penEnd(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        var pen = this.findTouchById( id );
        if ( pen ) {
          var pointChanged = pen.end( point, event );
          if ( pointChanged ) {
            this.moveEvent( pen, event );
          }
          this.removePointer( pen );
          this.upEvent( pen, event );
        }
        else {
          assert && assert( false, 'Pen not found for penEnd: ' + id );
        }
      },

      penMove: function( id, point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penMove(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        var pen = this.findTouchById( id );
        if ( pen ) {
          pen.move( point, event );
          this.moveEvent( pen, event );
        }
        else {
          assert && assert( false, 'Pen not found for penMove: ' + id );
        }
      },

      penCancel: function( id, point, event ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penCancel(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
        if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
        var pen = this.findTouchById( id );
        if ( pen ) {
          var pointChanged = pen.cancel( point, event );
          if ( pointChanged ) {
            this.moveEvent( pen, event );
          }
          this.removePointer( pen );
          this.cancelEvent( pen, event );
        }
        else {
          assert && assert( false, 'Pen not found for penCancel: ' + id );
        }
      },

      pointerDown: function( id, type, point, event ) {
        switch( type ) {
          case 'mouse':
            // In IE for pointer down events, we want to make sure than the next interactions off the page are sent to
            // this element (it will bubble). See https://github.com/phetsims/scenery/issues/464 and
            // http://news.qooxdoo.org/mouse-capturing.
            var target = ( this.listenerTarget === window || this.listenerTarget === document ) ? document.body : this.listenerTarget;
            if ( target.setPointerCapture && event.pointerId ) {
              target.setPointerCapture( event.pointerId );
            }
            // The actual event afterwards
            this.mouseDown( point, event );
            break;
          case 'touch':
            this.touchStart( id, point, event );
            break;
          case 'pen':
            this.penStart( id, point, event );
            break;
          default:
            if ( console.log ) {
              console.log( 'Unknown pointer type: ' + type );
            }
        }
      },

      pointerUp: function( id, type, point, event ) {
        switch( type ) {
          case 'mouse':
            this.mouseUp( point, event );
            break;
          case 'touch':
            this.touchEnd( id, point, event );
            break;
          case 'pen':
            this.penEnd( id, point, event );
            break;
          default:
            if ( console.log ) {
              console.log( 'Unknown pointer type: ' + type );
            }
        }
      },

      pointerCancel: function( id, type, point, event ) {
        switch( type ) {
          case 'mouse':
            if ( console && console.log ) {
              console.log( 'WARNING: Pointer mouse cancel was received' );
            }
            break;
          case 'touch':
            this.touchCancel( id, point, event );
            break;
          case 'pen':
            this.penCancel( id, point, event );
            break;
          default:
            if ( console.log ) {
              console.log( 'Unknown pointer type: ' + type );
            }
        }
      },

      pointerMove: function( id, type, point, event ) {
        switch( type ) {
          case 'mouse':
            this.mouseMove( point, event );
            break;
          case 'touch':
            this.touchMove( id, point, event );
            break;
          case 'pen':
            this.penMove( id, point, event );
            break;
          default:
            if ( console.log ) {
              console.log( 'Unknown pointer type: ' + type );
            }
        }
      },

      pointerOver: function( id, type, point, event ) {

      },

      pointerOut: function( id, type, point, event ) {

      },

      pointerEnter: function( id, type, point, event ) {

      },

      pointerLeave: function( id, type, point, event ) {

      },

      upEvent: function( pointer, event ) {
        var trail = this.rootNode.trailUnderPointer( pointer ) || new scenery.Trail( this.rootNode );

        this.dispatchEvent( trail, 'up', pointer, event, true );

        // touch pointers are transient, so fire exit/out to the trail afterwards
        if ( pointer.isTouch ) {
          this.exitEvents( pointer, event, trail, 0, true );
        }

        pointer.trail = trail;
      },

      downEvent: function( pointer, event ) {
        var trail = this.rootNode.trailUnderPointer( pointer ) || new scenery.Trail( this.rootNode );

        // touch pointers are transient, so fire enter/over to the trail first
        if ( pointer.isTouch ) {
          this.enterEvents( pointer, event, trail, 0, true );
        }

        this.dispatchEvent( trail, 'down', pointer, event, true );

        pointer.trail = trail;
      },

      moveEvent: function( pointer, event ) {
        var changed = this.branchChangeEvents( pointer, event, true );
        if ( changed ) {
          sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'branch change due to move event' );
        }
      },

      cancelEvent: function( pointer, event ) {
        var trail = this.rootNode.trailUnderPointer( pointer ) || new scenery.Trail( this.rootNode );

        this.dispatchEvent( trail, 'cancel', pointer, event, true );

        // touch pointers are transient, so fire exit/out to the trail afterwards
        if ( pointer.isTouch ) {
          this.exitEvents( pointer, event, trail, 0, true );
        }

        pointer.trail = trail;
      },

      // return whether there was a change
      branchChangeEvents: function( pointer, event, isMove ) {
        var trail = this.rootNode.trailUnderPointer( pointer ) || new scenery.Trail( this.rootNode );
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
          'checking branch change: ' + trail.toString() + ' at ' + pointer.point.toString() );
        var oldTrail = pointer.trail || new scenery.Trail( this.rootNode ); // TODO: consider a static trail reference

        var lastNodeChanged = oldTrail.lastNode() !== trail.lastNode();
        if ( !lastNodeChanged && !isMove ) {
          // bail out if nothing needs to be done
          return false;
        }

        var branchIndex = scenery.Trail.branchIndex( trail, oldTrail );
        var isBranchChange = branchIndex !== trail.length || branchIndex !== oldTrail.length;
        isBranchChange && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
          'branch change from ' + oldTrail.toString() + ' to ' + trail.toString() );

        // event order matches http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
        if ( isMove ) {
          this.dispatchEvent( trail, 'move', pointer, event, true );
        }

        // we want to approximately mimic http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
        // TODO: if a node gets moved down 1 depth, it may see both an exit and enter?
        this.exitEvents( pointer, event, oldTrail, branchIndex, lastNodeChanged );
        this.enterEvents( pointer, event, trail, branchIndex, lastNodeChanged );

        pointer.trail = trail;
        return isBranchChange;
      },

      enterEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
        if ( trail.length > branchIndex ) {
          for ( var newIndex = trail.length - 1; newIndex >= branchIndex; newIndex-- ) {
            this.dispatchEvent( trail.slice( 0, newIndex + 1 ), 'enter', pointer, event, false );
          }
        }

        if ( lastNodeChanged ) {
          this.dispatchEvent( trail, 'over', pointer, event, true );
        }
      },

      exitEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
        if ( lastNodeChanged ) {
          this.dispatchEvent( trail, 'out', pointer, event, true );
        }

        if ( trail.length > branchIndex ) {
          for ( var oldIndex = branchIndex; oldIndex < trail.length; oldIndex++ ) {
            this.dispatchEvent( trail.slice( 0, oldIndex + 1 ), 'exit', pointer, event, false );
          }
        }
      },

      validatePointers: function() {
        var that = this;

        var i = this.pointers.length;
        while ( i-- ) {
          var pointer = this.pointers[ i ];
          if ( pointer.point ) {
            var changed = that.branchChangeEvents( pointer, null, false );
            if ( changed ) {
              sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'branch change due validatePointers' );
            }
          }
        }
      },

      dispatchEvent: function( trail, type, pointer, event, bubbles ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
          'Input: ' + type + ' on ' + trail.toString() + ' for pointer ' + pointer.toString() + ' at ' + pointer.point.toString() );
        assert && assert( trail, 'Falsy trail for dispatchEvent' );

        // TODO: is there a way to make this event immutable?
        var inputEvent = new scenery.Event( {
          trail: trail, // {Trail} path to the leaf-most node, ordered list, from root to leaf
          type: type, // {String} what event was triggered on the listener
          pointer: pointer, // {Pointer}
          domEvent: event, // raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)
          currentTarget: null, // {Node} whatever node you attached the listener to, null when passed to a Pointer,
          target: trail.lastNode() // {Node} leaf-most node in trail
        } );

        // first run through the pointer's listeners to see if one of them will handle the event
        this.dispatchToPointer( type, pointer, inputEvent );

        // if not yet handled, run through the trail in order to see if one of them will handle the event
        // at the base of the trail should be the scene node, so the scene will be notified last
        this.dispatchToTargets( trail, pointer, type, inputEvent, bubbles );
      },

      // TODO: reduce code sharing between here and dispatchToTargets!
      dispatchToPointer: function( type, pointer, inputEvent ) {
        if ( inputEvent.aborted || inputEvent.handled ) {
          return;
        }

        var specificType = pointer.type + type; // e.g. mouseup, touchup

        var pointerListeners = pointer.listeners.slice( 0 ); // defensive copy
        for ( var i = 0; i < pointerListeners.length; i++ ) {
          var listener = pointerListeners[ i ];

          // if a listener returns true, don't handle any more
          var aborted = false;

          if ( !aborted && listener[ specificType ] ) {
            listener[ specificType ]( inputEvent );
            aborted = inputEvent.aborted;
          }
          if ( pointer.firesGenericEvent && !aborted && listener[ type ] ) {
            listener[ type ]( inputEvent );
            aborted = inputEvent.aborted;
          }

          // bail out if the event is aborted, so no other listeners are triggered
          if ( aborted ) {
            return;
          }
        }
      },

      dispatchToTargets: function( trail, pointer, type, inputEvent, bubbles ) {
        if ( inputEvent.aborted || inputEvent.handled ) {
          return;
        }

        var specificType = pointer.type + type; // e.g. mouseup, touchup

        for ( var i = trail.length - 1; i >= 0; bubbles ? i-- : i = -1 ) {
          var target = trail.nodes[ i ];
          inputEvent.currentTarget = target;

          var listeners = target.getInputListeners();

          for ( var k = 0; k < listeners.length; k++ ) {
            var listener = listeners[ k ];

            // if a listener returns true, don't handle any more
            var aborted = false;

            if ( !aborted && listener[ specificType ] ) {
              listener[ specificType ]( inputEvent );
              aborted = inputEvent.aborted;
            }
            if ( pointer.firesGenericEvent && !aborted && listener[ type ] ) {
              listener[ type ]( inputEvent );
              aborted = inputEvent.aborted;
            }

            // bail out if the event is aborted, so no other listeners are triggered
            if ( aborted ) {
              return;
            }
          }

          // if the input event was handled, don't follow the trail down another level
          if ( inputEvent.handled ) {
            return;
          }
        }
      }
    },

    // Statics
    {


      serializeDomEvent: function serializeDomEvent( domEvent ) {
        var lines = [];
        for ( var prop in domEvent ) {
          if ( domEventPropertiesToSerialize[ prop ] ) {

            // stringifying dom event object properties can cause circular references, so we avoid that completely
            if ( prop === 'touches' || prop === 'targetTouches' || prop === 'changedTouches' ) {
              var arr = [];
              for ( var i = 0; i < domEvent[ prop ].length; i++ ) {

                // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList
                var touch = domEvent[ prop ].item( i );
                arr.push( serializeDomEvent( touch ) );
              }
              lines.push( prop + ':[' + arr.join( ',' ) + ']' );
            }
            else {
              lines.push( prop + ':' + ( ( typeof domEvent[ prop ] === 'object' ) && ( domEvent[ prop ] !== null ) ? '{}' : JSON.stringify( domEvent[ prop ] ) ) );
            }
          }
        }
        return '{' + lines.join( ',' ) + '}';
      },

      serializeVector2: function( vector ) {
        return 'new dot.Vector2(' + vector.x + ',' + vector.y + ')';
      },

      debugKeyEvent: function( domEvent ) {
        return domEvent.timeStamp + ' ' + domEvent.type;
      },

      debugText: function( vector, domEvent ) {
        return vector.x + ',' + vector.y + ' ' + domEvent.timeStamp + ' ' + domEvent.type;
      },

      // maps the current MS pointer types onto the pointer spec
      msPointerType: function( evt ) {
        if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_TOUCH ) {
          return 'touch';
        }
        else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_PEN ) {
          return 'pen';
        }
        else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_MOUSE ) {
          return 'mouse';
        }
        else {
          return evt.pointerType; // hope for the best
        }
      },

      /*---------------------------------------------------------------------------*
       * Accessibility Support (TODO: Should this move to another file?)
       *----------------------------------------------------------------------------*/

      // Since only one element can have focus, Scenery uses a static element to track node focus.  That is, even
      // if there are multiple Displays, only one Node (across all displays) will have focus in this frame.
      focusedTrailProperty: new Property( null ),

      // ES5 getter and setter for axon-style convenience (reportedly at a performance cost)
      get focusedTrail() {
        return Input.focusedTrailProperty.get();
      },

      set focusedTrail( trail ) {
        Input.focusedTrailProperty.set( trail );
      },

      /**
       * Adds the entire list of trails from the parent instance into the list.  List is modified in-place and returned.
       * This is very expensive (linear in the size of the scene graph), so use sparingly.  Currently used for focus
       * traversal.
       * @param trail
       * @param list
       * @param predicate
       */
      flattenTrails: function( parentTrail, trail, list, predicate ) {
        while ( trail !== null ) {
          if ( predicate( trail ) && trail.isExtensionOf( parentTrail, true ) ) {
            list.push( trail );
          }
          trail = trail.next();
        }
      },

      getAllFocusableTrails: function() {
        var focusableTrails = [];
        var focusable = function( trail ) {
          return trail.isFocusable() && trail.isVisible();
        };

        // If a focus context (such as a popup) has been added, restrict the search to that instances and its children.
        if ( Input.focusContexts.length ) {
          Input.flattenTrails( Input.focusContexts[ Input.focusContexts.length - 1 ].trail, Input.focusContexts[ Input.focusContexts.length - 1 ].trail, focusableTrails, focusable );
        }
        else {
          var display = globalDisplay;

          var rootNode = display.rootNode;
          var trails = rootNode.getTrails();

          for ( var k = 0; k < trails.length; k++ ) {
            var trail = trails[ k ];

            // Add to the list of all focusable items across Displays & Trails
            Input.flattenTrails( trail, trail, focusableTrails, focusable );
          }
        }
        return focusableTrails;
      },

      getNextFocusableTrail: function( deltaIndex ) {

        // TODO: Should we persist this list across frames and do deltas for performance?
        // TODO: We used to, but it was difficult to handle instances added/removed
        // TODO: And on OSX/Chrome this seems to have good enough performance (didn't notice any qualitative slowdown)
        // TODO: Perhaps test on Mobile Safari?
        // TODO: Also, using a pattern like this could make it difficult to customize the focus traversal regions.
        var focusableTrails = Input.getAllFocusableTrails();

        //If the focused instance was null, find the first focusable element.
        if ( Input.focusedTrail === null ) {

          return focusableTrails[ 0 ];
        }
        else {
          //Find the index of the currently focused instance, and look for the next focusable instance.
          //TODO: this will fail horribly if the old node was removed, for instance.
          //TODO: Will need to be generalized, etc.

          var currentlyFocusedTrail = indexOfUsingEquality( focusableTrails, Input.focusedTrail );
          var newIndex = currentlyFocusedTrail + deltaIndex;
          //console.log( focusableInstances.length, currentlyFocusedInstance, newIndex );

          //TODO: These loops probably not too smart here, may be better as math.
          while ( newIndex < 0 ) {
            newIndex += focusableTrails.length;
          }
          while ( newIndex >= focusableTrails.length ) {
            newIndex -= focusableTrails.length;
          }

          return focusableTrails[ newIndex ];
        }
      },

      // Move the focus to the next focusable element.  Called by AccessibilityLayer.
      moveFocus: function( deltaIndex ) {
        Input.focusedTrail = Input.getNextFocusableTrail( deltaIndex );
      },

      // A focusContext is a node that focus is restricted to.  If the list is empty, then anything in the application
      // can be focused.  This is used when showing dialogs that will restrict focus.  The reason this is a stack is that
      // dialogs can spawn other dialogs.  When a dialog is dismissed, focus should return to the component that had focus
      // before the dialog was shown.
      // @private Could be a private closure var, but left public for ease of debugging.
      focusContexts: [],

      pushFocusContext: function( trail ) {
        Input.focusContexts.push( {
          trail: trail,
          previousFocusedNode: Input.focusedTrail
        } );

        // Move focus to the 1st element in the new context, but only if the focus subsystem is enabled
        // Simulation do not show focus regions unless the user has pressed tab once
        if ( Input.focusedTrail ) {
          Input.focusedTrail = Input.getAllFocusableTrails()[ 0 ];
        }
      },

      /**
       * Removes the last focus context, such as when a dialog is dismissed.  The dialog's instance is required as an argument
       * so it can be verified that it was the top element on the stack.
       */
      popFocusContext: function( trail ) {
        var top = Input.focusContexts.pop();
        assert && assert( top.trail.equals( trail ) );

        // Restore focus to the node that had focus before the popup was shown (if it still exists), but only if the
        // focus subsystem is enabled.  Simulation do not show focus regions unless the user has pressed tab once
        if ( Input.focusedTrail ) {
          Input.focusedTrail = top.previousFocusedNode;
        }
      },

      // Keep track of which keys are currently pressed so we know whether the shift key is down for accessibility
      // TODO: this effort is duplicated with this.pointers (which also covers different things)
      // TODO: Should they be coalesced?
      pressedKeys: [],

      // Export some key codes for reuse in listeners.
      // TODO: See if these can be replaced by DOM/Browser API support
      KEY_SPACE: 32,
      KEY_ENTER: 13,
      KEY_TAB: 9,
      KEY_RIGHT_ARROW: 39,
      KEY_LEFT_ARROW: 37,
      KEY_UP_ARROW: 38,
      KEY_DOWN_ARROW: 40,
      KEY_SHIFT: 16,
      KEY_ESCAPE: 27
    } );
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Creates and references a stylesheet that can be built up while Scenery is loading.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/SceneryStyle',['require','SCENERY/scenery'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var styleElement = document.createElement( 'style' );
  styleElement.type = 'text/css';
  document.head.appendChild( styleElement );

  var stylesheet = document.styleSheets[ document.styleSheets.length - 1 ];
  assert && assert( stylesheet.disabled === false );

  return scenery.register( 'SceneryStyle', {
    stylesheet: stylesheet,
    styleElement: styleElement,

    addRule: function( ruleString ) {
      // using a this reference so it doesn't need to be a closure
      this.stylesheet.insertRule( ruleString, 0 );
    }
  } );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A Path draws a Shape with a specific type of fill and stroke.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Path',['require','PHET_CORE/inherit','KITE/Shape','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/nodes/Paintable','SCENERY/display/SVGSelfDrawable','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );

  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepSVGPathElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  function Path( shape, options ) {
    // TODO: consider directly passing in a shape object (or at least handling that case)
    // NOTE: _shape can be lazily constructed, in the case of types like Rectangle where they have their own drawing code
    this._shape = null;
    this._strokedShape = null; // a stroked copy of the shape, lazily computed

    // boundsMethod determines how our (self) bounds are computed, and can particularly determine how expensive
    // to compute our bounds are if we are stroked. There are the following options:
    // 'accurate' - Always uses the most accurate way of getting bounds
    // 'unstroked' - Ignores any stroke, just gives the filled bounds.
    //               If there is a stroke, the bounds will be marked as inaccurate
    // 'tightPadding' - Pads the filled bounds by enough to cover everything except mitered joints.
    //                   If there is a stroke, the bounds wil be marked as inaccurate.
    // 'safePadding' - Pads the filled bounds by enough to cover all line joins/caps.
    // 'none' - Returns Bounds2.NOTHING. The bounds will be marked as inaccurate.
    this._boundsMethod = 'accurate'; // 'accurate', 'unstroked', 'tightPadding', 'safePadding', 'none'

    // ensure we have a parameter object
    options = options || {};

    // Used as a listener to Shapes for when they are invalidated
    this._invalidShapeListener = this.invalidateShape.bind( this );

    this.initializePaintable();

    Node.call( this );
    this.invalidateSupportedRenderers();

    // Set up the boundsMethod first before setting the Shape, see https://github.com/phetsims/scenery/issues/489
    if ( options.boundsMethod ) {
      this.setBoundsMethod( options.boundsMethod );
    }
    this.setShape( shape );

    this.mutate( options );
  }

  scenery.register( 'Path', Path );

  inherit( Node, Path, {
    // allow more specific path types (Rectangle, Line) to override what restrictions we have
    getPathRendererBitmask: function() {
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG;
    },

    invalidateSupportedRenderers: function() {
      this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getPathRendererBitmask() );
    },

    // sets the shape drawn, or null to remove the shape
    setShape: function( shape ) {
      if ( this._shape !== shape ) {
        // Remove Shape invalidation listener if applicable
        if ( this._shape ) {
          this._shape.offStatic( 'invalidated', this._invalidShapeListener );
        }

        if ( typeof shape === 'string' ) {
          // be content with setShape always invalidating the shape?
          shape = new Shape( shape );
        }
        this._shape = shape;
        this.invalidateShape();

        // Add Shape invalidation listener if applicable
        if ( this._shape ) {
          this._shape.onStatic( 'invalidated', this._invalidShapeListener );
        }
      }
      return this;
    },
    set shape( value ) { this.setShape( value ); },

    getShape: function() {
      return this._shape;
    },
    get shape() { return this.getShape(); },

    getStrokedShape: function() {
      if ( !this._strokedShape ) {
        this._strokedShape = this.getShape().getStrokedShape( this._lineDrawingStyles );
      }
      return this._strokedShape;
    },

    /**
     * Invalidates the Shape stored itself. Should mainly only be called on Path itself, not subtypes like
     * Line/Rectangle/Circle/etc. once constructed.
     */
    invalidateShape: function() {
      this.invalidatePath();

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyShape(); // subtypes of Path may not have this, but it's called during construction
      }
    },

    /**
     * Invalidates the self-bounds, that could have changed from different things.
     */
    invalidatePath: function() {
      this._strokedShape = null;

      this.invalidateSelf(); // We don't immediately compute the bounds
    },

    /**
     * @override
     *
     * @returns {boolean}
     */
    updateSelfBounds: function() {
      var selfBounds = this.hasShape() ? this.computeShapeBounds() : Bounds2.NOTHING;
      var changed = !selfBounds.equals( this._selfBounds );
      if ( changed ) {
        this._selfBounds.set( selfBounds );
      }
      return changed;
    },

    setBoundsMethod: function( boundsMethod ) {
      assert && assert( boundsMethod === 'accurate' ||
                        boundsMethod === 'unstroked' ||
                        boundsMethod === 'tightPadding' ||
                        boundsMethod === 'safePadding' ||
                        boundsMethod === 'none' );
      if ( this._boundsMethod !== boundsMethod ) {
        this._boundsMethod = boundsMethod;
        this.invalidatePath();

        this.trigger0( 'boundsMethod' );

        this.trigger0( 'selfBoundsValid' ); // whether our self bounds are valid may have changed
      }
      return this;
    },
    set boundsMethod( value ) { return this.setBoundsMethod( value ); },

    getBoundsMethod: function() {
      return this._boundsMethod;
    },
    get boundsMethod() { return this.getBoundsMethod(); },

    // separated out, so that we can override this with a faster version in subtypes. includes the Stroke, if any
    computeShapeBounds: function() {
      // boundsMethod: 'none' will return no bounds
      if ( this._boundsMethod === 'none' ) {
        return Bounds2.NOTHING;
      }
      else {
        // boundsMethod: 'unstroked', or anything without a stroke will then just use the normal shape bounds
        if ( !this.hasStroke() || this.getLineWidth() === 0 || this._boundsMethod === 'unstroked' ) {
          return this.getShape().bounds;
        }
        else {
          // 'accurate' will always require computing the full stroked shape, and taking its bounds
          if ( this._boundsMethod === 'accurate' ) {
            return this.getShape().getStrokedBounds( this.getLineStyles() );
          }
          // Otherwise we compute bounds based on 'tightPadding' and 'safePadding', the one difference being that
          // 'safePadding' will include whatever bounds necessary to include miters. Square line-cap requires a
          // slightly extended bounds in either case.
          else {
            var factor;
            // If miterLength (inside corner to outside corner) exceeds miterLimit * strokeWidth, it will get turned to
            // a bevel, so our factor will be based just on the miterLimit.
            if ( this._boundsMethod === 'safePadding' && this.getLineJoin() === 'miter' ) {
              factor = this.getMiterLimit();
            }
            else if ( this.getLineCap() === 'square' ) {
              factor = Math.SQRT2;
            }
            else {
              factor = 1;
            }
            return this.getShape().bounds.dilated( factor * this.getLineWidth() / 2 );
          }
        }
      }
    },

    // @override
    areSelfBoundsValid: function() {
      if ( this._boundsMethod === 'accurate' || this._boundsMethod === 'safePadding' ) {
        return true;
      }
      else if ( this._boundsMethod === 'none' ) {
        return false;
      }
      else {
        return !this.hasStroke(); // 'tightPadding' and 'unstroked' options
      }
    },

    // @override
    getTransformedSelfBounds: function( matrix ) {
      return ( this._stroke ? this.getStrokedShape() : this.getShape() ).getBoundsWithTransform( matrix );
    },

    // hook stroke mixin changes to invalidation
    invalidateStroke: function() {
      this.invalidatePath();
      this.trigger0( 'selfBoundsValid' ); // Stroke changing could have changed our self-bounds-validitity (unstroked/etc)
    },

    hasShape: function() {
      return this._shape;
    },

    canvasPaintSelf: function( wrapper ) {
      Path.PathCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },

    createSVGDrawable: function( renderer, instance ) {
      return Path.PathSVGDrawable.createFromPool( renderer, instance );
    },

    createCanvasDrawable: function( renderer, instance ) {
      return Path.PathCanvasDrawable.createFromPool( renderer, instance );
    },

    createWebGLDrawable: function( renderer, instance ) {
      return Path.PathWebGLDrawable.createFromPool( renderer, instance );
    },

    isPainted: function() {
      return true;
    },

    // override for computation of whether a point is inside the self content
    // point is considered to be in the local coordinate frame
    containsPointSelf: function( point ) {
      var result = false;
      if ( !this.hasShape() ) {
        return result;
      }

      // if this node is fillPickable, we will return true if the point is inside our fill area
      if ( this._fillPickable ) {
        result = this.getShape().containsPoint( point );
      }

      // also include the stroked region in the hit area if strokePickable
      if ( !result && this._strokePickable ) {
        result = this.getStrokedShape().containsPoint( point );
      }
      return result;
    },

    // whether this node's self intersects the specified bounds, in the local coordinate frame
    intersectsBoundsSelf: function( bounds ) {
      // TODO: should a shape's stroke be included?
      return this.hasShape() ? this._shape.intersectsBounds( bounds ) : false;
    },

    // if we have to apply a transform workaround for https://github.com/phetsims/scenery/issues/196 (only when we have a pattern or gradient)
    requiresSVGBoundsWorkaround: function() {
      if ( !this._stroke || !this._stroke.getSVGDefinition || !this.hasShape() ) {
        return false;
      }

      var bounds = this.computeShapeBounds( false ); // without stroke
      return bounds.x * bounds.y === 0; // at least one of them was zero, so the bounding box has no area
    },

    getDebugHTMLExtras: function() {
      return this._shape ? ' (<span style="color: #88f" onclick="window.open( \'data:text/plain;charset=utf-8,\' + encodeURIComponent( \'' + this._shape.getSVGPath() + '\' ) );">path</span>)' : '';
    },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.Path( ' + ( this._shape ? this._shape.toString() : this._shape ) + ', {' + propLines + '} )';
    },

    getPropString: function( spaces, includeChildren ) {
      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
      result = this.appendFillablePropString( spaces, result );
      result = this.appendStrokablePropString( spaces, result );
      return result;
    }
  } );

  Path.prototype._mutatorKeys = [ 'boundsMethod', 'shape' ].concat( Node.prototype._mutatorKeys );

  // mix in fill/stroke handling code. for now, this is done after 'shape' is added to the mutatorKeys so that stroke parameters
  // get set first
  Paintable.mixin( Path );

  /*---------------------------------------------------------------------------*
   * Rendering State mixin (DOM/SVG)
   *----------------------------------------------------------------------------*/

  Path.PathStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      // initializes, and resets (so we can support pooled states)
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true; // flag that is marked if ANY "paint" dirty flag is set (basically everything except for transforms, so we can accelerated the transform-only case)
        this.dirtyShape = true;

        // adds fill/stroke-specific flags and state
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      proto.disposeState = function() {
        this.disposePaintableState();
      };

      // catch-all dirty, if anything that isn't a transform is marked as dirty
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyShape = function() {
        this.dirtyShape = true;
        this.markPaintDirty();
      };

      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyShape = false;
      };

      Paintable.PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  /*---------------------------------------------------------------------------*
   * SVG Rendering
   *----------------------------------------------------------------------------*/

  Path.PathSVGDrawable = function PathSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( SVGSelfDrawable, Path.PathSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGPathElements ); // usesPaint: true

      if ( !this.svgElement ) {
        this.svgElement = document.createElementNS( scenery.svgns, 'path' );
      }

      return this;
    },

    updateSVGSelf: function() {
      assert && assert( !this.node.requiresSVGBoundsWorkaround(),
        'No workaround for https://github.com/phetsims/scenery/issues/196 is provided at this time, please add an epsilon' );

      var path = this.svgElement;
      if ( this.dirtyShape ) {
        var svgPath = this.node.hasShape() ? this.node._shape.getSVGPath() : '';

        // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980
        // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing
        // the attribute can cause this bug
        if ( !svgPath ) { svgPath = 'M0 0'; }

        // only set the SVG path if it's not the empty string
        path.setAttribute( 'd', svgPath );
      }

      this.updateFillStrokeStyle( path );
    }
  } );
  Path.PathStatefulDrawable.mixin( Path.PathSVGDrawable );
  SelfDrawable.Poolable.mixin( Path.PathSVGDrawable );

  /*---------------------------------------------------------------------------*
   * Canvas rendering
   *----------------------------------------------------------------------------*/

  Path.PathCanvasDrawable = function PathCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( CanvasSelfDrawable, Path.PathCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;

      if ( node.hasShape() ) {
        // TODO: fill/stroke delay optimizations?
        context.beginPath();
        node._shape.writeToContext( context );

        if ( node.hasFill() ) {
          node.beforeCanvasFill( wrapper ); // defined in Paintable
          context.fill();
          node.afterCanvasFill( wrapper ); // defined in Paintable
        }

        // Do not render strokes in Canvas if the lineWidth is 0, see https://github.com/phetsims/scenery/issues/523
        if ( node.hasStroke() && node.getLineWidth() > 0 ) {
          node.beforeCanvasStroke( wrapper ); // defined in Paintable
          context.stroke();
          node.afterCanvasStroke( wrapper ); // defined in Paintable
        }
      }
    },

    // stateless dirty functions
    markDirtyShape: function() { this.markPaintDirty(); },

    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  Paintable.PaintableStatelessDrawable.mixin( Path.PathCanvasDrawable );
  SelfDrawable.Poolable.mixin( Path.PathCanvasDrawable );

  return Path;
} );



// Copyright 2013-2015, University of Colorado Boulder

/**
 * TODO docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid
 */

define( 'SCENERY/display/WebGLSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  function WebGLSelfDrawable( renderer, instance ) {
    this.initializeWebGLSelfDrawable( renderer, instance );

    throw new Error( 'Should use initialization and pooling' );
  }

  scenery.register( 'WebGLSelfDrawable', WebGLSelfDrawable );

  inherit( SelfDrawable, WebGLSelfDrawable, {
    initializeWebGLSelfDrawable: function( renderer, instance ) {
      // super initialization
      this.initializeSelfDrawable( renderer, instance );

      // this is the same across lifecycles
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );

      // when our relative transform changes, notify us in the pre-repaint phase
      instance.relativeTransform.addListener( this.transformListener );

      // trigger precomputation of the relative transform, since we will always need it when it is updated
      instance.relativeTransform.addPrecompute();

      return this;
    },

    markTransformDirty: function() {
      this.markDirty();
    },

    // @override
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );

      // mark us as dirty when our self visibility changes
      this.markDirty();
    },

    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();

      SelfDrawable.prototype.dispose.call( this );
    }
  } );

  return WebGLSelfDrawable;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A rectangular node that inherits Path, and allows for optimized drawing,
 * and improved rectangle handling.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Rectangle',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Path','KITE/Shape','DOT/Bounds2','DOT/Vector2','DOT/Dimension2','DOT/Matrix3','AXON/Property','SCENERY/util/Features','SCENERY/nodes/Paintable','SCENERY/display/DOMSelfDrawable','SCENERY/display/SVGSelfDrawable','SCENERY/display/CanvasSelfDrawable','SCENERY/display/WebGLSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/Renderer','SCENERY/util/Color'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Property = require( 'AXON/Property' );
  var Features = require( 'SCENERY/util/Features' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Color = require( 'SCENERY/util/Color' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepDOMRectangleElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory
  var keepSVGRectangleElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  // scratch matrix used in DOM rendering
  var scratchMatrix = Matrix3.dirtyFromPool();

  /**
   * @constructor
   * @public
   *
   * Possible constructor signatures
   * new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius, [options] )
   * new Rectangle( x, y, width, height, [options] )
   * new Rectangle( [options] )
   * new Rectangle( bounds2, [options] )
   * new Rectangle( bounds2, cornerXRadius, cornerYRadius, [options] )
   *
   * Available parameters to the various constructor options:
   * @param {number} x - x-position of the upper-left corner (left bound)
   * @param {number} y - y-position of the upper-left corner (top bound)
   * @param {number} width - width of the rectangle to the right of the upper-left corner, required to be >= 0
   * @param {number} height - height of the rectangle below the upper-left corner, required to be >= 0
   * @param {number} cornerXRadius - positive vertical radius (width) of the rounded corner, or 0 to indicate the corner should be sharp
   * @param {number} cornerYRadius - positive horizontal radius (height) of the rounded corner, or 0 to indicate the corner should be sharp
   * @param {Object} [options] - Options object for Scenery
   *
   * Current available options for the options object (custom for Rectangle, not Path or Node):
   * rectX - Left edge of the rectangle in the local coordinate frame
   * rectY - Top edge of the rectangle in the local coordinate frame
   * rectWidth - Width of the rectangle in the local coordinate frame
   * rectHeight - Height of the rectangle in the local coordinate frame
   * cornerXRadius - The x-axis radius for elliptical/circular rounded corners.
   * cornerYRadius - The y-axis radius for elliptical/circular rounded corners.
   * cornerRadius - Sets both "X" and "Y" corner radii above.
   *
   * NOTE: the X and Y corner radii need to both be greater than zero for rounded corners to appear. If they have the
   * same non-zero value, circular rounded corners will be used.
   */
  function Rectangle( x, y, width, height, cornerXRadius, cornerYRadius, options ) {
    if ( typeof x === 'object' ) {
      if ( x instanceof Bounds2 ) {
        // allow new Rectangle( bounds2, { ... } ) or new Rectangle( bounds2, cornerXRadius, cornerYRadius, options )
        this._rectX = x.minX;
        this._rectY = x.minY;
        this._rectWidth = x.width;
        this._rectHeight = x.height;
        if ( arguments.length < 3 ) {
          // Rectangle( bounds2, { ... } )
          options = y;
          this._cornerXRadius = 0;
          this._cornerYRadius = 0;
        }
        else {
          // Rectangle( bounds2, cornerXRadius, cornerYRadius, { ... } )
          options = height;
          this._cornerXRadius = y;
          this._cornerYRadius = width;
        }
      }
      else {
        // allow new Rectangle( { rectX: x, rectY: y, rectWidth: width, rectHeight: height, ... } )
        // the mutators will call invalidateRectangle() and properly set the shape
        options = x;
        this._rectX = options.rectX || 0;
        this._rectY = options.rectY || 0;
        this._rectWidth = options.rectWidth;
        this._rectHeight = options.rectHeight;
        this._cornerXRadius = options.cornerXRadius || 0;
        this._cornerYRadius = options.cornerYRadius || 0;
      }
    }
    else if ( arguments.length < 6 ) {
      // new Rectangle( x, y, width, height, [options] )
      this._rectX = x;
      this._rectY = y;
      this._rectWidth = width;
      this._rectHeight = height;
      this._cornerXRadius = 0;
      this._cornerYRadius = 0;

      // ensure we have a parameter object
      options = cornerXRadius || {};

    }
    else {
      // normal case with args (including cornerXRadius / cornerYRadius)
      this._rectX = x;
      this._rectY = y;
      this._rectWidth = width;
      this._rectHeight = height;
      this._cornerXRadius = cornerXRadius;
      this._cornerYRadius = cornerYRadius;

      // ensure we have a parameter object
      options = options || {};

    }
    // fallback for non-canvas or non-svg rendering, and for proper bounds computation

    Path.call( this, null, options );
  }

  scenery.register( 'Rectangle', Rectangle );

  inherit( Path, Rectangle, {

    getMaximumArcSize: function() {
      return Math.min( this._rectWidth / 2, this._rectHeight / 2 );
    },

    getStrokeRendererBitmask: function() {
      var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
      // DOM stroke handling doesn't YET support gradients, patterns, or dashes (with the current implementation, it shouldn't be too hard)
      if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern && !this.hasLineDash() ) {
        // we can't support the bevel line-join with our current DOM rectangle display
        if ( this.getLineJoin() === 'miter' || ( this.getLineJoin() === 'round' && Features.borderRadius ) ) {
          bitmask |= Renderer.bitmaskDOM;
        }
      }

      if ( !this.hasStroke() ) {
        bitmask |= Renderer.bitmaskWebGL;
      }

      return bitmask;
    },

    getPathRendererBitmask: function() {
      var bitmask = Renderer.bitmaskCanvas | Renderer.bitmaskSVG;

      var maximumArcSize = this.getMaximumArcSize();

      // If the top/bottom or left/right strokes touch and overlap in the middle (small rectangle, big stroke), our DOM method won't work.
      // Additionally, if we're handling rounded rectangles or a stroke with lineJoin 'round', we'll need borderRadius
      // We also require for DOM that if it's a rounded rectangle, it's rounded with circular arcs (for now, could potentially do a transform trick!)
      if ( ( !this.hasStroke() || ( this.getLineWidth() <= this._rectHeight && this.getLineWidth() <= this._rectWidth ) ) &&
           ( !this.isRounded() || ( Features.borderRadius && this._cornerXRadius === this._cornerYRadius ) ) &&
           this._cornerYRadius <= maximumArcSize && this._cornerXRadius <= maximumArcSize ) {
        bitmask |= Renderer.bitmaskDOM;
      }

      // TODO: why check here, if we also check in the 'stroke' portion?
      if ( !this.hasStroke() && !this.isRounded() ) {
        bitmask |= Renderer.bitmaskWebGL;
      }

      return bitmask;
    },

    setRect: function( x, y, width, height, arcWidth, arcHeight ) {
      assert && assert( x !== undefined && y !== undefined && width !== undefined && height !== undefined, 'x/y/width/height need to be defined' );

      // for now, check whether this is needed
      // TODO: note that this could decrease performance? Remove if this is a bottleneck
      if ( this._rectX === x &&
           this._rectY === y &&
           this._rectWidth === width &&
           this._rectHeight === height &&
           this._cornerXRadius === arcWidth &&
           this._cornerYRadius === arcHeight ) {
        return;
      }

      this._rectX = x;
      this._rectY = y;
      this._rectWidth = width;
      this._rectHeight = height;
      this._cornerXRadius = arcWidth || 0;
      this._cornerYRadius = arcHeight || 0;

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyRectangle();
      }
      this.invalidateRectangle();
    },

    // sets the Rectangle's x/y/width/height from the {Bounds2} bounds passed in.
    setRectBounds: function( bounds ) {
      assert && assert( bounds instanceof Bounds2 );

      this.setRect( bounds.x, bounds.y, bounds.width, bounds.height );
    },
    set rectBounds( value ) { this.setRectBounds( value ); },

    // gets a {Bounds2} from the Rectangle's x/y/width/height
    getRectBounds: function() {
      return Bounds2.rect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
    },
    get rectBounds() { return this.getRectBounds(); },

    // sets the Rectangle's width/height from the {Dimension2} size passed in.
    setRectSize: function( size ) {
      assert && assert( size instanceof Dimension2 );

      this.setRectWidth( size.width );
      this.setRectHeight( size.height );
    },
    set rectSize( value ) { this.setRectSize( value ); },

    // gets a {Dimension2} from the Rectangle's width/height
    getRectSize: function() {
      return new Dimension2( this._rectWidth, this._rectHeight );
    },
    get rectSize() { return this.getRectSize(); },

    // sets the width of the rectangle while keeping its right edge (x + width) in the same position
    setRectWidthFromRight: function( width ) {
      assert && assert( typeof width === 'number' );

      if ( this._rectWidth !== width ) {
        var right = this._rectX + this._rectWidth;
        this.setRectWidth( width );
        this.setRectX( right - width );
      }
    },
    set rectWidthFromRight( value ) { this.setRectWidthFromRight( value ); },
    get rectWidthFromRight() { return this.getRectWidth(); }, // because JSHint complains

    // sets the height of the rectangle while keeping its bottom edge (y + height) in the same position
    setRectHeightFromBottom: function( height ) {
      assert && assert( typeof height === 'number' );

      if ( this._rectHeight !== height ) {
        var bottom = this._rectY + this._rectHeight;
        this.setRectHeight( height );
        this.setRectY( bottom - height );
      }
    },
    set rectHeightFromBottom( value ) { this.setRectHeightFromBottom( value ); },
    get rectHeightFromBottom() { return this.getRectHeight(); }, // because JSHint complains

    isRounded: function() {
      return this._cornerXRadius !== 0 && this._cornerYRadius !== 0;
    },

    computeShapeBounds: function() {
      var bounds = new Bounds2( this._rectX, this._rectY, this._rectX + this._rectWidth, this._rectY + this._rectHeight );
      if ( this._stroke ) {
        // since we are axis-aligned, any stroke will expand our bounds by a guaranteed set amount
        bounds = bounds.dilated( this.getLineWidth() / 2 );
      }
      return bounds;
    },

    // @override, since Path's general function would slow us down (we're a rectangle, our local coordinate frame is perfect for this)
    getTransformedSelfBounds: function( matrix ) {
      return this.selfBounds.transformed( matrix );
    },

    createRectangleShape: function() {
      if ( this.isRounded() ) {
        // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other
        var maximumArcSize = Math.min( this._rectWidth / 2, this._rectHeight / 2 );
        return Shape.roundRectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight,
          Math.min( maximumArcSize, this._cornerXRadius ), Math.min( maximumArcSize, this._cornerYRadius ) );
      }
      else {
        return Shape.rectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
      }
    },

    invalidateRectangle: function() {
      assert && assert( isFinite( this._rectX ), 'A rectangle needs to have a finite x (' + this._rectX + ')' );
      assert && assert( isFinite( this._rectY ), 'A rectangle needs to have a finite y (' + this._rectY + ')' );
      assert && assert( this._rectWidth >= 0 && isFinite( this._rectWidth ),
        'A rectangle needs to have a non-negative finite width (' + this._rectWidth + ')' );
      assert && assert( this._rectHeight >= 0 && isFinite( this._rectHeight ),
        'A rectangle needs to have a non-negative finite height (' + this._rectHeight + ')' );
      assert && assert( this._cornerXRadius >= 0 && isFinite( this._cornerXRadius ),
        'A rectangle needs to have a non-negative finite arcWidth (' + this._cornerXRadius + ')' );
      assert && assert( this._cornerYRadius >= 0 && isFinite( this._cornerYRadius ),
        'A rectangle needs to have a non-negative finite arcHeight (' + this._cornerYRadius + ')' );
      // assert && assert( !this.isRounded() || ( this._rectWidth >= this._cornerXRadius * 2 && this._rectHeight >= this._cornerYRadius * 2 ),
      //                                 'The rounded sections of the rectangle should not intersect (the length of the straight sections shouldn\'t be negative' );

      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;

      // should invalidate the path and ensure a redraw
      this.invalidatePath();

      // since we changed the rectangle arc width/height, it could make DOM work or not
      this.invalidateSupportedRenderers();
    },

    // accelerated hit detection for axis-aligned optionally-rounded rectangle
    // fast computation if it isn't rounded. if rounded, we check if a corner computation is needed (usually isn't), and only check that one needed corner
    containsPointSelf: function( point ) {
      var x = this._rectX;
      var y = this._rectY;
      var width = this._rectWidth;
      var height = this._rectHeight;
      var arcWidth = this._cornerXRadius;
      var arcHeight = this._cornerYRadius;
      var halfLine = this.getLineWidth() / 2;

      var result = true;
      if ( this._strokePickable ) {
        // test the outer boundary if we are stroke-pickable (if also fill-pickable, this is the only test we need)
        var rounded = this.isRounded();
        if ( !rounded && this.getLineJoin() === 'bevel' ) {
          // fall-back for bevel
          return Path.prototype.containsPointSelf.call( this, point );
        }
        var miter = this.getLineJoin() === 'miter' && !rounded;
        result = result && Rectangle.intersects( x - halfLine, y - halfLine,
            width + 2 * halfLine, height + 2 * halfLine,
            miter ? 0 : ( arcWidth + halfLine ), miter ? 0 : ( arcHeight + halfLine ),
            point );
      }

      if ( this._fillPickable ) {
        if ( this._strokePickable ) {
          return result;
        }
        else {
          return Rectangle.intersects( x, y, width, height, arcWidth, arcHeight, point );
        }
      }
      else if ( this._strokePickable ) {
        return result && !Rectangle.intersects( x + halfLine, y + halfLine,
            width - 2 * halfLine, height - 2 * halfLine,
            arcWidth - halfLine, arcHeight - halfLine,
            point );
      }
      else {
        return false; // either fill nor stroke is pickable
      }
    },

    intersectsBoundsSelf: function( bounds ) {
      return !this.computeShapeBounds().intersection( bounds ).isEmpty();
    },

    canvasPaintSelf: function( wrapper ) {
      Rectangle.RectangleCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },

    createDOMDrawable: function( renderer, instance ) {
      return Rectangle.RectangleDOMDrawable.createFromPool( renderer, instance );
    },

    createSVGDrawable: function( renderer, instance ) {
      return Rectangle.RectangleSVGDrawable.createFromPool( renderer, instance );
    },

    createCanvasDrawable: function( renderer, instance ) {
      return Rectangle.RectangleCanvasDrawable.createFromPool( renderer, instance );
    },

    createWebGLDrawable: function( renderer, instance ) {
      return Rectangle.RectangleWebGLDrawable.createFromPool( renderer, instance );
    },

    /*---------------------------------------------------------------------------*
     * Miscellaneous
     *----------------------------------------------------------------------------*/

    getBasicConstructor: function( propLines ) {
      return 'new scenery.Rectangle( ' +
             this._rectX + ', ' + this._rectY + ', ' +
             this._rectWidth + ', ' + this._rectHeight + ', ' +
             this._cornerXRadius + ', ' + this._cornerYRadius +
             ', {' + propLines + '} )';
    },

    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Rectangle to something non-null' );
      }
      else {
        // probably called from the Path constructor
        this.invalidatePath();
      }
    },

    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createRectangleShape();
      }
      return this._shape;
    },

    hasShape: function() {
      return true;
    },

    getCornerRadius: function() {
      assert && assert( this._cornerXRadius === this._cornerYRadius,
        'getCornerRadius() invalid if x/y radii are different' );

      return this._cornerXRadius;
    },
    get cornerRadius() { return this.getCornerRadius(); },

    setCornerRadius: function( cornerRadius ) {
      this.setCornerXRadius( cornerRadius );
      this.setCornerYRadius( cornerRadius );
      return this;
    },
    set cornerRadius( value ) { this.setCornerRadius( value ); }
  } );

  /*---------------------------------------------------------------------------*
   * Other Rectangle properties and ES5
   *----------------------------------------------------------------------------*/

  function addRectProp( name, setGetCapitalized, eventName ) {
    var getName = 'get' + setGetCapitalized;
    var setName = 'set' + setGetCapitalized;
    var privateName = '_' + name;
    var dirtyMethodName = 'markDirty' + eventName;

    Rectangle.prototype[ getName ] = function() {
      return this[ privateName ];
    };

    Rectangle.prototype[ setName ] = function( value ) {
      if ( this[ privateName ] !== value ) {
        this[ privateName ] = value;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          var state = this._drawables[ i ];
          state[ dirtyMethodName ]();
          state.markPaintDirty();
        }
        this.invalidateRectangle();
      }
      return this;
    };

    Object.defineProperty( Rectangle.prototype, name, {
      set: Rectangle.prototype[ setName ],
      get: Rectangle.prototype[ getName ]
    } );
  }

  addRectProp( 'rectX', 'RectX', 'X' );
  addRectProp( 'rectY', 'RectY', 'Y' );
  addRectProp( 'rectWidth', 'RectWidth', 'Width' );
  addRectProp( 'rectHeight', 'RectHeight', 'Height' );
  addRectProp( 'cornerXRadius', 'CornerXRadius', 'CornerXRadius' );
  addRectProp( 'cornerYRadius', 'CornerYRadius', 'CornerYRadius' );

  // not adding mutators for now
  Rectangle.prototype._mutatorKeys = [ 'rectX', 'rectY', 'rectWidth', 'rectHeight', 'cornerRadius', 'cornerXRadius', 'cornerYRadius' ].concat( Path.prototype._mutatorKeys );

  Rectangle.intersects = function( x, y, width, height, arcWidth, arcHeight, point ) {
    var result = point.x >= x &&
                 point.x <= x + width &&
                 point.y >= y &&
                 point.y <= y + height;

    if ( !result || arcWidth <= 0 || arcHeight <= 0 ) {
      return result;
    }

    // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other
    var maximumArcSize = Math.min( width / 2, height / 2 );
    arcWidth = Math.min( maximumArcSize, arcWidth );
    arcHeight = Math.min( maximumArcSize, arcHeight );

    // we are rounded and inside the logical rectangle (if it didn't have rounded corners)

    // closest corner arc's center (we assume the rounded rectangle's arcs are 90 degrees fully, and don't intersect)
    var closestCornerX;
    var closestCornerY;
    var guaranteedInside = false;

    // if we are to the inside of the closest corner arc's center, we are guaranteed to be in the rounded rectangle (guaranteedInside)
    if ( point.x < x + width / 2 ) {
      closestCornerX = x + arcWidth;
      guaranteedInside = guaranteedInside || point.x >= closestCornerX;
    }
    else {
      closestCornerX = x + width - arcWidth;
      guaranteedInside = guaranteedInside || point.x <= closestCornerX;
    }
    if ( guaranteedInside ) { return true; }

    if ( point.y < y + height / 2 ) {
      closestCornerY = y + arcHeight;
      guaranteedInside = guaranteedInside || point.y >= closestCornerY;
    }
    else {
      closestCornerY = y + height - arcHeight;
      guaranteedInside = guaranteedInside || point.y <= closestCornerY;
    }
    if ( guaranteedInside ) { return true; }

    // we are now in the rectangular region between the logical corner and the center of the closest corner's arc.

    // offset from the closest corner's arc center
    var offsetX = point.x - closestCornerX;
    var offsetY = point.y - closestCornerY;

    // normalize the coordinates so now we are dealing with a unit circle
    // (technically arc, but we are guaranteed to be in the area covered by the arc, so we just consider the circle)
    // NOTE: we are rounded, so both arcWidth and arcHeight are non-zero (this is well defined)
    offsetX /= arcWidth;
    offsetY /= arcHeight;

    offsetX *= offsetX;
    offsetY *= offsetY;
    return offsetX + offsetY <= 1; // return whether we are in the rounded corner. see the formula for an ellipse
  };

  Rectangle.rect = function( x, y, width, height, options ) {
    return new Rectangle( x, y, width, height, 0, 0, options );
  };

  Rectangle.roundedRect = function( x, y, width, height, arcWidth, arcHeight, options ) {
    return new Rectangle( x, y, width, height, arcWidth, arcHeight, options );
  };

  Rectangle.bounds = function( bounds, options ) {
    return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, 0, 0, options );
  };

  Rectangle.roundedBounds = function( bounds, arcWidth, arcHeight, options ) {
    return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, arcWidth, arcHeight, options );
  };

  /*---------------------------------------------------------------------------*
   * Rendering state mixin (DOM/SVG)
   *----------------------------------------------------------------------------*/

  Rectangle.RectangleStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      // initializes, and resets (so we can support pooled states)
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true; // flag that is marked if ANY "paint" dirty flag is set (basically everything except for transforms, so we can accelerated the transform-only case)
        this.dirtyX = true;
        this.dirtyY = true;
        this.dirtyWidth = true;
        this.dirtyHeight = true;
        this.dirtyCornerXRadius = true;
        this.dirtyCornerYRadius = true;

        // adds fill/stroke-specific flags and state
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      proto.disposeState = function() {
        this.disposePaintableState();
      };

      // catch-all dirty, if anything that isn't a transform is marked as dirty
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyRectangle = function() {
        // TODO: consider bitmask instead?
        this.dirtyX = true;
        this.dirtyY = true;
        this.dirtyWidth = true;
        this.dirtyHeight = true;
        this.dirtyCornerXRadius = true;
        this.dirtyCornerYRadius = true;
        this.markPaintDirty();
      };

      proto.markDirtyX = function() {
        this.dirtyX = true;
        this.markPaintDirty();
      };
      proto.markDirtyY = function() {
        this.dirtyY = true;
        this.markPaintDirty();
      };
      proto.markDirtyWidth = function() {
        this.dirtyWidth = true;
        this.markPaintDirty();
      };
      proto.markDirtyHeight = function() {
        this.dirtyHeight = true;
        this.markPaintDirty();
      };
      proto.markDirtyCornerXRadius = function() {
        this.dirtyCornerXRadius = true;
        this.markPaintDirty();
      };
      proto.markDirtyCornerYRadius = function() {
        this.dirtyCornerYRadius = true;
        this.markPaintDirty();
      };

      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyX = false;
        this.dirtyY = false;
        this.dirtyWidth = false;
        this.dirtyHeight = false;
        this.dirtyCornerXRadius = false;
        this.dirtyCornerYRadius = false;
      };

      Paintable.PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  /*---------------------------------------------------------------------------*
   * DOM rendering
   *----------------------------------------------------------------------------*/

  var RectangleDOMDrawable = Rectangle.RectangleDOMDrawable = inherit( DOMSelfDrawable, function RectangleDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }, {
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );

      // only create elements if we don't already have them (we pool visual states always, and depending on the platform may also pool the actual elements to minimize
      // allocation and performance costs)
      if ( !this.fillElement || !this.strokeElement ) {
        var fillElement = this.fillElement = document.createElement( 'div' );
        fillElement.style.display = 'block';
        fillElement.style.position = 'absolute';
        fillElement.style.left = '0';
        fillElement.style.top = '0';
        fillElement.style.pointerEvents = 'none';

        var strokeElement = this.strokeElement = document.createElement( 'div' );
        strokeElement.style.display = 'block';
        strokeElement.style.position = 'absolute';
        strokeElement.style.left = '0';
        strokeElement.style.top = '0';
        strokeElement.style.pointerEvents = 'none';
        fillElement.appendChild( strokeElement );
      }

      this.domElement = this.fillElement;

      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    updateDOM: function() {
      var node = this.node;
      var fillElement = this.fillElement;
      var strokeElement = this.strokeElement;

      if ( this.paintDirty ) {
        var borderRadius = Math.min( node._cornerXRadius, node._cornerYRadius );
        var borderRadiusDirty = this.dirtyCornerXRadius || this.dirtyCornerYRadius;

        if ( this.dirtyWidth ) {
          fillElement.style.width = node._rectWidth + 'px';
        }
        if ( this.dirtyHeight ) {
          fillElement.style.height = node._rectHeight + 'px';
        }
        if ( borderRadiusDirty ) {
          fillElement.style[ Features.borderRadius ] = borderRadius + 'px'; // if one is zero, we are not rounded, so we do the min here
        }
        if ( this.dirtyFill ) {
          fillElement.style.backgroundColor = node.getCSSFill();
        }

        if ( this.dirtyStroke ) {
          // update stroke presence
          if ( node.hasStroke() ) {
            strokeElement.style.borderStyle = 'solid';
          }
          else {
            strokeElement.style.borderStyle = 'none';
          }
        }

        if ( node.hasStroke() ) {
          // since we only execute these if we have a stroke, we need to redo everything if there was no stroke previously.
          // the other option would be to update stroked information when there is no stroke (major performance loss for fill-only rectangles)
          var hadNoStrokeBefore = this.lastStroke === null;

          if ( hadNoStrokeBefore || this.dirtyWidth || this.dirtyLineWidth ) {
            strokeElement.style.width = ( node._rectWidth - node.getLineWidth() ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyHeight || this.dirtyLineWidth ) {
            strokeElement.style.height = ( node._rectHeight - node.getLineWidth() ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyLineWidth ) {
            strokeElement.style.left = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.top = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.borderWidth = node.getLineWidth() + 'px';
          }

          if ( hadNoStrokeBefore || this.dirtyStroke ) {
            strokeElement.style.borderColor = node.getSimpleCSSStroke();
          }

          if ( hadNoStrokeBefore || borderRadiusDirty || this.dirtyLineWidth || this.dirtyLineOptions ) {
            strokeElement.style[ Features.borderRadius ] = ( node.isRounded() || node.getLineJoin() === 'round' ) ? ( borderRadius + node.getLineWidth() / 2 ) + 'px' : '0';
          }
        }
      }

      // shift the element vertically, postmultiplied with the entire transform.
      if ( this.transformDirty || this.dirtyX || this.dirtyY ) {
        scratchMatrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( node._rectX, node._rectY );
        scratchMatrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( scratchMatrix, this.fillElement, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToClean();
    },

    setToClean: function() {
      this.setToCleanState();

      this.cleanPaintableState();

      this.transformDirty = false;
    },

    dispose: function() {
      this.disposeState();

      if ( !keepDOMRectangleElements ) {
        // clear the references
        this.fillElement = null;
        this.strokeElement = null;
        this.domElement = null;
      }

      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  Rectangle.RectangleStatefulDrawable.mixin( RectangleDOMDrawable );
  SelfDrawable.Poolable.mixin( RectangleDOMDrawable );

  /*---------------------------------------------------------------------------*
   * SVG rendering
   *----------------------------------------------------------------------------*/

  Rectangle.RectangleSVGDrawable = function RectangleSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( SVGSelfDrawable, Rectangle.RectangleSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGRectangleElements ); // usesPaint: true

      this.lastArcW = -1; // invalid on purpose
      this.lastArcH = -1; // invalid on purpose

      if ( !this.svgElement ) {
        this.svgElement = document.createElementNS( scenery.svgns, 'rect' );
      }

      return this;
    },

    updateSVGSelf: function() {
      var rect = this.svgElement;

      if ( this.dirtyX ) {
        rect.setAttribute( 'x', this.node._rectX );
      }
      if ( this.dirtyY ) {
        rect.setAttribute( 'y', this.node._rectY );
      }
      if ( this.dirtyWidth ) {
        rect.setAttribute( 'width', this.node._rectWidth );
      }
      if ( this.dirtyHeight ) {
        rect.setAttribute( 'height', this.node._rectHeight );
      }
      if ( this.dirtyCornerXRadius || this.dirtyCornerYRadius || this.dirtyWidth || this.dirtyHeight ) {
        var arcw = 0;
        var arch = 0;

        // workaround for various browsers if rx=20, ry=0 (behavior is inconsistent, either identical to rx=20,ry=20, rx=0,ry=0. We'll treat it as rx=0,ry=0)
        // see https://github.com/phetsims/scenery/issues/183
        if ( this.node.isRounded() ) {
          var maximumArcSize = this.node.getMaximumArcSize();
          arcw = Math.min( this.node._cornerXRadius, maximumArcSize );
          arch = Math.min( this.node._cornerYRadius, maximumArcSize );
        }
        if ( arcw !== this.lastArcW ) {
          this.lastArcW = arcw;
          rect.setAttribute( 'rx', arcw );
        }
        if ( arch !== this.lastArcH ) {
          this.lastArcH = arch;
          rect.setAttribute( 'ry', arch );
        }
      }

      this.updateFillStrokeStyle( rect );
    }
  } );
  Rectangle.RectangleStatefulDrawable.mixin( Rectangle.RectangleSVGDrawable );
  SelfDrawable.Poolable.mixin( Rectangle.RectangleSVGDrawable );

  /*---------------------------------------------------------------------------*
   * Canvas rendering
   *----------------------------------------------------------------------------*/

  Rectangle.RectangleCanvasDrawable = function RectangleCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( CanvasSelfDrawable, Rectangle.RectangleCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;

      // use the standard version if it's a rounded rectangle, since there is no Canvas-optimized version for that
      if ( node.isRounded() ) {
        context.beginPath();
        var maximumArcSize = node.getMaximumArcSize();
        var arcw = Math.min( node._cornerXRadius, maximumArcSize );
        var arch = Math.min( node._cornerYRadius, maximumArcSize );
        var lowX = node._rectX + arcw;
        var highX = node._rectX + node._rectWidth - arcw;
        var lowY = node._rectY + arch;
        var highY = node._rectY + node._rectHeight - arch;
        if ( arcw === arch ) {
          // we can use circular arcs, which have well defined stroked offsets
          context.arc( highX, lowY, arcw, -Math.PI / 2, 0, false );
          context.arc( highX, highY, arcw, 0, Math.PI / 2, false );
          context.arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false );
          context.arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false );
        }
        else {
          // we have to resort to elliptical arcs
          context.ellipse( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false );
          context.ellipse( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false );
          context.ellipse( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false );
          context.ellipse( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false );
        }
        context.closePath();

        if ( node.hasFill() ) {
          node.beforeCanvasFill( wrapper ); // defined in Paintable
          context.fill();
          node.afterCanvasFill( wrapper ); // defined in Paintable
        }
        if ( node.hasStroke() ) {
          node.beforeCanvasStroke( wrapper ); // defined in Paintable
          context.stroke();
          node.afterCanvasStroke( wrapper ); // defined in Paintable
        }
      }
      else {
        // TODO: how to handle fill/stroke delay optimizations here?
        if ( node.hasFill() ) {
          node.beforeCanvasFill( wrapper ); // defined in Paintable
          context.fillRect( node._rectX, node._rectY, node._rectWidth, node._rectHeight );
          node.afterCanvasFill( wrapper ); // defined in Paintable
        }
        if ( node.hasStroke() ) {
          node.beforeCanvasStroke( wrapper ); // defined in Paintable
          context.strokeRect( node._rectX, node._rectY, node._rectWidth, node._rectHeight );
          node.afterCanvasStroke( wrapper ); // defined in Paintable
        }
      }
    },

    // stateless dirty functions
    markDirtyRectangle: function() { this.markPaintDirty(); },

    markDirtyX: function() {
      this.markDirtyRectangle();
    },
    markDirtyY: function() {
      this.markDirtyRectangle();
    },
    markDirtyWidth: function() {
      this.markDirtyRectangle();
    },
    markDirtyHeight: function() {
      this.markDirtyRectangle();
    },
    markDirtyCornerXRadius: function() {
      this.markDirtyRectangle();
    },
    markDirtyCornerYRadius: function() {
      this.markDirtyRectangle();
    },

    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  Paintable.PaintableStatelessDrawable.mixin( Rectangle.RectangleCanvasDrawable );
  SelfDrawable.Poolable.mixin( Rectangle.RectangleCanvasDrawable );

  /*---------------------------------------------------------------------------*
   * WebGL rendering
   *----------------------------------------------------------------------------*/

  var scratchColor = new Color( 'transparent' );

  // NOTE: only currently supports solid fills, no strokes
  Rectangle.RectangleWebGLDrawable = inherit( WebGLSelfDrawable, function RectangleWebGLDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }, {
    webglRenderer: Renderer.webglVertexColorPolygons,

    // called either from the constructor or from pooling
    initialize: function( renderer, instance ) {
      this.initializeWebGLSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );

      if ( !this.vertexArray ) {
        // format [X Y R G B A] for all vertices
        this.vertexArray = new Float32Array( 6 * 6 ); // 6-length components for 6 vertices (2 tris).
      }

      // corner vertices in the relative transform root coordinate space
      this.upperLeft = new Vector2();
      this.lowerLeft = new Vector2();
      this.upperRight = new Vector2();
      this.lowerRight = new Vector2();

      this.transformDirty = true;
      this.includeVertices = true; // used by the processor

      return this;
    },

    onAddToBlock: function( webglBlock ) {
      this.webglBlock = webglBlock; // TODO: do we need this reference?
      this.markDirty();
    },

    onRemoveFromBlock: function( webglBlock ) {
    },

    // @override
    markTransformDirty: function() {
      this.transformDirty = true;

      WebGLSelfDrawable.prototype.markTransformDirty.call( this );
    },

    update: function() {
      if ( this.dirty ) {
        this.dirty = false;

        if ( this.dirtyFill ) {
          this.includeVertices = this.node.hasFill();

          if ( this.includeVertices ) {
            var fill = ( this.node.fill instanceof Property ) ? this.node.fill.value : this.node.fill;
            var color =  scratchColor.set( fill );
            var red = color.red / 255;
            var green = color.green / 255;
            var blue = color.blue / 255;
            var alpha = color.alpha;

            for ( var i = 0; i < 6; i++ ) {
              var offset = i * 6;
              this.vertexArray[ 2 + offset ] = red;
              this.vertexArray[ 3 + offset ] = green;
              this.vertexArray[ 4 + offset ] = blue;
              this.vertexArray[ 5 + offset ] = alpha;
            }
          }
        }

        if ( this.transformDirty || this.dirtyX || this.dirtyY || this.dirtyWidth || this.dirtyHeight ) {
          this.transformDirty = false;

          var x = this.node._rectX;
          var y = this.node._rectY;
          var width = this.node._rectWidth;
          var height = this.node._rectHeight;

          var transformMatrix = this.instance.relativeTransform.matrix; // with compute need, should always be accurate
          transformMatrix.multiplyVector2( this.upperLeft.setXY( x, y ) );
          transformMatrix.multiplyVector2( this.lowerLeft.setXY( x, y + height ) );
          transformMatrix.multiplyVector2( this.upperRight.setXY( x + width, y ) );
          transformMatrix.multiplyVector2( this.lowerRight.setXY( x + width, y + height ) );

          // first triangle XYs
          this.vertexArray[ 0 ] = this.upperLeft.x;
          this.vertexArray[ 1 ] = this.upperLeft.y;
          this.vertexArray[ 6 ] = this.lowerLeft.x;
          this.vertexArray[ 7 ] = this.lowerLeft.y;
          this.vertexArray[ 12 ] = this.upperRight.x;
          this.vertexArray[ 13 ] = this.upperRight.y;

          // second triangle XYs
          this.vertexArray[ 18 ] = this.upperRight.x;
          this.vertexArray[ 19 ] = this.upperRight.y;
          this.vertexArray[ 24 ] = this.lowerLeft.x;
          this.vertexArray[ 25 ] = this.lowerLeft.y;
          this.vertexArray[ 30 ] = this.lowerRight.x;
          this.vertexArray[ 31 ] = this.lowerRight.y;
        }
      }

      this.setToCleanState();
      this.cleanPaintableState();
    },

    dispose: function() {
      // TODO: disposal of buffers?

      // super
      WebGLSelfDrawable.prototype.dispose.call( this );
    }
  } );
  Rectangle.RectangleStatefulDrawable.mixin( Rectangle.RectangleWebGLDrawable );
  SelfDrawable.Poolable.mixin( Rectangle.RectangleWebGLDrawable ); // pooling

  return Rectangle;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Used for identifying when any ancestor transform of a node in a trail causes that node's global transform to change.
 * It also provides fast computation of that global matrix, NOT recomputing every matrix, even on most transform
 * changes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Jesse Greenberg
 */

define( 'SCENERY/util/TransformTracker',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );

  /**
   * Creates a transform-tracking object, where it can send out updates on transform changes, and also efficiently
   * compute the transform.
   * @constructor
   * @public
   *
   * @param {Trail} trail
   * @param {Object} [options]
   */
  function TransformTracker( trail, options ) {
    var tracker = this;

    options = _.extend( {
      isStatic: false // {boolean} - Whether the bounds listeners should be added with on() or onStatic().
    }, options );
    this._isStatic = options.isStatic;

    // @public {Trail}
    this.trail = trail;

    // @private {Array.<Matrix3>|null}
    // this._matrices[ i ] will be equal to: trail.nodes[ 1 ].matrix * ... * trail.nodes[ i + 1 ].matrix
    //
    this._matrices = null; // Will be initialized on first need.

    // @private {number} - this._matrices[ i ] where i >= this._dirtyIndex will need to be recomputed
    this._dirtyIndex = 0;

    // @private {Array.<Function>} - Listeners added by client, will be called on transform changes.
    this._listeners = [];

    // Hook up listeners to each Node in the trail, so we are notified of changes. Will be removed on disposal.
    this._nodeTransformListeners = [];
    for ( var j = 1; j < this.trail.length; j++ ) {
      // Wrapping with closure to prevent changes
      var nodeTransformListener = (function( index ) {
        return function() {
          tracker.onTransformChange( index );
        };
      })( j - 1 );

      this._nodeTransformListeners.push( nodeTransformListener );

      if ( this._isStatic ) {
        trail.nodes[ j ].onStatic( 'transform', nodeTransformListener );
      }
      else {
        trail.nodes[ j ].on( 'transform', nodeTransformListener );
      }
    }
  }

  scenery.register( 'TransformTracker', TransformTracker );

  inherit( Object, TransformTracker, {
    /**
     * Gets rid of all external references and listeners. This object is inoperable afterwards.
     * @public
     */
    dispose: function() {
      for ( var j = 1; j < this.trail.length; j++ ) {
        var nodeTransformListener = this._nodeTransformListeners[ j - 1 ];

        if ( this._isStatic ) {
          this.trail.nodes[ j ].offStatic( 'transform', nodeTransformListener );
        }
        else {
          this.trail.nodes[ j ].off( 'transform', nodeTransformListener );
        }
      }
    },

    /**
     * Adds a listener function that will be synchronously called whenever the transform for this Trail changes.
     * @public
     *
     * @param {Function} listener - Listener will be called with no arguments.
     */
    addListener: function( listener ) {
      assert && assert( typeof listener === 'function' );

      this._listeners.push( listener );
    },

    /**
     * Removes a listener that was previously added with addListener().
     * @public
     *
     * @param {Function} listener
     */
    removeListener: function( listener ) {
      assert && assert( typeof listener === 'function' );

      var index = _.indexOf( this._listeners, listener );
      assert && assert( index >= 0, 'TransformTracker listener not found' );

      this._listeners.splice( index, 1 );
    },

    /**
     * Notifies listeners of a transform change.
     * @private
     */
    notifyListeners: function() {
      var listeners = this._listeners;

      if ( !this._isStatic ) {
        listeners = listeners.slice();
      }

      var length = listeners.length;
      for ( var i = 0; i < length; i++ ) {
        listeners[ i ]();
      }
    },

    /**
     * Called when one of the nodes' transforms is changed.
     * @private
     *
     * @param {number} matrixIndex - The index into our matrices array, e.g. this._matrices[ matrixIndex ].
     */
    onTransformChange: function( matrixIndex ) {
      this._dirtyIndex = Math.min( this._dirtyIndex, matrixIndex );
      this.notifyListeners();
    },

    /**
     * Returns the local-to-global transformation matrix for the Trail, which transforms its leaf node's local
     * coordinate frame into the global coordinate frame.
     * @public
     *
     * NOTE: The matrix returned should not be mutated. Please make a copy if needed.
     *
     * @returns {Matrix3}
     */
    getMatrix: function() {
      if ( this._matrices === null ) {
        this._matrices = [];

        // Start at 1, so that we don't include the root node's transform
        for ( var i = 1; i < this.trail.length; i++ ) {
          this._matrices.push( new Matrix3() );
        }
      }

      // If the trail isn't long enough to have a transform, return the identity matrix
      if ( this._matrices.length <= 0 ) {
        return Matrix3.IDENTITY;
      }

      // Starting at the dirty index, recompute matrices.
      var numMatrices = this._matrices.length;
      for ( var index = this._dirtyIndex; index < numMatrices; index++ ) {
        var nodeMatrix = this.trail.nodes[ index + 1 ].matrix;

        if ( index === 0 ) {
          this._matrices[ index ].set( nodeMatrix );
        }
        else {
          this._matrices[ index ].set( this._matrices[ index - 1 ] );
          this._matrices[ index ].multiplyMatrix( nodeMatrix );
        }
      }

      // Reset the dirty index to mark all matrices as 'clean'.
      this._dirtyIndex = numMatrices;

      // Return the last matrix, which contains our composite transformation.
      return this._matrices[ numMatrices - 1 ];
    },
    get matrix() { return this.getMatrix(); }
  } );

  return TransformTracker;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Focus highlight overlay for accessible displays.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/FocusOverlay',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','SCENERY/nodes/Rectangle','SCENERY/util/Color','SCENERY/util/TransformTracker','KITE/Shape','SCENERY/nodes/Node','SCENERY/nodes/Path'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );

  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Color = require( 'SCENERY/util/Color' );
  var TransformTracker = require( 'SCENERY/util/TransformTracker' );
  var Shape = require( 'KITE/Shape' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );

  function FocusOverlay( display, focusRootNode ) {
    this.display = display; // @private {Display}
    this.focusRootNode = focusRootNode; // @private {Node} - The root Node of our child display

    // When the focus changes, all of these are modified.
    this.trail = null; // @private {Trail|null}
    this.node = null; // @private {Node|null}
    this.mode = null; // @private {String|null}
    this.transformTracker = null; // @private {TransformTracker|null}

    // @private {boolean} - If true, the next update() will trigger an update to the highlight's transform.
    this.transformDirty = true;

    // @private - The main node for the highlight. It will be transformed.
    this.highlightNode = new Node();
    this.focusRootNode.addChild( this.highlightNode );

    // @private {Display}
    this.focusDisplay = new scenery.Display( this.focusRootNode, {
      width: this.width,
      height: this.height,
      allowCSSHacks: false,
      accessibility: false,
      isApplication: false,
      interactive: false
    } );

    // @private {DOMElement}
    this.domElement = this.focusDisplay.domElement;
    this.domElement.style.pointerEvents = 'none';

    // @private Bounds highlight
    this.boundsHighlight = new Rectangle( 0, 0, 0, 0, { stroke: FocusOverlay.focusColor, visible: false } );
    this.innerBoundsHighlight = new Rectangle( 0, 0, 0, 0, { stroke: FocusOverlay.innerFocusColor } );
    this.boundsHighlight.addChild( this.innerBoundsHighlight );

    // @private Shape highlight
    this.shapeHighlight = new Path( null, { stroke: FocusOverlay.focusColor, visible: false } );
    this.innerShapeHighlight = new Path( null, { stroke: FocusOverlay.innerFocusColor } );
    this.shapeHighlight.addChild( this.innerShapeHighlight );

    // @private Node highlight
    this.nodeHighlight = null;

    this.highlightNode.addChild( this.boundsHighlight );
    this.highlightNode.addChild( this.shapeHighlight );

    // @private - Listeners bound once, so we can access them for removal.
    this.boundsListener = this.onBoundsChange.bind( this );
    this.transformListener = this.onTransformChange.bind( this );
    this.focusListener = this.onFocusChange.bind( this );

    scenery.Display.focusProperty.link( this.focusListener );
  }

  scenery.register( 'FocusOverlay', FocusOverlay );

  inherit( Object, FocusOverlay, {
    dispose: function() {
      if ( this.hasHighlight() ) {
        this.deactivateHighlight();
      }

      scenery.Display.focusProperty.unlink( this.focusListener );
    },

    hasHighlight: function() {
      return !!this.trail;
    },

    /**
     * Activates the highlight, choosing a mode for whether the highlight will be a shape, node, or bounds.
     * @private
     *
     * @param {Trail} trail - The focused trail to highlight. It assumes that this trail is in this display.
     */
    activateHighlight: function( trail ) {
      this.trail = trail;
      this.node = trail.lastNode();
      this.transformTracker = new TransformTracker( trail, {
        isStatic: true
      } );
      this.transformTracker.addListener( this.transformListener );

      // Shape mode
      if ( this.node.accessibleContent.focusHighlight instanceof Shape ) {
        this.mode = 'shape';

        this.shapeHighlight.visible = true;
        this.shapeHighlight.shape = this.innerShapeHighlight.shape = this.node.accessibleContent.focusHighlight;
      }
      // Node mode
      else if ( this.node.accessibleContent.focusHighlight instanceof Node ) {
        this.mode = 'node';

        // Use the node itself as the highlight
        this.nodeHighlight = this.node.accessibleContent.focusHighlight;
        this.highlightNode.addChild( this.nodeHighlight );
      }
      // Bounds mode
      else {
        this.mode = 'bounds';

        this.boundsHighlight.visible = true;
        this.node.onStatic( 'localBounds', this.boundsListener );

        this.onBoundsChange();
      }

      this.transformDirty = true;
    },

    /**
     * Deactivates the current highlight, disposing and removing listeners as necessary.
     * @private
     */
    deactivateHighlight: function() {
      if ( this.mode === 'shape' ) {
        this.shapeHighlight.visible = false;
      }
      else if ( this.mode === 'node' ) {
        this.highlightNode.removeChild( this.nodeHighlight );
        this.nodeHighlight = null;
      }
      else if ( this.mode === 'bounds' ) {
        this.boundsHighlight.visible = false;
        this.node.offStatic( 'localBounds', this.boundsListener );
      }

      this.trail = null;
      this.node = null;
      this.mode = null;
      this.transformTracker.removeListener( this.transformListener );
      this.transformTracker.dispose();
    },

    // Called from FocusOverlay after transforming the highlight. Only called when the transform changes.
    afterTransform: function() {
      if ( this.mode === 'shape' ) {
        this.shapeHighlight.lineWidth = 4 / this.shapeHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
        this.innerShapeHighlight.lineWidth = 2.5 / this.shapeHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
      }
      else if ( this.mode === 'bounds' ) {
        this.boundsHighlight.lineWidth = 4 / this.boundsHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
        this.innerBoundsHighlight.lineWidth = 2.5 / this.boundsHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
      }
    },

    onTransformChange: function() {
      this.transformDirty = true;
    },

    // Called when bounds change on our node when we are in "Bounds" mode
    onBoundsChange: function() {
      this.boundsHighlight.setRectBounds( this.node.localBounds );
      this.innerBoundsHighlight.setRectBounds( this.node.localBounds );
    },

    // Called when the main Scenery focus pair (Display,Trail) changes.
    onFocusChange: function( focus ) {
      var newTrail = ( focus && focus.display === this.display ) ? focus.trail : null;

      if ( this.hasHighlight() ) {
        this.deactivateHighlight();
      }

      if ( newTrail ) {
        this.activateHighlight( newTrail );
      }
    },

    update: function() {
      // Transform the highlight to match the position of the node
      if ( this.hasHighlight() && this.transformDirty ) {
        this.transformDirty = false;

        this.highlightNode.setMatrix( this.transformTracker.matrix );
        this.afterTransform();
      }

      if ( !this.display.size.equals( this.focusDisplay.size ) ) {
        this.focusDisplay.setWidthHeight( this.display.width, this.display.height );
      }
      this.focusDisplay.updateDisplay();
    }
  }, {
    focusColor: new Color( 'rgba(212,19,106,0.5)' ),
    innerFocusColor: new Color( 'rgba(250,40,135,0.9)' )
  } );

  return FocusOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Supertype for overlays that display colored shapes (updated every frame).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/ShapeBasedOverlay',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  function ShapeBasedOverlay( display, rootNode, name ) {
    this.display = display;
    this.rootNode = rootNode;

    var svg = this.svg = document.createElementNS( scenery.svgns, 'svg' );
    svg.style.position = 'absolute';
    svg.setAttribute( 'class', name );
    svg.style.top = 0;
    svg.style.left = 0;
    svg.style[ 'pointer-events' ] = 'none';

    function resize( width, height ) {
      svg.setAttribute( 'width', width );
      svg.setAttribute( 'height', height );
      svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
    }

    display.onStatic( 'displaySize', function( dimension ) {
      resize( dimension.width, dimension.height );
    } );
    resize( display.width, display.height );

    this.domElement = svg;
  }

  scenery.register( 'ShapeBasedOverlay', ShapeBasedOverlay );

  inherit( Object, ShapeBasedOverlay, {
    addShape: function( shape, color, isOffset ) {
      var path = document.createElementNS( scenery.svgns, 'path' );
      var svgPath = shape.getSVGPath();

      // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980
      // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing
      // the attribute can cause this bug
      if ( !svgPath ) { svgPath = 'M0 0'; }

      if ( svgPath ) {
        // only set the SVG path if it's not the empty string
        path.setAttribute( 'd', svgPath );
      }
      else if ( path.hasAttribute( 'd' ) ) {
        path.removeAttribute( 'd' );
      }

      path.setAttribute( 'style', 'fill: none; stroke: ' + color + '; stroke-dasharray: 5, 3; stroke-dashoffset: ' + ( isOffset ? 5 : 0 ) + '; stroke-width: 3;' );
      this.svg.appendChild( path );
    },

    update: function() {
      while ( this.svg.childNodes.length ) {
        this.svg.removeChild( this.svg.childNodes[ this.svg.childNodes.length - 1 ] );
      }

      this.addShapes();
    },

    // STUB to be overridden
    addShapes: function() {

    },

    dispose: function() {

    }
  } );

  return ShapeBasedOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Displays mouse and touch areas when they are customized. Expensive to display!
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/PointerAreaOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  function PointerAreaOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'mouseTouchAreaOverlay' );
  }

  scenery.register( 'PointerAreaOverlay', PointerAreaOverlay );

  inherit( ShapeBasedOverlay, PointerAreaOverlay, {
    // @override
    addShapes: function() {
      var self = this;

      new scenery.Trail( this.rootNode ).eachTrailUnder( function( trail ) {
        var node = trail.lastNode();
        if ( !node.isVisible() ) {
          // skip this subtree if the node is invisible
          return true;
        }
        if ( ( node.mouseArea || node.touchArea ) && trail.isVisible() ) {
          var transform = trail.getTransform();

          if ( node.mouseArea ) {
            self.addShape( transform.transformShape( node.mouseArea.isBounds ? Shape.bounds( node.mouseArea ) : node.mouseArea ), 'rgba(0,0,255,0.8)', true );
          }
          if ( node.touchArea ) {
            self.addShape( transform.transformShape( node.touchArea.isBounds ? Shape.bounds( node.touchArea ) : node.touchArea ), 'rgba(255,0,0,0.8)', false );
          }
        }
      } );
    }
  } );

  return PointerAreaOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * The PointerOverlay shows pointer locations in the scene.  This is useful when recording a session for interviews or when a teacher is broadcasting
 * a tablet session on an overhead projector.  See https://github.com/phetsims/scenery/issues/111
 *
 * Each pointer is rendered in a different <svg> so that CSS3 transforms can be used to make performance smooth on iPad.
 *
 * @author Sam Reid
 */
define( 'SCENERY/overlays/PointerOverlay',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/scenery','SCENERY/util/Trail','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  var Util = require( 'SCENERY/util/Util' );

  function PointerOverlay( display, rootNode ) {
    var pointerOverlay = this;
    this.display = display;
    this.rootNode = rootNode;

    // add element to show the pointers
    this.pointerSVGContainer = document.createElement( 'div' );
    this.pointerSVGContainer.style.position = 'absolute';
    this.pointerSVGContainer.style.top = 0;
    this.pointerSVGContainer.style.left = 0;
    this.pointerSVGContainer.style[ 'pointer-events' ] = 'none';

    var innerRadius = 10;
    var strokeWidth = 1;
    var diameter = (innerRadius + strokeWidth / 2) * 2;
    var radius = diameter / 2;

    //Resize the parent div when the rootNode is resized
    display.onStatic( 'displaySize', function( dimension ) {
      pointerOverlay.pointerSVGContainer.setAttribute( 'width', dimension.width );
      pointerOverlay.pointerSVGContainer.setAttribute( 'height', dimension.height );
      pointerOverlay.pointerSVGContainer.style.clip = 'rect(0px,' + dimension.width + 'px,' + dimension.height + 'px,0px)';
    } );

    //Display a pointer that was added.  Use a separate SVG layer for each pointer so it can be hardware accelerated, otherwise it is too slow just setting svg internal attributes
    var pointerAdded = this.pointerAdded = function( pointer ) {

      if ( pointer.isKey ) { return; }

      var svg = document.createElementNS( scenery.svgns, 'svg' );
      svg.style.position = 'absolute';
      svg.style.top = 0;
      svg.style.left = 0;
      svg.style[ 'pointer-events' ] = 'none';

      //Fit the size to the display
      svg.setAttribute( 'width', diameter );
      svg.setAttribute( 'height', diameter );

      var circle = document.createElementNS( scenery.svgns, 'circle' );

      //use css transform for performance?
      circle.setAttribute( 'cx', innerRadius + strokeWidth / 2 );
      circle.setAttribute( 'cy', innerRadius + strokeWidth / 2 );
      circle.setAttribute( 'r', innerRadius );
      circle.setAttribute( 'style', 'fill:black;' );
      circle.setAttribute( 'style', 'stroke:white;' );
      circle.setAttribute( 'opacity', 0.4 );

      //Add a move listener to the pointer to update position when it has moved
      var pointerRemoved = function() {

        //For touches that get a touch up event, remove them.  But when the mouse button is released, don't stop showing the mouse location
        if ( pointer.isTouch ) {
          pointerOverlay.pointerSVGContainer.removeChild( svg );
          pointer.removeInputListener( moveListener );
        }
      };
      var moveListener = {
        move: function() {

          //TODO: Why is point sometimes null?
          if ( pointer.point ) {

            //TODO: this allocates memory when pointers are dragging, perhaps rewrite to remove allocations
            Util.applyCSSTransform( Matrix3.translation( pointer.point.x - radius, pointer.point.y - radius ), svg );
          }
        },

        up: pointerRemoved,
        cancel: pointerRemoved
      };
      pointer.addInputListener( moveListener );

      moveListener.move();
      svg.appendChild( circle );
      pointerOverlay.pointerSVGContainer.appendChild( svg );
    };
    display._input.addPointerAddedListener( pointerAdded );

    //if there is already a mouse, add it here
    //TODO: if there already other non-mouse touches, could be added here
    if ( display._input && display._input.mouse ) {
      pointerAdded( display._input.mouse );
    }

    this.domElement = this.pointerSVGContainer;
  }

  scenery.register( 'PointerOverlay', PointerOverlay );

  inherit( Object, PointerOverlay, {
    dispose: function() {
      this.display._input.removePointerAddedListener( this.pointerAdded );
    },

    update: function() {

    }
  } );

  return PointerOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Displays CanvasNode bounds.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/CanvasNodeBoundsOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  function CanvasNodeBoundsOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'canvasNodeBoundsOverlay' );
  }

  scenery.register( 'CanvasNodeBoundsOverlay', CanvasNodeBoundsOverlay );

  inherit( ShapeBasedOverlay, CanvasNodeBoundsOverlay, {
    // @override
    addShapes: function() {
      var self = this;

      new scenery.Trail( this.rootNode ).eachTrailUnder( function( trail ) {
        var node = trail.lastNode();
        if ( !node.isVisible() ) {
          // skip this subtree if the node is invisible
          return true;
        }
        if ( ( node instanceof scenery.CanvasNode ) && trail.isVisible() ) {
          var transform = trail.getTransform();

          self.addShape( transform.transformShape( Shape.bounds( node.selfBounds ) ), 'rgba(0,255,0,0.8)', true );
        }
      } );
    }
  } );

  return CanvasNodeBoundsOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Shows the bounds of current fitted blocks.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/FittedBlockBoundsOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','DOT/Matrix3','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  function FittedBlockBoundsOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'canvasNodeBoundsOverlay' );
  }

  scenery.register( 'FittedBlockBoundsOverlay', FittedBlockBoundsOverlay );

  inherit( ShapeBasedOverlay, FittedBlockBoundsOverlay, {
    // @override
    addShapes: function() {
      var self = this;

      function processBackbone( backbone, matrix ) {
        if ( backbone.willApplyTransform ) {
          matrix = matrix.timesMatrix( backbone.backboneInstance.relativeTransform.matrix );
        }
        backbone.blocks.forEach( function( block ) {
          processBlock( block, matrix );
        } );
      }

      function processBlock( block, matrix ) {
        if ( block.fitBounds && !block.fitBounds.isEmpty() ) {
          self.addShape( Shape.bounds( block.fitBounds ).transformed( matrix ), 'rgba(255,0,0,0.8)', true );
        }
        if ( block.firstDrawable && block.lastDrawable ) {
          for ( var childDrawable = block.firstDrawable; childDrawable !== block.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            processDrawable( childDrawable, matrix );
          }
          processDrawable( block.lastDrawable, matrix );
        }
      }

      function processDrawable( drawable, matrix ) {
        // How we detect backbones (for now)
        if ( drawable.backboneInstance ) {
          processBackbone( drawable, matrix );
        }
      }

      processBackbone( this.display._rootBackbone, Matrix3.IDENTITY );
    }
  } );

  return FittedBlockBoundsOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A persistent display of a specific Node and its descendants, which is updated at discrete points in time.
 * Unlike Scenery's old Scene type, a Display is not itself a Node.
 *
 * Use display.getDOMElement or display.domElement to retrieve the Display's DOM representation.
 * Use display.updateDisplay() to trigger the visual update in the Display's DOM element.
 *
 * Internal documentation:
 *
 * Lifecycle information:
 *   Instance (create,dispose)
 *     - out of update:            Stateless stub is created synchronously when a Node's children are added where we
 *                                 have no relevant Instance.
 *     - start of update:          Creates first (root) instance if it doesn't exist (stateless stub).
 *     - synctree:                 Create descendant instances under stubs, fills in state, and marks removed subtree
 *                                 roots for disposal.
 *     - update instance disposal: Disposes root instances that were marked. This also disposes all descendant
 *                                 instances, and for every instance,
 *                                 it disposes the currently-attached drawables.
 *   Drawable (create,dispose)
 *     - synctree:                 Creates all drawables where necessary. If it replaces a self/group/shared drawable on
 *                                 the instance,
 *                                 that old drawable is marked for disposal.
 *     - update instance disposal: Any drawables attached to disposed instances are disposed themselves (see Instance
 *                                 lifecycle).
 *     - update drawable disposal: Any marked drawables that were replaced or removed from an instance (it didn't
 *                                 maintain a reference) are disposed.
 *
 *   add/remove drawables from blocks:
 *     - stitching changes pending "parents", marks for block update
 *     - backbones marked for disposal (e.g. instance is still there, just changed to not have a backbone) will mark
 *         drawables for block updates
 *     - add/remove drawables phase updates drawables that were marked
 *     - disposed backbone instances will only remove drawables if they weren't marked for removal previously (e.g. in
 *         case we are from a removed instance)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Display',['require','PHET_CORE/inherit','PHET_CORE/extend','AXON/Events','AXON/Property','DOT/Dimension2','DOT/Vector2','DOT/Matrix3','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/util/Features','SCENERY/display/BackboneDrawable','SCENERY/display/CanvasBlock','SCENERY/display/CanvasSelfDrawable','SCENERY/display/ChangeInterval','SCENERY/display/DOMSelfDrawable','SCENERY/display/Drawable','SCENERY/display/Instance','SCENERY/display/InlineCanvasCacheDrawable','SCENERY/display/Renderer','SCENERY/display/SharedCanvasCacheDrawable','SCENERY/display/SVGSelfDrawable','SCENERY/input/Input','SCENERY/util/Trail','SCENERY/accessibility/AccessibleInstance','SCENERY/util/SceneryStyle','SCENERY/overlays/FocusOverlay','SCENERY/overlays/PointerAreaOverlay','SCENERY/overlays/PointerOverlay','SCENERY/overlays/CanvasNodeBoundsOverlay','SCENERY/overlays/FittedBlockBoundsOverlay'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var Events = require( 'AXON/Events' );
  var Property = require( 'AXON/Property' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Features = require( 'SCENERY/util/Features' );
  require( 'SCENERY/display/BackboneDrawable' );
  require( 'SCENERY/display/CanvasBlock' );
  require( 'SCENERY/display/CanvasSelfDrawable' );
  var ChangeInterval = require( 'SCENERY/display/ChangeInterval' );
  require( 'SCENERY/display/DOMSelfDrawable' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Instance = require( 'SCENERY/display/Instance' );
  require( 'SCENERY/display/InlineCanvasCacheDrawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  require( 'SCENERY/display/SharedCanvasCacheDrawable' );
  require( 'SCENERY/display/SVGSelfDrawable' );
  require( 'SCENERY/input/Input' );
  require( 'SCENERY/util/Trail' );
  var AccessibleInstance = require( 'SCENERY/accessibility/AccessibleInstance' );
  var SceneryStyle = require( 'SCENERY/util/SceneryStyle' );
  var FocusOverlay = require( 'SCENERY/overlays/FocusOverlay' );
  var PointerAreaOverlay = require( 'SCENERY/overlays/PointerAreaOverlay' );
  var PointerOverlay = require( 'SCENERY/overlays/PointerOverlay' );
  var CanvasNodeBoundsOverlay = require( 'SCENERY/overlays/CanvasNodeBoundsOverlay' );
  var FittedBlockBoundsOverlay = require( 'SCENERY/overlays/FittedBlockBoundsOverlay' );

  // flags object used for determining what the cursor should be underneath a mouse
  var isMouseFlags = { isMouse: true };

  /*
   * Constructs a Display that will show the rootNode and its subtree in a visual state. Default options provided below
   *
   * @param {Node} rootNode - Displays this node and all of its descendants
   *
   * Valid parameters in the parameter object:
   * {
   *   allowSceneOverflow: false,           // Usually anything displayed outside of this $main (DOM/CSS3 transformed SVG) is hidden with CSS overflow
   *   allowCSSHacks: true,                 // Applies styling that prevents mobile browser graphical issues
   *   enablePointerEvents: true,           // Allows pointer events / MSPointerEvent to be used on supported platforms.
   *   width: <current main width>,         // Override the main container's width
   *   height: <current main height>,       // Override the main container's height
   *   preserveDrawingBuffer: false,        // Whether WebGL Canvases should preserve their drawing buffer.
   *                                        //   WARNING!: This can significantly reduce performance if set to true.
   *   allowWebGL: true,                    // Boolean flag that indicates whether scenery is allowed to use WebGL for rendering
   *                                        // Makes it possible to disable WebGL for ease of testing on non-WebGL platforms, see #289
   *   accessibility: true                  // Whether accessibility enhancements is enabled
   *   interactive: true                    // Whether mouse/touch/keyboard inputs are enabled (if input has been added)
   */
  function Display( rootNode, options ) {
    assert && assert( rootNode, 'rootNode is a required parameter' );

    // supertype call to axon.Events (should just initialize a few properties here, notably _eventListeners and _staticEventListeners)
    Events.call( this );

    options = _.extend( {
      // initial display width
      width: ( options && options.container && options.container.clientWidth ) || 640,

      // initial display height
      height: ( options && options.container && options.container.clientHeight ) || 480,

      //OHTWO TODO: hook up allowCSSHacks
      allowCSSHacks: true,       // applies CSS styles to the root DOM element that make it amenable to interactive content
      allowSceneOverflow: false, // usually anything displayed outside of our dom element is hidden with CSS overflow
      //OHTWO TODO: hook up enablePointerEvents
      enablePointerEvents: true, // whether we should specifically listen to pointer events if we detect support
      defaultCursor: 'default',  // what cursor is used when no other cursor is specified
      backgroundColor: null,      // initial background color
      preserveDrawingBuffer: false,
      allowWebGL: true,
      accessibility: true,
      isApplication: false,      // adds the aria-role: 'application' when accessibility is enabled
      interactive: true
    }, options );
    this.options = options; // @private

    // The (integral, > 0) dimensions of the Display's DOM element (only updates the DOM element on updateDisplay())
    this._size = new Dimension2( this.options.width, this.options.height );
    this._currentSize = new Dimension2( -1, -1 ); // used to check against new size to see what we need to change

    this._rootNode = rootNode;
    this._rootNode.addRootedDisplay( this );
    this._rootBackbone = null; // to be filled in later
    this._domElement = ( options && options.container ) ?
                       scenery.BackboneDrawable.repurposeBackboneContainer( options.container ) :
                       scenery.BackboneDrawable.createDivBackbone();
    this._sharedCanvasInstances = {}; // map from Node ID to Instance, for fast lookup
    this._baseInstance = null; // will be filled with the root Instance

    // We have a monotonically-increasing frame ID, generally for use with a pattern where we can mark objects with this
    // to note that they are either up-to-date or need refreshing due to this particular frame (without having to clear
    // that information after use). This is incremented every frame
    this._frameId = 0; // {Number}

    this._dirtyTransformRoots = [];
    this._dirtyTransformRootsWithoutPass = [];

    this._instanceRootsToDispose = [];
    this._drawablesToDispose = [];

    // Block changes are handled by changing the "pending" block/backbone on drawables. We want to change them all after
    // the main stitch process has completed, so we can guarantee that a single drawable is removed from its previous
    // block before being added to a new one. This is taken care of in an updateDisplay pass after syncTree / stitching.
    this._drawablesToChangeBlock = []; // {[Drawable]}

    // Drawables have two implicit linked-lists, "current" and "old". syncTree modifies the "current" linked-list
    // information so it is up-to-date, but needs to use the "old" information also. We move updating the
    // "current" => "old" linked-list information until after syncTree and stitching is complete, and is taken care of
    // in an updateDisplay pass.
    this._drawablesToUpdateLinks = []; // {[Drawable]}

    // We store information on {ChangeInterval}s that records change interval information, that may contain references.
    // We don't want to leave those references dangling after we don't need them, so they are recorded and cleaned in
    // one of updateDisplay's phases.
    this._changeIntervalsToDispose = []; // {[ChangeInterval]}

    this._lastCursor = null;

    this._currentBackgroundCSS = null;
    this._backgroundColor = null;

    // used for shortcut animation frame functions
    this._requestAnimationFrameID = 0;

    // will be filled in with a scenery.Input if event handling is enabled
    this._input = null;
    this._interactive = this.options.interactive;

    // overlays currently being displayed.
    // API expected:
    //   .domElement
    //   .update()
    this._overlays = [];
    this._pointerOverlay = null;
    this._pointerAreaOverlay = null;
    this._canvasAreaBoundsOverlay = null;
    this._fittedBlockBoundsOverlay = null;

    // properties for fuzzMouseEvents, so that we can track the status of a persistent mouse pointer
    this._fuzzMouseIsDown = false;
    this._fuzzMousePosition = new Vector2(); // start at 0,0
    this._fuzzMouseLastMoved = false; // whether the last mouse event was a move (we skew probabilities based on this)

    if ( assert ) {
      // @private @assertion-only {boolean} - Whether we are running the paint phase of updateDisplay() for this Display.
      this._isPainting = false;
    }

    this.applyCSSHacks();

    this.setBackgroundColor( this.options.backgroundColor );

    // global reference if we have a Display (useful)
    this.scenery = scenery;

    if ( this.options.accessibility ) {
      if ( this.options.isApplication ) {
        this._domElement.setAttribute( 'aria-role', 'application' );
      }

      SceneryStyle.addRule( '.accessibility * { position: absolute; left: 0; top: 0; width: 0; height: 0, clip: rect(0,0,0,0); }' );

      this._focusRootNode = new Node();
      this._focusOverlay = new FocusOverlay( this, this._focusRootNode );
      this.addOverlay( this._focusOverlay );

      this._rootAccessibleInstance = AccessibleInstance.createFromPool( null, this, new scenery.Trail() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Display root instance: ' + this._rootAccessibleInstance.toString() );
      this._rootAccessibleInstance.addSubtree( new scenery.Trail( this._rootNode ) );

      document.body.appendChild( this._rootAccessibleInstance.peer.domElement );

      this._unsortedAccessibleInstances = [];
    }
  }

  scenery.register( 'Display', Display );

  inherit( Object, Display, extend( {
    // returns the base DOM element that will be displayed by this Display
    getDOMElement: function() {
      return this._domElement;
    },
    get domElement() { return this.getDOMElement(); },

    // updates the display's DOM element with the current visual state of the attached root node and its descendants
    updateDisplay: function() {

      //OHTWO TODO: turn off after most debugging work is done
      if ( window.sceneryDebugPause ) {
        return;
      }

      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.perfSyncTreeCount = 0;
        this.perfStitchCount = 0;
        this.perfIntervalCount = 0;
        this.perfDrawableBlockChangeCount = 0;
        this.perfDrawableOldIntervalCount = 0;
        this.perfDrawableNewIntervalCount = 0;
      }

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'updateDisplay frame ' + this._frameId );
      sceneryLog && sceneryLog.Display && sceneryLog.push();

      var firstRun = !!this._baseInstance;

      // check to see whether contents under pointers changed (and if so, send the enter/exit events) to
      // maintain consistent state
      if ( this._input ) {
        this._input.validatePointers();
      }

      // validate bounds for everywhere that could trigger bounds listeners. we want to flush out any changes, so that we can call validateBounds()
      // from code below without triggering side effects (we assume that we are not reentrant).
      this._rootNode.validateWatchedBounds();

      if ( assertSlow ) { this.options.accessibility && this._rootAccessibleInstance.auditRoot(); }

      this._baseInstance = this._baseInstance || scenery.Instance.createFromPool( this, new scenery.Trail( this._rootNode ), true, false );
      this._baseInstance.baseSyncTree();
      if ( firstRun ) {
        this.markTransformRootDirty( this._baseInstance, this._baseInstance.isTransformed ); // marks the transform root as dirty (since it is)
      }

      // update our drawable's linked lists where necessary
      while ( this._drawablesToUpdateLinks.length ) {
        this._drawablesToUpdateLinks.pop().updateLinks();
      }

      // clean change-interval information from instances, so we don't leak memory/references
      while ( this._changeIntervalsToDispose.length ) {
        this._changeIntervalsToDispose.pop().dispose();
      }

      this._rootBackbone = this._rootBackbone || this._baseInstance.groupDrawable;
      assert && assert( this._rootBackbone, 'We are guaranteed a root backbone as the groupDrawable on the base instance' );
      assert && assert( this._rootBackbone === this._baseInstance.groupDrawable, 'We don\'t want the base instance\'s groupDrawable to change' );


      if ( assertSlow ) { this._rootBackbone.audit( true, false, true ); } // allow pending blocks / dirty

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'drawable block change phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      while ( this._drawablesToChangeBlock.length ) {
        var changed = this._drawablesToChangeBlock.pop().updateBlock();
        if ( sceneryLog && scenery.isLoggingPerformance() && changed ) {
          this.perfDrawableBlockChangeCount++;
        }
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();

      if ( assertSlow ) { this._rootBackbone.audit( false, false, true ); } // allow only dirty
      if ( assertSlow ) { this._baseInstance.audit( this._frameId, false ); }

      // pre-repaint phase: update relative transform information for listeners (notification) and precomputation where desired
      this.updateDirtyTransformRoots();
      // pre-repaint phase update visibility information on instances
      this._baseInstance.updateVisibility( true, true, false );

      if ( assertSlow ) { this._baseInstance.auditVisibility( true ); }

      if ( assertSlow ) { this._baseInstance.audit( this._frameId, true ); }

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'instance root disposal phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      // dispose all of our instances. disposing the root will cause all descendants to also be disposed.
      // will also dispose attached drawables (self/group/etc.)
      while ( this._instanceRootsToDispose.length ) {
        this._instanceRootsToDispose.pop().dispose();
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();

      if ( assertSlow ) { this._rootNode.auditInstanceSubtreeForDisplay( this ); } // make sure trails are valid

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'drawable disposal phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      // dispose all of our other drawables.
      while ( this._drawablesToDispose.length ) {
        this._drawablesToDispose.pop().dispose();
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();

      if ( assertSlow ) { this._baseInstance.audit( this._frameId ); }

      if ( assert ) {
        assert( !this._isPainting, 'Display was already updating paint, may have thrown an error on the last update' );
        this._isPainting = true;
      }

      // repaint phase
      //OHTWO TODO: can anything be updated more efficiently by tracking at the Display level? Remember, we have recursive updates so things get updated in the right order!
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'repaint phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      this._rootBackbone.update();
      sceneryLog && sceneryLog.Display && sceneryLog.pop();

      if ( assert ) {
        this._isPainting = false;
      }

      if ( assertSlow ) { this._rootBackbone.audit( false, false, false ); } // allow nothing
      if ( assertSlow ) { this._baseInstance.audit( this._frameId ); }

      this.updateCursor();
      this.updateBackgroundColor();

      this.updateSize();

      if ( this._overlays.length ) {
        var zIndex = this._rootBackbone.lastZIndex;
        for ( var i = 0; i < this._overlays.length; i++ ) {
          // layer the overlays properly
          var overlay = this._overlays[ i ];
          overlay.domElement.style.zIndex = zIndex++;

          overlay.update();
        }
      }

      this._frameId++;

      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        var syncTreeMessage = 'syncTree count: ' + this.perfSyncTreeCount;
        if ( this.perfSyncTreeCount > 500 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 100 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 20 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 0 ) {
          sceneryLog.PerfVerbose && sceneryLog.PerfVerbose( syncTreeMessage );
        }

        var drawableBlockCountMessage = 'drawable block changes: ' + this.perfDrawableBlockChangeCount + ' for' +
                                        ' -' + this.perfDrawableOldIntervalCount +
                                        ' +' + this.perfDrawableNewIntervalCount;
        if ( this.perfDrawableBlockChangeCount > 200 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 60 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 10 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 0 ) {
          sceneryLog.PerfVerbose && sceneryLog.PerfVerbose( drawableBlockCountMessage );
        }
      }

      sceneryLog && sceneryLog.Display && sceneryLog.pop();
    },

    updateSize: function() {
      var sizeDirty = false;
      //OHTWO TODO: if we aren't clipping or setting background colors, can we get away with having a 0x0 container div and using absolutely-positioned children?
      if ( this._size.width !== this._currentSize.width ) {
        sizeDirty = true;
        this._currentSize.width = this._size.width;
        this._domElement.style.width = this._size.width + 'px';
      }
      if ( this._size.height !== this._currentSize.height ) {
        sizeDirty = true;
        this._currentSize.height = this._size.height;
        this._domElement.style.height = this._size.height + 'px';
      }
      if ( sizeDirty && !this.options.allowSceneOverflow ) {
        // to prevent overflow, we add a CSS clip
        //TODO: 0px => 0?
        this._domElement.style.clip = 'rect(0px,' + this._size.width + 'px,' + this._size.height + 'px,0px)';
      }
    },

    getRootNode: function() {
      return this._rootNode;
    },
    get rootNode() { return this.getRootNode(); },

    // The dimensions of the Display's DOM element
    getSize: function() {
      return this._size;
    },
    get size() { return this.getSize(); },

    getBounds: function() {
      return this._size.toBounds();
    },
    get bounds() { return this.getBounds(); },

    // size: dot.Dimension2. Changes the size that the Display's DOM element will be after the next updateDisplay()
    setSize: function( size ) {
      assert && assert( size instanceof Dimension2 );
      assert && assert( size.width % 1 === 0, 'Display.width should be an integer' );
      assert && assert( size.width > 0, 'Display.width should be greater than zero' );
      assert && assert( size.height % 1 === 0, 'Display.height should be an integer' );
      assert && assert( size.height > 0, 'Display.height should be greater than zero' );

      if ( !this._size.equals( size ) ) {
        this._size = size;

        this.trigger1( 'displaySize', this._size );
      }
    },

    setWidthHeight: function( width, height ) {
      // TODO: don't burn an instance here?
      this.setSize( new Dimension2( width, height ) );
    },

    // The width of the Display's DOM element
    getWidth: function() {
      return this._size.width;
    },
    get width() { return this.getWidth(); },

    // Sets the width that the Display's DOM element will be after the next updateDisplay(). Should be an integral value.
    setWidth: function( width ) {
      assert && assert( typeof width === 'number', 'Display.width should be a number' );

      if ( this.getWidth() !== width ) {
        // TODO: remove allocation here?
        this.setSize( new Dimension2( width, this.getHeight() ) );
      }
    },
    set width( value ) { this.setWidth( value ); },

    // The height of the Display's DOM element
    getHeight: function() {
      return this._size.height;
    },
    get height() { return this.getHeight(); },

    // Sets the height that the Display's DOM element will be after the next updateDisplay(). Should be an integral value.
    setHeight: function( height ) {
      assert && assert( typeof height === 'number', 'Display.height should be a number' );

      if ( this.getHeight() !== height ) {
        // TODO: remove allocation here?
        this.setSize( new Dimension2( this.getWidth(), height ) );
      }
    },
    set height( value ) { this.setHeight( value ); },

    // {String} (CSS), {Color} instance, or null (no background color).
    // Will be applied to the root DOM element on updateDisplay(), and no sooner.
    setBackgroundColor: function( color ) {
      assert && assert( color === null || typeof color === 'string' || color instanceof scenery.Color );

      this._backgroundColor = color;
    },
    set backgroundColor( value ) { this.setBackgroundColor( value ); },

    getBackgroundColor: function() {
      return this._backgroundColor;
    },
    get backgroundColor() { return this.getBackgroundColor(); },

    get interactive() { return this._interactive; },
    set interactive( value ) {
      this._interactive = value;
      if ( !this._interactive && this._input ) {
        this._input.clearBatchedEvents();
      }
    },

    addOverlay: function( overlay ) {
      this._overlays.push( overlay );
      this._domElement.appendChild( overlay.domElement );
    },

    removeOverlay: function( overlay ) {
      this._domElement.removeChild( overlay.domElement );
      this._overlays.splice( _.indexOf( this._overlays, overlay ), 1 );
    },

    /**
     * Returns the AccessibleInstance which has the longest trail that is an ancestor of the passed in trail. It will
     * fall back to the root accessible instance if there is no other available one.
     * @private
     *
     * @param {Trail} trail
     * @returns {AccessibleInstance}
     */
    getBaseAccessibleInstance: function( trail ) {
      // Search through trail to find longest trail extension where the leafmost node has accessible content, but does
      // not include the node that was just added.
      var i;
      for ( i = trail.length - 2; i >= 0; i-- ) {
        // break if there is accessible content for nodes along the trail, including root.
        if ( trail.nodes[ i ].accessibleContent ) {
          break;
        }
      }
      // no ancestor of the added node was accessible, so add things directly to root accessible instance.
      if ( i < 0 ) {
        return this._rootAccessibleInstance;
      }
      // otherwise, we encountered an accessible instance and i points to the leaf most node for the sub trail.
      else {
        var leafMostAccessibleNode = trail.nodes[ i ];
        var accessibleInstances = leafMostAccessibleNode._accessibleInstances;
        // look up the accessible instance given the leaf most accessible node.
        for ( var j = 0; j < accessibleInstances.length; j++ ) {
          var accessibleInstance = accessibleInstances[ j ];
          if ( trail.isExtensionOf( accessibleInstance.trail ) ) {
            return accessibleInstance;
          }
        }
      }

      throw new Error( 'A base accessible instance must be defined.' );
    },

    markUnsortedAccessibleInstance: function( accessibleInstance ) {
      this._unsortedAccessibleInstances.push( accessibleInstance );
    },

    sortAccessibleInstances: function() {
      while ( this._unsortedAccessibleInstances.length ) {
        this._unsortedAccessibleInstances.pop().sortChildren();
      }
    },

    /**
     * Called when a subtree with accessible content is added.
     * @private
     *
     * @param {Trail} trail
     */
    addAccessibleTrail: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.addAccessibleTrail ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();

      this.getBaseAccessibleInstance( trail ).addSubtree( trail );

      this.sortAccessibleInstances();

      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },

    /**
     * Called when a subtree with accessible content is removed.
     * @private
     *
     * @param {Trail} trail
     */
    removeAccessibleTrail: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.removeAccessibleTrail ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();

      this.getBaseAccessibleInstance( trail ).removeSubtree( trail );

      this.sortAccessibleInstances();

      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },

    /**
     * Called when an ancestor node's accessible content is changed.
     * @private
     *
     * @param {Trail} trail
     * @param {object} oldAccessibleContent
     * @param {object} newAccessibleContent
     */
    changedAccessibleContent: function( trail, oldAccessibleContent, newAccessibleContent ) {
      if ( !this.options.accessibility ) {
        return;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility(
        'Display.changedAccessibleContent ' + trail.toString() +
        ' old: ' + ( !!oldAccessibleContent ) +
        ' new: ' + ( !!newAccessibleContent ) );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();

      this.getBaseAccessibleInstance( trail ).removeSubtree( trail );
      this.getBaseAccessibleInstance( trail ).addSubtree( trail );

      this.sortAccessibleInstances();

      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },

    /**
     * Called when an ancestor node's accessible order is changed.
     * @private
     *
     * @param {Trail} trail
     */
    changedAccessibleOrder: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.changedAccessibleOrder ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();

      this.getBaseAccessibleInstance( trail ).markAsUnsorted();

      this.sortAccessibleInstances();

      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },

    /*
     * Returns the bitmask union of all renderers (canvas/svg/dom/webgl) that are used for display, excluding
     * BackboneDrawables (which would be DOM).
     */
    getUsedRenderersBitmask: function() {
      function renderersUnderBackbone( backbone ) {
        var bitmask = 0;
        _.each( backbone.blocks, function( block ) {
          if ( block instanceof scenery.DOMBlock && block.domDrawable instanceof scenery.BackboneDrawable ) {
            bitmask = bitmask | renderersUnderBackbone( block.domDrawable );
          }
          else {
            bitmask = bitmask | block.renderer;
          }
        } );
        return bitmask;
      }

      // only return the renderer-specific portion (no other hints, etc)
      return renderersUnderBackbone( this._rootBackbone ) & Renderer.bitmaskRendererArea;
    },

    /*
     * Called from Instances that will need a transform update (for listeners and precomputation).
     * @param passTransform {Boolean} - Whether we should pass the first transform root when validating transforms (should be true if the instance is transformed)
     */
    markTransformRootDirty: function( instance, passTransform ) {
      passTransform ? this._dirtyTransformRoots.push( instance ) : this._dirtyTransformRootsWithoutPass.push( instance );
    },

    updateDirtyTransformRoots: function() {
      sceneryLog && sceneryLog.transformSystem && sceneryLog.transformSystem( 'updateDirtyTransformRoots' );
      sceneryLog && sceneryLog.transformSystem && sceneryLog.push();
      while ( this._dirtyTransformRoots.length ) {
        this._dirtyTransformRoots.pop().relativeTransform.updateTransformListenersAndCompute( false, false, this._frameId, true );
      }
      while ( this._dirtyTransformRootsWithoutPass.length ) {
        this._dirtyTransformRootsWithoutPass.pop().relativeTransform.updateTransformListenersAndCompute( false, false, this._frameId, false );
      }
      sceneryLog && sceneryLog.transformSystem && sceneryLog.pop();
    },

    markDrawableChangedBlock: function( drawable ) {
      assert && assert( drawable instanceof Drawable );

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markDrawableChangedBlock: ' + drawable.toString() );
      this._drawablesToChangeBlock.push( drawable );
    },

    markInstanceRootForDisposal: function( instance ) {
      assert && assert( instance instanceof Instance, 'How would an instance not be an instance of an instance?!?!?' );

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markInstanceRootForDisposal: ' + instance.toString() );
      this._instanceRootsToDispose.push( instance );
    },

    markDrawableForDisposal: function( drawable ) {
      assert && assert( drawable instanceof Drawable );

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markDrawableForDisposal: ' + drawable.toString() );
      this._drawablesToDispose.push( drawable );
    },

    markDrawableForLinksUpdate: function( drawable ) {
      assert && assert( drawable instanceof Drawable );

      this._drawablesToUpdateLinks.push( drawable );
    },

    // Add a {ChangeInterval} for the "remove change interval info" phase (we don't want to leak memory/references)
    markChangeIntervalToDispose: function( changeInterval ) {
      assert && assert( changeInterval instanceof ChangeInterval );

      this._changeIntervalsToDispose.push( changeInterval );
    },

    updateBackgroundColor: function() {
      assert && assert( this._backgroundColor === null ||
                        typeof this._backgroundColor === 'string' ||
                        this._backgroundColor instanceof scenery.Color );

      var newBackgroundCSS = this._backgroundColor === null ?
                             '' :
                             ( this._backgroundColor.toCSS ?
                               this._backgroundColor.toCSS() :
                               this._backgroundColor );
      if ( newBackgroundCSS !== this._currentBackgroundCSS ) {
        this._currentBackgroundCSS = newBackgroundCSS;

        this._domElement.style.backgroundColor = newBackgroundCSS;
      }
    },

    /*---------------------------------------------------------------------------*
     * Cursors
     *----------------------------------------------------------------------------*/

    updateCursor: function() {
      if ( this._input && this._input.mouse && this._input.mouse.point ) {
        if ( this._input.mouse.cursor ) {
          sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( 'set on pointer: ' + this._input.mouse.cursor );
          return this.setSceneCursor( this._input.mouse.cursor );
        }

        //OHTWO TODO: For a display, just return an instance and we can avoid the garbage collection/mutation at the cost of the linked-list traversal instead of an array
        var mouseTrail = this._rootNode.trailUnderPoint( this._input.mouse.point, isMouseFlags );

        if ( mouseTrail ) {
          for ( var i = mouseTrail.length - 1; i >= 0; i-- ) {
            var node = mouseTrail.nodes[ i ];
            var cursor = node.getCursor();

            if ( cursor ) {
              sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( cursor + ' on ' + node.constructor.name + '#' + node.id );
              return this.setSceneCursor( cursor );
            }
          }
        }

        sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( '--- for ' + ( mouseTrail ? mouseTrail.toString() : '(no hit)' ) );
      }

      // fallback case
      return this.setSceneCursor( this.options.defaultCursor );
    },

    setSceneCursor: function( cursor ) {
      if ( cursor !== this._lastCursor ) {
        this._lastCursor = cursor;
        var customCursors = Display.customCursors[ cursor ];
        if ( customCursors ) {
          // go backwards, so the most desired cursor sticks
          for ( var i = customCursors.length - 1; i >= 0; i-- ) {
            this._domElement.style.cursor = customCursors[ i ];
          }
        }
        else {
          this._domElement.style.cursor = cursor;
        }
      }
    },

    applyCSSHacks: function() {
      // to use CSS3 transforms for performance, hide anything outside our bounds by default
      if ( !this.options.allowSceneOverflow ) {
        this._domElement.style.overflow = 'hidden';
      }

      // Prevents selection cursor issues in Safari, see https://github.com/phetsims/scenery/issues/476
      document.onselectstart = function() {
        return false;
      };

      // forward all pointer events
      this._domElement.style.msTouchAction = 'none';

      // don't allow browser to switch between font smoothing methods for text (see https://github.com/phetsims/scenery/issues/431)
      Features.setStyle( this._domElement, Features.fontSmoothing, 'antialiased' );

      if ( this.options.allowCSSHacks ) {
        // some css hacks (inspired from https://github.com/EightMedia/hammer.js/blob/master/hammer.js).
        // modified to only apply the proper prefixed version instead of spamming all of them, and doesn't use jQuery.
        Features.setStyle( this._domElement, Features.userDrag, 'none' );
        Features.setStyle( this._domElement, Features.userSelect, 'none' );
        Features.setStyle( this._domElement, Features.touchAction, 'none' );
        Features.setStyle( this._domElement, Features.touchCallout, 'none' );
        Features.setStyle( this._domElement, Features.tapHighlightColor, 'rgba(0,0,0,0)' );
      }
    },

    // TODO: consider SVG data URLs
    canvasDataURL: function( callback ) {
      this.canvasSnapshot( function( canvas ) {
        callback( canvas.toDataURL() );
      } );
    },

    // renders what it can into a Canvas (so far, Canvas and SVG layers work fine)
    canvasSnapshot: function( callback ) {
      var canvas = document.createElement( 'canvas' );
      canvas.width = this._size.width;
      canvas.height = this._size.height;

      var context = canvas.getContext( '2d' );

      //OHTWO TODO: allow actual background color directly, not having to check the style here!!!
      this._rootNode.renderToCanvas( canvas, context, function() {
        callback( canvas, context.getImageData( 0, 0, canvas.width, canvas.height ) );
      }, this.domElement.style.backgroundColor );
    },

    //TODO: reduce code duplication for handling overlays
    setPointerDisplayVisible: function( visibility ) {
      // @deprecated, Joist code calls us with undefined first....
      if ( visibility === undefined ) {
        return;
      }

      assert && assert( typeof visibility === 'boolean' );

      var hasOverlay = !!this._pointerOverlay;

      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._pointerOverlay );
          this._pointerOverlay.dispose();
          this._pointerOverlay = null;
        }
        else {
          this._pointerOverlay = new PointerOverlay( this, this._rootNode );
          this.addOverlay( this._pointerOverlay );
        }
      }
    },

    //TODO: reduce code duplication for handling overlays
    setPointerAreaDisplayVisible: function( visibility ) {
      // @deprecated, Joist code calls us with undefined first....
      if ( visibility === undefined ) {
        return;
      }

      assert && assert( typeof visibility === 'boolean' );

      var hasOverlay = !!this._pointerAreaOverlay;

      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._pointerAreaOverlay );
          this._pointerAreaOverlay.dispose();
          this._pointerAreaOverlay = null;
        }
        else {
          this._pointerAreaOverlay = new PointerAreaOverlay( this, this._rootNode );
          this.addOverlay( this._pointerAreaOverlay );
        }
      }
    },

    //TODO: reduce code duplication for handling overlays
    setCanvasNodeBoundsVisible: function( visibility ) {
      // @deprecated, Joist code calls us with undefined first....
      if ( visibility === undefined ) {
        return;
      }

      assert && assert( typeof visibility === 'boolean' );

      var hasOverlay = !!this._canvasAreaBoundsOverlay;

      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._canvasAreaBoundsOverlay );
          this._canvasAreaBoundsOverlay.dispose();
          this._canvasAreaBoundsOverlay = null;
        }
        else {
          this._canvasAreaBoundsOverlay = new CanvasNodeBoundsOverlay( this, this._rootNode );
          this.addOverlay( this._canvasAreaBoundsOverlay );
        }
      }
    },

    //TODO: reduce code duplication for handling overlays
    setFittedBlockBoundsVisible: function( visibility ) {
      // @deprecated, Joist code calls us with undefined first....
      if ( visibility === undefined ) {
        return;
      }

      assert && assert( typeof visibility === 'boolean' );

      var hasOverlay = !!this._fittedBlockBoundsOverlay;

      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._fittedBlockBoundsOverlay );
          this._fittedBlockBoundsOverlay.dispose();
          this._fittedBlockBoundsOverlay = null;
        }
        else {
          this._fittedBlockBoundsOverlay = new FittedBlockBoundsOverlay( this, this._rootNode );
          this.addOverlay( this._fittedBlockBoundsOverlay );
        }
      }
    },

    resizeOnWindowResize: function() {
      var display = this;

      var resizer = function() {
        display.setWidthHeight( window.innerWidth, window.innerHeight );
      };
      window.addEventListener( 'resize', resizer );
      resizer();
    },

    // Updates on every request animation frame. If stepCallback is passed in, it is called before updateDisplay() with
    // stepCallback( timeElapsedInSeconds )
    updateOnRequestAnimationFrame: function( stepCallback ) {
      // keep track of how much time elapsed over the last frame
      var lastTime = 0;
      var timeElapsedInSeconds = 0;

      var display = this;
      (function step() {
        display._requestAnimationFrameID = window.requestAnimationFrame( step, display._domElement );

        // calculate how much time has elapsed since we rendered the last frame
        var timeNow = new Date().getTime();
        if ( lastTime !== 0 ) {
          timeElapsedInSeconds = ( timeNow - lastTime ) / 1000.0;
        }
        lastTime = timeNow;

        stepCallback && stepCallback( timeElapsedInSeconds );
        display.updateDisplay();
      })();
    },

    cancelUpdateOnRequestAnimationFrame: function() {
      window.cancelAnimationFrame( this._requestAnimationFrameID );
    },

    initializeStandaloneEvents: function( parameters ) {
      // TODO extract similarity between standalone and fullscreen!
      var element = this._domElement;
      this.initializeEvents( _.extend( {}, {
        listenerTarget: element,
        pointFromEvent: function pointFromEvent( evt ) {
          var mainBounds = element.getBoundingClientRect();
          return Vector2.createFromPool( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );
        }
      }, parameters ) );
    },

    initializeFullscreenEvents: function( parameters ) {
      var element = this._domElement;
      this.initializeEvents( _.extend( {}, {
        listenerTarget: document,
        pointFromEvent: function pointFromEvent( evt ) {
          var mainBounds = element.getBoundingClientRect();
          return Vector2.createFromPool( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );
        }
      }, parameters ) );
    },

    initializeWindowEvents: function( parameters ) {
      this.initializeEvents( _.extend( {}, {
        listenerTarget: window,
        pointFromEvent: function pointFromEvent( evt ) {
          return Vector2.createFromPool( evt.clientX, evt.clientY );
        }
      }, parameters ) );
    },

    //OHTWO TODO: ability to disconnect event handling (useful for playground debugging)
    initializeEvents: function( parameters ) {
      assert && assert( !this._input, 'Events cannot be attached twice to a display (for now)' );

      // TODO: come up with more parameter names that have the same string length, so it looks creepier
      var pointFromEvent = parameters.pointFromEvent;
      var listenerTarget = parameters.listenerTarget;
      var batchDOMEvents = parameters.batchDOMEvents; //OHTWO TODO: hybrid batching (option to batch until an event like 'up' that might be needed for security issues)

      var input = new scenery.Input( this, listenerTarget, !!batchDOMEvents, this.options.enablePointerEvents, pointFromEvent );
      this._input = input;

      input.connectListeners();
    },

    detachEvents: function() {
      assert && assert( this._input, 'detachEvents() should be called only when events are attached' );

      this._input.disconnectListeners();
      this._input = null;
    },

    /**
     * Dispose function for Display.
     *
     * TODO: this dispose function is not complete.
     * @public
     */
    dispose: function() {
      this._rootNode.removeRootedDisplay( this );
    },

    ensureNotPainting: function() {
      assert && assert( !this._isPainting,
        'This should not be run in the call tree of updateDisplay(). If you see this, it is likely that either the ' +
        'last updateDisplay() had a thrown error and it is trying to be run again (in which case, investigate that ' +
        'error), OR code was run/triggered from inside an updateDisplay() that has the potential to cause an infinite ' +
        'loop, e.g. CanvasNode paintCanvas() call manipulating another Node, or a bounds listener that Scenery missed.' );
    },

    /**
     * Sends a number of random mouse events through the input system
     *
     * @param {number} averageEventQuantity - The average number of mouse events
     */
    fuzzMouseEvents: function( averageEventQuantity ) {
      var chance;

      // run a variable number of events, with a certain chance of bailing out (so no events are possible)
      // models a geometric distribution of events
      while ( ( chance = Math.random() ) < 1 - 1 / averageEventQuantity ) {
        var domEvent;
        if ( chance < ( this._fuzzMouseLastMoved ? 0.7 : 0.4 ) ) {
          // toggle up/down
          domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec

          // technically deprecated, but DOM4 event constructors not out yet. people on #whatwg said to use it
          domEvent.initMouseEvent( this._fuzzMouseIsDown ? 'mouseup' : 'mousedown', true, true, window, 1, // click count
            this._fuzzMousePosition.x, this._fuzzMousePosition.y, this._fuzzMousePosition.x, this._fuzzMousePosition.y,
            false, false, false, false,
            0, // button
            null );

          this._input.validatePointers();

          if ( this._fuzzMouseIsDown ) {
            this._input.mouseUp( this._fuzzMousePosition, domEvent );
            this._fuzzMouseIsDown = false;
          }
          else {
            this._input.mouseDown( this._fuzzMousePosition, domEvent );
            this._fuzzMouseIsDown = true;
          }

          this._fuzzMouseLastMoved = false;
        }
        else {
          // change the mouse position
          this._fuzzMousePosition = new Vector2(
            Math.floor( Math.random() * this.width ),
            Math.floor( Math.random() * this.height )
          );

          // our move event
          domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec

          // technically deprecated, but DOM4 event constructors not out yet. people on #whatwg said to use it
          domEvent.initMouseEvent( 'mousemove', true, true, window, 0, // click count
            this._fuzzMousePosition.x, this._fuzzMousePosition.y, this._fuzzMousePosition.x, this._fuzzMousePosition.y,
            false, false, false, false,
            0, // button
            null );

          this._input.validatePointers();
          this._input.mouseMove( this._fuzzMousePosition, domEvent );

          this._fuzzMouseLastMoved = true;
        }
      }
    },

    /**
     * Returns an HTML fragment {string} that includes a large amount of debugging information, including a view of the
     * instance tree and drawable tree.
     */
    getDebugHTML: function() {
      function str( ob ) {
        return ob ? ob.toString() : ob + '';
      }

      var headerStyle = 'font-weight: bold; font-size: 120%; margin-top: 5px;';

      var depth = 0;

      var result = '';

      result += '<div style="' + headerStyle + '">Display Summary</div>';
      result += this._size.toString() + ' frame:' + this._frameId + ' input:' + !!this._input + ' cursor:' + this._lastCursor + '<br>';

      function nodeCount( node ) {
        var count = 1; // for us
        for ( var i = 0; i < node.children.length; i++ ) {
          count += nodeCount( node.children[ i ] );
        }
        return count;
      }

      result += 'Nodes: ' + nodeCount( this._rootNode ) + '<br>';

      function instanceCount( instance ) {
        var count = 1; // for us
        for ( var i = 0; i < instance.children.length; i++ ) {
          count += instanceCount( instance.children[ i ] );
        }
        return count;
      }

      result += this._baseInstance ? ( 'Instances: ' + instanceCount( this._baseInstance ) + '<br>' ) : '';

      function drawableCount( drawable ) {
        var count = 1; // for us
        if ( drawable.blocks ) {
          // we're a backbone
          _.each( drawable.blocks, function( childDrawable ) {
            count += drawableCount( childDrawable );
          } );
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          // we're a block
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            count += drawableCount( childDrawable );
          }
          count += drawableCount( drawable.lastDrawable );
        }
        return count;
      }

      result += this._rootBackbone ? ( 'Drawables: ' + drawableCount( this._rootBackbone ) + '<br>' ) : '';

      var drawableCountMap = {}; // {string} drawable constructor name => {number} count of seen
      // increment the count in our map
      function countRetainedDrawable( drawable ) {
        var name = drawable.constructor.name;
        if ( drawableCountMap[ name ] ) {
          drawableCountMap[ name ]++;
        }
        else {
          drawableCountMap[ name ] = 1;
        }
      }

      function retainedDrawableCount( instance ) {
        var count = 0;
        if ( instance.selfDrawable ) {
          countRetainedDrawable( instance.selfDrawable );
          count++;
        }
        if ( instance.groupDrawable ) {
          countRetainedDrawable( instance.groupDrawable );
          count++;
        }
        if ( instance.sharedCacheDrawable ) {
          countRetainedDrawable( instance.sharedCacheDrawable );
          count++;
        }
        for ( var i = 0; i < instance.children.length; i++ ) {
          count += retainedDrawableCount( instance.children[ i ] );
        }
        return count;
      }

      result += this._baseInstance ? ( 'Retained Drawables: ' + retainedDrawableCount( this._baseInstance ) + '<br>' ) : '';
      for ( var drawableName in drawableCountMap ) {
        result += '&nbsp;&nbsp;&nbsp;&nbsp;' + drawableName + ': ' + drawableCountMap[ drawableName ] + '<br>';
      }

      function blockSummary( block ) {
        // ensure we are a block
        if ( !block.firstDrawable || !block.lastDrawable ) {
          return;
        }

        var hasBackbone = block.domDrawable && block.domDrawable.blocks;

        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';

        div += block.toString();
        if ( !hasBackbone ) {
          div += ' (' + block.drawableCount + ' drawables)';
        }

        div += '</div>';

        depth += 1;
        if ( hasBackbone ) {
          for ( var k = 0; k < block.domDrawable.blocks.length; k++ ) {
            div += blockSummary( block.domDrawable.blocks[ k ] );
          }
        }
        depth -= 1;

        return div;
      }

      if ( this._rootBackbone ) {
        result += '<div style="' + headerStyle + '">Block Summary</div>';
        for ( var i = 0; i < this._rootBackbone.blocks.length; i++ ) {
          result += blockSummary( this._rootBackbone.blocks[ i ] );
        }
      }

      function instanceSummary( instance ) {
        var iSummary = '';

        function addQualifier( text ) {
          iSummary += ' <span style="color: #008">' + text + '</span>';
        }

        var node = instance.node;

        iSummary += instance.id;
        iSummary += ' ' + ( node.constructor.name ? node.constructor.name : '?' );
        iSummary += ' <span style="font-weight: ' + ( node.isPainted() ? 'bold' : 'normal' ) + '">' + node.id + '</span>';
        iSummary += node.getDebugHTMLExtras();

        if ( !node.visible ) {
          addQualifier( 'invis' );
        }
        if ( !instance.visible ) {
          addQualifier( 'I-invis' );
        }
        if ( !instance.relativeVisible ) {
          addQualifier( 'I-rel-invis' );
        }
        if ( !instance.selfVisible ) {
          addQualifier( 'I-self-invis' );
        }
        if ( !instance.fittability.ancestorsFittable ) {
          addQualifier( 'nofit-ancestor' );
        }
        if ( !instance.fittability.selfFittable ) {
          addQualifier( 'nofit-self' );
        }
        if ( node.pickable === true ) {
          addQualifier( 'pickable' );
        }
        if ( node.pickable === false ) {
          addQualifier( 'unpickable' );
        }
        if ( instance.trail.isPickable() ) {
          addQualifier( '<span style="color: #808">hits</span>' );
        }
        if ( node.clipArea ) {
          addQualifier( 'clipArea' );
        }
        if ( node.mouseArea ) {
          addQualifier( 'mouseArea' );
        }
        if ( node.touchArea ) {
          addQualifier( 'touchArea' );
        }
        if ( node.getInputListeners().length ) {
          addQualifier( 'inputListeners' );
        }
        if ( node.getRenderer() ) {
          addQualifier( 'renderer:' + node.getRenderer() );
        }
        if ( node.isLayerSplit() ) {
          addQualifier( 'layerSplit' );
        }
        if ( node.opacity < 1 ) {
          addQualifier( 'opacity:' + node.opacity );
        }

        if ( node._boundsEventCount > 0 ) {
          addQualifier( '<span style="color: #800">boundsListen:' + node._boundsEventCount + ':' + node._boundsEventSelfCount + '</span>' );
        }

        var transformType = '';
        switch( node.transform.getMatrix().type ) {
          case Matrix3.Types.IDENTITY:
            transformType = '';
            break;
          case Matrix3.Types.TRANSLATION_2D:
            transformType = 'translated';
            break;
          case Matrix3.Types.SCALING:
            transformType = 'scale';
            break;
          case Matrix3.Types.AFFINE:
            transformType = 'affine';
            break;
          case Matrix3.Types.OTHER:
            transformType = 'other';
            break;
        }
        if ( transformType ) {
          iSummary += ' <span style="color: #88f" title="' + node.transform.getMatrix().toString().replace( '\n', '&#10;' ) + '">' + transformType + '</span>';
        }

        iSummary += ' <span style="color: #888">[Trail ' + instance.trail.indices.join( '.' ) + ']</span>';
        iSummary += ' <span style="color: #c88">' + str( instance.state ) + '</span>';
        iSummary += ' <span style="color: #8c8">' + node._rendererSummary.bitmask.toString( 16 ) + ( node._rendererBitmask !== Renderer.bitmaskNodeDefault ? ' (' + node._rendererBitmask.toString( 16 ) + ')' : '' ) + '</span>';

        return iSummary;
      }

      function drawableSummary( drawable ) {
        var drawableString = drawable.toString();
        if ( drawable.visible ) {
          drawableString = '<strong>' + drawableString + '</strong>';
        }
        if ( drawable.dirty ) {
          drawableString += ( drawable.dirty ? ' <span style="color: #c00;">[x]</span>' : '' );
        }
        if ( !drawable.fittable ) {
          drawableString += ( drawable.dirty ? ' <span style="color: #0c0;">[no-fit]</span>' : '' );
        }
        return drawableString;
      }

      function printInstanceSubtree( instance ) {
        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';

        function addDrawable( name, drawable ) {
          div += ' <span style="color: #888">' + name + ':' + drawableSummary( drawable ) + '</span>';
        }

        div += instanceSummary( instance );

        instance.selfDrawable && addDrawable( 'self', instance.selfDrawable );
        instance.groupDrawable && addDrawable( 'group', instance.groupDrawable );
        instance.sharedCacheDrawable && addDrawable( 'sharedCache', instance.sharedCacheDrawable );

        div += '</div>';
        result += div;

        depth += 1;
        _.each( instance.children, function( childInstance ) {
          printInstanceSubtree( childInstance );
        } );
        depth -= 1;
      }

      if ( this._baseInstance ) {
        result += '<div style="' + headerStyle + '">Root Instance Tree</div>';
        printInstanceSubtree( this._baseInstance );
      }

      _.each( this._sharedCanvasInstances, function( instance ) {
        result += '<div style="' + headerStyle + '">Shared Canvas Instance Tree</div>';
        printInstanceSubtree( instance );
      } );

      function printDrawableSubtree( drawable ) {
        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';

        div += drawableSummary( drawable );
        if ( drawable.instance ) {
          div += ' <span style="color: #0a0;">(' + drawable.instance.trail.toPathString() + ')</span>';
          div += '&nbsp;&nbsp;&nbsp;' + instanceSummary( drawable.instance );
        }
        else if ( drawable.backboneInstance ) {
          div += ' <span style="color: #a00;">(' + drawable.backboneInstance.trail.toPathString() + ')</span>';
          div += '&nbsp;&nbsp;&nbsp;' + instanceSummary( drawable.backboneInstance );
        }

        div += '</div>';
        result += div;

        if ( drawable.blocks ) {
          // we're a backbone
          depth += 1;
          _.each( drawable.blocks, function( childDrawable ) {
            printDrawableSubtree( childDrawable );
          } );
          depth -= 1;
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          // we're a block
          depth += 1;
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            printDrawableSubtree( childDrawable );
          }
          printDrawableSubtree( drawable.lastDrawable ); // wasn't hit in our simplified (and safer) loop
          depth -= 1;
        }
      }

      if ( this._rootBackbone ) {
        result += '<div style="font-weight: bold;">Root Drawable Tree</div>';
        printDrawableSubtree( this._rootBackbone );
      }

      //OHTWO TODO: add shared cache drawable trees

      return result;
    },

    popupDebug: function() {
      var htmlContent = '<!DOCTYPE html>' +
                        '<html lang="en">' +
                        '<head><title>Scenery Debug Snapshot</title></head>' +
                        '<body style="font-size: 12px;">' + this.getDebugHTML() + '</body>' +
                        '</html>';
      window.open( 'data:text/html;charset=utf-8,' + encodeURIComponent( htmlContent ) );
    },

    toStringWithChildren: function( mutateRoot, rootName ) {
      rootName = rootName || 'scene';
      var rootNode = this._rootNode;
      var result = '';

      var nodes = this._rootNode.getTopologicallySortedNodes().slice( 0 ).reverse(); // defensive slice, in case we store the order somewhere

      function name( node ) {
        return node === rootNode ? rootName : ( ( node.constructor.name ? node.constructor.name.toLowerCase() : '(node)' ) + node.id );
      }

      _.each( nodes, function( node ) {
        if ( result ) {
          result += '\n';
        }

        if ( mutateRoot && node === rootNode ) {
          var props = rootNode.getPropString( '  ', false );
          var mutation = ( props ? ( '\n' + props + '\n' ) : '' );
          if ( mutation !== '' ) {
            result += rootName + '.mutate( {' + mutation + '} )';
          }
          else {
            // bleh. strip off the last newline
            result = result.slice( 0, -1 );
          }
        }
        else {
          result += 'var ' + name( node ) + ' = ' + node.toString( '', false );
        }

        _.each( node.children, function( child ) {
          result += '\n' + name( node ) + '.addChild( ' + name( child ) + ' );';
        } );
      } );

      return result;
    },

    /**
     * Will attempt to call callback( {string} dataURI ) with the rasterization of the entire Display's DOM structure,
     * used for internal testing. Will call-back null if there was an error
     *
     * Only tested on recent Chrome and Firefox, not recommended for general use. Guaranteed not to work for IE <= 10.
     *
     * See https://github.com/phetsims/scenery/issues/394 for some details.
     */
    foreignObjectRasterization: function( callback ) {
      // Scan our drawable tree for Canvases. We'll rasterize them here (to data URLs) so we can replace them later in
      // the HTML tree (with images) before putting that in the foreignObject. That way, we can actually display
      // things rendered in Canvas in our rasterization.
      var canvasUrlMap = {};

      function scanForCanvases( drawable ) {
        if ( drawable.blocks ) {
          // we're a backbone
          _.each( drawable.blocks, function( childDrawable ) {
            scanForCanvases( childDrawable );
          } );
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          // we're a block
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            scanForCanvases( childDrawable );
          }
          scanForCanvases( drawable.lastDrawable ); // wasn't hit in our simplified (and safer) loop

          if ( drawable.domElement && drawable.domElement instanceof window.HTMLCanvasElement ) {
            canvasUrlMap[ drawable.canvasId ] = drawable.domElement.toDataURL();
          }
        }
      }

      scanForCanvases( this._rootBackbone );

      var canvas = document.createElement( 'canvas' );
      var context = canvas.getContext( '2d' );
      canvas.width = this.width;
      canvas.height = this.height;

      // Create a new document, so that we can (1) serialize it to XHTML, and (2) manipulate it independently.
      // Inspired by http://cburgmer.github.io/rasterizeHTML.js/
      var doc = document.implementation.createHTMLDocument( '' );
      doc.documentElement.innerHTML = this.domElement.outerHTML;
      doc.documentElement.setAttribute( 'xmlns', doc.documentElement.namespaceURI );

      // Replace each <canvas> with an <img> that has src=canvas.toDataURL() and the same style
      var displayCanvases = doc.documentElement.getElementsByTagName( 'canvas' );
      displayCanvases = Array.prototype.slice.call( displayCanvases ); // don't use a live HTMLCollection copy!
      for ( var i = 0; i < displayCanvases.length; i++ ) {
        var displayCanvas = displayCanvases[ i ];

        var cssText = displayCanvas.style.cssText;

        var displayImg = doc.createElement( 'img' );
        var src = canvasUrlMap[ displayCanvas.id ];
        assert && assert( src, 'Must have missed a toDataURL() on a Canvas' );

        displayImg.src = src;
        displayImg.setAttribute( 'style', cssText );

        displayCanvas.parentNode.replaceChild( displayImg, displayCanvas );
      }

      // Serialize it to XHTML that can be used in foreignObject (HTML can't be)
      var xhtml = new window.XMLSerializer().serializeToString( doc.documentElement );

      // Create an SVG container with a foreignObject.
      var data = '<svg xmlns="http://www.w3.org/2000/svg" width="' + this.width + '" height="' + this.height + '">' +
                 '<foreignObject width="100%" height="100%">' +
                 '<div xmlns="http://www.w3.org/1999/xhtml">' +
                 xhtml +
                 '</div>' +
                 '</foreignObject>' +
                 '</svg>';

      // Load an <img> with the SVG data URL, and when loaded draw it into our Canvas
      var img = new Image();
      img.onload = function() {
        context.drawImage( img, 0, 0 );
        callback( canvas.toDataURL() ); // Endpoint here
      };
      img.onerror = function() {
        callback( null );
      };
      // turn it to base64 and wrap it in the data URL format
      img.src = 'data:image/svg+xml;base64,' + window.btoa( data );
    },

    popupRasterization: function() {
      this.foreignObjectRasterization( window.open );
    }
  }, Events.prototype ) );

  Display.customCursors = {
    'scenery-grab-pointer': [ 'grab', '-moz-grab', '-webkit-grab', 'pointer' ],
    'scenery-grabbing-pointer': [ 'grabbing', '-moz-grabbing', '-webkit-grabbing', 'pointer' ]
  };

  Property.addProperty( Display, 'focus', null ); // { display: {Display}, trail: {Trail} }

  return Display;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * An accessible peer controls the appearance of an accessible Node's instance in the parallel DOM.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/accessibility/AccessiblePeer',['require','PHET_CORE/inherit','PHET_CORE/Poolable','AXON/Events','SCENERY/scenery','SCENERY/display/Display'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  var Display = require( 'SCENERY/display/Display' );

  var globalId = 1;

  function AccessiblePeer( accessibleInstance, domElement, containerDOMElement ) {
    this.initializeAccessiblePeer( accessibleInstance, domElement, containerDOMElement );
  }

  scenery.register( 'AccessiblePeer', AccessiblePeer );

  inherit( Events, AccessiblePeer, {
    /**
     * @param {DOMElement} domElement - The main DOM element used for this peer.
     * @param {DOMElement} [containerDOMElement] - A container DOM element (usually an ancestor of the domElement) where
     *                                             nested elements are placed
     */
    initializeAccessiblePeer: function( accessibleInstance, domElement, containerDOMElement ) {
      var peer = this;

      Events.call( this ); // TODO: is Events worth mixing in by default? Will we need to listen to events?

      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );

      // unique ID
      this.id = this.id || globalId++;

      this.accessibleInstance = accessibleInstance;
      this.display = accessibleInstance.display;
      this.trail = accessibleInstance.trail;

      this.domElement = domElement;
      this.containerDOMElement = containerDOMElement ? containerDOMElement : ( this.containerDOMElement || null );

      this.disposed = false;

      this.domElement.addEventListener( 'focus', function( event ) {
        if ( event.target === peer.domElement ) {
          Display.focus = {
            display: accessibleInstance.display,
            trail: accessibleInstance.trail
          };
        }
      } );

      this.domElement.addEventListener( 'blur', function( event ) {
        if ( event.target === peer.domElement ) {
          Display.focus = null;
        }
      } );

      return this;
    },

    getChildContainerElement: function() {
      return this.containerDOMElement || this.domElement;
    },

    dispose: function() {
      this.disposed = true;

      // for now
      this.freeToPool && this.freeToPool();
    }
  } );

  // TODO: evaluate pooling, and is it OK to pool only some peers?
  AccessiblePeer.Poolable = {
    mixin: function( selfDrawableType ) {
      // for pooling, allow <AccessiblePeerType>.createFromPool( accessibleInstance ) and accessiblePeer.freeToPool().
      // Creation will initialize the peer to an initial state.
      Poolable.mixin( selfDrawableType, {
        defaultFactory: function() {
          return new selfDrawableType();
        },
        constructorDuplicateFactory: function( pool ) {
          return function( accessibleInstance ) {
            if ( pool.length ) {
              return pool.pop().initialize( accessibleInstance );
            }
            else {
              return new selfDrawableType( accessibleInstance );
            }
          };
        }
      } );
    }
  };

  return AccessiblePeer;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A debugging version of the CanvasRenderingContext2D that will output all commands issued,
 * but can also forward them to a real context
 *
 * See the spec at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#2dcontext
 * Wrapping of the CanvasRenderingContext2D interface as of January 27th, 2013 (but not other interfaces like TextMetrics and Path)
 *
 * Shortcut to create:
 *    var context = new scenery.DebugContext( document.createElement( 'canvas' ).getContext( '2d' ) );
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/debug/DebugContext',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  // used to serialize arguments so that it displays exactly like the call would be executed
  function s( value ) {
    return JSON.stringify( value );
  }

  function log( message ) {
    console.log( 'context.' + message + ';' );
  }

  function attributeGet( name ) {
    log( name );
  }

  function attributeSet( name, value ) {
    log( name + ' = ' + s( value ) );
  }

  function command( name, args ) {
    if ( args === undefined || args.length === 0 ) {
      log( name + '()' );
    }
    else {
      log( name + '( ' + _.reduce( args, function( memo, arg ) {
          if ( memo.length > 0 ) {
            return memo + ', ' + s( arg );
          }
          else {
            return s( arg );
          }
        }, '' ) + ' )' );
    }
  }

  function DebugContext( context ) {
    this._context = context;

    // allow checking of context.ellipse for existence
    if ( context && !context.ellipse ) {
      this.ellipse = context.ellipse;
    }
  }

  scenery.register( 'DebugContext', DebugContext );

  inherit( Object, DebugContext, {
    get canvas() {
      attributeGet( 'canvas' );
      return this._context.canvas;
    },

    get width() {
      attributeGet( 'width' );
      return this._context.width;
    },

    get height() {
      attributeGet( 'height' );
      return this._context.height;
    },

    commit: function() {
      command( 'commit' );
      this._context.commit();
    },

    save: function() {
      command( 'save' );
      this._context.save();
    },

    restore: function() {
      command( 'restore' );
      this._context.restore();
    },

    get currentTransform() {
      attributeGet( 'currentTransform' );
      return this._context.currentTransform;
    },

    set currentTransform( transform ) {
      attributeSet( 'currentTransform', transform );
      this._context.currentTransform = transform;
    },

    scale: function( x, y ) {
      command( 'scale', [ x, y ] );
      this._context.scale( x, y );
    },

    rotate: function( angle ) {
      command( 'rotate', [ angle ] );
      this._context.rotate( angle );
    },

    translate: function( x, y ) {
      command( 'translate', [ x, y ] );
      this._context.translate( x, y );
    },

    transform: function( a, b, c, d, e, f ) {
      command( 'transform', [ a, b, c, d, e, f ] );
      this._context.transform( a, b, c, d, e, f );
    },

    setTransform: function( a, b, c, d, e, f ) {
      command( 'setTransform', [ a, b, c, d, e, f ] );
      this._context.setTransform( a, b, c, d, e, f );
    },

    resetTransform: function() {
      command( 'resetTransform' );
      this._context.resetTransform();
    },

    get globalAlpha() {
      attributeGet( 'globalAlpha' );
      return this._context.globalAlpha;
    },

    set globalAlpha( value ) {
      attributeSet( 'globalAlpha', value );
      this._context.globalAlpha = value;
    },

    get globalCompositeOperation() {
      attributeGet( 'globalCompositeOperation' );
      return this._context.globalCompositeOperation;
    },

    set globalCompositeOperation( value ) {
      attributeSet( 'globalCompositeOperation', value );
      this._context.globalCompositeOperation = value;
    },

    get imageSmoothingEnabled() {
      attributeGet( 'imageSmoothingEnabled' );
      return this._context.imageSmoothingEnabled;
    },

    set imageSmoothingEnabled( value ) {
      attributeSet( 'imageSmoothingEnabled', value );
      this._context.imageSmoothingEnabled = value;
    },

    get strokeStyle() {
      attributeGet( 'strokeStyle' );
      return this._context.strokeStyle;
    },

    set strokeStyle( value ) {
      attributeSet( 'strokeStyle', value );
      this._context.strokeStyle = value;
    },

    get fillStyle() {
      attributeGet( 'fillStyle' );
      return this._context.fillStyle;
    },

    set fillStyle( value ) {
      attributeSet( 'fillStyle', value );
      this._context.fillStyle = value;
    },

    // TODO: create wrapper
    createLinearGradient: function( x0, y0, x1, y1 ) {
      command( 'createLinearGradient', [ x0, y0, x1, y1 ] );
      return this._context.createLinearGradient( x0, y0, x1, y1 );
    },

    // TODO: create wrapper
    createRadialGradient: function( x0, y0, r0, x1, y1, r1 ) {
      command( 'createRadialGradient', [ x0, y0, r0, x1, y1, r1 ] );
      return this._context.createRadialGradient( x0, y0, r0, x1, y1, r1 );
    },

    // TODO: create wrapper
    createPattern: function( image, repetition ) {
      command( 'createPattern', [ image, repetition ] );
      return this._context.createPattern( image, repetition );
    },

    get shadowOffsetX() {
      attributeGet( 'shadowOffsetX' );
      return this._context.shadowOffsetX;
    },

    set shadowOffsetX( value ) {
      attributeSet( 'shadowOffsetX', value );
      this._context.shadowOffsetX = value;
    },

    get shadowOffsetY() {
      attributeGet( 'shadowOffsetY' );
      return this._context.shadowOffsetY;
    },

    set shadowOffsetY( value ) {
      attributeSet( 'shadowOffsetY', value );
      this._context.shadowOffsetY = value;
    },

    get shadowBlur() {
      attributeGet( 'shadowBlur' );
      return this._context.shadowBlur;
    },

    set shadowBlur( value ) {
      attributeSet( 'shadowBlur', value );
      this._context.shadowBlur = value;
    },

    get shadowColor() {
      attributeGet( 'shadowColor' );
      return this._context.shadowColor;
    },

    set shadowColor( value ) {
      attributeSet( 'shadowColor', value );
      this._context.shadowColor = value;
    },

    clearRect: function( x, y, w, h ) {
      command( 'clearRect', [ x, y, w, h ] );
      this._context.clearRect( x, y, w, h );
    },

    fillRect: function( x, y, w, h ) {
      command( 'fillRect', [ x, y, w, h ] );
      this._context.fillRect( x, y, w, h );
    },

    strokeRect: function( x, y, w, h ) {
      command( 'strokeRect', [ x, y, w, h ] );
      this._context.strokeRect( x, y, w, h );
    },

    get fillRule() {
      attributeGet( 'fillRule' );
      return this._context.fillRule;
    },

    set fillRule( value ) {
      attributeSet( 'fillRule', value );
      this._context.fillRule = value;
    },

    beginPath: function() {
      command( 'beginPath' );
      this._context.beginPath();
    },

    fill: function( path ) {
      if ( path ) {
        command( 'fill', [ path ] );
        this._context.fill( path );
      }
      else {
        command( 'fill' );
        this._context.fill();
      }
    },

    stroke: function( path ) {
      if ( path ) {
        command( 'stroke', [ path ] );
        this._context.stroke( path );
      }
      else {
        command( 'stroke' );
        this._context.stroke();
      }
    },

    drawSystemFocusRing: function( a, b ) {
      command( 'drawSystemFocusRing', b ? [ a, b ] : [ a ] );
      this._context.drawSystemFocusRing( a, b );
    },

    drawCustomFocusRing: function( a, b ) {
      command( 'drawCustomFocusRing', b ? [ a, b ] : [ a ] );
      return this._context.drawCustomFocusRing( a, b );
    },

    scrollPathIntoView: function( path ) {
      command( 'scrollPathIntoView', path ? [ path ] : undefined );
      this._context.scrollPathIntoView( path );
    },

    clip: function( path ) {
      command( 'clip', path ? [ path ] : undefined );
      this._context.clip( path );
    },

    resetClip: function() {
      command( 'resetClip' );
      this._context.resetClip();
    },

    isPointInPath: function( a, b, c ) {
      command( 'isPointInPath', c ? [ a, b, c ] : [ a, b ] );
      return this._context.isPointInPath( a, b, c );
    },

    fillText: function( text, x, y, maxWidth ) {
      command( 'fillText', maxWidth !== undefined ? [ text, x, y, maxWidth ] : [ text, x, y ] );
      this._context.fillText( text, x, y, maxWidth );
    },

    strokeText: function( text, x, y, maxWidth ) {
      command( 'strokeText', maxWidth !== undefined ? [ text, x, y, maxWidth ] : [ text, x, y ] );
      this._context.strokeText( text, x, y, maxWidth );
    },

    measureText: function( text ) {
      command( 'measureText', [ text ] );
      return this._context.measureText( text );
    },

    drawImage: function( image, a, b, c, d, e, f, g, h ) {
      command( 'drawImage', c !== undefined ? ( e !== undefined ? [ image, a, b, c, d, e, f, g, h ] : [ image, a, b, c, d ] ) : [ image, a, b ] );
      this._context.drawImage( image, a, b, c, d, e, f, g, h );
    },

    addHitRegion: function( options ) {
      command( 'addHitRegion', [ options ] );
      this._context.addHitRegion( options );
    },

    removeHitRegion: function( options ) {
      command( 'removeHitRegion', [ options ] );
      this._context.removeHitRegion( options );
    },

    createImageData: function( a, b ) {
      command( 'createImageData', b !== undefined ? [ a, b ] : [ a ] );
      return this._context.createImageData( a, b );
    },

    createImageDataHD: function( a, b ) {
      command( 'createImageDataHD', [ a, b ] );
      return this._context.createImageDataHD( a, b );
    },

    getImageData: function( sx, sy, sw, sh ) {
      command( 'getImageData', [ sx, sy, sw, sh ] );
      return this._context.getImageData( sx, sy, sw, sh );
    },

    getImageDataHD: function( sx, sy, sw, sh ) {
      command( 'getImageDataHD', [ sx, sy, sw, sh ] );
      return this._context.getImageDataHD( sx, sy, sw, sh );
    },

    putImageData: function( imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight ) {
      command( 'putImageData', dirtyX !== undefined ? [ imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight ] : [ imageData, dx, dy ] );
      this._context.putImageData( imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight );
    },

    putImageDataHD: function( imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight ) {
      command( 'putImageDataHD', dirtyX !== undefined ? [ imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight ] : [ imageData, dx, dy ] );
      this._context.putImageDataHD( imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight );
    },

    /*---------------------------------------------------------------------------*
     * CanvasDrawingStyles
     *----------------------------------------------------------------------------*/

    get lineWidth() {
      attributeGet( 'lineWidth' );
      return this._context.lineWidth;
    },

    set lineWidth( value ) {
      attributeSet( 'lineWidth', value );
      this._context.lineWidth = value;
    },

    get lineCap() {
      attributeGet( 'lineCap' );
      return this._context.lineCap;
    },

    set lineCap( value ) {
      attributeSet( 'lineCap', value );
      this._context.lineCap = value;
    },

    get lineJoin() {
      attributeGet( 'lineJoin' );
      return this._context.lineJoin;
    },

    set lineJoin( value ) {
      attributeSet( 'lineJoin', value );
      this._context.lineJoin = value;
    },

    get miterLimit() {
      attributeGet( 'miterLimit' );
      return this._context.miterLimit;
    },

    set miterLimit( value ) {
      attributeSet( 'miterLimit', value );
      this._context.miterLimit = value;
    },

    setLineDash: function( segments ) {
      command( 'setLineDash', [ segments ] );
      this._context.setLineDash( segments );
    },

    getLineDash: function() {
      command( 'getLineDash' );
      return this._context.getLineDash();
    },

    get lineDashOffset() {
      attributeGet( 'lineDashOffset' );
      return this._context.lineDashOffset;
    },

    set lineDashOffset( value ) {
      attributeSet( 'lineDashOffset', value );
      this._context.lineDashOffset = value;
    },

    get font() {
      attributeGet( 'font' );
      return this._context.font;
    },

    set font( value ) {
      attributeSet( 'font', value );
      this._context.font = value;
    },

    get textAlign() {
      attributeGet( 'textAlign' );
      return this._context.textAlign;
    },

    set textAlign( value ) {
      attributeSet( 'textAlign', value );
      this._context.textAlign = value;
    },

    get textBaseline() {
      attributeGet( 'textBaseline' );
      return this._context.textBaseline;
    },

    set textBaseline( value ) {
      attributeSet( 'textBaseline', value );
      this._context.textBaseline = value;
    },

    get direction() {
      attributeGet( 'direction' );
      return this._context.direction;
    },

    set direction( value ) {
      attributeSet( 'direction', value );
      this._context.direction = value;
    },

    /*---------------------------------------------------------------------------*
     * CanvasPathMethods
     *----------------------------------------------------------------------------*/

    closePath: function() {
      command( 'closePath' );
      this._context.closePath();
    },

    moveTo: function( x, y ) {
      command( 'moveTo', [ x, y ] );
      this._context.moveTo( x, y );
    },

    lineTo: function( x, y ) {
      command( 'lineTo', [ x, y ] );
      this._context.lineTo( x, y );
    },

    quadraticCurveTo: function( cpx, cpy, x, y ) {
      command( 'quadraticCurveTo', [ cpx, cpy, x, y ] );
      this._context.quadraticCurveTo( cpx, cpy, x, y );
    },

    bezierCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) {
      command( 'bezierCurveTo', [ cp1x, cp1y, cp2x, cp2y, x, y ] );
      this._context.bezierCurveTo( cp1x, cp1y, cp2x, cp2y, x, y );
    },

    arcTo: function( x1, y1, x2, y2, radiusX, radiusY, rotation ) {
      command( 'arcTo', radiusY !== undefined ? [ x1, y1, x2, y2, radiusX, radiusY, rotation ] : [ x1, y1, x2, y2, radiusX ] );
      this._context.arcTo( x1, y1, x2, y2, radiusX, radiusY, rotation );
    },

    rect: function( x, y, w, h ) {
      command( 'rect', [ x, y, w, h ] );
      this._context.rect( x, y, w, h );
    },

    arc: function( x, y, radius, startAngle, endAngle, anticlockwise ) {
      command( 'arc', [ x, y, radius, startAngle, endAngle, anticlockwise ] );
      this._context.arc( x, y, radius, startAngle, endAngle, anticlockwise );
    },

    ellipse: function( x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
      command( 'ellipse', [ x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ] );
      this._context.ellipse( x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
    }
  } );

  return DebugContext;
} );



// Copyright 2013-2015, University of Colorado Boulder


/**
 * Basic down/up pointer handling for a Node, so that it's easy to handle buttons
 *
 * TODO: test hand handle down, go off screen, up. How to handle that properly?
 * TODO: tests
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/DownUpListener',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Input'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  var Input = require( 'SCENERY/input/Input' );

  /*
   * The 'trail' parameter passed to down/upInside/upOutside will end with the node to which this DownUpListener has been added.
   *
   * Allowed options: {
   *    mouseButton: 0  // The mouse button to use: left: 0, middle: 1, right: 2, see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
   *    down: null      // down( event, trail ) is called when the pointer is pressed down on this node
   *                    // (and another pointer is not already down on it).
   *    up: null        // up( event, trail ) is called after 'down', regardless of the pointer's current location.
   *                    // Additionally, it is called AFTER upInside or upOutside, whichever is relevant
   *    upInside: null  // upInside( event, trail ) is called after 'down', when the pointer is released inside
   *                    // this node (it or a descendant is the top pickable node under the pointer)
   *    upOutside: null // upOutside( event, trail ) is called after 'down', when the pointer is released outside
   *                    // this node (it or a descendant is the not top pickable node under the pointer, even if the
   *                    // same instance is still directly under the pointer)
   * }
   */
  function DownUpListener( options ) {
    var handler = this;

    options = _.extend( {
      mouseButton: 0 // allow a different mouse button
    }, options );
    this.options = options; // @private
    this.isDown = false;   // public, whether this listener is down
    this.downCurrentTarget = null; // 'up' is handled via a pointer lister, which will have null currentTarget, so save the 'down' currentTarget
    this.downTrail = null;
    this.pointer = null;

    // this listener gets added to the pointer on a 'down'
    this.downListener = {
      // mouse/touch up
      up: function( event ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener (pointer) up for ' + handler.downTrail.toString() );
        assert && assert( event.pointer === handler.pointer );
        if ( !event.pointer.isMouse || event.domEvent.button === handler.options.mouseButton ) {
          handler.buttonUp( event );
        }
      },

      // touch cancel
      cancel: function( event ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener (pointer) cancel for ' + handler.downTrail.toString() );
        assert && assert( event.pointer === handler.pointer );
        handler.buttonUp( event );
      },

      // When the enter or space key is released, trigger an up event
      // TODO: Only trigger this if the enter/space key went down for this node
      keyup: function( event ) {
        var keyCode = event.domEvent.keyCode;
        if ( keyCode === Input.KEY_ENTER || keyCode === Input.KEY_SPACE ) {
          handler.buttonUp( event );
        }
      }
    };
  }

  scenery.register( 'DownUpListener', DownUpListener );

  inherit( Object, DownUpListener, {
    buttonDown: function( event ) {
      // already down from another pointer, don't do anything
      if ( this.isDown ) { return; }

      // ignore other mouse buttons
      if ( event.pointer.isMouse && event.domEvent.button !== this.options.mouseButton ) { return; }

      // add our listener so we catch the up wherever we are
      event.pointer.addInputListener( this.downListener );

      this.isDown = true;
      this.downCurrentTarget = event.currentTarget;
      this.downTrail = event.trail.subtrailTo( event.currentTarget, false );
      this.pointer = event.pointer;

      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener buttonDown for ' + this.downTrail.toString() );
      if ( this.options.down ) {
        this.options.down( event, this.downTrail );
      }
    },

    buttonUp: function( event ) {
      this.isDown = false;
      this.pointer.removeInputListener( this.downListener );

      var currentTargetSave = event.currentTarget;
      event.currentTarget = this.downCurrentTarget; // up is handled by a pointer listener, so currentTarget would be null.
      if ( this.options.upInside || this.options.upOutside ) {
        var trailUnderPointer = event.trail;

        // TODO: consider changing this so that it just does a hit check and ignores anything in front?
        var isInside = trailUnderPointer.isExtensionOf( this.downTrail, true );

        if ( isInside && this.options.upInside ) {
          this.options.upInside( event, this.downTrail );
        }
        else if ( !isInside && this.options.upOutside ) {
          this.options.upOutside( event, this.downTrail );
        }
      }
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener buttonUp for ' + this.downTrail.toString() );
      if ( this.options.up ) {
        this.options.up( event, this.downTrail );
      }
      event.currentTarget = currentTargetSave; // be polite to other listeners, restore currentTarget
    },

    /*---------------------------------------------------------------------------*
     * events called from the node input listener
     *----------------------------------------------------------------------------*/

    // mouse/touch down on this node
    down: function( event ) {
      this.buttonDown( event );
    },

    // When enter/space pressed for this node, trigger a button down
    keydown: function( event ) {
      var keyCode = event.domEvent.keyCode;
      if ( keyCode === Input.KEY_ENTER || keyCode === Input.KEY_SPACE ) {
        this.buttonDown( event );
      }
    }
  } );

  return DownUpListener;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Basic button handling.
 *
 * Uses 4 states:
 * up: mouse not over, not pressed
 * over: mouse over, not pressed
 * down: mouse over, pressed
 * out: mouse not over, pressed
 *
 * TODO: offscreen handling
 * TODO: fix enter/exit edge cases for moving nodes or add/remove child, and when touches are created
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/ButtonListener',['require','SCENERY/scenery','SCENERY/util/Trail','PHET_CORE/inherit','SCENERY/input/DownUpListener'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  var inherit = require( 'PHET_CORE/inherit' );

  var DownUpListener = require( 'SCENERY/input/DownUpListener' );

  /**
   * Options for the ButtonListener:
   *
   * mouseButton: 0
   * fireOnDown: false // default is to fire on 'up' after 'down', but passing fireOnDown: true will fire on 'down' instead
   * up: null          // Called on an 'up' state change, as up( event, oldState )
   * over: null        // Called on an 'over' state change, as over( event, oldState )
   * down: null        // Called on an 'down' state change, as down( event, oldState )
   * out: null         // Called on an 'out' state change, as out( event, oldState )
   * fire: null        // Called on a state change to/from 'down' (depending on fireOnDown), as fire( event ). Called after the triggering up/over/down event.
   */
  function ButtonListener( options ) {
    var self = this;

    this.buttonState = 'up'; // public: 'up', 'over', 'down' or 'out'

    this._overCount = 0; // how many pointers are over us (track a count, so we can handle multiple pointers gracefully)

    this._buttonOptions = options; // store the options object so we can call the callbacks

    var buttonListener = this;
    DownUpListener.call( this, {

      mouseButton: options.mouseButton || 0, // forward the mouse button, default to 0 (LMB)

      // parameter to DownUpListener, NOT an input listener itself
      down: function( event, trail ) {
        if ( event.pointer.isKey ) {
          self.enter( event );
        }
        buttonListener.setButtonState( event, 'down' );
      },

      // parameter to DownUpListener, NOT an input listener itself
      up: function( event, trail ) {
        buttonListener.setButtonState( event, buttonListener._overCount > 0 ? 'over' : 'up' );
        if ( event.pointer.isKey ) {
          self.exit( event );
        }
      }
    } );
  }

  scenery.register( 'ButtonListener', ButtonListener );

  inherit( DownUpListener, ButtonListener, {

    setButtonState: function( event, state ) {
      if ( state !== this.buttonState ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
          'ButtonListener state change to ' + state + ' from ' + this.buttonState + ' for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
        var oldState = this.buttonState;

        this.buttonState = state;

        if ( this._buttonOptions[ state ] ) {
          this._buttonOptions[ state ]( event, oldState );
        }

        if ( this._buttonOptions.fire &&
             this._overCount > 0 &&
             ( this._buttonOptions.fireOnDown ? ( state === 'down' ) : ( oldState === 'down' ) ) ) {
          this._buttonOptions.fire( event );
        }
      }
    },

    enter: function( event ) {
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'ButtonListener enter for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
      this._overCount++;
      if ( this._overCount === 1 ) {
        this.setButtonState( event, this.isDown ? 'down' : 'over' );
      }
    },

    exit: function( event ) {
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'ButtonListener exit for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
      assert && assert( this._overCount > 0, 'Exit events not matched by an enter' );
      this._overCount--;
      if ( this._overCount === 0 ) {
        this.setButtonState( event, this.isDown ? 'out' : 'up' );
      }
    }
  } );

  return ButtonListener;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Basic dragging for a node.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/SimpleDragHandler',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  /*
   * Allowed options: {
   *    allowTouchSnag: false // allow touch swipes across an object to pick it up. If a function is passed, the value allowTouchSnag( event ) is used
   *    dragCursor: 'pointer' // while dragging with the mouse, sets the cursor to this value (or use null to not override the cursor while dragging)
   *    mouseButton: 0        // allow changing the mouse button that activates the drag listener. -1 should activate on any mouse button, 0 on left, 1 for middle, 2 for right, etc.
   *    start: null           // if non-null, called when a drag is started. start( event, trail )
   *    drag: null            // if non-null, called when the user moves something with a drag (not a start or end event).
   *                                                                         drag( event, trail )
   *    end: null             // if non-null, called when a drag is ended.   end( event, trail )
   *    translate:            // if this exists, translate( { delta: _, oldPosition: _, position: _ } ) will be called.
   * }
   */
  function SimpleDragHandler( options ) {
    var handler = this;

    options = _.extend( {
      allowTouchSnag: false,
      mouseButton: 0,
      dragCursor: 'pointer'
    }, options );
    this.options = options; // @private

    this.dragging = false;            // whether a node is being dragged with this handler
    this.pointer = null;              // the pointer doing the current dragging
    this.trail = null;                // stores the path to the node that is being dragged
    this.transform = null;            // transform of the trail to our node (but not including our node, so we can prepend the deltas)
    this.node = null;                 // the node that we are handling the drag for
    this.lastDragPoint = null;        // the location of the drag at the previous event (so we can calculate a delta)
    this.startTransformMatrix = null; // the node's transform at the start of the drag, so we can reset on a touch cancel
    this.mouseButton = undefined;     // tracks which mouse button was pressed, so we can handle that specifically
    // TODO: consider mouse buttons as separate pointers?

    // if an ancestor is transformed, pin our node
    this.transformListener = {
      transform: function( args ) {
        if ( !handler.trail.isExtensionOf( args.trail, true ) ) {
          return;
        }

        var newMatrix = args.trail.getMatrix();
        var oldMatrix = handler.transform.getMatrix();

        // if A was the trail's old transform, B is the trail's new transform, we need to apply (B^-1 A) to our node
        handler.node.prependMatrix( newMatrix.inverted().timesMatrix( oldMatrix ) );

        // store the new matrix so we can do deltas using it now
        handler.transform.setMatrix( newMatrix );
      }
    };

    // this listener gets added to the pointer when it starts dragging our node
    this.dragListener = {
      // mouse/touch up
      up: function( event ) {
        assert && assert( event.pointer === handler.pointer );
        if ( !event.pointer.isMouse || event.domEvent.button === handler.mouseButton ) {
          var saveCurrentTarget = event.currentTarget;
          event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
          handler.endDrag( event );
          event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        }
      },

      // touch cancel
      cancel: function( event ) {
        assert && assert( event.pointer === handler.pointer );

        var saveCurrentTarget = event.currentTarget;
        event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
        handler.endDrag( event );
        event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget

        // since it's a cancel event, go back!
        if ( !handler.transform ) {
          handler.node.setMatrix( handler.startTransformMatrix );
        }
      },

      // mouse/touch move
      move: function( event ) {
        assert && assert( event.pointer === handler.pointer );

        var globalDelta = handler.pointer.point.minus( handler.lastDragPoint );

        // ignore move events that have 0-length (Chrome seems to be auto-firing these on Windows, see https://code.google.com/p/chromium/issues/detail?id=327114)
        if ( globalDelta.magnitudeSquared() === 0 ) {
          return;
        }

        var delta = handler.transform.inverseDelta2( globalDelta );

        // move by the delta between the previous point, using the precomputed transform
        // prepend the translation on the node, so we can ignore whatever other transform state the node has
        if ( handler.options.translate ) {
          var translation = handler.node.getMatrix().getTranslation();
          handler.options.translate.call( null, {
            delta: delta,
            oldPosition: translation,
            position: translation.plus( delta )
          } );
        }
        handler.lastDragPoint = handler.pointer.point;

        if ( handler.options.drag ) {
          // TODO: consider adding in a delta to the listener
          // TODO: add the position in to the listener
          var saveCurrentTarget = event.currentTarget;
          event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
          handler.options.drag.call( null, event, handler.trail ); // new position (old position?) delta
          event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        }
      }
    };
  }

  scenery.register( 'SimpleDragHandler', SimpleDragHandler );

  inherit( Object, SimpleDragHandler, {
    startDrag: function( event ) {
      // set a flag on the pointer so it won't pick up other nodes
      event.pointer.dragging = true;
      event.pointer.cursor = this.options.dragCursor;
      event.pointer.addInputListener( this.dragListener );
      // event.trail.rootNode().addEventListener( this.transformListener ); // TODO: replace with new parent transform listening solution

      // set all of our persistent information
      this.dragging = true;
      this.pointer = event.pointer;
      this.trail = event.trail.subtrailTo( event.currentTarget, true );
      this.transform = this.trail.getTransform();
      this.node = event.currentTarget;
      this.lastDragPoint = event.pointer.point;
      this.startTransformMatrix = event.currentTarget.getMatrix().copy();
      // event.domEvent may not exist if this is touch-to-snag
      this.mouseButton = event.pointer.isMouse ? event.domEvent.button : undefined;

      if ( this.options.start ) {
        this.options.start.call( null, event, this.trail );
      }
    },

    endDrag: function( event ) {
      this.pointer.dragging = false;
      this.pointer.cursor = null;
      this.pointer.removeInputListener( this.dragListener );
      // this.trail.rootNode().removeEventListener( this.transformListener ); // TODO: replace with new parent transform listening solution
      this.dragging = false;

      if ( this.options.end ) {
        this.options.end.call( null, event, this.trail );
      }

      // release our reference
      this.pointer = null;
    },

    tryToSnag: function( event ) {
      // don't allow drag attempts that use the wrong mouse button (-1 indicates any mouse button works)
      if ( event.pointer.isMouse && event.domEvent && this.options.mouseButton !== event.domEvent.button && this.options.mouseButton !== -1 ) {
        return;
      }

      // only start dragging if the pointer isn't dragging anything, we aren't being dragged, and if it's a mouse it's button is down
      if ( !this.dragging && !event.pointer.dragging ) {
        this.startDrag( event );
      }
    },

    tryTouchToSnag: function( event ) {
      // allow touches to start a drag by moving "over" this node, and allows clients to specify custom logic for when touchSnag is allowable
      if ( this.options.allowTouchSnag && ( this.options.allowTouchSnag === true || this.options.allowTouchSnag( event ) ) ) {
        this.tryToSnag( event );
      }
    },

    /*---------------------------------------------------------------------------*
     * events called from the node input listener
     *----------------------------------------------------------------------------*/

    // mouse/touch down on this node
    down: function( event ) {
      this.tryToSnag( event );
    },

    // touch enters this node
    touchenter: function( event ) {
      this.tryTouchToSnag( event );
    },

    // touch moves over this node
    touchmove: function( event ) {
      this.tryTouchToSnag( event );
    }
  } );

  return SimpleDragHandler;
} );



// Copyright 2013-2015, University of Colorado Boulder

/**
 * A node that can be custom-drawn with Canvas calls. Manual handling of dirty region repainting.
 *
 * setCanvasBounds (or the mutator canvasBounds) should be used to set the area that is drawn to (otherwise nothing
 * will show up)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/CanvasNode',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  var emptyArray = []; // constant

  // pass a canvasBounds option if you want to specify the self bounds
  function CanvasNode( options ) {
    Node.call( this, options );
    this.setRendererBitmask( Renderer.bitmaskCanvas );
  }

  scenery.register( 'CanvasNode', CanvasNode );

  inherit( Node, CanvasNode, {

    /**
     * How to set the bounds of the CanvasNode
     *
     * @param {Bounds2} selfBounds
     */
    setCanvasBounds: function( selfBounds ) {
      this.invalidateSelf( selfBounds );
    },
    set canvasBounds( value ) { this.setCanvasBounds( value ); },
    get canvasBounds() { return this.getSelfBounds(); },

    isPainted: function() {
      return true;
    },

    /**
     * Override paintCanvas with a faster version, since fillRect and drawRect don't affect the current default path.
     * @public
     *
     * IMPORTANT NOTE: This function will be run from inside Scenery's Display.updateDisplay(), so it should not modify
     * or mutate any Scenery nodes (particularly anything that would cause something to be marked as needing a repaint).
     * Ideally, this function should have no outside effects other than painting to the Canvas provided.
     *
     * @param {CanvasRenderingContext2D} context
     */
    paintCanvas: function( context ) {
      throw new Error( 'CanvasNode needs paintCanvas implemented' );
    },

    invalidatePaint: function() {
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirty();
      }
    },

    canvasPaintSelf: function( wrapper ) {
      this.paintCanvas( wrapper.context );
    },

    // override for computation of whether a point is inside the self content
    // point is considered to be in the local coordinate frame
    containsPointSelf: function( point ) {
      return false;
      // throw new Error( 'CanvasNode needs containsPointSelf implemented' );
    },

    createCanvasDrawable: function( renderer, instance ) {
      return CanvasNode.CanvasNodeDrawable.createFromPool( renderer, instance );
    },

    // whether this node's self intersects the specified bounds, in the local coordinate frame
    // intersectsBoundsSelf: function( bounds ) {
    //   // TODO: implement?
    // },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.CanvasNode( {' + propLines + '} )'; // TODO: no real way to do this nicely?
    }

  } );

  CanvasNode.prototype._mutatorKeys = [ 'canvasBounds' ].concat( Node.prototype._mutatorKeys );

  /*---------------------------------------------------------------------------*
   * Canvas rendering
   *----------------------------------------------------------------------------*/

  CanvasNode.CanvasNodeDrawable = function CanvasNodeDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( CanvasSelfDrawable, CanvasNode.CanvasNodeDrawable, {
    initialize: function( renderer, instance ) {
      return this.initializeCanvasSelfDrawable( renderer, instance );
    },

    paintCanvas: function( wrapper, node ) {
      assert && assert( !node.selfBounds.isEmpty(), 'CanvasNode should not be used with an empty canvasBounds. ' +
                                                    'Please set canvasBounds (or use setCanvasBounds()) on ' + node.constructor.name );

      if ( !node.selfBounds.isEmpty() ) {
        var context = wrapper.context;
        context.save();

        // set back to Canvas default styles
        context.fillStyle = 'black';
        context.strokeStyle = 'black';
        context.lineWidth = 1;
        context.lineCap = 'butt';
        context.lineJoin = 'miter';
        context.lineDash = emptyArray;
        context.lineDashOffset = 0;
        context.miterLimit = 10;

        node.paintCanvas( context );

        context.restore();
      }
    }
  } );
  SelfDrawable.Poolable.mixin( CanvasNode.CanvasNodeDrawable );

  return CanvasNode;
} );



// Copyright 2013-2015, University of Colorado Boulder

/**
 * A circular node that inherits Path, and allows for optimized drawing,
 * and improved parameter handling.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Circle',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Bounds2','DOT/Matrix3','SCENERY/nodes/Path','KITE/Shape','SCENERY/util/Features','SCENERY/nodes/Paintable','SCENERY/display/DOMSelfDrawable','SCENERY/display/SVGSelfDrawable','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/Renderer','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Features = require( 'SCENERY/util/Features' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  require( 'SCENERY/util/Util' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepDOMCircleElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory
  var keepSVGCircleElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  function Circle( radius, options ) {
    if ( typeof radius === 'object' ) {
      // allow new Circle( { radius: ... } )
      // the mutators will call invalidateCircle() and properly set the shape
      options = radius;
      this._radius = options.radius;
    }
    else {
      this._radius = radius;

      // ensure we have a parameter object
      options = options || {};

    }
    // fallback for non-canvas or non-svg rendering, and for proper bounds computation

    Path.call( this, null, options );
  }

  scenery.register( 'Circle', Circle );

  inherit( Path, Circle, {
    getStrokeRendererBitmask: function() {
      var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
      if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern && this.getLineWidth() <= this.getRadius() ) {
        bitmask |= Renderer.bitmaskDOM;
      }
      return bitmask;
    },

    getPathRendererBitmask: function() {
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG | ( Features.borderRadius ? Renderer.bitmaskDOM : 0 );
    },

    invalidateCircle: function() {
      assert && assert( this._radius >= 0, 'A circle needs a non-negative radius' );

      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;

      // should invalidate the path and ensure a redraw
      this.invalidatePath();
    },

    createCircleShape: function() {
      return Shape.circle( 0, 0, this._radius );
    },

    intersectsBoundsSelf: function( bounds ) {
      // TODO: handle intersection with somewhat-infinite bounds!
      var x = Math.abs( bounds.centerX );
      var y = Math.abs( bounds.centerY );
      var halfWidth = bounds.maxX - x;
      var halfHeight = bounds.maxY - y;

      // too far to have a possible intersection
      if ( x > halfWidth + this._radius || y > halfHeight + this._radius ) {
        return false;
      }

      // guaranteed intersection
      if ( x <= halfWidth || y <= halfHeight ) {
        return true;
      }

      // corner case
      x -= halfWidth;
      y -= halfHeight;
      return x * x + y * y <= this._radius * this._radius;
    },

    canvasPaintSelf: function( wrapper ) {
      Circle.CircleCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },

    createDOMDrawable: function( renderer, instance ) {
      return Circle.CircleDOMDrawable.createFromPool( renderer, instance );
    },

    createSVGDrawable: function( renderer, instance ) {
      return Circle.CircleSVGDrawable.createFromPool( renderer, instance );
    },

    createCanvasDrawable: function( renderer, instance ) {
      return Circle.CircleCanvasDrawable.createFromPool( renderer, instance );
    },

    createWebGLDrawable: function( renderer, instance ) {
      return Circle.CircleWebGLDrawable.createFromPool( renderer, instance );
    },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.Circle( ' + this._radius + ', {' + propLines + '} )';
    },

    getRadius: function() {
      return this._radius;
    },

    setRadius: function( radius ) {
      assert && assert( typeof radius === 'number', 'Circle.radius must be a number' );

      if ( this._radius !== radius ) {
        this._radius = radius;
        this.invalidateCircle();

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyRadius();
        }
      }
      return this;
    },

    computeShapeBounds: function() {
      var bounds = new Bounds2( -this._radius, -this._radius, this._radius, this._radius );
      if ( this._stroke ) {
        // since we are axis-aligned, any stroke will expand our bounds by a guaranteed set amount
        bounds = bounds.dilated( this.getLineWidth() / 2 );
      }
      return bounds;
    },

    // accelerated hit detection
    containsPointSelf: function( point ) {
      var magSq = point.x * point.x + point.y * point.y;
      var result = true;
      var iRadius;
      if ( this._strokePickable ) {
        iRadius = this.getLineWidth() / 2;
        var outerRadius = this._radius + iRadius;
        result = result && magSq <= outerRadius * outerRadius;
      }

      if ( this._fillPickable ) {
        if ( this._strokePickable ) {
          // we were either within the outer radius, or not
          return result;
        }
        else {
          // just testing in the fill range
          return magSq <= this._radius * this._radius;
        }
      }
      else if ( this._strokePickable ) {
        var innerRadius = this._radius - iRadius;
        return result && magSq >= innerRadius * innerRadius;
      }
      else {
        return false; // neither stroke nor fill is pickable
      }
    },

    get radius() { return this.getRadius(); },
    set radius( value ) { return this.setRadius( value ); },

    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Circle to something non-null' );
      }
      else {
        // probably called from the Path constructor
        this.invalidatePath();
      }
    },

    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createCircleShape();
      }
      return this._shape;
    },

    hasShape: function() {
      return true;
    }
  } );

  // not adding mutators for now
  Circle.prototype._mutatorKeys = [ 'radius' ].concat( Path.prototype._mutatorKeys );

  /*---------------------------------------------------------------------------*
   * Rendering State mixin (DOM/SVG)
   *----------------------------------------------------------------------------*/

  Circle.CircleStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      // initializes, and resets (so we can support pooled states)
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true; // flag that is marked if ANY "paint" dirty flag is set (basically everything except for transforms, so we can accelerated the transform-only case)
        this.dirtyRadius = true;

        // adds fill/stroke-specific flags and state
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      proto.disposeState = function() {
        this.disposePaintableState();
      };

      // catch-all dirty, if anything that isn't a transform is marked as dirty
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyRadius = function() {
        this.dirtyRadius = true;
        this.markPaintDirty();
      };

      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyRadius = false;
      };

      Paintable.PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  /*---------------------------------------------------------------------------*
   * DOM rendering
   *----------------------------------------------------------------------------*/

  Circle.CircleDOMDrawable = function CircleDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( DOMSelfDrawable, Circle.CircleDOMDrawable, {
    // initializes, and resets (so we can support pooled states)
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );

      if ( !this.matrix ) {
        this.matrix = Matrix3.dirtyFromPool();
      }

      // only create elements if we don't already have them (we pool visual states always, and depending on the platform may also pool the actual elements to minimize
      // allocation and performance costs)
      if ( !this.fillElement || !this.strokeElement ) {
        var fillElement = this.fillElement = document.createElement( 'div' );
        var strokeElement = this.strokeElement = document.createElement( 'div' );
        fillElement.style.display = 'block';
        fillElement.style.position = 'absolute';
        fillElement.style.left = '0';
        fillElement.style.top = '0';
        fillElement.style.pointerEvents = 'none';
        strokeElement.style.display = 'block';
        strokeElement.style.position = 'absolute';
        strokeElement.style.left = '0';
        strokeElement.style.top = '0';
        strokeElement.style.pointerEvents = 'none';
        fillElement.appendChild( strokeElement );
      }

      this.domElement = this.fillElement;

      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    updateDOM: function() {
      var node = this.node;
      var fillElement = this.fillElement;
      var strokeElement = this.strokeElement;

      if ( this.paintDirty ) {
        if ( this.dirtyRadius ) {
          fillElement.style.width = ( 2 * node._radius ) + 'px';
          fillElement.style.height = ( 2 * node._radius ) + 'px';
          fillElement.style[ Features.borderRadius ] = node._radius + 'px';
        }
        if ( this.dirtyFill ) {
          fillElement.style.backgroundColor = node.getCSSFill();
        }

        if ( this.dirtyStroke ) {
          // update stroke presence
          if ( node.hasStroke() ) {
            strokeElement.style.borderStyle = 'solid';
          }
          else {
            strokeElement.style.borderStyle = 'none';
          }
        }

        if ( node.hasStroke() ) {
          // since we only execute these if we have a stroke, we need to redo everything if there was no stroke previously.
          // the other option would be to update stroked information when there is no stroke (major performance loss for fill-only Circles)
          var hadNoStrokeBefore = this.lastStroke === null;

          if ( hadNoStrokeBefore || this.dirtyLineWidth || this.dirtyRadius ) {
            strokeElement.style.width = ( 2 * node._radius - node.getLineWidth() ) + 'px';
            strokeElement.style.height = ( 2 * node._radius - node.getLineWidth() ) + 'px';
            strokeElement.style[ Features.borderRadius ] = ( node._radius + node.getLineWidth() / 2 ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyLineWidth ) {
            strokeElement.style.left = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.top = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.borderWidth = node.getLineWidth() + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyStroke ) {
            strokeElement.style.borderColor = node.getSimpleCSSStroke();
          }
        }
      }

      // shift the element vertically, postmultiplied with the entire transform.
      if ( this.transformDirty || this.dirtyRadius ) {
        this.matrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( -node._radius, -node._radius );
        this.matrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( this.matrix, this.fillElement, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToClean();
    },

    setToClean: function() {
      this.setToCleanState();

      this.cleanPaintableState();

      this.transformDirty = false;
    },

    dispose: function() {
      this.disposeState();

      // Release the DOM elements from the poolable visual state so they aren't kept in memory.
      // May not be done on platforms where we have enough memory to pool these
      if ( !keepDOMCircleElements ) {
        // clear the references
        this.fillElement = null;
        this.strokeElement = null;
        this.domElement = null;
      }
      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  Circle.CircleStatefulDrawable.mixin( Circle.CircleDOMDrawable );
  SelfDrawable.Poolable.mixin( Circle.CircleDOMDrawable );

  /*---------------------------------------------------------------------------*
   * SVG Rendering
   *----------------------------------------------------------------------------*/

  Circle.CircleSVGDrawable = function CircleSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( SVGSelfDrawable, Circle.CircleSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGCircleElements ); // usesPaint: true

      if ( !this.svgElement ) {
        this.svgElement = document.createElementNS( scenery.svgns, 'circle' );
      }

      return this;
    },
    updateSVGSelf: function() {
      var circle = this.svgElement;

      if ( this.dirtyRadius ) {
        circle.setAttribute( 'r', this.node._radius );
      }

      this.updateFillStrokeStyle( circle );
    }
  } );
  Circle.CircleStatefulDrawable.mixin( Circle.CircleSVGDrawable );
  SelfDrawable.Poolable.mixin( Circle.CircleSVGDrawable );

  /*---------------------------------------------------------------------------*
   * Canvas rendering
   *----------------------------------------------------------------------------*/

  Circle.CircleCanvasDrawable = function CircleCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( CanvasSelfDrawable, Circle.CircleCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;

      context.beginPath();
      context.arc( 0, 0, node._radius, 0, Math.PI * 2, false );
      context.closePath();

      if ( node.hasFill() ) {
        node.beforeCanvasFill( wrapper ); // defined in Paintable
        context.fill();
        node.afterCanvasFill( wrapper ); // defined in Paintable
      }
      if ( node.hasStroke() ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.stroke();
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },

    // stateless dirty functions
    markDirtyRadius: function() { this.markPaintDirty(); },

    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  Paintable.PaintableStatelessDrawable.mixin( Circle.CircleCanvasDrawable );
  SelfDrawable.Poolable.mixin( Circle.CircleCanvasDrawable );

  return Circle;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Escaping of HTML content that will be placed in the body, inside an element as a node.
 *
 * This is NOT for escaping something in other HTML contexts, for example as an attribute value
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'PHET_CORE/escapeHTML',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function escapeHTML( str ) {
    // see https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet
    // HTML Entity Encoding
    return str
      .replace( /&/g, '&amp;' )
      .replace( /</g, '&lt;' )
      .replace( />/g, '&gt;' )
      .replace( /\"/g, '&quot;' )
      .replace( /\'/g, '&#x27;' )
      .replace( /\//g, '&#x2F;' );
  }

  phetCore.register( 'escapeHTML', escapeHTML );

  return escapeHTML;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * DOM nodes. Currently lightweight handling
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/DOM',['require','PHET_CORE/inherit','PHET_CORE/escapeHTML','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/util/Util','SCENERY/display/DOMSelfDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var escapeHTML = require( 'PHET_CORE/escapeHTML' );
  var Bounds2 = require( 'DOT/Bounds2' );

  var scenery = require( 'SCENERY/scenery' );

  var Node = require( 'SCENERY/nodes/Node' ); // DOM inherits from Node
  var Renderer = require( 'SCENERY/display/Renderer' );
  require( 'SCENERY/util/Util' );

  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  function DOM( element, options ) {
    options = options || {};

    this._interactive = false;

    // unwrap from jQuery if that is passed in, for consistency
    if ( element && element.jquery ) {
      element = element[ 0 ];
    }

    this._container = document.createElement( 'div' );
    this._$container = $( this._container );
    this._$container.css( 'position', 'absolute' );
    this._$container.css( 'left', 0 );
    this._$container.css( 'top', 0 );

    this.invalidateDOMLock = false;

    // don't let Scenery apply a transform directly (the DOM element will take care of that)
    this._preventTransform = false;

    // so that the mutator will call setElement()
    options.element = element;

    // will set the element after initializing
    Node.call( this, options );
    this.setRendererBitmask( Renderer.bitmaskDOM );
  }

  scenery.register( 'DOM', DOM );

  inherit( Node, DOM, {
    // we use a single DOM instance, so this flag should indicate that we don't support duplicating it
    allowsMultipleDOMInstances: false,

    // needs to be attached to the DOM tree for this to work
    calculateDOMBounds: function() {
      // var boundingRect = this._element.getBoundingClientRect();
      // return new Bounds2( 0, 0, boundingRect.width, boundingRect.height );
      var $element = $( this._element );
      return new Bounds2( 0, 0, $element.width(), $element.height() );
    },

    createTemporaryContainer: function() {
      var temporaryContainer = document.createElement( 'div' );
      $( temporaryContainer ).css( {
        display: 'hidden',
        padding: '0 !important',
        margin: '0 !important',
        position: 'absolute',
        left: 0,
        top: 0,
        width: 65535,
        height: 65535
      } );
      return temporaryContainer;
    },

    invalidateDOM: function() {
      // prevent this from being executed as a side-effect from inside one of its own calls
      if ( this.invalidateDOMLock ) {
        return;
      }
      this.invalidateDOMLock = true;

      // we will place ourselves in a temporary container to get our real desired bounds
      var temporaryContainer = this.createTemporaryContainer();

      // move to the temporary container
      this._container.removeChild( this._element );
      temporaryContainer.appendChild( this._element );
      document.body.appendChild( temporaryContainer );

      // bounds computation and resize our container to fit precisely
      var selfBounds = this.calculateDOMBounds();
      this.invalidateSelf( selfBounds );
      this._$container.width( selfBounds.getWidth() );
      this._$container.height( selfBounds.getHeight() );

      // move back to the main container
      document.body.removeChild( temporaryContainer );
      temporaryContainer.removeChild( this._element );
      this._container.appendChild( this._element );

      this.invalidateDOMLock = false;
    },

    getDOMElement: function() {
      return this._container;
    },

    createDOMDrawable: function( renderer, instance ) {
      return DOM.DOMDrawable.createFromPool( renderer, instance );
    },

    isPainted: function() {
      return true;
    },

    setElement: function( element ) {
      assert && assert( !this._element, 'We should only ever attach one DOMElement to a DOM node' );

      if ( this._element !== element ) {
        if ( this._element ) {
          this._container.removeChild( this._element );
        }

        this._element = element;
        this._$element = $( element );

        this._container.appendChild( this._element );

        // TODO: bounds issue, since this will probably set to empty bounds and thus a repaint may not draw over it
        this.invalidateDOM();
      }

      return this; // allow chaining
    },

    getElement: function() {
      return this._element;
    },

    setInteractive: function( interactive ) {
      if ( this._interactive !== interactive ) {
        this._interactive = interactive;

        // TODO: anything needed here?
      }
    },

    isInteractive: function() {
      return this._interactive;
    },

    setPreventTransform: function( preventTransform ) {
      assert && assert( typeof preventTransform === 'boolean' );

      if ( this._preventTransform !== preventTransform ) {
        this._preventTransform = preventTransform;

        // TODO: anything needed here?
      }
    },

    isTransformPrevented: function() {
      return this._preventTransform;
    },

    set element( value ) { this.setElement( value ); },
    get element() { return this.getElement(); },

    set interactive( value ) { this.setInteractive( value ); },
    get interactive() { return this.isInteractive(); },

    set preventTransform( value ) { this.setPreventTransform( value ); },
    get preventTransform() { return this.isTransformPrevented(); },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.DOM( $( \'' + escapeHTML( this._container.innerHTML.replace( /'/g, '\\\'' ) ) + '\' ), {' + propLines + '} )';
    },

    getPropString: function( spaces, includeChildren ) {
      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
      if ( this.interactive ) {
        if ( result ) {
          result += ',\n';
        }
        result += spaces + 'interactive: true';
      }
      return result;
    }
  } );

  DOM.prototype._mutatorKeys = [ 'element', 'interactive', 'preventTransform' ].concat( Node.prototype._mutatorKeys );

  /*---------------------------------------------------------------------------*
   * DOM rendering
   *----------------------------------------------------------------------------*/

  DOM.DOMDrawable = inherit( DOMSelfDrawable, function DOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }, {
    // initializes, and resets (so we can support pooled states)
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );

      this.domElement = this.node._container;

      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    updateDOM: function() {
      if ( this.transformDirty && !this.node._preventTransform ) {
        scenery.Util.applyPreparedTransform( this.getTransformMatrix(), this.domElement, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToClean();
    },

    setToClean: function() {
      this.transformDirty = false;
    },

    dispose: function() {
      DOMSelfDrawable.prototype.dispose.call( this );

      this.domElement = null;
    }
  } );

  SelfDrawable.Poolable.mixin( DOM.DOMDrawable );

  return DOM;
} );



// Copyright 2014-2015, University of Colorado Boulder

/**
 * LayoutBox lays out its children in a row, either horizontally or vertically (based on an optional parameter).
 * VBox and HBox are convenience subtypes that specify the orientation.
 * See https://github.com/phetsims/scenery/issues/281
 *
 * @author Sam Reid
 * @author Aaron Davis
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY/nodes/LayoutBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Node'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );

  // constants
  var DEFAULT_SPACING = 0;

  /**
   * @param {Object} [options] Same as Node.constructor.options with the following additions:
   * @constructor
   */
  function LayoutBox( options ) {

    if ( options && options.spacing ) {
      assert && assert( typeof options.spacing === 'number', 'LayoutBox requires spacing to be a number, if it is provided' );
    }

    options = _.extend( {

      //The default orientation, chosen by popular vote.  At the moment there are around 436 VBox references and 338 HBox references
      orientation: 'vertical',

      // The spacing between each Node (a number)
      spacing: DEFAULT_SPACING,

      //How to line up the items
      align: 'center',

      //By default, update the layout when children are added/removed/resized, see #116
      resize: true
    }, options ); // @private

    // validate options
    assert && assert( options.orientation === 'vertical' || options.orientation === 'horizontal' );
    if ( options.orientation === 'vertical' ) {
      assert && assert( options.align === 'center' || options.align === 'left' || options.align === 'right', 'illegal alignment: ' + options.align );
    }
    else {
      assert && assert( options.align === 'center' || options.align === 'top' || options.align === 'bottom', 'illegal alignment: ' + options.align );
    }

    this.orientation = options.orientation; // @private
    this.align = options.align; // @private
    this.resize = options.resize; // @private
    this._spacing = options.spacing; // @private {number}

    Node.call( this );

    this.boundsListener = this.updateLayout.bind( this ); // @private
    this.updatingLayout = false; // @private flag used to short-circuit updateLayout and prevent stackoverflow

    // Apply the supplied options, including children.
    // The layout calls are triggered if (a) options.resize is set to true or (b) during initialization
    // When true, the this.inited flag signifies that the initial layout is being done.
    this.inited = false; // @private
    this.mutate( options );
    this.inited = true;
  }

  scenery.register( 'LayoutBox', LayoutBox );

  return inherit( Node, LayoutBox, {

    /**
     * The actual layout logic, typically run from the constructor OR updateLayout().
     * @private
     */
    layout: function() {

      var children = this.getChildren(); // call this once, since it returns a copy
      var i;
      var child;

      // Get the smallest Bounds2 that contains all of our children (triggers bounds validation for all of them)
      var childBounds = this.childBounds;

      // Logic for layout out the components.
      // Aaron and Sam looked at factoring this out, but the result looked less readable since each attribute
      // would have to be abstracted over.
      if ( this.orientation === 'vertical' ) {
        // Start at y=0 in the coordinate frame of this node.  Not possible to set this through the spacing option, instead just set it with the {y:number} option.
        var y = 0;
        for ( i = 0; i < children.length; i++ ) {
          child = children[ i ];
          if ( !child.bounds.isValid() ) {
            continue;
          }
          child.top = y;

          // Set the position horizontally
          if ( this.align === 'left' ) {
            child.left = childBounds.minX;
          }
          else if ( this.align === 'right' ) {
            child.right = childBounds.maxX;
          }
          else { // 'center'
            child.centerX = childBounds.centerX;
          }

          // Move to the next vertical position.
          y += child.height + this._spacing;
        }
      }
      else {
        // Start at x=0 in the coordinate frame of this node.  Not possible to set this through the spacing option, instead just set it with the {x:number} option.
        var x = 0;
        for ( i = 0; i < children.length; i++ ) {
          child = children[ i ];
          if ( !child.bounds.isValid() ) {
            continue;
          }
          child.left = x;

          // Set the position horizontally
          if ( this.align === 'top' ) {
            child.top = childBounds.minY;
          }
          else if ( this.align === 'bottom' ) {
            child.bottom = childBounds.maxY;
          }
          else { // 'center'
            child.centerY = childBounds.centerY;
          }

          // Move to the next horizontal position.
          x += child.width + this._spacing;
        }
      }
    },

    /**
     * Updates the layout of this LayoutBox. Called automatically during initialization, when children change (if
     * resize is true), or when client wants to call this public method for any reason.
     * @public
     */
    updateLayout: function() {
      // Bounds of children are changed in updateLayout, we don't want to stackoverflow, so bail if already updating layout
      if ( !this.updatingLayout ) {
        this.updatingLayout = true;
        this.layout();
        this.updatingLayout = false;
      }
    },

    /**
     * @override - Overrides from Node, so we can listen for bounds changes.
     * We have to listen to the bounds of each child individually, since individual child bounds changes might not
     * trigger an overall bounds change.
     */
    insertChild: function( index, node ) {

      // Super call
      Node.prototype.insertChild.call( this, index, node );

      // Update the layout (a) if it should be dynamic or (b) during initialization
      if ( this.resize || !this.inited ) {
        this.updateLayout();
      }

      if ( this.resize ) {
        node.onStatic( 'bounds', this.boundsListener );
      }
    },

    /**
     * @override - Overrides from Node, so we can listen for bounds changes.
     *
     * @param {Node} node
     * @param {number} indexOfChild
     */
    removeChildWithIndex: function( node, indexOfChild ) {

      if ( this.resize ) {
        node.offStatic( 'bounds', this.boundsListener );
      }

      // Super call
      Node.prototype.removeChildWithIndex.call( this, node, indexOfChild );

      // Update the layout (a) if it should be dynamic or (b) during initialization
      if ( this.resize || !this.inited ) {
        this.updateLayout();
      }
    },

    /**
     * Sets spacing between items in the box.
     * @public
     *
     * @param {number} spacing
     */
    setSpacing: function( spacing ) {

      // Make sure the provided spacing is a number (since we previously allowed number | function here
      assert && assert( typeof spacing === 'number', 'spacing must be a number' );

      if ( this._spacing !== spacing ) {
        this._spacing = spacing;

        // TODO: Do we need to check for if we are resizing?
        this.updateLayout();
      }
    },
    set spacing( value ) {
      this.setSpacing( value );
    },

    /**
     * Gets the spacing between items in the box.
     * @public
     *
     * @returns {number}
     */
    getSpacing: function() {
      return this._spacing;
    },
    get spacing() {
      return this.getSpacing();
    }
  } );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * HBox is a convenience specialization of LayoutBox with horizontal orientation.
 *
 * @author Sam Reid
 */
define( 'SCENERY/nodes/HBox',['require','PHET_CORE/inherit','SCENERY/nodes/LayoutBox','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var LayoutBox = require( 'SCENERY/nodes/LayoutBox' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @param {Object} [options] see LayoutBox
   * @constructor
   */
  function HBox( options ) {
    LayoutBox.call( this, _.extend( {}, options, { orientation: 'horizontal' } ) );
  }

  scenery.register( 'HBox', HBox );

  return inherit( LayoutBox, HBox );
} );
// Copyright 2013-2015, University of Colorado Boulder


/**
 * Font handling for text drawing
 *
 * Examples:
 * new scenery.Font().font                      // "10px sans-serif" (the default)
 * new scenery.Font( { family: 'serif' } ).font // "10px serif"
 * new scenery.Font( { weight: 'bold' } ).font  // "bold 10px sans-serif"
 * new scenery.Font( { size: 16 } ).font        // "16px sans-serif"
 * var font = new scenery.Font( {
 *   family: '"Times New Roman", serif',
 *   style: 'italic',
 *   lineHeight: 10
 * } );
 * font.font;                                   // "italic 10px/10 'Times New Roman', serif"
 * font.family;                                 // "'Times New Roman', serif"
 * font.weight;                                 // 400 (the default)
 *
 * Useful specs:
 * http://www.w3.org/TR/css3-fonts/
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Font',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  // constants used for detection (since styles/variants/weights/stretches can be mixed in the preamble of the shorthand string)
  var styles = [ 'normal', 'italic', 'oblique' ];
  var variants = [ 'normal', 'small-caps' ];
  var weights = [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900' ];
  var stretches = [ 'normal', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded' ];

  // size constants used for detection
  // var sizes = [ 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'larger', 'smaller' ];

  function castSize( size ) {
    if ( typeof size === 'number' ) {
      return size + 'px'; // add the pixels suffix by default for numbers
    }
    else {
      return size; // assume that it's a valid to-spec string
    }
  }

  function Font( options ) {
    // options from http://www.w3.org/TR/css3-fonts/
    this._style = 'normal';      // normal | italic | oblique
    this._variant = 'normal';    // normal | small-caps
    this._weight = 'normal';     // normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
    this._stretch = 'normal';    // normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded
    this._size = '10px';         // <absolute-size> | <relative-size> | <length> | <percentage> -- unitless number interpreted as px. absolute suffixes: cm, mm, in, pt, pc, px. relative suffixes: em, ex, ch, rem, vw, vh, vmin, vmax.
    this._lineHeight = 'normal'; // normal | <number> | <length> | <percentage> -- NOTE: Canvas spec forces line-height to normal
    this._family = 'sans-serif'; // comma-separated list of families, including generic families (serif, sans-serif, cursive, fantasy, monospace). ideally escape with double-quotes

    // font  [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]? <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ] | caption | icon | menu | message-box | small-caption | status-bar
    // <font-variant-css21> = [normal | small-caps]

    var type = typeof options;
    if ( type === 'string' ) {
      // parse a somewhat proper CSS3 form (not guaranteed to handle it precisely the same as browsers yet)

      // split based on whitespace allowed by CSS spec (more restrictive than regular regexp whitespace)
      var tokens = _.filter( options.split( /[\x09\x0A\x0C\x0D\x20]/ ), function( token ) { return token.length > 0; } );

      // pull tokens out until we reach something that doesn't match. that must be the font size (according to spec)
      for ( var i = 0; i < tokens.length; i++ ) {
        var token = tokens[ i ];
        if ( token === 'normal' ) {
          // nothing has to be done, everything already normal as default
        }
        else if ( _.contains( styles, token ) ) {
          assert && assert( this._style === 'normal', 'Style cannot be applied twice. Already set to "' + this._style + '", attempt to replace with "' + token + '"' );
          this._style = token;
        }
        else if ( _.contains( variants, token ) ) {
          assert && assert( this._variant === 'normal', 'Variant cannot be applied twice. Already set to "' + this._variant + '", attempt to replace with "' + token + '"' );
          this._variant = token;
        }
        else if ( _.contains( weights, token ) ) {
          assert && assert( this._weight === 'normal', 'Weight cannot be applied twice. Already set to "' + this._weight + '", attempt to replace with "' + token + '"' );
          this._weight = token;
        }
        else if ( _.contains( stretches, token ) ) {
          assert && assert( this._stretch === 'normal', 'Stretch cannot be applied twice. Already set to "' + this._stretch + '", attempt to replace with "' + token + '"' );
          this._stretch = token;
        }
        else {
          // not a style/variant/weight/stretch, must be a font size, possibly with an included line-height
          var subtokens = token.split( /\// ); // extract font size from any line-height
          this._size = subtokens[ 0 ];
          if ( subtokens[ 1 ] ) {
            this._lineHeight = subtokens[ 1 ];
          }
          // all future tokens are guaranteed to be part of the font-family if it is given according to spec
          this._family = tokens.slice( i + 1 ).join( ' ' );
          break;
        }
      }
    }
    else if ( type === 'object' ) {
      if ( options.style !== undefined ) {
        this._style = options.style;
      }
      if ( options.variant !== undefined ) {
        this._variant = options.variant;
      }
      if ( options.weight !== undefined ) {
        this._weight = '' + options.weight; // cast it to a string explicitly
      }
      if ( options.stretch !== undefined ) {
        this._stretch = options.stretch;
      }
      if ( options.size !== undefined ) {
        this._size = castSize( options.size );
      }
      if ( options.lineHeight !== undefined ) {
        this._lineHeight = options.lineHeight;
      }
      if ( options.family !== undefined ) {
        this._family = options.family;
      }
    }

    // sanity checks to prevent errors in interpretation or in the font shorthand usage
    assert && assert( typeof this._style === 'string' && _.contains( styles, this._style ),
      'Font style must be one of "normal", "italic", or "oblique"' );
    assert && assert( typeof this._variant === 'string' && _.contains( variants, this._variant ),
      'Font variant must be "normal" or "small-caps"' );
    assert && assert( typeof this._weight === 'string' && _.contains( weights, this._weight ),
      'Font weight must be one of "normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", or "900"' );
    assert && assert( typeof this._stretch === 'string' && _.contains( stretches, this._stretch ),
      'Font stretch must be one of "normal", "ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "semi-expanded", "expanded", "extra-expanded", or "ultra-expanded"' );
    assert && assert( typeof this._size === 'string' && !_.contains( [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ], this._size[ this._size.length - 1 ] ),
      'Font size must be either passed as a number (not a string, interpreted as px), or must contain a suffix for percentage, absolute or relative units, or an explicit size constant' );
    assert && assert( typeof this._lineHeight === 'string' );
    assert && assert( typeof this._family === 'string' );

    // initialize the shorthand font property (stored as _font)
    this._font = this.computeShorthand();

    phetAllocation && phetAllocation( 'Font' );
  }

  scenery.register( 'Font', Font );

  inherit( Object, Font, {
    getFont: function() { return this._font; },
    getStyle: function() { return this._style; },
    getVariant: function() { return this._variant; },
    getWeight: function() { return this._weight; },
    getStretch: function() { return this._stretch; },
    getSize: function() { return this._size; },
    getLineHeight: function() { return this._lineHeight; },
    getFamily: function() { return this._family; },

    get font() { return this.getFont(); },
    get style() { return this.getStyle(); },
    get variant() { return this.getVariant(); },
    get weight() { return this.getWeight(); },
    get stretch() { return this.getStretch(); },
    get size() { return this.getSize(); },
    get lineHeight() { return this.getLineHeight(); },
    get family() { return this.getFamily(); },

    copy: function( options ) {
      return new Font( _.extend( {
        style: this._style,
        variant: this._variant,
        weight: this._weight,
        stretch: this._stretch,
        size: this._size,
        lineHeight: this._lineHeight,
        family: this._family
      }, options ) );
    },

    computeShorthand: function() {
      var ret = '';
      if ( this._style !== 'normal' ) { ret += this._style + ' '; }
      if ( this._variant !== 'normal' ) { ret += this._variant + ' '; }
      if ( this._weight !== 'normal' ) { ret += this._weight + ' '; }
      if ( this._stretch !== 'normal' ) { ret += this._stretch + ' '; }
      ret += this._size;
      if ( this._lineHeight !== 'normal' ) { ret += '/' + this._lineHeight; }
      ret += ' ' + this._family;
      return ret;
    },

    toCSS: function() {
      return this.getFont();
    }
  } );

  Font.DEFAULT = new Font();

  return Font;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Text
 *
 * TODO: newlines (multiline)
 * TODO: don't get bounds until the Text node is fully mutated?
 *
 * Useful specs:
 * http://www.w3.org/TR/css3-text/
 * http://www.w3.org/TR/css3-fonts/
 * http://www.w3.org/TR/SVG/text.html
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Text',['require','PHET_CORE/inherit','PHET_CORE/escapeHTML','PHET_CORE/platform','DOT/Bounds2','DOT/Matrix3','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/nodes/Paintable','SCENERY/util/Font','SCENERY/util/Util','SCENERY/util/CanvasContextWrapper','SCENERY/display/DOMSelfDrawable','SCENERY/display/SVGSelfDrawable','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/WebGLSelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var escapeHTML = require( 'PHET_CORE/escapeHTML' );
  var platform = require( 'PHET_CORE/platform' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );

  var Node = require( 'SCENERY/nodes/Node' ); // inherits from Node
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );
  require( 'SCENERY/util/Font' );
  require( 'SCENERY/util/Util' ); // for canvasAccurateBounds and CSS transforms
  require( 'SCENERY/util/CanvasContextWrapper' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepDOMTextElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory
  var keepSVGTextElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  // scratch matrix used in DOM rendering
  var scratchMatrix = Matrix3.dirtyFromPool();

  var textSizeContainerId = 'sceneryTextSizeContainer';
  var textSizeElementId = 'sceneryTextSizeElement';
  var svgTextSizeContainer = document.getElementById( textSizeContainerId );
  var svgTextSizeElement = document.getElementById( textSizeElementId );

  // SVG bounds seems to be malfunctioning for Safari 5. Since we don't have a reproducible test machine for
  // fast iteration, we'll guess the user agent and use DOM bounds instead of SVG.
  // Hopefully the two contraints rule out any future Safari versions (fairly safe, but not impossible!)
  var useDOMAsFastBounds = window.navigator.userAgent.indexOf( 'like Gecko) Version/5' ) !== -1 &&
                           window.navigator.userAgent.indexOf( 'Safari/' ) !== -1;

  var hybridTextNode; // a node that is used to measure SVG text top/height for hybrid caching purposes
  var initializingHybridTextNode = false;

  // Some browsers (IE/Edge) can't handle our UTF-8 embedding marks AND SVG textLength/spacingAndGlyphs. We disable
  // using these features, because they aren't necessary on these browsers.
  // See https://github.com/phetsims/scenery/issues/455 for more information.
  var useSVGTextLengthAdjustments = !platform.ie && !platform.edge;

  // Maps CSS {string} => {Bounds2}, so that we can cache the vertical font sizes outside of the Font objects themselves.
  var hybridFontVerticalCache = {};

  function Text( text, options ) {
    this._text = '';                   // filled in with mutator
    this._font = scenery.Font.DEFAULT; // default font, usually 10px sans-serif
    this._direction = 'ltr';           // ltr, rtl, inherit -- consider inherit deprecated, due to how we compute text bounds in an off-screen canvas
    this._boundsMethod = 'hybrid';     // fast (SVG/DOM, no canvas rendering allowed), fastCanvas (SVG/DOM, canvas rendering allowed without dirty regions),
    // accurate (Canvas accurate recursive), or hybrid (cache SVG height, use canvas measureText for width)

    // whether the text is rendered as HTML or not. if defined (in a subtype constructor), use that value instead
    this._isHTML = this._isHTML === undefined ? false : this._isHTML;

    // {null|string} - The actual string displayed (can have non-breaking spaces and embedding marks rewritten).
    // When this is null, its value needs to be recomputed
    this._cachedRenderedText = null;

    // ensure we have a parameter object
    options = options || {};

    // default to black filled text
    if ( options.fill === undefined ) {
      options.fill = '#000000';
    }

    if ( text !== undefined ) {
      // set the text parameter so that setText( text ) is effectively called in the mutator from the super call
      options.text = text;
    }

    this.initializePaintable();

    Node.call( this, options );
    this.updateTextFlags(); // takes care of setting up supported renderers
  }

  scenery.register( 'Text', Text );

  inherit( Node, Text, {
    domUpdateTransformOnRepaint: true, // since we have to integrate the baseline offset into the CSS transform, signal to DOMLayer

    setText: function( text ) {
      assert && assert( text !== null && text !== undefined, 'Text should be defined and non-null. Use the empty string if needed.' );

      // cast it to a string (for numbers, etc., and do it before the change guard so we don't accidentally trigger on non-changed text)
      text = '' + text;

      if ( text !== this._text ) {
        var oldText = this._text;
        this._text = text;
        this._cachedRenderedText = null;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyText();
        }

        this.invalidateText();
        this.trigger2( 'text', oldText, text );
      }
      return this;
    },

    getText: function() {
      return this._text;
    },

    /**
     * Returns a potentially modified version of this.text, where spaces are replaced with non-breaking spaces,
     * and embedding marks are potentially simplified.
     * @public
     *
     * @returns {string}
     */
    getRenderedText: function() {
      if ( this._cachedRenderedText === null ) {
        // Using the non-breaking space (&nbsp;) encoded as 0x00A0 in UTF-8
        this._cachedRenderedText = this._text.replace( ' ', '\xA0' );

        if ( platform.edge ) {
          // Simplify embedding marks to work around an Edge bug, see https://github.com/phetsims/scenery/issues/520
          this._cachedRenderedText = Text.simplifyEmbeddingMarks( this._cachedRenderedText );
        }
      }

      return this._cachedRenderedText;
    },
    get renderedText() { return this.getRenderedText(); },

    setBoundsMethod: function( method ) {
      assert && assert( method === 'fast' || method === 'fastCanvas' || method === 'accurate' || method === 'hybrid', 'Unknown Text boundsMethod' );
      if ( method !== this._boundsMethod ) {
        this._boundsMethod = method;
        this.updateTextFlags();

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyBounds();
        }

        this.invalidateText();

        this.trigger0( 'boundsMethod' );

        this.trigger0( 'selfBoundsValid' ); // whether our self bounds are valid may have changed
      }
      return this;
    },

    getBoundsMethod: function() {
      return this._boundsMethod;
    },

    getTextRendererBitmask: function() {
      var bitmask = 0;

      // canvas support (fast bounds may leak out of dirty rectangles)
      if ( this._boundsMethod !== 'fast' && !this._isHTML ) {
        bitmask |= Renderer.bitmaskCanvas;
      }
      if ( !this._isHTML ) {
        bitmask |= Renderer.bitmaskSVG;
      }

      // fill and stroke will determine whether we have DOM text support
      bitmask |= Renderer.bitmaskDOM;

      return bitmask;
    },

    invalidateSupportedRenderers: function() {
      this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getTextRendererBitmask() );
    },

    updateTextFlags: function() {
      this.invalidateSupportedRenderers();
    },

    invalidateText: function() {
      this.invalidateSelf();

      // TODO: consider replacing this with a general dirty flag notification, and have DOM update bounds every frame?
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyBounds();
      }

      // we may have changed renderers if parameters were changed!
      this.updateTextFlags();
    },

    /**
     * @override
     *
     * @returns {boolean}
     */
    updateSelfBounds: function() {
      // TODO: don't create another Bounds2 object just for this!
      var selfBounds;

      // investigate http://mudcu.be/journal/2011/01/html5-typographic-metrics/
      if ( this._isHTML || ( useDOMAsFastBounds && this._boundsMethod !== 'accurate' ) ) {
        selfBounds = this.approximateDOMBounds();
      }
      else if ( this._boundsMethod === 'hybrid' ) {
        selfBounds = this.approximateHybridBounds();
      }
      else if ( this._boundsMethod === 'fast' || this._boundsMethod === 'fastCanvas' ) {
        selfBounds = this.approximateSVGBounds();
      }
      else {
        selfBounds = this.accurateCanvasBounds();
      }

      // for now, just add extra on, ignoring the possibility of mitered joints passing beyond
      if ( this.hasStroke() ) {
        selfBounds.dilate( this.getLineWidth() / 2 );
      }

      var changed = !selfBounds.equals( this._selfBounds );
      if ( changed ) {
        this._selfBounds.set( selfBounds );
      }
      return changed;
    },

    // @override from Paintable
    invalidateStroke: function() {
      // stroke can change both the bounds and renderer
      this.invalidateText();
    },

    // @override from Paintable
    invalidateFill: function() {
      // fill type can change the renderer (gradient/fill not supported by DOM)
      this.invalidateText();
    },

    canvasPaintSelf: function( wrapper ) {
      Text.TextCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },

    createDOMDrawable: function( renderer, instance ) {
      return Text.TextDOMDrawable.createFromPool( renderer, instance );
    },

    createSVGDrawable: function( renderer, instance ) {
      return Text.TextSVGDrawable.createFromPool( renderer, instance );
    },

    createCanvasDrawable: function( renderer, instance ) {
      return Text.TextCanvasDrawable.createFromPool( renderer, instance );
    },

    createWebGLDrawable: function( renderer, instance ) {
      return Text.TextWebGLDrawable.createFromPool( renderer, instance );
    },

    // a DOM node (not a Scenery DOM node, but an actual DOM node) with the text
    getDOMTextNode: function() {
      if ( this._isHTML ) {
        var span = document.createElement( 'span' );
        span.innerHTML = this._text;
        return span;
      }
      else {
        return document.createTextNode( this.renderedText );
      }
    },

    /*---------------------------------------------------------------------------*
     * Bounds
     *----------------------------------------------------------------------------*/

    getVerticalBounds: function() {
      if ( !hybridTextNode ) {
        return Bounds2.NOTHING; // we are the hybridTextNode, ignore us
      }

      var css = this._font.toCSS();
      var verticalBounds = hybridFontVerticalCache[ css ];
      if ( !verticalBounds ) {
        hybridTextNode.setFont( this._font );
        verticalBounds = hybridFontVerticalCache[ css ] = hybridTextNode.getBounds().copy();
      }

      return verticalBounds;
    },

    accurateCanvasBounds: function() {
      var node = this;
      var svgBounds = this.approximateSVGBounds(); // this seems to be slower than expected, mostly due to Font getters

      //If svgBounds are zero, then return the zero bounds
      if ( !this._text || svgBounds.width === 0 ) {
        return svgBounds;
      }

      // NOTE: should return new instance, so that it can be mutated later
      return scenery.Util.canvasAccurateBounds( function( context ) {
        context.font = node.font;
        context.direction = node.direction;
        context.fillText( node.renderedText, 0, 0 );
        if ( node.hasStroke() ) {
          var fakeWrapper = new scenery.CanvasContextWrapper( null, context );
          node.beforeCanvasStroke( fakeWrapper );
          context.strokeText( node.renderedText, 0, 0 );
          node.afterCanvasStroke( fakeWrapper );
        }
      }, {
        precision: 0.5,
        resolution: 128,
        initialScale: 32 / Math.max( Math.abs( svgBounds.minX ), Math.abs( svgBounds.minY ), Math.abs( svgBounds.maxX ), Math.abs( svgBounds.maxY ) )
      } );
    },

    approximateCanvasWidth: function() {
      var context = scenery.scratchContext;
      context.font = this.font;
      context.direction = this.direction;
      return context.measureText( this.renderedText ).width;
    },

    // NOTE: should return new instance, so that it can be mutated later
    approximateSVGBounds: function() {
      if ( !svgTextSizeContainer.parentNode ) {
        if ( document.body ) {
          document.body.appendChild( svgTextSizeContainer );
        }
        else {
          // TODO: better way to handle the hybridTextNode being added inside the HEAD? Requiring a body for proper operation might be a problem.
          if ( initializingHybridTextNode ) {
            // if this is almost assuredly the hybridTextNode, return nothing for now. TODO: better way of handling this! it's a hack!
            return Bounds2.NOTHING;
          }
          else {
            throw new Error( 'No document.body and trying to get approximate SVG bounds of a Text node' );
          }
        }
      }
      updateSVGTextToMeasure( svgTextSizeElement, this );
      var rect = svgTextSizeElement.getBBox();
      return new Bounds2( rect.x, rect.y, rect.x + rect.width, rect.y + rect.height );
    },

    // NOTE: should return new instance, so that it can be mutated later
    approximateHybridBounds: function() {
      var verticalBounds = this.getVerticalBounds();

      var canvasWidth = this.approximateCanvasWidth();

      // it seems that SVG bounds generally have x=0, so we hard code that here
      return new Bounds2( 0, verticalBounds.minY, canvasWidth, verticalBounds.maxY );
    },

    // NOTE: should return new instance, so that it can be mutated later
    approximateDOMBounds: function() {
      var maxHeight = 1024; // technically this will fail if the font is taller than this!
      var isRTL = this.direction === 'rtl';

      // <div style="position: absolute; left: 0; top: 0; padding: 0 !important; margin: 0 !important;"><span id="baselineSpan" style="font-family: Verdana; font-size: 25px;">QuipTaQiy</span><div style="vertical-align: baseline; display: inline-block; width: 0; height: 500px; margin: 0 important!; padding: 0 important!;"></div></div>

      var div = document.createElement( 'div' );
      $( div ).css( {
        position: 'absolute',
        left: 0,
        top: 0,
        padding: '0 !important',
        margin: '0 !important',
        display: 'hidden'
      } );

      var span = document.createElement( 'span' );
      $( span ).css( 'font', this.getFont() );
      span.appendChild( this.getDOMTextNode() );
      span.setAttribute( 'direction', this._direction );

      var fakeImage = document.createElement( 'div' );
      $( fakeImage ).css( {
        'vertical-align': 'baseline',
        display: 'inline-block',
        width: 0,
        height: maxHeight + 'px',
        margin: '0 !important',
        padding: '0 !important'
      } );

      div.appendChild( span );
      div.appendChild( fakeImage );

      document.body.appendChild( div );
      var rect = span.getBoundingClientRect();
      var divRect = div.getBoundingClientRect();
      // add 1 pixel to rect.right to prevent HTML text wrapping
      var result = new Bounds2( rect.left, rect.top - maxHeight, rect.right + 1, rect.bottom - maxHeight ).shifted( -divRect.left, -divRect.top );
      // console.log( 'result: ' + result );
      document.body.removeChild( div );

      var width = rect.right - rect.left;
      return result.shiftedX( isRTL ? -width : 0 ); // should we even swap here?
    },

    approximateImprovedDOMBounds: function() {
      // TODO: reuse this div?
      var div = document.createElement( 'div' );
      div.style.display = 'inline-block';
      div.style.font = this.getFont();
      div.style.color = 'transparent';
      div.style.padding = '0 !important';
      div.style.margin = '0 !important';
      div.style.position = 'absolute';
      div.style.left = '0';
      div.style.top = '0';
      div.setAttribute( 'direction', this._direction );
      div.appendChild( this.getDOMTextNode() );

      document.body.appendChild( div );
      var bounds = new Bounds2( div.offsetLeft, div.offsetTop, div.offsetLeft + div.offsetWidth + 1, div.offsetTop + div.offsetHeight + 1 );
      document.body.removeChild( div );

      // Compensate for the baseline alignment
      var verticalBounds = this.getVerticalBounds();
      return bounds.shiftedY( verticalBounds.minY );
    },

    // @override from Node
    getSafeSelfBounds: function() {
      var expansionFactor = 1; // we use a new bounding box with a new size of size * ( 1 + 2 * expansionFactor )

      var selfBounds = this.getSelfBounds();

      // NOTE: we'll keep this as an estimate for the bounds including stroke miters
      return selfBounds.dilatedXY( expansionFactor * selfBounds.width, expansionFactor * selfBounds.height );
    },

    /*---------------------------------------------------------------------------*
     * Self setters / getters
     *----------------------------------------------------------------------------*/

    setFont: function( font ) {
      if ( this.font !== font ) {
        this._font = font instanceof scenery.Font ? font : new scenery.Font( font );

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyFont();
        }

        this.invalidateText();
      }
      return this;
    },

    // NOTE: returns mutable copy for now, consider either immutable version, defensive copy, or note about invalidateText()
    getFont: function() {
      return this._font.getFont();
    },

    setDirection: function( direction ) {
      this._direction = direction;

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyDirection();
      }

      this.invalidateText();
      return this;
    },

    getDirection: function() {
      return this._direction;
    },

    isPainted: function() {
      return true;
    },

    // @override
    areSelfBoundsValid: function() {
      return this._boundsMethod === 'accurate';
    },

    getDebugHTMLExtras: function() {
      return ' "' + escapeHTML( this.renderedText ) + '"' + ( this._isHTML ? ' (html)' : '' );
    },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.Text( \'' + escapeHTML( this._text.replace( /'/g, '\\\'' ) ) + '\', {' + propLines + '} )';
    },

    getPropString: function( spaces, includeChildren ) {
      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
      result = this.appendFillablePropString( spaces, result );
      result = this.appendStrokablePropString( spaces, result );

      // TODO: if created again, deduplicate with Node's getPropString
      function addProp( key, value, nowrap ) {
        if ( result ) {
          result += ',\n';
        }
        if ( !nowrap && typeof value === 'string' ) {
          result += spaces + key + ': \'' + value + '\'';
        }
        else {
          result += spaces + key + ': ' + value;
        }
      }

      if ( this.font !== new scenery.Font().getFont() ) {
        addProp( 'font', this.font.replace( /'/g, '\\\'' ) );
      }

      if ( this._direction !== 'ltr' ) {
        addProp( 'direction', this._direction );
      }

      return result;
    }
  } );

  /*---------------------------------------------------------------------------*
   * Font setters / getters
   *----------------------------------------------------------------------------*/

  function addFontForwarding( propertyName, fullCapitalized, shortUncapitalized ) {
    var getterName = 'get' + fullCapitalized;
    var setterName = 'set' + fullCapitalized;

    Text.prototype[ getterName ] = function() {
      // use the ES5 getter to retrieve the property. probably somewhat slow.
      return this._font[ shortUncapitalized ];
    };

    Text.prototype[ setterName ] = function( value ) {
      // create a full copy of our font instance
      var ob = {};
      ob[ shortUncapitalized ] = value;
      var newFont = this._font.copy( ob );

      // apply the new Font. this should call invalidateText() as normal
      // TODO: do more specific font dirty flags in the future, for how SVG does things
      this.setFont( newFont );
      return this;
    };

    Object.defineProperty( Text.prototype, propertyName, {
      set: Text.prototype[ setterName ],
      get: Text.prototype[ getterName ]
    } );
  }

  addFontForwarding( 'fontWeight', 'FontWeight', 'weight' );
  addFontForwarding( 'fontFamily', 'FontFamily', 'family' );
  addFontForwarding( 'fontStretch', 'FontStretch', 'stretch' );
  addFontForwarding( 'fontStyle', 'FontStyle', 'style' );
  addFontForwarding( 'fontSize', 'FontSize', 'size' );
  addFontForwarding( 'lineHeight', 'LineHeight', 'lineHeight' );

  Text.prototype._mutatorKeys = [
    'boundsMethod', 'text', 'font', 'fontWeight', 'fontFamily', 'fontStretch', 'fontStyle', 'fontSize', 'lineHeight', 'direction'
  ].concat( Node.prototype._mutatorKeys );

  // font-specific ES5 setters and getters are defined using addFontForwarding above
  Object.defineProperty( Text.prototype, 'font', { set: Text.prototype.setFont, get: Text.prototype.getFont } );
  Object.defineProperty( Text.prototype, 'text', { set: Text.prototype.setText, get: Text.prototype.getText } );
  Object.defineProperty( Text.prototype, 'direction', {
    set: Text.prototype.setDirection,
    get: Text.prototype.getDirection
  } );
  Object.defineProperty( Text.prototype, 'boundsMethod', {
    set: Text.prototype.setBoundsMethod,
    get: Text.prototype.getBoundsMethod
  } );

  // mix in support for fills and strokes
  Paintable.mixin( Text );

  /*---------------------------------------------------------------------------*
   * Unicode embedding marks workaround for https://github.com/phetsims/scenery/issues/520
   *----------------------------------------------------------------------------*/

  // Unicode embedding marks that we can combine to work around the Edge issue
  var LTR = '\u202a';
  var RTL = '\u202b';
  var POP = '\u202c';

  /**
   * Replaces embedding mark characters with visible strings. Useful for debugging for strings with embedding marks.
   * @public
   *
   * @param {string} string
   * @returns {string} - With embedding marks replaced.
   */
  Text.embeddedDebugString = function( string ) {
    return string.replace( /\u202a/g, '[LTR]' ).replace( /\u202b/g, '[RTL]' ).replace( /\u202c/g, '[POP]' );
  };

  /**
   * Returns a (potentially) modified string where embedding marks have been simplified.
   * @public
   *
   * This simplification wouldn't usually be necessary, but we need to prevent cases like
   * https://github.com/phetsims/scenery/issues/520 where Edge decides to turn [POP][LTR] (after another [LTR]) into
   * a 'box' character, when nothing should be rendered.
   *
   * This will remove redundant nesting:
   *   e.g. [LTR][LTR]boo[POP][POP] => [LTR]boo[POP])
   * and will also combine adjacent directions:
   *   e.g. [LTR]Mail[POP][LTR]Man[POP] => [LTR]MailMan[Pop]
   *
   * Note that it will NOT combine in this way if there was a space between the two LTRs:
   *   e.g. [LTR]Mail[POP] [LTR]Man[Pop])
   * as in the general case, we'll want to preserve the break there between embeddings.
   *
   * TODO: A stack-based implementation that doesn't create a bunch of objects/closures would be nice for performance.
   *
   * @param {string} string
   * @returns {string}
   */
  Text.simplifyEmbeddingMarks = function( string ) {
    // First, we'll convert the string into a tree form, where each node is either a string object OR an object of the
    // node type { dir: {LTR||RTL}, children: {Array.<node>}, parent: {null|node} }. Thus each LTR...POP and RTL...POP
    // become a node with their interiors becoming children.

    // Root node (no direction, so we preserve root LTR/RTLs)
    var root = {
      dir: null,
      children: [],
      parent: null
    };
    var current = root;
    for ( var i = 0; i < string.length; i++ ) {
      var chr = string.charAt( i );

      // Push a direction
      if ( chr === LTR || chr === RTL ) {
        var node = {
          dir: chr,
          children: [],
          parent: current
        };
        current.children.push( node );
        current = node;
      }
      // Pop a direction
      else if ( chr === POP ) {
        assert && assert( current.parent, 'Bad nesting of embedding marks: ' + Text.embeddedDebugString( string ) );
        current = current.parent;
      }
      // Append characters to the current direction
      else {
        current.children.push( chr );
      }
    }
    assert && assert( current === root, 'Bad nesting of embedding marks: ' + Text.embeddedDebugString( string ) );

    // Remove redundant nesting (e.g. [LTR][LTR]...[POP][POP])
    function collapseNesting( node ) {
      for ( var i = node.children.length - 1; i >= 0; i-- ) {
        var child = node.children[ i ];
        if ( node.dir === child.dir ) {
          Array.prototype.splice.apply( node.children, [ i, 1 ].concat( child.children ) );
        }
      }
    }

    // Remove overridden nesting (e.g. [LTR][RTL]...[POP][POP]), since the outer one is not needed
    function collapseUnnecessary( node ) {
      if ( node.children.length === 1 && node.children[ 0 ].dir ) {
        node.dir = node.children[ 0 ].dir;
        node.children = node.children[ 0 ].children;
      }
    }

    // Collapse adjacent matching dirs, e.g. [LTR]...[POP][LTR]...[POP]
    function collapseAdjacent( node ) {
      for ( var i = node.children.length - 1; i >= 1; i-- ) {
        var previousChild = node.children[ i - 1 ];
        var child = node.children[ i ];
        if ( child.dir && previousChild.dir === child.dir ) {
          previousChild.children = previousChild.children.concat( child.children );
          node.children.splice( i, 1 );

          // Now try to collapse adjacent items in the child, since we combined children arrays
          collapseAdjacent( previousChild );
        }
      }
    }

    // Simplifies the tree using the above functions
    function simplify( node ) {
      if ( typeof node === 'string' ) {
        return;
      }

      for ( var i = 0; i < node.children.length; i++ ) {
        simplify( node.children[ i ] );
      }

      collapseUnnecessary( node );
      collapseNesting( node );
      collapseAdjacent( node );

      return node;
    }

    // Turns a tree into a string
    function stringify( node ) {
      if ( typeof node === 'string' ) {
        return node;
      }
      var childString = node.children.map( stringify ).join( '' );
      if ( node.dir ) {
        return node.dir + childString + '\u202c';
      }
      else {
        return childString;
      }
    }

    return stringify( simplify( root ) );
  };

  /*---------------------------------------------------------------------------*
   * Rendering State mixin (DOM/SVG)
   *----------------------------------------------------------------------------*/

  Text.TextStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      // initializes, and resets (so we can support pooled states)
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true; // flag that is marked if ANY "paint" dirty flag is set (basically everything except for transforms, so we can accelerated the transform-only case)
        this.dirtyText = true;
        this.dirtyFont = true;
        this.dirtyBounds = true;
        this.dirtyDirection = true;

        // adds fill/stroke-specific flags and state
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      proto.disposeState = function() {
        this.disposePaintableState();
      };

      // catch-all dirty, if anything that isn't a transform is marked as dirty
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyText = function() {
        this.dirtyText = true;
        this.markPaintDirty();
      };
      proto.markDirtyFont = function() {
        this.dirtyFont = true;
        this.markPaintDirty();
      };
      proto.markDirtyBounds = function() {
        this.dirtyBounds = true;
        this.markPaintDirty();
      };
      proto.markDirtyDirection = function() {
        this.dirtyDirection = true;
        this.markPaintDirty();
      };

      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyText = false;
        this.dirtyFont = false;
        this.dirtyBounds = false;
        this.dirtyDirection = false;
      };

      Paintable.PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  /*---------------------------------------------------------------------------*
   * DOM rendering
   *----------------------------------------------------------------------------*/

  var TextDOMDrawable = Text.TextDOMDrawable = inherit( DOMSelfDrawable, function TextDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }, {
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );

      // only create elements if we don't already have them (we pool visual states always, and depending on the platform may also pool the actual elements to minimize
      // allocation and performance costs)
      if ( !this.domElement ) {
        this.domElement = document.createElement( 'div' );
        this.domElement.style.display = 'block';
        this.domElement.style.position = 'absolute';
        this.domElement.style.pointerEvents = 'none';
        this.domElement.style.left = '0';
        this.domElement.style.top = '0';
      }

      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    updateDOM: function() {
      var node = this.node;

      var div = this.domElement;

      if ( this.paintDirty ) {
        if ( this.dirtyFont ) {
          div.style.font = node.getFont();
        }
        if ( this.dirtyStroke ) {
          div.style.color = node.getCSSFill();
        }
        if ( this.dirtyBounds ) { // TODO: this condition is set on invalidateText, so it's almost always true?
          div.style.width = node.getSelfBounds().width + 'px';
          div.style.height = node.getSelfBounds().height + 'px';
          // TODO: do we require the jQuery versions here, or are they vestigial?
          // $div.width( node.getSelfBounds().width );
          // $div.height( node.getSelfBounds().height );
        }
        if ( this.dirtyText ) {
          // TODO: actually do this in a better way
          div.innerHTML = node.renderedText;
        }
        if ( this.dirtyDirection ) {
          div.setAttribute( 'dir', node._direction );
        }
      }

      if ( this.transformDirty || this.dirtyText || this.dirtyFont || this.dirtyBounds ) {
        // shift the text vertically, postmultiplied with the entire transform.
        var yOffset = node.getSelfBounds().minY;
        scratchMatrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( 0, yOffset );
        scratchMatrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( scratchMatrix, div, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToClean();
    },

    setToClean: function() {
      this.setToCleanState();

      this.cleanPaintableState();

      this.transformDirty = false;
    },

    dispose: function() {
      this.disposeState();

      if ( !keepDOMTextElements ) {
        // clear the references
        this.domElement = null;
      }

      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  Text.TextStatefulDrawable.mixin( TextDOMDrawable );
  SelfDrawable.Poolable.mixin( TextDOMDrawable );

  /*---------------------------------------------------------------------------*
   * SVG rendering
   *----------------------------------------------------------------------------*/

  Text.TextSVGDrawable = function TextSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( SVGSelfDrawable, Text.TextSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGTextElements ); // usesPaint: true

      if ( !this.svgElement ) {
        // NOTE! reference SVG element at top of file copies createSVGElement!
        var text = this.svgElement = document.createElementNS( scenery.svgns, 'text' );
        text.appendChild( document.createTextNode( '' ) );

        // TODO: flag adjustment for SVG qualities
        text.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
        text.setAttribute( 'text-rendering', 'geometricPrecision' );
        if ( useSVGTextLengthAdjustments ) {
          text.setAttribute( 'lengthAdjust', 'spacingAndGlyphs' );
        }
        text.setAttributeNS( 'http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve' );
      }

      return this;
    },

    updateSVGSelf: function() {
      var text = this.svgElement;

      if ( this.dirtyDirection ) {
        text.setAttribute( 'direction', this.node._direction );
      }

      // set all of the font attributes, since we can't use the combined one
      if ( this.dirtyFont ) {
        text.setAttribute( 'font-family', this.node._font.getFamily() );
        text.setAttribute( 'font-size', this.node._font.getSize() );
        text.setAttribute( 'font-style', this.node._font.getStyle() );
        text.setAttribute( 'font-weight', this.node._font.getWeight() );
        text.setAttribute( 'font-stretch', this.node._font.getStretch() );
      }

      // update the text-node's value
      if ( this.dirtyText ) {
        text.lastChild.nodeValue = this.node.renderedText;
      }

      // text length correction, tested with scenery/tests/text-quality-test.html to determine how to match Canvas/SVG rendering (and overall length)
      if ( this.dirtyBounds && useSVGTextLengthAdjustments && isFinite( this.node.selfBounds.width ) ) {
        text.setAttribute( 'textLength', this.node.selfBounds.width );
      }

      this.updateFillStrokeStyle( text );
    }
  } );
  Text.TextStatefulDrawable.mixin( Text.TextSVGDrawable );
  SelfDrawable.Poolable.mixin( Text.TextSVGDrawable );

  /*---------------------------------------------------------------------------*
   * Canvas rendering
   *----------------------------------------------------------------------------*/

  Text.TextCanvasDrawable = function TextCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( CanvasSelfDrawable, Text.TextCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;

      // extra parameters we need to set, but should avoid setting if we aren't drawing anything
      if ( node.hasFill() || node.hasStroke() ) {
        wrapper.setFont( node._font.getFont() );
        wrapper.setDirection( node._direction );
      }

      if ( node.hasFill() ) {
        node.beforeCanvasFill( wrapper ); // defined in Paintable
        context.fillText( node.renderedText, 0, 0 );
        node.afterCanvasFill( wrapper ); // defined in Paintable
      }
      if ( node.hasStroke() ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.strokeText( node.renderedText, 0, 0 );
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },

    // stateless dirty functions
    markDirtyText: function() { this.markPaintDirty(); },
    markDirtyFont: function() { this.markPaintDirty(); },
    markDirtyBounds: function() { this.markPaintDirty(); },
    markDirtyDirection: function() { this.markPaintDirty(); },

    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  Paintable.PaintableStatelessDrawable.mixin( Text.TextCanvasDrawable );
  SelfDrawable.Poolable.mixin( Text.TextCanvasDrawable );

  /*---------------------------------------------------------------------------*
   * WebGL rendering
   *----------------------------------------------------------------------------*/

  Text.TextWebGLDrawable = inherit( WebGLSelfDrawable, function TextWebGLDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }, {
    // called either from the constructor or from pooling
    initialize: function( renderer, instance ) {
      this.initializeWebGLSelfDrawable( renderer, instance );
    },

    onAddToBlock: function( webglBlock ) {
      var self = this;
      this.node.toImageNodeAsynchronous( function( imageNodeContainer ) {
        //toImageNode returns a containerNode with its first child set as ImageNode
        var imageNode = imageNodeContainer.children[ 0 ];
        self.textHandle = webglBlock.webGLRenderer.textureRenderer.createFromImageNode( imageNode, 0.4 );

        // TODO: Don't call this each time a new item is added.
        webglBlock.webGLRenderer.textureRenderer.bindVertexBuffer();
        webglBlock.webGLRenderer.textureRenderer.bindDirtyTextures();
        self.updateText();
      } );

      //TODO: Update the state in the buffer arrays
    },

    onRemoveFromBlock: function( webglBlock ) {

    },

    //Nothing necessary since everything currently handled in the uModelViewMatrix below
    //However, we may switch to dynamic draw, and handle the matrix change only where necessary in the future?
    updateText: function() {
      if ( this.textHandle ) {
        this.textHandle.update();
      }
    },

    render: function( shaderProgram ) {
      // This is handled by the ColorTriangleRenderer
    },

    dispose: function() {
      this.disposeWebGLBuffers();
      // super
      WebGLSelfDrawable.prototype.dispose.call( this );
    },

    disposeWebGLBuffers: function() {
      this.webglBlock.webGLRenderer.colorTriangleRenderer.colorTriangleBufferData.dispose( this.rectangleHandle );
    },

    markDirtyText: function() {
      this.markDirty();
    },

    markDirtyBounds: function() {
      this.markDirty();
    },

    // general flag set on the state, which we forward directly to the drawable's paint flag
    markPaintDirty: function() {
      this.markDirty();
    },

    //TODO: Make sure all of the dirty flags make sense here.  Should we be using fillDirty, paintDirty, dirty, etc?
    update: function() {
      //if ( this.dirty ) {
      this.updateText();
      this.dirty = false;
      //}
    }
  } );

  // include stubs (stateless) for marking dirty stroke and fill (if necessary). we only want one dirty flag, not multiple ones, for WebGL (for now)
  Paintable.PaintableStatefulDrawable.mixin( Text.TextWebGLDrawable );

  // set up pooling
  SelfDrawable.Poolable.mixin( Text.TextWebGLDrawable );

  /*---------------------------------------------------------------------------*
   * Hybrid text setup (for bounds testing)
   *----------------------------------------------------------------------------*/

  function createSVGTextToMeasure() {
    var text = document.createElementNS( scenery.svgns, 'text' );
    text.appendChild( document.createTextNode( '' ) );

    // TODO: flag adjustment for SVG qualities
    text.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
    text.setAttribute( 'text-rendering', 'geometricPrecision' );
    text.setAttributeNS( 'http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve' );
    return text;
  }

  function updateSVGTextToMeasure( textElement, textNode ) {
    textElement.setAttribute( 'direction', textNode._direction );
    textElement.setAttribute( 'font-family', textNode._font.getFamily() );
    textElement.setAttribute( 'font-size', textNode._font.getSize() );
    textElement.setAttribute( 'font-style', textNode._font.getStyle() );
    textElement.setAttribute( 'font-weight', textNode._font.getWeight() );
    textElement.setAttribute( 'font-stretch', textNode._font.getStretch() );
    textElement.lastChild.nodeValue = textNode.renderedText;
  }

  if ( !svgTextSizeContainer ) {
    // set up the container and text for testing text bounds quickly (using approximateSVGBounds)
    svgTextSizeContainer = document.createElementNS( scenery.svgns, 'svg' );
    svgTextSizeContainer.setAttribute( 'width', '2' );
    svgTextSizeContainer.setAttribute( 'height', '2' );
    svgTextSizeContainer.setAttribute( 'id', textSizeContainerId );
    svgTextSizeContainer.setAttribute( 'style', 'visibility: hidden; pointer-events: none; position: absolute; left: -65535px; right: -65535px;' ); // so we don't flash it in a visible way to the user
  }
  // NOTE! copies createSVGElement
  if ( !svgTextSizeElement ) {
    svgTextSizeElement = createSVGTextToMeasure();
    svgTextSizeElement.setAttribute( 'id', textSizeElementId );
    svgTextSizeContainer.appendChild( svgTextSizeElement );
  }

  initializingHybridTextNode = true;
  hybridTextNode = new Text( 'm', { boundsMethod: 'fast' } );
  initializingHybridTextNode = false;

  return Text;
} );



// Copyright 2013-2015, University of Colorado Boulder

/**
 * HTML Text, with the same interface as Text
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/HTMLText',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Text'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Text = require( 'SCENERY/nodes/Text' ); // inherits from Text

  /**
   * NOTE: Currently does not properly handle multi-line (<br>) text height, since it expects DOM text that will be an
   * inline element
   */
  function HTMLText( text, options ) {
    // internal flag for Text
    this._isHTML = true;

    Text.call( this, text, options );
  }

  scenery.register( 'HTMLText', HTMLText );

  inherit( Text, HTMLText, {} );

  return HTMLText;
} );



// Copyright 2015, University of Colorado Boulder

/**
 * A mixin for subtypes of Node, used to prevent children being added/removed to that subtype of Node.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Leaf',['require','SCENERY/scenery'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var Leaf = {
    mixin: function( type ) {
      var proto = type.prototype;

      proto.insertChild = function( index, node ) {
        throw new Error( 'Attempt to insert child into Leaf' );
      };

      proto.removeChildWithIndex = function( node, indexOfChild ) {
        throw new Error( 'Attempt to remove child from Leaf' );
      };
    }
  };
  scenery.register( 'Leaf', Leaf );

  return scenery.Leaf;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * A Node meant to just take up certain bounds. It is never displayed, and cannot have children.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Spacer',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Bounds2','SCENERY/nodes/Node','SCENERY/nodes/Leaf'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Bounds2 = require( 'DOT/Bounds2' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Leaf = require( 'SCENERY/nodes/Leaf' );

  /**
   * Creates a spacer taking up a rectangular area from x: [0,width] and y: [0,height]. Use x/y in options to control
   * its position.
   */
  function Spacer( width, height, options ) {
    Node.call( this );

    // override the local bounds to our area
    this.localBounds = new Bounds2( 0, 0, width, height );

    this.mutate( options );
  }

  scenery.register( 'Spacer', Spacer );

  inherit( Node, Spacer );
  Leaf.mixin( Spacer ); // prevent children from being added, since we're overriding local bounds

  return Spacer;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * A Node meant to just take up horizontal space (usually for layout purposes).
 * It is never displayed, and cannot have children.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/HStrut',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Spacer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Spacer = require( 'SCENERY/nodes/Spacer' );

  /**
   * Creates a strut with x in the range [0,width] and y=0.
   */
  function HStrut( width, options ) {
    Spacer.call( this, width, 0, options );
  }

  scenery.register( 'HStrut', HStrut );

  return inherit( Spacer, HStrut );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A node that displays a single image either from an actual HTMLImageElement, a URL, a Canvas element, or a mipmap
 * data structure described in the constructor.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Image',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','PHET_CORE/platform','DOT/Bounds2','DOT/Vector2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/util/Util','SCENERY/display/DOMSelfDrawable','SCENERY/display/SVGSelfDrawable','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/WebGLSelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var platform = require( 'PHET_CORE/platform' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );

  var scenery = require( 'SCENERY/scenery' );

  var Node = require( 'SCENERY/nodes/Node' ); // Image inherits from Node
  var Renderer = require( 'SCENERY/display/Renderer' ); // we need to specify the Renderer in the prototype
  require( 'SCENERY/util/Util' );

  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepDOMImageElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory
  var keepSVGImageElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  var defaultMipmapBias = -0.7;
  var defaultMipmapInitialLevel = 4; // by default, precompute all levels that will be used (so we don't hit this during animation)
  var defaultMipmapMaxLevel = 5;

  var log2 = Math.log2 || function( x ) {
      return Math.log( x ) / Math.LN2;
    };

  /*
   * Constructs an Image node from a particular source.
   * @public
   *
   * We support a few different 'image' parameter types:
   *
   * HTMLImageElement - A normal HTML <img>. If it hasn't been fully loaded yet, Scenery will take care of adding a
   *   listener that will update Scenery with its width/height (and load its data) when the image is fully loaded. NOTE
   *   that if you just created the <img>, it probably isn't loaded yet, particularly in Safari. If the Image node is
   *   constructed with an <img> that hasn't fully loaded, it will have a width and height of 0, which may cause issues
   *   if you are using bounds for layout. Please see initialWidth/initialHeight notes below.
   *
   * URL - Provide a {string}, and Scenery will assume it is a URL. This can be a normal URL, or a data URI, both will
   *   work. Please note that this has the same loading-order issues as using HTMLImageElement, but that it's almost
   *   always guaranteed to not have a width/height when you create the Image node. Note that data URI support for
   *   formats depends on the browser - only JPEG and PNG are supported broadly. Please see initialWidth/initialHeight
   *   notes below.
   *
   * HTMLCanvasElement - It's possible to pass an HTML5 Canvas directly into the Image node. It will immediately be
   *   aware of the width/height (bounds) of the Canvas, but NOTE that the Image node will not listen to Canvas size
   *   changes. It is assumed that after you pass in a Canvas to an Image node that it will not be modified further.
   *   Additionally, the Image node will only be rendered using Canvas or WebGL if a Canvas is used as input.
   *
   * Mipmap data structure - Image supports a mipmap data structure that provides rasterized mipmap levels. The 'top'
   *   level (level 0) is the entire full-size image, and every other level is twice as small in every direction
   *   (~1/4 the pixels), rounding dimensions up. This is useful for browsers that display the image badly if the
   *   image is too large. Instead, Scenery will dynamically pick the most appropriate size of the image to use,
   *   which improves the image appearance.
   *   The passed in 'image' should be an Array of mipmap objects of the format:
   *   {
   *     img: {HTMLImageElement}, // preferably preloaded, but it isn't required
   *     url: {string}, // URL (usually a data URL) for the image level
   *     width: {number}, // width of the mipmap level, in pixels
   *     height: {number} // height of the mipmap level, in pixels
   *   }
   *   At least one level is required (level 0), and each mipmap level corresponds to the index in the array, e.g.:
   *   [
   *     level 0 (full size, e.g. 100x64)
   *     level 1 (half size, e.g. 50x32)
   *     level 2 (quarter size, e.g. 25x16)
   *     level 3 (eighth size, e.g. 13x8 - note the rounding up)
   *     ...
   *     level N (single pixel, e.g. 1x1 - this is the smallest level permitted, and there should only be one)
   *   ]
   *
   * -----------------
   *
   * Image also supports the following options beyond what Node itself provides:
   *
   * image - {see above} Allows changing the underlying input image to a Scenery Image node. Note that if for some
   *    reason the provided image was mutated somehow, it's recommended to call invalidateImage() instead of changing
   *    the image reference.
   *
   * initialWidth - {number} If the input image hasn't loaded yet, but the (expected) size is known, providing an
   *    initialWidth will cause the Image node to have the correct bounds (width) before the pixel data has been fully
   *    loaded. A value of 0 will be ignored.
   *
   * initialHeight - {number} If the input image hasn't loaded yet, but the (expected) size is known, providing an
   *    initialHeight will cause the Image node to have the correct bounds (height) before the pixel data has been fully
   *    loaded. A value of 0 will be ignored.
   *
   * mipmap - {boolean} Whether mipmaps are supported. Defaults to false, but is automatically set to true when a mipmap
   *    image is provided to it. Setting it to true on non-mipmap images will trigger creation of a medium-quality
   *    mipmap that will be used. NOTE that this mipmap generation is slow and CPU-intensive. Providing precomputed
   *    mipmap resources to an Image node will be much faster, and of higher quality.
   *
   * mipmapBias - {number} Allows adjustment of how much level-of-detail is displayed. Increasing it will typically
   *    decrease the displayed resolution, and decreases (going negative) will increase the displayed resolution, such
   *    that approximately:
   *        mipmapLevel = Math.round( computedMipmapLevel + mipmapBias )
   *
   * mipmapInitialLevel - {number} If relying on Scenery to generate the mipmaps (mipmap:true on a non-mipmap input),
   *    this will be the number of initial levels to compute.
   *
   * mipmapMaxLevel - {number} If relying on Scenery to generate the mipmaps (mipmap:true on a non-mipmap input),
   *    this will be the maximum (smallest) level that Scenery will compute.
   *
   * @param {see above} image
   * @param {Object} [options]
   */
  function Image( image, options ) {
    assert && assert( image, 'image should be available' );

    // allow not passing an options object
    options = options || {};

    // rely on the setImage call from the super constructor to do the setup
    if ( image ) {
      options.image = image;
    }

    // When non-zero, overrides the Image's natural width/height (in the local coordinate frame) while the Image's
    // dimensions can't be detected yet (i.e. it reports 0x0 like Safari does for an image that isn't fully loaded).
    // This allows for faster display of dynamically-created images if the dimensions are known ahead-of-time.
    // If the intitial dimensions don't match the image's dimensions after it is loaded, an assertion will be fired.
    this._initialWidth = 0;
    this._initialHeight = 0;

    // Mipmap client values
    this._mipmap = false; // {bool} - Whether mipmapping is enabled
    this._mipmapBias = defaultMipmapBias; // {number} - Amount of level-of-detail adjustment added to everything.
    this._mipmapInitialLevel = defaultMipmapInitialLevel; // {number} - Quantity of mipmap levels to initially compute
    this._mipmapMaxLevel = defaultMipmapMaxLevel; // {number} - Maximum mipmap levels to compute (lazily if > initial)

    // Mipmap internal handling
    this._mipmapCanvases = []; // TODO: power-of-2 handling for WebGL if helpful
    this._mipmapURLs = [];
    this._mipmapData = null; // if mipmap data is passed into our Image, it will be stored here for processing

    var self = this;
    // allows us to invalidate our bounds whenever an image is loaded
    this.loadListener = function( event ) {
      self.invalidateImage();

      // don't leak memory!
      self._image.removeEventListener( 'load', self.loadListener );
    };

    Node.call( this, options );
    this.invalidateSupportedRenderers();
  }

  scenery.register( 'Image', Image );

  inherit( Node, Image, {
    allowsMultipleDOMInstances: false, // TODO: support multiple instances

    invalidateImage: function() {
      if ( this._image ) {
        this.invalidateSelf( new Bounds2( 0, 0, this.getImageWidth(), this.getImageHeight() ) );
      }
      else {
        this.invalidateSelf( Bounds2.NOTHING );
      }

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyImage();
      }

      this.invalidateMipmaps();
    },

    getImage: function() {
      return this._image;
    },
    get image() { return this.getImage(); },

    invalidateSupportedRenderers: function() {
      if ( this._image instanceof HTMLCanvasElement ) {
        this.setRendererBitmask(
          Renderer.bitmaskCanvas |
          Renderer.bitmaskWebGL
        );
      }
      else {
        // assumes HTMLImageElement
        this.setRendererBitmask(
          Renderer.bitmaskCanvas |
          Renderer.bitmaskSVG |
          Renderer.bitmaskDOM |
          Renderer.bitmaskWebGL
        );
      }
    },

    setImage: function( image ) {
      if ( this._image !== image && ( typeof image !== 'string' || !this._image || ( image !== this._image.src && image !== this._mipmapData ) ) ) {
        // don't leak memory by referencing old images
        if ( this._image ) {
          this._image.removeEventListener( 'load', this.loadListener );
        }

        // clear old mipmap data references
        this._mipmapData = null;

        if ( typeof image === 'string' ) {
          // create an image with the assumed URL
          var src = image;
          image = document.createElement( 'img' );
          image.addEventListener( 'load', this.loadListener );
          image.src = src;
        }
        else if ( image instanceof HTMLImageElement ) {
          // only add a listener if we probably haven't loaded yet
          if ( !image.width || !image.height ) {
            image.addEventListener( 'load', this.loadListener );
          }
        }
        else if ( image instanceof Array ) {
          // mipmap data!
          this._mipmapData = image;
          image = image[ 0 ].img; // presumes we are already loaded

          // force initialization of mipmapping parameters, since invalidateMipmaps() is guaranteed to run below
          this._mipmapInitialLevel = this._mipmapMaxLevel = this._mipmapData.length;
          this._mipmap = true;
        }

        // swap supported renderers if necessary
        this.invalidateSupportedRenderers();

        this._image = image;

        this.invalidateImage(); // yes, if we aren't loaded yet this will give us 0x0 bounds
      }
      return this;
    },
    set image( value ) { this.setImage( value ); },

    getInitialWidth: function() {
      return this._initialWidth;
    },
    get initialWidth() { return this.getInitialWidth(); },

    setInitialWidth: function( width ) {
      this._initialWidth = width;

      this.invalidateImage();
    },
    set initialWidth( value ) { this.setInitialWidth( value ); },

    getInitialHeight: function() {
      return this._initialHeight;
    },
    get initialHeight() { return this.getInitialHeight(); },

    setInitialHeight: function( height ) {
      this._initialHeight = height;

      this.invalidateImage();
    },
    set initialHeight( value ) { this.setInitialHeight( value ); },

    isMipmap: function() {
      return this._mipmap;
    },
    get mipmap() { return this.isMipmap(); },

    setMipmap: function( mipmap ) {
      assert && assert( typeof mipmap === 'boolean' );

      if ( this._mipmap !== mipmap ) {
        this._mipmap = mipmap;

        this.invalidateMipmaps();
      }
    },
    set mipmap( value ) { this.setMipmap( value ); },

    getMipmapBias: function() {
      return this._mipmapBias;
    },
    get mipmapBias() { return this.getMipmapBias(); },

    setMipmapBias: function( bias ) {
      assert && assert( typeof bias === 'number' );

      if ( this._mipmapBias !== bias ) {
        this._mipmapBias = bias;

        this.invalidateMipmaps();
      }
    },
    set mipmapBias( value ) { this.setMipmapBias( value ); },

    getMipmapInitialLevel: function() {
      return this._mipmapInitialLevel;
    },
    get mipmapInitialLevel() { return this.getMipmapInitialLevel(); },

    setMipmapInitialLevel: function( level ) {
      assert && assert( typeof level === 'number' );

      if ( this._mipmapInitialLevel !== level ) {
        this._mipmapInitialLevel = level;

        this.invalidateMipmaps();
      }
    },
    set mipmapInitialLevel( value ) { this.setMipmapInitialLevel( value ); },

    getMipmapMaxLevel: function() {
      return this._mipmapMaxLevel;
    },
    get mipmapMaxLevel() { return this.getMipmapMaxLevel(); },

    setMipmapMaxLevel: function( level ) {
      assert && assert( typeof level === 'number' );

      if ( this._mipmapMaxLevel !== level ) {
        this._mipmapMaxLevel = level;

        this.invalidateMipmaps();
      }
    },
    set mipmapMaxLevel( value ) { this.setMipmapMaxLevel( value ); },

    // @private
    constructNextMipmap: function() {
      var level = this._mipmapCanvases.length;
      var biggerCanvas = this._mipmapCanvases[ level - 1 ];

      // ignore any 1x1 canvases (or smaller?!?)
      if ( biggerCanvas.width * biggerCanvas.height > 2 ) {
        var canvas = document.createElement( 'canvas' );
        canvas.width = Math.ceil( biggerCanvas.width / 2 );
        canvas.height = Math.ceil( biggerCanvas.height / 2 );

        // sanity check
        if ( canvas.width > 0 && canvas.height > 0 ) {
          var context = canvas.getContext( '2d' );
          context.scale( 0.5, 0.5 );
          context.drawImage( biggerCanvas, 0, 0 );

          this._mipmapCanvases.push( canvas );
          this._mipmapURLs.push( canvas.toDataURL() );
        }
      }
    },

    // @public
    invalidateMipmaps: function() {
      cleanArray( this._mipmapCanvases );
      cleanArray( this._mipmapURLs );

      if ( this._image && this._mipmap ) {
        if ( this._mipmapData ) {
          for ( var k = 0; k < this._mipmapData.length; k++ ) {
            var url = this._mipmapData[ k ].url;
            this._mipmapURLs.push( url );
            // TODO: baseCanvas only upon demand?
            var canvas = document.createElement( 'canvas' );
            canvas.width = this._mipmapData[ k ].width;
            canvas.height = this._mipmapData[ k ].height;
            var context = canvas.getContext( '2d' );
            context.drawImage( this._mipmapData[ k ].img, 0, 0 );
            this._mipmapCanvases.push( canvas );
          }
        }
        else {
          var baseCanvas = document.createElement( 'canvas' );
          baseCanvas.width = this.getImageWidth();
          baseCanvas.height = this.getImageHeight();

          // if we are not loaded yet, just ignore
          if ( baseCanvas.width && baseCanvas.height ) {
            var baseContext = baseCanvas.getContext( '2d' );
            baseContext.drawImage( this._image, 0, 0 );

            this._mipmapCanvases.push( baseCanvas );
            this._mipmapURLs.push( baseCanvas.toDataURL() );

            var level = 0;
            while ( ++level < this._mipmapInitialLevel ) {
              this.constructNextMipmap();
            }
          }

          var stateLen = this._drawables.length;
          for ( var i = 0; i < stateLen; i++ ) {
            this._drawables[ i ].markDirtyMipmap();
          }
        }
      }

      this.trigger0( 'mipmap' );
    },

    /**
     * Returns the desired mipmap level (0-indexed) that should be used for the particular scale.
     *
     * @param {number} scale
     */
    getMipmapLevel: function( scale ) {
      assert && assert( scale > 0 );

      // If we are shown larger than scale, ALWAYS choose the highest resolution
      if ( scale >= 1 ) {
        return 0;
      }

      var level = log2( 1 / scale ); // our approximate level of detail
      level = Math.round( level + this._mipmapBias ); // convert to an integer level

      if ( level < 0 ) {
        level = 0;
      }
      if ( level > this._mipmapMaxLevel ) {
        level = this._mipmapMaxLevel;
      }

      // If necessary, do lazy construction of the mipmap level
      if ( this.mipmap && !this._mipmapCanvases[ level ] ) {
        var currentLevel = this._mipmapCanvases.length - 1;
        while ( ++currentLevel <= level ) {
          this.constructNextMipmap();
        }
        // Sanity check, since constructNextMipmap() may have had to bail out. We had to compute some, so use the last
        return Math.min( level, this._mipmapCanvases.length - 1 );
      }
      // Should already be constructed, or isn't needed
      else {
        return level;
      }
    },

    /**
     * @returns {HTMLCanvasElement} - Matching <canvas> for the level of detail
     */
    getMipmapCanvas: function( level ) {
      assert && assert( level >= 0 && level < this._mipmapCanvases.length && ( level % 1 ) === 0 );

      return this._mipmapCanvases[ level ];
    },

    /**
     * @returns {string} - Matching data URL for the level of detail
     */
    getMipmapURL: function( level ) {
      assert && assert( level >= 0 && level < this._mipmapCanvases.length && ( level % 1 ) === 0 );

      return this._mipmapURLs[ level ];
    },

    hasMipmaps: function() {
      return this._mipmapCanvases.length > 0;
    },

    getImageWidth: function() {
      var detectedWidth = this._mipmapData ? this._mipmapData[ 0 ].width : ( this._image.naturalWidth || this._image.width );
      if ( detectedWidth === 0 ) {
        return this._initialWidth; // either 0 (default), or the overridden value
      }
      else {
        assert && assert( this._initialWidth === 0 || this._initialWidth === detectedWidth, 'Bad Image.initialWidth' );

        return detectedWidth;
      }
    },
    get imageWidth() { return this.getImageWidth(); },

    getImageHeight: function() {
      var detectedHeight = this._mipmapData ? this._mipmapData[ 0 ].height : ( this._image.naturalHeight || this._image.height );
      if ( detectedHeight === 0 ) {
        return this._initialHeight; // either 0 (default), or the overridden value
      }
      else {
        assert && assert( this._initialHeight === 0 || this._initialHeight === detectedHeight, 'Bad Image.initialHeight' );

        return detectedHeight;
      }
    },
    get imageHeight() { return this.getImageHeight(); },

    getImageURL: function() {
      return this._image.src;
    },

    // signal that we are actually rendering something
    isPainted: function() {
      return true;
    },

    canvasPaintSelf: function( wrapper ) {
      Image.ImageCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },

    createDOMDrawable: function( renderer, instance ) {
      return Image.ImageDOMDrawable.createFromPool( renderer, instance );
    },

    createSVGDrawable: function( renderer, instance ) {
      return Image.ImageSVGDrawable.createFromPool( renderer, instance );
    },

    createCanvasDrawable: function( renderer, instance ) {
      return Image.ImageCanvasDrawable.createFromPool( renderer, instance );
    },

    createWebGLDrawable: function( renderer, instance ) {
      return Image.ImageWebGLDrawable.createFromPool( renderer, instance );
    },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.Image( \'' + ( this._image.src ? this._image.src.replace( /'/g, '\\\'' ) : 'other' ) + '\', {' + propLines + '} )';
    }
  } );

  Image.prototype._mutatorKeys = [ 'image', 'initialWidth', 'initialHeight', 'mipmap', 'mipmapBias', 'mipmapInitialLevel', 'mipmapMaxLevel' ].concat( Node.prototype._mutatorKeys );

  // utility for others
  Image.createSVGImage = function( url, width, height ) {
    var element = document.createElementNS( scenery.svgns, 'image' );
    element.setAttribute( 'x', 0 );
    element.setAttribute( 'y', 0 );
    element.setAttribute( 'width', width + 'px' );
    element.setAttribute( 'height', height + 'px' );
    element.setAttributeNS( scenery.xlinkns, 'xlink:href', url );

    return element;
  };

  // Creates an {object} suitable to be passed to Image as a mipmap (from a Canvas)
  Image.createFastMipmapFromCanvas = function( baseCanvas ) {
    var mipmaps = [];

    var baseURL = baseCanvas.toDataURL();
    var baseImage = new window.Image();
    baseImage.src = baseURL;

    // base level
    mipmaps.push( {
      img: baseImage,
      url: baseURL,
      width: baseCanvas.width,
      height: baseCanvas.height
    } );

    var largeCanvas = baseCanvas;
    while ( largeCanvas.width >= 2 && largeCanvas.height >= 2 ) {
      // smaller level
      var mipmap = {};

      // draw half-size
      var canvas = document.createElement( 'canvas' );
      canvas.width = mipmap.width = Math.ceil( largeCanvas.width / 2 );
      canvas.height = mipmap.height = Math.ceil( largeCanvas.height / 2 );
      var context = canvas.getContext( '2d' );
      context.setTransform( 0.5, 0, 0, 0.5, 0, 0 );
      context.drawImage( largeCanvas, 0, 0 );

      // set up the image and url
      mipmap.url = canvas.toDataURL();
      mipmap.img = new window.Image();
      mipmap.img.src = mipmap.url;
      largeCanvas = canvas;

      mipmaps.push( mipmap );
    }

    return mipmaps;
  };

  /*---------------------------------------------------------------------------*
   * Rendering State mixin (DOM/SVG) //TODO: Does this also apply to WebGL?
   *----------------------------------------------------------------------------*/

  Image.ImageStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      // initializes, and resets (so we can support pooled states)
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true; // flag that is marked if ANY "paint" dirty flag is set (basically everything except for transforms, so we can accelerated the transform-only case)
        this.dirtyImage = true;
        this.dirtyMipmap = true;

        return this; // allow for chaining
      };

      proto.disposeState = function() {

      };

      // catch-all dirty, if anything that isn't a transform is marked as dirty
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyImage = function() {
        this.dirtyImage = true;
        this.markPaintDirty();
      };

      proto.markDirtyMipmap = function() {
        this.dirtyMipmap = true;
        this.markPaintDirty();
      };

      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyImage = false;
        this.dirtyMipmap = false;
      };
    }
  };

  /*---------------------------------------------------------------------------*
   * DOM rendering
   *----------------------------------------------------------------------------*/

  Image.ImageDOMDrawable = inherit( DOMSelfDrawable, function ImageDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }, {
    // initializes, and resets (so we can support pooled states)
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );

      // only create elements if we don't already have them (we pool visual states always, and depending on the platform may also pool the actual elements to minimize
      // allocation and performance costs)
      if ( !this.domElement ) {
        this.domElement = document.createElement( 'img' );
        this.domElement.style.display = 'block';
        this.domElement.style.position = 'absolute';
        this.domElement.style.pointerEvents = 'none';
        this.domElement.style.left = '0';
        this.domElement.style.top = '0';
      }

      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    updateDOM: function() {
      var node = this.node;
      var img = this.domElement;

      if ( this.paintDirty && this.dirtyImage ) {
        // TODO: allow other ways of showing a DOM image?
        img.src = node._image ? node._image.src : '//:0'; // NOTE: for img with no src (but with a string), see http://stackoverflow.com/questions/5775469/whats-the-valid-way-to-include-an-image-with-no-src
      }

      if ( this.transformDirty ) {
        scenery.Util.applyPreparedTransform( this.getTransformMatrix(), this.domElement, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToClean();
    },

    setToClean: function() {
      this.setToCleanState();

      this.transformDirty = false;
    },

    dispose: function() {
      this.disposeState();

      if ( !keepDOMImageElements ) {
        this.domElement = null; // clear our DOM reference if we want to toss it
      }

      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  Image.ImageStatefulDrawable.mixin( Image.ImageDOMDrawable );
  SelfDrawable.Poolable.mixin( Image.ImageDOMDrawable );

  /*---------------------------------------------------------------------------*
   * SVG Rendering
   *----------------------------------------------------------------------------*/

  Image.ImageSVGDrawable = function ImageSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( SVGSelfDrawable, Image.ImageSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, false, keepSVGImageElements ); // usesPaint: false

      sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' initialized for ' + instance.toString() );
      var self = this;

      if ( !this.svgElement ) {
        this.svgElement = document.createElementNS( scenery.svgns, 'image' );
        this.svgElement.setAttribute( 'x', 0 );
        this.svgElement.setAttribute( 'y', 0 );
      }

      this._usingMipmap = false;
      this._mipmapLevel = -1; // will always be invalidated

      // if mipmaps are enabled, this listener will be added to when our relative transform changes
      this._mipmapTransformListener = this._mipmapTransformListener || function() {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( self.id + ' Transform dirties mipmap' );
          self.markDirtyMipmap();
        };

      this._mipmapListener = this._mipmapListener || function() {
          // sanity check
          self.markDirtyMipmap();

          // update our mipmap usage status
          self.updateMipmapStatus( self.node._mipmap );
        };
      this.node.onStatic( 'mipmap', this._mipmapListener );
      this.updateMipmapStatus( instance.node._mipmap );

      return this;
    },

    updateSVGSelf: function() {
      var image = this.svgElement;

      if ( this.dirtyImage ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Updating dirty image' );
        if ( this.node._image ) {
          // like <image xlink:href='http://phet.colorado.edu/images/phet-logo-yellow.png' x='0' y='0' height='127px' width='242px'/>
          this.updateURL( image, true );
        }
        else {
          image.setAttribute( 'width', '0' );
          image.setAttribute( 'height', '0' );
          image.setAttributeNS( scenery.xlinkns, 'xlink:href', '//:0' ); // see http://stackoverflow.com/questions/5775469/whats-the-valid-way-to-include-an-image-with-no-src
        }
      }
      else if ( this.dirtyMipmap && this.node._image ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Updating dirty mipmap' );
        this.updateURL( image, false );
      }
    },

    updateURL: function( image, forced ) {
      // determine our mipmap level, if any is used
      var level = -1; // signals a default of "we are not using mipmapping"
      if ( this.node._mipmap ) {
        var matrix = this.instance.relativeTransform.matrix;
        // a sense of "average" scale, which should be exact if there is no asymmetric scale/shear applied
        var approximateScale = ( Math.sqrt( matrix.m00() * matrix.m00() + matrix.m10() * matrix.m10() ) +
                                 Math.sqrt( matrix.m01() * matrix.m01() + matrix.m11() * matrix.m11() ) ) / 2;
        approximateScale *= ( window.devicePixelRatio || 1 ); // for retina-like devices
        level = this.node.getMipmapLevel( approximateScale );
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Mipmap level: ' + level );
      }

      // bail out if we would use the currently-used mipmap level (or none) and there was no image change
      if ( !forced && level === this._mipmapLevel ) {
        return;
      }

      // if we are switching to having no mipmap
      if ( this._mipmapLevel >= 0 && level === -1 ) {
        // IE guard needed since removeAttribute fails, see https://github.com/phetsims/scenery/issues/395
        ( platform.ie9 || platform.ie10 ) ? image.setAttribute( 'transform', '' ) : image.removeAttribute( 'transform' );
      }
      this._mipmapLevel = level;

      if ( this.node._mipmap && this.node.hasMipmaps() ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Setting image URL to mipmap level ' + level );
        var url = this.node.getMipmapURL( level );
        var canvas = this.node.getMipmapCanvas( level );
        image.setAttribute( 'width', canvas.width + 'px' );
        image.setAttribute( 'height', canvas.height + 'px' );
        // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
        // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
        // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
        // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
        image.setAttribute( 'transform', 'scale(' + Math.pow( 2, level ).toFixed( 20 ) + ')' );
        image.setAttributeNS( scenery.xlinkns, 'xlink:href', url );
      }
      else {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Setting image URL' );
        image.setAttribute( 'width', this.node.getImageWidth() + 'px' );
        image.setAttribute( 'height', this.node.getImageHeight() + 'px' );
        image.setAttributeNS( scenery.xlinkns, 'xlink:href', this.node.getImageURL() );
      }
    },

    updateMipmapStatus: function( usingMipmap ) {
      if ( this._usingMipmap !== usingMipmap ) {
        this._usingMipmap = usingMipmap;

        if ( usingMipmap ) {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Adding mipmap compute/listener needs' );
          this.instance.relativeTransform.addListener( this._mipmapTransformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
          this.instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated
        }
        else {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Removing mipmap compute/listener needs' );
          this.instance.relativeTransform.removeListener( this._mipmapTransformListener );
          this.instance.relativeTransform.removePrecompute();
        }

        // sanity check
        this.markDirtyMipmap();
      }
    },

    dispose: function() {
      sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' disposing' );

      // clean up mipmap listeners and compute needs
      this.updateMipmapStatus( false );
      this.node.offStatic( 'mipmap', this._mipmapListener );

      SVGSelfDrawable.prototype.dispose.call( this );
    }
  } );
  Image.ImageStatefulDrawable.mixin( Image.ImageSVGDrawable );
  SelfDrawable.Poolable.mixin( Image.ImageSVGDrawable );

  /*---------------------------------------------------------------------------*
   * Canvas rendering
   *----------------------------------------------------------------------------*/

  Image.ImageCanvasDrawable = function ImageCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( CanvasSelfDrawable, Image.ImageCanvasDrawable, {
    initialize: function( renderer, instance ) {
      return this.initializeCanvasSelfDrawable( renderer, instance );
    },

    paintCanvas: function( wrapper, node ) {
      if ( node._image ) {
        wrapper.context.drawImage( node._image, 0, 0 );
      }
    },

    // stateless dirty functions
    markDirtyImage: function() { this.markPaintDirty(); },
    markDirtyMipmap: function() { this.markPaintDirty(); }
  } );
  SelfDrawable.Poolable.mixin( Image.ImageCanvasDrawable );

  /*---------------------------------------------------------------------------*
   * WebGL rendering
   *----------------------------------------------------------------------------*/

  Image.ImageWebGLDrawable = inherit( WebGLSelfDrawable, function ImageWebGLDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }, {
    webglRenderer: Renderer.webglTexturedTriangles,

    // called either from the constructor or from pooling
    initialize: function( renderer, instance ) {
      this.initializeWebGLSelfDrawable( renderer, instance );

      if ( !this.vertexArray ) {
        // format [X Y U V] for 6 vertices
        this.vertexArray = new Float32Array( 4 * 6 ); // 4-length components for 6 vertices (2 tris).
      }

      // corner vertices in the relative transform root coordinate space
      this.upperLeft = new Vector2();
      this.lowerLeft = new Vector2();
      this.upperRight = new Vector2();
      this.lowerRight = new Vector2();

      this.xyDirty = true; // is our vertex position information out of date?
      this.uvDirty = true; // is our UV information out of date?

      // {SpriteSheet.Sprite} exported for WebGLBlock's rendering loop
      this.sprite = null;

      return this;
    },

    onAddToBlock: function( webglBlock ) {
      this.webglBlock = webglBlock; // TODO: do we need this reference?
      this.markDirty();

      this.reserveSprite();
    },

    onRemoveFromBlock: function( webglBlock ) {
      this.unreserveSprite();
    },

    reserveSprite: function() {
      if ( this.sprite ) {
        // if we already reserved a sprite for the image, bail out
        if ( this.sprite.image === this.node._image ) {
          return;
        }
        // otherwise we need to ditch our last reservation before reserving a new sprite
        else {
          this.unreserveSprite();
        }
      }

      // if the width/height isn't loaded yet, we can still use the desired value
      var width = this.node.getImageWidth();
      var height = this.node.getImageHeight();

      // if we have a width/height, we'll load a sprite
      this.sprite = ( width > 0 && height > 0 ) ? this.webglBlock.addSpriteSheetImage( this.node._image, width, height ) : null;

      // full updates on everything if our sprite changes
      this.xyDirty = true;
      this.uvDirty = true;
    },

    unreserveSprite: function() {
      if ( this.sprite ) {
        this.webglBlock.removeSpriteSheetImage( this.sprite );
      }
      this.sprite = null;
    },

    // @override
    markTransformDirty: function() {
      this.xyDirty = true;

      WebGLSelfDrawable.prototype.markTransformDirty.call( this );
    },

    // called when something about the Image's image itself changes (not transform, etc.)
    markPaintDirty: function() {
      this.xyDirty = true; // vertex positions can depend on image width/height
      this.uvDirty = true;

      this.markDirty();
    },

    update: function() {
      if ( this.dirty ) {
        this.dirty = false;

        // ensure that we have a reserved sprite (part of the spritesheet)
        this.reserveSprite();

        // if we don't have a sprite (we don't have a loaded image yet), just bail
        if ( !this.sprite ) {
          return;
        }

        if ( this.uvDirty ) {
          this.uvDirty = false;

          var uvBounds = this.sprite.uvBounds;

          // TODO: consider reversal of minY and maxY usage here for vertical inverse

          // first triangle UVs
          this.vertexArray[ 2 ] = uvBounds.minX; // upper left U
          this.vertexArray[ 3 ] = uvBounds.minY; // upper left V
          this.vertexArray[ 6 ] = uvBounds.minX; // lower left U
          this.vertexArray[ 7 ] = uvBounds.maxY; // lower left V
          this.vertexArray[ 10 ] = uvBounds.maxX; // upper right U
          this.vertexArray[ 11 ] = uvBounds.minY; // upper right V

          // second triangle UVs
          this.vertexArray[ 14 ] = uvBounds.maxX; // upper right U
          this.vertexArray[ 15 ] = uvBounds.minY; // upper right V
          this.vertexArray[ 18 ] = uvBounds.minX; // lower left U
          this.vertexArray[ 19 ] = uvBounds.maxY; // lower left V
          this.vertexArray[ 22 ] = uvBounds.maxX; // lower right U
          this.vertexArray[ 23 ] = uvBounds.maxY; // lower right V
        }

        if ( this.xyDirty ) {
          this.xyDirty = false;

          var width = this.node.getImageWidth();
          var height = this.node.getImageHeight();

          var transformMatrix = this.instance.relativeTransform.matrix; // with compute need, should always be accurate
          transformMatrix.multiplyVector2( this.upperLeft.setXY( 0, 0 ) );
          transformMatrix.multiplyVector2( this.lowerLeft.setXY( 0, height ) );
          transformMatrix.multiplyVector2( this.upperRight.setXY( width, 0 ) );
          transformMatrix.multiplyVector2( this.lowerRight.setXY( width, height ) );

          // first triangle XYs
          this.vertexArray[ 0 ] = this.upperLeft.x;
          this.vertexArray[ 1 ] = this.upperLeft.y;
          this.vertexArray[ 4 ] = this.lowerLeft.x;
          this.vertexArray[ 5 ] = this.lowerLeft.y;
          this.vertexArray[ 8 ] = this.upperRight.x;
          this.vertexArray[ 9 ] = this.upperRight.y;

          // second triangle XYs
          this.vertexArray[ 12 ] = this.upperRight.x;
          this.vertexArray[ 13 ] = this.upperRight.y;
          this.vertexArray[ 16 ] = this.lowerLeft.x;
          this.vertexArray[ 17 ] = this.lowerLeft.y;
          this.vertexArray[ 20 ] = this.lowerRight.x;
          this.vertexArray[ 21 ] = this.lowerRight.y;
        }
      }
    },

    dispose: function() {
      // TODO: disposal of buffers?

      // super
      WebGLSelfDrawable.prototype.dispose.call( this );
    }
  } );
  Image.ImageStatefulDrawable.mixin( Image.ImageWebGLDrawable );
  SelfDrawable.Poolable.mixin( Image.ImageWebGLDrawable ); // pooling

  return Image;
} );



// Copyright 2013-2015, University of Colorado Boulder

/**
 * DEPRECATED EXPERIMENTAL: USE AT YOUR OWN CAUTION
 *
 * A container that allows flexible layout generation based on layout methods that can be composed together.
 *
 * Experimental demo (for use in Scenery's playground):
 *   var n = new scenery.LayoutNode( scenery.LayoutNode.Vertical.and( scenery.LayoutNode.AlignLeft ) );
 *   scene.addChild( n );
 *   n.addChild( new scenery.Text( 'Some Text' ) );
 *   n.addChild( new scenery.Text( 'Text pushed to the right' ), { padLeft: 10 } );
 *   n.addChild( new scenery.Text( 'Some padding on top and bottom' ), { padTop: 10, padBottom: 20 } );
 *   n.addChild( new scenery.Text( 'Just Regular Text' ) );
 *   n.addChild( new scenery.Text( 'Right-aligned' ), { layoutMethod: scenery.LayoutNode.Vertical.and( scenery.LayoutNode.AlignRight ) } );
 *   n.addChild( new scenery.Text( 'Center-aligned' ), { layoutMethod: scenery.LayoutNode.Vertical.and( scenery.LayoutNode.AlignHorizontalCenter ) } );
 *   n.addChild( new scenery.Text( 'Pad from right' ), { layoutMethod: scenery.LayoutNode.Vertical.and( scenery.LayoutNode.AlignRight ), padRight: 10 } );
 *   n.children[2].text += ' and it updates!';
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/LayoutNode',['require','PHET_CORE/inherit','PHET_CORE/extend','SCENERY/scenery','SCENERY/nodes/Node','DOT/Bounds2'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  // var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Bounds2 = require( 'DOT/Bounds2' );

  // var debug = false;

  // @deprecated
  function LayoutNode( defaultMethod, options ) {
    var layoutNode = this;

    assert && assert( defaultMethod instanceof LayoutMethod, 'defaultMethod is required' );

    options = extend( {
      updateOnBounds: true,
      defaultMethod: defaultMethod
    }, options );

    this._activelyLayingOut = false;
    this._updateOnBounds = true;
    this._defaultMethod = null;
    this._elements = [];
    this._elementMap = {}; // maps node ID => element
    // this._invisibleBackground = new Rectangle( 0, 0, 0x1f, 0x1f, { visible: false } ); // takes up space that represents the bounds of all of the layout elements (with their padding)
    this._boundsListener = function() {
      if ( layoutNode._updateOnBounds ) {
        layoutNode.updateLayout();
      }
    };

    Node.call( this, options );

    // this.addChild( this._invisibleBackground );

    this.updateLayout();

    throw new Error( 'Deprecated, please do not use (replacement for overrideBounds has not been provided)' );
  }

  scenery.register( 'LayoutNode', LayoutNode );

  inherit( Node, LayoutNode, {
    get layoutProperties() { return new LayoutProperties( this._elements ); },

    get layoutBounds() {
      var result = Bounds2.NOTHING.copy();
      _.each( this._elements, function( element ) {
        result.includeBounds( element.layoutBounds );
      } );
      return result;
    },

    set defaultMethod( value ) {
      this._defaultMethod = value;
      this.updateLayout();
      return this;
    },
    get defaultMethod() { return this._defaultMethod; },

    set updateOnBounds( value ) {
      this._updateOnBounds = value;
      return this;
    },
    get updateOnBounds() { return this._updateOnBounds; },

    /*
     * Options can consist of:
     *   layoutMethod - layout method
     *   useVisibleBounds - (false) whether to use visible bounds instead of normal bounds - TODO how to auto-update when using these?
     *   padLeft / padRight / padTop / padBottom
     *   boundsMethod - custom overriding of entire boundsMethod
     */
    insertChild: function( index, node, options ) {
      var layoutNode = this;

      options = extend( {
        useVisibleBounds: false,
        padLeft: 0,
        padRight: 0,
        padTop: 0,
        padBottom: 0
      }, options );
      // var baseBoundsFunc = ( options.useVisibleBounds ? node.getVisibleBounds : node.getBounds ).bind( node );

      Node.prototype.insertChild.call( this, index, node );

      var methodGetter = options.layoutMethod ? function() { return options.layoutMethod; } : function() { return layoutNode._defaultMethod; };
      var element = new LayoutElement( node, methodGetter, options.boundsMethod ? options.boundsMethod : function( bounds ) {
        if ( options.useVisibleBounds ) {
          bounds = node.visibleBounds;
        }

        return new Bounds2( bounds.minX - options.padLeft, bounds.minY - options.padTop, bounds.maxX + options.padRight, bounds.maxY + options.padBottom );
      } );
      this.addElement( element );

      this.updateLayout();
    },

    addChild: function( node, options ) {
      this.insertChild( this._children.length, node, options );
    },

    // override
    removeChildWithIndex: function( node, indexOfChild ) {
      Node.prototype.removeChildWithIndex.call( this, node, indexOfChild );
      if ( this._elementMap[ node.id ] ) {
        delete this._elementMap[ node.id ];
      }

      this.updateLayout();
    },

    addElement: function( element ) {
      this._elements.push( element );
      element.node.addEventListener( 'bounds', this._boundsListener );
    },

    removeElement: function( element ) {
      this._elements.splice( this._elements.indexOf( element ), 1 ); // TODO: replace with some remove() instead of splice()
      element.node.removeEventListener( 'bounds', this._boundsListener );
    },

    updateLayout: function() {
      if ( this._activelyLayingOut ) {
        // don't start another layout while one is going on!
        return;
      }
      this._activelyLayingOut = true;
      var layoutProperties = this.layoutProperties;
      for ( var i = 0; i < this._elements.length; i++ ) {
        var element = this._elements[ i ];
        element.layoutMethod.layout( element, i, ( i > 0 ? this._elements[ i - 1 ] : null ), layoutProperties );
      }

      // use the invisible background to take up all of our layout areas
      // this._invisibleBackground.removeAllChildren();
      // var bounds = this.layoutBounds;
      // if ( !bounds.isEmpty() ) {
      //   this._invisibleBackground.addChild( new Rectangle( bounds, { visible: false } ) );
      // }

      // if ( debug ) {
      //   this._invisibleBackground.visible = true;
      //   this._invisibleBackground.fill = 'rgba(255,0,0,0.4)';

      //   _.each( this._elements, function( element ) {
      //     this._invisibleBackground.addChild( new Rectangle( element.node.bounds ), {
      //       fill: 'rgba(255,0,0,0.4)',
      //       stroke: 'blue'
      //     } );
      //   } );
      // }
      this._activelyLayingOut = false;
    }
  } );

  /*
   * LayoutMethod - function layout( element, index, previousElement, layoutProperties )
   */
  var LayoutMethod = LayoutNode.LayoutMethod = function LayoutMethod( layout ) {
    if ( layout ) {
      this.layout = layout;
    }
  };
  inherit( Object, LayoutMethod, {
    and: function( otherLayoutMethod ) {
      var thisLayoutMethod = this;

      return new LayoutMethod( function compositeLayout( element, index, previousElement, layoutProperties ) {
        thisLayoutMethod.layout( element, index, previousElement, layoutProperties );
        otherLayoutMethod.layout( element, index, previousElement, layoutProperties );
      } );
    }
  } );

  /*---------------------------------------------------------------------------*
   * Layout Methods
   *----------------------------------------------------------------------------*/

  LayoutNode.Vertical = new LayoutMethod( function verticalLayout( element, index, previousElement, layoutProperties ) {
    element.layoutTop = previousElement ? previousElement.layoutBounds.bottom : 0;
  } );

  LayoutNode.Horizontal = new LayoutMethod( function horizontalLayout( element, index, previousElement, layoutProperties ) {
    element.layoutLeft = previousElement ? previousElement.layoutBounds.right : 0;
  } );

  LayoutNode.AlignLeft = new LayoutMethod( function alignLeftLayout( element, index, previousElement, layoutProperties ) {
    element.layoutLeft = 0;
  } );

  LayoutNode.AlignHorizontalCenter = new LayoutMethod( function alignHorizontalCenterLayout( element, index, previousElement, layoutProperties ) {
    element.layoutLeft = ( layoutProperties.maxWidth - element.layoutBounds.width ) / 2;
  } );

  LayoutNode.AlignRight = new LayoutMethod( function alignRightLayout( element, index, previousElement, layoutProperties ) {
    element.layoutLeft = layoutProperties.maxWidth - element.layoutBounds.width;
  } );

  LayoutNode.AlignTop = new LayoutMethod( function alignTopLayout( element, index, previousElement, layoutProperties ) {
    element.layoutTop = 0;
  } );

  LayoutNode.AlignVerticalCenter = new LayoutMethod( function alignVerticalCenterLayout( element, index, previousElement, layoutProperties ) {
    element.layoutTop = ( layoutProperties.maxHeight - element.layoutBounds.height ) / 2;
  } );

  LayoutNode.AlignBottom = new LayoutMethod( function alignBottomLayout( element, index, previousElement, layoutProperties ) {
    element.layoutTop = layoutProperties.maxHeight - element.layoutBounds.height;
  } );

  /*---------------------------------------------------------------------------*
   * Internals
   *----------------------------------------------------------------------------*/

  var LayoutProperties = LayoutNode.LayoutProperties = function LayoutProperties( elements ) {
    var largestWidth = 0;
    var largestHeight = 0;

    _.each( elements, function( element ) {
      largestWidth = Math.max( largestWidth, element.layoutBounds.width );
      largestHeight = Math.max( largestHeight, element.layoutBounds.height );
    } );

    this.maxWidth = largestWidth;
    this.maxHeight = largestHeight;
  };

  var LayoutElement = LayoutNode.LayoutElement = function LayoutElement( node, layoutMethodGetter, boundsMethod ) {
    this.node = node;
    this.layoutMethodGetter = layoutMethodGetter;
    this.boundsMethod = boundsMethod;
  };
  inherit( Object, LayoutElement, {
    get bounds() { return this.node.bounds; },
    get layoutBounds() { return this.boundsMethod( this.bounds ); },
    get layoutMethod() { return this.layoutMethodGetter(); },

    get layoutTop() { throw new Error( 'JSHint wants this getter' ); },
    set layoutTop( y ) {
      var padding = this.bounds.top - this.layoutBounds.top;
      this.node.top = y + padding;
    },

    get layoutLeft() { throw new Error( 'JSHint wants this getter' ); },
    set layoutLeft( x ) {
      var padding = this.bounds.left - this.layoutBounds.left;
      this.node.left = x + padding;
    }
  } );

  LayoutNode.prototype._mutatorKeys = [ 'defaultMethod', 'updateOnBounds' ].concat( Node.prototype._mutatorKeys );

  return LayoutNode;
} );



// Copyright 2013-2015, University of Colorado Boulder

/**
 * A line that inherits Path, and allows for optimized drawing,
 * and improved line handling.
 *
 * TODO: add DOM support
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Line',['require','PHET_CORE/inherit','SCENERY/scenery','KITE/segments/Line','SCENERY/nodes/Path','KITE/Shape','DOT/Bounds2','DOT/Vector2','SCENERY/nodes/Paintable','SCENERY/display/SVGSelfDrawable','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/Renderer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var KiteLine = require( 'KITE/segments/Line' ); // eslint-disable-line require-statement-match

  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );

  var Paintable = require( 'SCENERY/nodes/Paintable' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );

  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepSVGLineElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  /**
   * Currently, all numerical parameters should be finite.
   * x1:         x-position of the start
   * y1:         y-position of the start
   * x2:         x-position of the end
   * y2:         y-position of the end
   *
   * Available constructors:
   * new Line( x1, y1, x2, y2, { ... } )
   * new Line( new Vector2( x1, y1 ), new Vector2( x2, y2 ), { ... } )
   * new Line( { x1: x1, y1: y1, x2: x2, y2: y2,  ... } )
   */
  function Line( x1, y1, x2, y2, options ) {
    if ( typeof x1 === 'object' ) {
      if ( x1 instanceof Vector2 ) {
        // assumes Line( Vector2, Vector2, options );
        this._x1 = x1.x;
        this._y1 = x1.y;
        this._x2 = y1.x;
        this._y2 = y1.y;
        options = x2 || {};
      }
      else {
        // assumes Line( { ... } ), init to zero for now
        this._x1 = 0;
        this._y1 = 0;
        this._x2 = 0;
        this._y2 = 0;
        options = x1 || {};
      }
    }
    else {
      // new Line(  x1, y1, x2, y2, [options] )
      this._x1 = x1;
      this._y1 = y1;
      this._x2 = x2;
      this._y2 = y2;

      // ensure we have a parameter object
      options = options || {};
    }
    // fallback for non-canvas or non-svg rendering, and for proper bounds computation

    Path.call( this, null, options );
  }

  scenery.register( 'Line', Line );

  inherit( Path, Line, {

    /**
     * Set the geometry of the line, including stand and end point.
     * @param {number} x1 - the start x coordinate
     * @param {number} y1 - the start y coordinate
     * @param {number} x2 - the end x coordinate
     * @param {number} y2 - the end y coordinate
     */
    setLine: function( x1, y1, x2, y2 ) {
      assert && assert( x1 !== undefined && y1 !== undefined && x2 !== undefined && y2 !== undefined, 'parameters need to be defined' );

      this._x1 = x1;
      this._y1 = y1;
      this._x2 = x2;
      this._y2 = y2;

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyLine();
      }

      this.invalidateLine();
    },

    setPoint1: function( x1, y1 ) {
      if ( typeof x1 === 'number' ) {
        // setPoint1( x1, y1 );
        assert && assert( x1 !== undefined && y1 !== undefined, 'parameters need to be defined' );
        this._x1 = x1;
        this._y1 = y1;
      }
      else {
        // setPoint1( Vector2 )
        assert && assert( x1.x !== undefined && x1.y !== undefined, 'parameters need to be defined' );
        this._x1 = x1.x;
        this._y1 = x1.y;
      }
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyP1();
      }
      this.invalidateLine();
    },
    set p1( point ) { this.setPoint1( point ); },
    get p1() { return new Vector2( this._x1, this._y1 ); },

    setPoint2: function( x2, y2 ) {
      if ( typeof x2 === 'number' ) {
        // setPoint2( x2, y2 );
        assert && assert( x2 !== undefined && y2 !== undefined, 'parameters need to be defined' );
        this._x2 = x2;
        this._y2 = y2;
      }
      else {
        // setPoint2( Vector2 )
        assert && assert( x2.x !== undefined && x2.y !== undefined, 'parameters need to be defined' );
        this._x2 = x2.x;
        this._y2 = x2.y;
      }
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyP2();
      }
      this.invalidateLine();
    },
    set p2( point ) { this.setPoint2( point ); },
    get p2() { return new Vector2( this._x2, this._y2 ); },

    createLineShape: function() {
      return Shape.lineSegment( this._x1, this._y1, this._x2, this._y2 );
    },

    invalidateLine: function() {
      assert && assert( isFinite( this._x1 ), 'A rectangle needs to have a finite x1 (' + this._x1 + ')' );
      assert && assert( isFinite( this._y1 ), 'A rectangle needs to have a finite y1 (' + this._y1 + ')' );
      assert && assert( isFinite( this._x2 ), 'A rectangle needs to have a finite x2 (' + this._x2 + ')' );
      assert && assert( isFinite( this._y2 ), 'A rectangle needs to have a finite y2 (' + this._y2 + ')' );

      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;

      // should invalidate the path and ensure a redraw
      this.invalidatePath();
    },

    containsPointSelf: function( point ) {
      if ( this._strokePickable ) {
        return Path.prototype.containsPointSelf.call( this, point );
      }
      else {
        return false; // nothing is in a line! (although maybe we should handle edge points properly?)
      }
    },

    intersectsBoundsSelf: function( bounds ) {
      // TODO: optimization
      return new KiteLine( this.p1, this.p2 ).intersectsBounds( bounds );
    },

    canvasPaintSelf: function( wrapper ) {
      Line.LineCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },

    computeShapeBounds: function() {
      // optimized form for a single line segment (no joins, just two caps)
      if ( this._stroke ) {
        var lineCap = this.getLineCap();
        var halfLineWidth = this.getLineWidth() / 2;
        if ( lineCap === 'round' ) {
          // we can simply dilate by half the line width
          return new Bounds2(
            Math.min( this._x1, this._x2 ) - halfLineWidth, Math.min( this._y1, this._y2 ) - halfLineWidth,
            Math.max( this._x1, this._x2 ) + halfLineWidth, Math.max( this._y1, this._y2 ) + halfLineWidth );
        }
        else {
          // (dx,dy) is a vector p2-p1
          var dx = this._x2 - this._x1;
          var dy = this._y2 - this._y1;
          var magnitude = Math.sqrt( dx * dx + dy * dy );
          if ( magnitude === 0 ) {
            // if our line is a point, just dilate by halfLineWidth
            return new Bounds2( this._x1 - halfLineWidth, this._y1 - halfLineWidth, this._x2 + halfLineWidth, this._y2 + halfLineWidth );
          }
          // (sx,sy) is a vector with a magnitude of halfLineWidth pointed in the direction of (dx,dy)
          var sx = halfLineWidth * dx / magnitude;
          var sy = halfLineWidth * dy / magnitude;
          var bounds = Bounds2.NOTHING.copy();

          if ( lineCap === 'butt' ) {
            // four points just using the perpendicular stroked offsets (sy,-sx) and (-sy,sx)
            bounds.addCoordinates( this._x1 - sy, this._y1 + sx );
            bounds.addCoordinates( this._x1 + sy, this._y1 - sx );
            bounds.addCoordinates( this._x2 - sy, this._y2 + sx );
            bounds.addCoordinates( this._x2 + sy, this._y2 - sx );
          }
          else {
            assert && assert( lineCap === 'square' );

            // four points just using the perpendicular stroked offsets (sy,-sx) and (-sy,sx) and parallel stroked offsets
            bounds.addCoordinates( this._x1 - sx - sy, this._y1 - sy + sx );
            bounds.addCoordinates( this._x1 - sx + sy, this._y1 - sy - sx );
            bounds.addCoordinates( this._x2 + sx - sy, this._y2 + sy + sx );
            bounds.addCoordinates( this._x2 + sx + sy, this._y2 + sy - sx );
          }
          return bounds;
        }
      }
      else {
        // It might have a fill? Just include the fill bounds for now.
        var fillBounds = Bounds2.NOTHING.copy();
        fillBounds.addCoordinates( this._x1, this._y1 );
        fillBounds.addCoordinates( this._x2, this._y2 );
        return fillBounds;
      }
    },

    createSVGDrawable: function( renderer, instance ) {
      return Line.LineSVGDrawable.createFromPool( renderer, instance );
    },

    createCanvasDrawable: function( renderer, instance ) {
      return Line.LineCanvasDrawable.createFromPool( renderer, instance );
    },

    createWebGLDrawable: function( renderer, instance ) {
      return Line.LineWebGLDrawable.createFromPool( renderer, instance );
    },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.Line( ' + this._x1 + ', ' + this._y1 + ', ' + this._x1 + ', ' + this._y1 + ', {' + propLines + '} )';
    },

    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Line to something non-null' );
      }
      else {
        // probably called from the Path constructor
        this.invalidatePath();
      }
    },

    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createLineShape();
      }
      return this._shape;
    },

    hasShape: function() {
      return true;
    },

    // A line does not render its fill, so it supports all renderers.  Right?
    // - SR, 2014
    getFillRendererBitmask: function() {
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG | Renderer.bitmaskDOM;
    }

  } );

  function addLineProp( capitalizedShort ) {
    var lowerShort = capitalizedShort.toLowerCase();

    var getName = 'get' + capitalizedShort;
    var setName = 'set' + capitalizedShort;
    var privateName = '_' + lowerShort;
    var dirtyMethodName = 'markDirty' + capitalizedShort;

    Line.prototype[ getName ] = function() {
      return this[ privateName ];
    };

    Line.prototype[ setName ] = function( value ) {
      if ( this[ privateName ] !== value ) {
        this[ privateName ] = value;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          var state = this._drawables[ i ];
          state[ dirtyMethodName ]();
        }
        this.invalidateLine();
      }
      return this;
    };

    Object.defineProperty( Line.prototype, lowerShort, {
      set: Line.prototype[ setName ],
      get: Line.prototype[ getName ]
    } );
  }

  addLineProp( 'X1' );
  addLineProp( 'Y1' );
  addLineProp( 'X2' );
  addLineProp( 'Y2' );

  // not adding mutators for now
  Line.prototype._mutatorKeys = [ 'p1', 'p2', 'x1', 'y1', 'x2', 'y2' ].concat( Path.prototype._mutatorKeys );

  /*---------------------------------------------------------------------------*
   * Rendering State mixin (DOM/SVG)
   *----------------------------------------------------------------------------*/

  Line.LineStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      // initializes, and resets (so we can support pooled states)
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true; // flag that is marked if ANY "paint" dirty flag is set (basically everything except for transforms, so we can accelerated the transform-only case)
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.dirtyX2 = true;
        this.dirtyY2 = true;

        // adds fill/stroke-specific flags and state
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      proto.disposeState = function() {
        this.disposePaintableState();
      };

      // catch-all dirty, if anything that isn't a transform is marked as dirty
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyLine = function() {
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.dirtyX2 = true;
        this.dirtyY2 = true;
        this.markPaintDirty();
      };

      proto.markDirtyP1 = function() {
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.markPaintDirty();
      };

      proto.markDirtyP2 = function() {
        this.dirtyX2 = true;
        this.dirtyY2 = true;
        this.markPaintDirty();
      };

      proto.markDirtyX1 = function() {
        this.dirtyX1 = true;
        this.markPaintDirty();
      };

      proto.markDirtyY1 = function() {
        this.dirtyY1 = true;
        this.markPaintDirty();
      };

      proto.markDirtyX2 = function() {
        this.dirtyX2 = true;
        this.markPaintDirty();
      };

      proto.markDirtyY2 = function() {
        this.dirtyY2 = true;
        this.markPaintDirty();
      };

      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyX1 = false;
        this.dirtyY1 = false;
        this.dirtyX2 = false;
        this.dirtyY2 = false;
      };

      Paintable.PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  /*---------------------------------------------------------------------------*
   * Stateless drawable mixin
   *----------------------------------------------------------------------------*/

  Line.LineStatelessDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      // initializes, and resets (so we can support pooled states)
      proto.initializeLineStateless = function() {
        this.paintDirty = true; // flag that is marked if ANY "paint" dirty flag is set (basically everything except for transforms, so we can accelerated the transform-only case)
        return this; // allow for chaining
      };

      // catch-all dirty, if anything that isn't a transform is marked as dirty
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyLine = function() {
        this.markPaintDirty();
      };

      proto.markDirtyP1 = function() {
        this.markPaintDirty();
      };

      proto.markDirtyP2 = function() {
        this.markPaintDirty();
      };

      proto.markDirtyX1 = function() {
        this.markPaintDirty();
      };

      proto.markDirtyY1 = function() {
        this.markPaintDirty();
      };

      proto.markDirtyX2 = function() {
        this.markPaintDirty();
      };

      proto.markDirtyY2 = function() {
        this.markPaintDirty();
      };

      Paintable.PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  /*---------------------------------------------------------------------------*
   * SVG Rendering
   *----------------------------------------------------------------------------*/

  Line.LineSVGDrawable = function LineSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( SVGSelfDrawable, Line.LineSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGLineElements ); // usesPaint: true

      if ( !this.svgElement ) {
        this.svgElement = document.createElementNS( scenery.svgns, 'line' );
      }

      return this;
    },

    updateSVGSelf: function() {
      var line = this.svgElement;

      if ( this.dirtyX1 ) {
        line.setAttribute( 'x1', this.node._x1 );
      }
      if ( this.dirtyY1 ) {
        line.setAttribute( 'y1', this.node._y1 );
      }
      if ( this.dirtyX2 ) {
        line.setAttribute( 'x2', this.node._x2 );
      }
      if ( this.dirtyY2 ) {
        line.setAttribute( 'y2', this.node._y2 );
      }

      this.updateFillStrokeStyle( line );
    }
  } );
  Line.LineStatefulDrawable.mixin( Line.LineSVGDrawable );
  SelfDrawable.Poolable.mixin( Line.LineSVGDrawable );

  /*---------------------------------------------------------------------------*
   * Canvas rendering
   *----------------------------------------------------------------------------*/

  Line.LineCanvasDrawable = function LineCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  };
  inherit( CanvasSelfDrawable, Line.LineCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;

      context.beginPath();
      context.moveTo( node._x1, node._y1 );
      context.lineTo( node._x2, node._y2 );

      if ( node._stroke ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.stroke();
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },

    // stateless dirty methods:
    markDirtyLine: function() { this.markPaintDirty(); },
    markDirtyP1: function() { this.markPaintDirty(); },
    markDirtyP2: function() { this.markPaintDirty(); },
    markDirtyX1: function() { this.markPaintDirty(); },
    markDirtyY1: function() { this.markPaintDirty(); },
    markDirtyX2: function() { this.markPaintDirty(); },
    markDirtyY2: function() { this.markPaintDirty(); },

    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  Paintable.PaintableStatelessDrawable.mixin( Line.LineCanvasDrawable );
  SelfDrawable.Poolable.mixin( Line.LineCanvasDrawable );

  return Line;
} );



// Copyright 2013-2015, University of Colorado Boulder

/**
 * A node which always fills the entire screen, no matter what the transform is.
 * Used for showing an overlay on the screen e.g., when a popup dialog is shown.
 * This can fade the background to focus on the dialog/popup as well as intercept mouse events for dismissing the dialog/popup.
 * Note: This is currently implemented using large numbers, it should be rewritten to work in any coordinate frame, possibly using kite.Shape.plane()
 * TODO: Implement using infinite geometry
 *
 * @author Sam Reid
 */

define( 'SCENERY/nodes/Plane',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Rectangle'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Rectangle = require( 'SCENERY/nodes/Rectangle' );

  /**
   * @param {Object} [options] Any options for the plane, typically fill/opacity (many others such as scale, translation, rotation should have no effect)
   * @constructor
   */
  function Plane( options ) {
    Rectangle.call( this, -2000, -2000, 6000, 6000, options );
  }

  scenery.register( 'Plane', Plane );

  return inherit( Rectangle, Plane );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * VBox is a convenience specialization of LayoutBox with vertical orientation.
 *
 * @author Sam Reid
 */
define( 'SCENERY/nodes/VBox',['require','PHET_CORE/inherit','SCENERY/nodes/LayoutBox','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var LayoutBox = require( 'SCENERY/nodes/LayoutBox' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @param {Object} [options] see LayoutBox
   * @constructor
   */
  function VBox( options ) {
    LayoutBox.call( this, _.extend( {}, options, { orientation: 'vertical' } ) );
  }

  scenery.register( 'VBox', VBox );

  return inherit( LayoutBox, VBox );
} );
// Copyright 2015, University of Colorado Boulder

/**
 * A Node meant to just take up vertical space (usually for layout purposes).
 * It is never displayed, and cannot have children.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/VStrut',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Spacer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Spacer = require( 'SCENERY/nodes/Spacer' );

  /**
   * Creates a strut with x=0 and y in the range [0,height].
   */
  function VStrut( height, options ) {
    Spacer.call( this, 0, height, options );
  }

  scenery.register( 'VStrut', VStrut );

  return inherit( Spacer, VStrut );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * A node that can be custom-drawn with WebGL calls. Manual handling of dirty region repainting.  Analogous to CanvasNode
 *
 * setCanvasBounds (or the mutator canvasBounds) should be used to set the area that is drawn to (otherwise nothing
 * will show up)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid
 */
define( 'SCENERY/nodes/WebGLNode',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Matrix3','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/display/WebGLSelfDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  // pass a canvasBounds option if you want to specify the self bounds
  function WebGLNode( options ) {
    Node.call( this, options );
    this.setRendererBitmask( Renderer.bitmaskWebGL );
  }

  scenery.register( 'WebGLNode', WebGLNode );

  inherit( Node, WebGLNode, {

    // how to set the bounds of the WebGLNode
    setCanvasBounds: function( selfBounds ) {
      this.invalidateSelf( selfBounds );
    },
    set canvasBounds( value ) { this.setCanvasBounds( value ); },
    get canvasBounds() { return this.getSelfBounds(); },

    isPainted: function() {
      return true;
    },

    /**
     * Initializes a WebGL drawable for a displayed instance of this node.
     * @public
     *
     * Meant to be overridden by a concrete sub-type.
     *
     * IMPORTANT NOTE: This function will be run from inside Scenery's Display.updateDisplay(), so it should not modify
     * or mutate any Scenery nodes (particularly anything that would cause something to be marked as needing a repaint).
     * Ideally, this function should have no outside effects other than painting to the Canvas provided.
     *
     * @param {WebGLNode.WebGLNodeDrawable} drawable
     */
    initializeWebGLDrawable: function( drawable ) {
      throw new Error( 'WebGLNode needs initializeWebGLDrawable implemented' );
    },

    /**
     * Paints a WebGL drawable for a displayed instance of this node.
     * @public
     *
     * Meant to be overridden by a concrete sub-type.
     *
     * IMPORTANT NOTE: This function will be run from inside Scenery's Display.updateDisplay(), so it should not modify
     * or mutate any Scenery nodes (particularly anything that would cause something to be marked as needing a repaint).
     * Ideally, this function should have no outside effects other than painting to the Canvas provided.
     *
     * For handling transforms, this function provides a matrix with the local-to-global coordinate transform, e.g.:
     * gl.uniformMatrix3fv( uniforms.uModelViewMatrix, false, matrix.entries );
     * AND also a recommended projection transform:
     * gl.uniformMatrix3fv( uniforms.uProjectionMatrix, false, drawable.webGLBlock.projectionMatrixArray );
     *
     * @param {WebGLNode.WebGLNodeDrawable} drawable
     * @param {Matrix3} matrix - The model-view matrix, from this node's local coordinate frame to Scenery's
     *                           global coordinate frame
     */
    paintWebGLDrawable: function( drawable, matrix ) {
      throw new Error( 'WebGLNode needs paintWebGLDrawable implemented' );
    },

    /**
     * Cleans up a WebGL drawable for a displayed instance of this node.
     * @public
     *
     * Meant to be overridden by a concrete sub-type.
     *
     * IMPORTANT NOTE: This function will be run from inside Scenery's Display.updateDisplay(), so it should not modify
     * or mutate any Scenery nodes (particularly anything that would cause something to be marked as needing a repaint).
     * Ideally, this function should have no outside effects other than painting to the Canvas provided.
     *
     * @param {WebGLNode.WebGLNodeDrawable} drawable
     */
    disposeWebGLDrawable: function( drawable ) {
      throw new Error( 'WebGLNode needs disposeWebGLDrawable implemented' );
    },

    invalidatePaint: function() {
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirty();
      }
    },

    // override for computation of whether a point is inside the self content
    // point is considered to be in the local coordinate frame
    containsPointSelf: function( point ) {
      return false;
      // throw new Error( 'WebGLNode needs containsPointSelf implemented' );
    },

    canvasPaintSelf: function( wrapper ) {
      assert && assert( 'unimplemented: canvasPaintSelf in WebGLNode' );
    },

    createWebGLDrawable: function( renderer, instance ) {
      return WebGLNode.WebGLNodeDrawable.createFromPool( renderer, instance );
    },

    // whether this node's self intersects the specified bounds, in the local coordinate frame
    // intersectsBoundsSelf: function( bounds ) {
    //   // TODO: implement?
    // },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.WebGLNode( {' + propLines + '} )'; // TODO: no real way to do this nicely?
    }

  } );

  WebGLNode.prototype._mutatorKeys = [ 'canvasBounds' ].concat( Node.prototype._mutatorKeys );

  var modelViewMatrix = new Matrix3().setTo32Bit();

  WebGLNode.WebGLNodeDrawable = inherit( WebGLSelfDrawable, function WebGLNodeDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }, {
    webglRenderer: Renderer.webglCustom,

    // called either from the constructor, or from pooling
    initialize: function( renderer, instance ) {
      this.initializeWebGLSelfDrawable( renderer, instance );
    },

    onAddToBlock: function( webGLBlock ) {
      this.webGLBlock = webGLBlock;
      this.backingScale = this.webGLBlock.backingScale;
      this.gl = this.webGLBlock.gl;

      this.node.initializeWebGLDrawable( this );
    },

    onRemoveFromBlock: function( webGLBlock ) {

    },

    draw: function() {
      // we have a precompute need
      var matrix = this.instance.relativeTransform.matrix;

      modelViewMatrix.set( matrix );

      this.node.paintWebGLDrawable( this, modelViewMatrix );
    },

    dispose: function() {
      this.node.disposeWebGLDrawable( this );

      if ( this.webGLBlock ) {
        this.webGLBlock = null;
      }

      // super
      WebGLSelfDrawable.prototype.dispose.call( this );
    },

    // general flag set on the state, which we forward directly to the drawable's paint flag
    markPaintDirty: function() {
      this.markDirty();
    },

    // forward call to the WebGLNode
    get shaderAttributes() {
      return this.node.shaderAttributes;
    },

    update: function() {
      this.dirty = false;
    }
  } );
  SelfDrawable.Poolable.mixin( WebGLNode.WebGLNodeDrawable ); // pooling

  return WebGLNode;
} );

// Copyright 2014, University of Colorado Boulder


/**
 * Base type for gradients and patterns (and NOT the only type for fills/strokes)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Paint',['require','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var globalId = 1;

  function Paint() {
    this.id = 'paint' + globalId++;

    this.transformMatrix = null;
  }

  scenery.register( 'Paint', Paint );

  inherit( Object, Paint, {
    // abstract getCanvasStyle: function()

    isPaint: true,

    setTransformMatrix: function( transformMatrix ) {
      // TODO: invalidate?
      if ( this.transformMatrix !== transformMatrix ) {
        this.transformMatrix = transformMatrix;
      }
      return this;
    }
  } );

  return Paint;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Gradient base type for LinearGradient and RadialGradient. Will not function on its own
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Gradient',['require','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Paint','SCENERY/util/Color'],function( require ) {
  'use strict';

  require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Paint = require( 'SCENERY/util/Paint' );
  var Color = require( 'SCENERY/util/Color' );

  // TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
  function Gradient( canvasGradient ) {
    assert && assert( this.constructor.name !== 'Gradient', 'Please create a LinearGradient or RadialGradient. Do not directly use the supertype Gradient.' );
    Paint.call( this );

    this.stops = [];
    this.lastStopRatio = 0;

    this.canvasGradient = canvasGradient;
  }

  scenery.register( 'Gradient', Gradient );

  inherit( Paint, Gradient, {
    isGradient: true,

    /**
     * @param {Number} ratio        Monotonically increasing value in the range of 0 to 1
     * @param {Color|String} color  Color for the stop, either a scenery.Color or CSS color string
     */
    addColorStop: function( ratio, color ) {
      assert && assert( typeof ratio === 'number', 'Ratio needs to be a number' );
      assert && assert( ratio >= 0 && ratio <= 1, 'Ratio needs to be between 0,1 inclusively' );
      assert && assert( typeof color === 'string' || color instanceof Color,
        'Color should be a string or a {Color} object' );

      // TODO: invalidate the gradient?
      if ( this.lastStopRatio > ratio ) {
        // fail out, since browser quirks go crazy for this case
        throw new Error( 'Color stops not specified in the order of increasing ratios' );
      }
      else {
        this.lastStopRatio = ratio;
      }

      // make sure we have a scenery.Color now
      if ( typeof color === 'string' ) {
        color = new scenery.Color( color );
      }

      this.stops.push( {
        ratio: ratio,
        color: color
      } );

      // construct the Canvas gradient as we go
      this.canvasGradient.addColorStop( ratio, color.toCSS() );
      return this;
    },

    getCanvasStyle: function() {
      return this.canvasGradient;
    }
  } );

  return Gradient;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * A linear gradient that can be passed into the 'fill' or 'stroke' parameters.
 *
 * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/LinearGradient',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/Vector2','SCENERY/util/Gradient'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Gradient = require( 'SCENERY/util/Gradient' );

  // TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
  function LinearGradient( x0, y0, x1, y1 ) {
    assert && assert( isFinite( x0 ) && isFinite( y0 ) && isFinite( x1 ) && isFinite( y1 ) );
    var usesVectors = y1 === undefined;
    if ( usesVectors ) {
      assert && assert( ( x0 instanceof Vector2 ) && ( y0 instanceof Vector2 ), 'If less than 4 parameters are given, the first two parameters must be Vector2' );
    }
    this.start = usesVectors ? x0 : new Vector2( x0, y0 );
    this.end = usesVectors ? y0 : new Vector2( x1, y1 );

    // use the global scratch canvas instead of creating a new Canvas
    Gradient.call( this, scenery.scratchContext.createLinearGradient( x0, y0, x1, y1 ) );
  }

  scenery.register( 'LinearGradient', LinearGradient );

  inherit( Gradient, LinearGradient, {

    isLinearGradient: true,

    // seems we need the defs: http://stackoverflow.com/questions/7614209/linear-gradients-in-svg-without-defs
    // SVG: spreadMethod 'pad' 'reflect' 'repeat' - find Canvas usage
    getSVGDefinition: function() {
      /* Approximate example of what we are creating:
       <linearGradient id="grad2" x1="0" y1="0" x2="100" y2="0" gradientUnits="userSpaceOnUse">
       <stop offset="0" style="stop-color:rgb(255,255,0);stop-opacity:1" />
       <stop offset="0.5" style="stop-color:rgba(255,255,0,0);stop-opacity:0" />
       <stop offset="1" style="stop-color:rgb(255,0,0);stop-opacity:1" />
       </linearGradient>
       */
      var definition = document.createElementNS( scenery.svgns, 'linearGradient' );
      definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
      definition.setAttribute( 'x1', this.start.x );
      definition.setAttribute( 'y1', this.start.y );
      definition.setAttribute( 'x2', this.end.x );
      definition.setAttribute( 'y2', this.end.y );
      if ( this.transformMatrix ) {
        definition.setAttribute( 'gradientTransform', this.transformMatrix.getSVGTransform() );
      }

      _.each( this.stops, function( stop ) {
        var stopElement = document.createElementNS( scenery.svgns, 'stop' );
        stopElement.setAttribute( 'offset', stop.ratio );
        // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
        // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
        // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
        // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
        stopElement.setAttribute( 'style', 'stop-color: ' + stop.color.withAlpha( 1 ).toCSS() + '; stop-opacity: ' + stop.color.a.toFixed( 20 ) + ';' );
        definition.appendChild( stopElement );
      } );

      return definition;
    },

    toString: function() {
      var result = 'new scenery.LinearGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.end.x + ', ' + this.end.y + ' )';

      _.each( this.stops, function( stop ) {
        result += '.addColorStop( ' + stop.ratio + ', \'' + ( stop.color.toCSS ? stop.color.toCSS() : stop.color.toString() ) + '\' )';
      } );

      return result;
    }
  } );

  return LinearGradient;
} );

// Copyright 2013-2014, University of Colorado Boulder


/**
 * Live region is used with accessibility to read out changes in model state.
 * Should conform to the Axon property interface to make it easy to interchange.
 *
 * @author Sam Reid
 */

define( 'SCENERY/util/LiveRegion',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  function LiveRegion( instance, property, options ) {
    var liveRegion = this;
    this.property = property;
    options = options || {};

    //Defaulting to 0 would mean using the document order, which can easily be incorrect for a PhET simulation.
    //For any of the nodes to use a nonzero tabindex, they must all use a nonzero tabindex, see #40
    options.tabIndex = options.tabIndex || 1;

    // TODO: if element is a DOM element, verify that no other accessibility liveRegion is using it! (add a flag, and remove on disposal)
//    this.element = '<div role="region" id="bird-info" aria-live="polite">';
    this.element = document.createElement( 'div' );
    this.element.setAttribute( 'aria-live', 'polite' );
    this.element.setAttribute( 'role', 'region' );
    this.textNode = document.createTextNode( '' );
    this.element.appendChild( this.textNode );

    //Just setting the text causes NVDA to read deltas, you have to replace the node to have it read the text
    this.listener = function( newText ) {
      liveRegion.element.removeChild( liveRegion.textNode );
      liveRegion.textNode = document.createTextNode( newText );
      liveRegion.element.appendChild( liveRegion.textNode );
    };
    property.link( this.listener );
  }

  scenery.register( 'LiveRegion', LiveRegion );

  inherit( Object, LiveRegion, {
    dispose: function() { this.property.unlink( this.listener ); }
  } );

  return LiveRegion;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * A pattern that will deliver a fill or stroke that will repeat an image in both directions (x and y).
 *
 * TODO: future support for repeat-x, repeat-y or no-repeat (needs SVG support)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Pattern',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Paint'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Paint = require( 'SCENERY/util/Paint' );

  // TODO: support scene or other various content (SVG is flexible, can backport to canvas)
  // TODO: investigate options to support repeat-x, repeat-y or no-repeat in SVG (available repeat options from Canvas)
  function Pattern( image ) {
    Paint.call( this );

    this.image = image;

    // use the global scratch canvas instead of creating a new Canvas
    this.canvasPattern = scenery.scratchContext.createPattern( image, 'repeat' );
  }

  scenery.register( 'Pattern', Pattern );

  inherit( Paint, Pattern, {
    isPattern: true,

    getCanvasStyle: function() {
      return this.canvasPattern;
    },

    getSVGDefinition: function() {
      var definition = document.createElementNS( scenery.svgns, 'pattern' );
      definition.setAttribute( 'patternUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
      definition.setAttribute( 'patternContentUnits', 'userSpaceOnUse' ); // TODO: is this needed?
      definition.setAttribute( 'x', 0 );
      definition.setAttribute( 'y', 0 );
      definition.setAttribute( 'width', this.image.width );
      definition.setAttribute( 'height', this.image.height );
      if ( this.transformMatrix ) {
        definition.setAttribute( 'patternTransform', this.transformMatrix.getSVGTransform() );
      }

      definition.appendChild( scenery.Image.createSVGImage( this.image.src, this.image.width, this.image.height ) );

      return definition;
    },

    toString: function() {
      return 'new scenery.Pattern( $( \'<img src="' + this.image.src + '"/>\' )[0] )';
    }
  } );

  return Pattern;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * A radial gradient that can be passed into the 'fill' or 'stroke' parameters.
 *
 * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/RadialGradient',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/Vector2','SCENERY/util/Gradient'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Gradient = require( 'SCENERY/util/Gradient' );

  // TODO: support Vector2s for p0 and p1
  function RadialGradient( x0, y0, r0, x1, y1, r1 ) {
    this.start = new Vector2( x0, y0 );
    this.end = new Vector2( x1, y1 );
    this.startRadius = r0;
    this.endRadius = r1;

    // linear function from radius to point on the line from start to end
    this.focalPoint = this.start.plus( this.end.minus( this.start ).times( this.startRadius / ( this.startRadius - this.endRadius ) ) );

    // make sure that the focal point is in both circles. SVG doesn't support rendering outside of them
    if ( this.startRadius >= this.endRadius ) {
      assert && assert( this.focalPoint.minus( this.start ).magnitude() <= this.startRadius );
    }
    else {
      assert && assert( this.focalPoint.minus( this.end ).magnitude() <= this.endRadius );
    }

    // use the global scratch canvas instead of creating a new Canvas
    Gradient.call( this, scenery.scratchContext.createRadialGradient( x0, y0, r0, x1, y1, r1 ) );
  }

  scenery.register( 'RadialGradient', RadialGradient );

  inherit( Gradient, RadialGradient, {

    isRadialGradient: true,

    getSVGDefinition: function() {
      var startIsLarger = this.startRadius > this.endRadius;
      var largePoint = startIsLarger ? this.start : this.end;
      // var smallPoint = startIsLarger ? this.end : this.start;
      var maxRadius = Math.max( this.startRadius, this.endRadius );
      var minRadius = Math.min( this.startRadius, this.endRadius );

      var definition = document.createElementNS( scenery.svgns, 'radialGradient' );

      definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
      definition.setAttribute( 'cx', largePoint.x );
      definition.setAttribute( 'cy', largePoint.y );
      definition.setAttribute( 'r', maxRadius );
      definition.setAttribute( 'fx', this.focalPoint.x );
      definition.setAttribute( 'fy', this.focalPoint.y );
      if ( this.transformMatrix ) {
        definition.setAttribute( 'gradientTransform', this.transformMatrix.getSVGTransform() );
      }

      //TODO: replace with dot.Util.linear
      // maps x linearly from [a0,b0] => [a1,b1]
      function linearMap( a0, b0, a1, b1, x ) {
        return a1 + ( x - a0 ) * ( b1 - a1 ) / ( b0 - a0 );
      }

      function applyStop( stop ) {
        // flip the stops if the start has a larger radius
        var ratio = startIsLarger ? 1 - stop.ratio : stop.ratio;

        // scale the stops properly if the smaller radius isn't 0
        if ( minRadius > 0 ) {
          // scales our ratio from [0,1] => [minRadius/maxRadius,0]
          ratio = linearMap( 0, 1, minRadius / maxRadius, 1, ratio );
        }

        // TODO: store color in our stops array, so we don't have to create additional objects every time?
        var stopElement = document.createElementNS( scenery.svgns, 'stop' );
        stopElement.setAttribute( 'offset', ratio );
        // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
        // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
        // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
        // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
        stopElement.setAttribute( 'style', 'stop-color: ' + stop.color.withAlpha( 1 ).toCSS() + '; stop-opacity: ' + stop.color.a.toFixed( 20 ) + ';' );
        definition.appendChild( stopElement );
      }

      var i;
      // switch the direction we apply stops in, so that the ratios always are increasing.
      if ( startIsLarger ) {
        for ( i = this.stops.length - 1; i >= 0; i-- ) {
          applyStop( this.stops[ i ] );
        }
      }
      else {
        for ( i = 0; i < this.stops.length; i++ ) {
          applyStop( this.stops[ i ] );
        }
      }

      return definition;
    },

    toString: function() {
      var result = 'new scenery.RadialGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.startRadius + ', ' + this.end.x + ', ' + this.end.y + ', ' + this.endRadius + ' )';

      _.each( this.stops, function( stop ) {
        result += '.addColorStop( ' + stop.ratio + ', \'' + stop.color.toString() + '\' )';
      } );

      return result;
    }
  } );

  return RadialGradient;
} );

// Copyright 2013-2014, University of Colorado Boulder


/*
 * An HTMLImageElement that is backed by a scene. Call update() on this SceneImage to update the image from the scene.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/SceneImage',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  // NOTE: ideally the scene shouldn't use SVG, since rendering that to a canvas takes a callback (and usually requires canvg)
  function SceneImage( scene ) {
    this.scene = scene;

    // we write the scene to a canvas, get its data URL, and pass that to the image.
    this.canvas = document.createElement( 'canvas' );
    this.context = this.canvas.getContext( '2d' );

    this.img = document.createElement( 'img' );
    this.update();
  }

  scenery.register( 'SceneImage', SceneImage );

  inherit( Object, SceneImage, {
    // NOTE: calling this before the previous update() completes may cause the previous onComplete to not be executed
    update: function( onComplete ) {
      var self = this;

      this.scene.updateScene();

      this.canvas.width = this.scene.getSceneWidth();
      this.canvas.height = this.scene.getSceneHeight();

      this.scene.renderToCanvas( this.canvas, this.context, function() {
        var url = self.toDataURL();

        self.img.onload = function() {
          onComplete();
          delete self.img.onload;
        };
        self.img.src = url;
      } );
    }
  } );

  return SceneImage;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Module that includes all Scenery dependencies, so that requiring this module will return an object
 * that consists of the entire exported 'scenery' namespace API.
 *
 * The API is actually generated by the 'scenery' module, so if this module (or all other modules) are
 * not included, the 'scenery' namespace may not be complete.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'main',[
  'SCENERY/scenery',

  'SCENERY/accessibility/AccessibleInstance',
  'SCENERY/accessibility/AccessiblePeer',

  'SCENERY/debug/DebugContext',

  'SCENERY/display/BackboneDrawable',
  'SCENERY/display/Block',
  'SCENERY/display/CanvasBlock',
  'SCENERY/display/CanvasSelfDrawable',
  'SCENERY/display/ChangeInterval',
  'SCENERY/display/Display',
  'SCENERY/display/DOMBlock',
  'SCENERY/display/DOMSelfDrawable',
  'SCENERY/display/Drawable',
  'SCENERY/display/Fittability',
  'SCENERY/display/FittedBlock',
  'SCENERY/display/GreedyStitcher',
  'SCENERY/display/InlineCanvasCacheDrawable',
  'SCENERY/display/Instance',
  'SCENERY/display/RebuildStitcher',
  'SCENERY/display/RelativeTransform',
  'SCENERY/display/Renderer',
  'SCENERY/display/SelfDrawable',
  'SCENERY/display/SharedCanvasCacheDrawable',
  'SCENERY/display/Stitcher',
  'SCENERY/display/SVGBlock',
  'SCENERY/display/SVGGroup',
  'SCENERY/display/SVGSelfDrawable',
  'SCENERY/display/WebGLBlock',
  'SCENERY/display/WebGLSelfDrawable',

  'SCENERY/input/BatchedDOMEvent',
  'SCENERY/input/ButtonListener',
  'SCENERY/input/DownUpListener',
  'SCENERY/input/Event',
  'SCENERY/input/Input',
  'SCENERY/input/Key',
  'SCENERY/input/Mouse',
  'SCENERY/input/Pen',
  'SCENERY/input/Pointer',
  'SCENERY/input/SimpleDragHandler',
  'SCENERY/input/Touch',

  'SCENERY/nodes/CanvasNode',
  'SCENERY/nodes/Circle',
  'SCENERY/nodes/DOM',
  'SCENERY/nodes/HBox',
  'SCENERY/nodes/HTMLText',
  'SCENERY/nodes/HStrut',
  'SCENERY/nodes/Image',
  'SCENERY/nodes/LayoutNode',
  'SCENERY/nodes/Leaf',
  'SCENERY/nodes/Line',
  'SCENERY/nodes/Node',
  'SCENERY/nodes/Paintable',
  'SCENERY/nodes/Path',
  'SCENERY/nodes/Plane',
  'SCENERY/nodes/Rectangle',
  'SCENERY/nodes/Spacer',
  'SCENERY/nodes/Text',
  'SCENERY/nodes/VBox',
  'SCENERY/nodes/VStrut',
  'SCENERY/nodes/WebGLNode',

  'SCENERY/overlays/CanvasNodeBoundsOverlay',
  'SCENERY/overlays/FittedBlockBoundsOverlay',
  'SCENERY/overlays/FocusOverlay',
  'SCENERY/overlays/PointerAreaOverlay',
  'SCENERY/overlays/PointerOverlay',

  'SCENERY/util/CanvasContextWrapper',
  'SCENERY/util/Color',
  'SCENERY/util/Features',
  'SCENERY/util/Font',
  'SCENERY/util/Gradient',
  'SCENERY/util/LinearGradient',
  'SCENERY/util/LiveRegion',
  'SCENERY/util/Pattern',
  'SCENERY/util/RadialGradient',
  'SCENERY/util/RendererSummary',
  'SCENERY/util/SceneImage',
  'SCENERY/util/SceneryStyle',
  'SCENERY/util/ShaderProgram',
  'SCENERY/util/SpriteSheet',
  'SCENERY/util/Trail',
  'SCENERY/util/TrailPointer',
  'SCENERY/util/TransformTracker',
  'SCENERY/util/Util'
], function( scenery ) {
  'use strict';

  // note: we don't need any of the other parts, we just need to specify them as dependencies so they fill in the scenery namespace
  return scenery;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Module that includes all Kite dependencies, so that requiring this module will return an object
 * that consists of the entire exported 'kite' namespace API.
 *
 * The API is actually generated by the 'kite' module, so if this module (or all other modules) are
 * not included, the 'kite' namespace may not be complete.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/main',[
  'KITE/kite',

  'KITE/Shape',
  'KITE/segments/Arc',
  'KITE/segments/Cubic',
  'KITE/segments/EllipticalArc',
  'KITE/segments/Line',
  'KITE/segments/Quadratic',
  'KITE/segments/Segment',
  'KITE/util/LineStyles',
  'KITE/util/Subpath',

  'KITE/parser/svgPath'
], function( kite // note: we don't need any of the other parts, we just need to specify them as dependencies so they fill in the kite namespace
) {
  'use strict';

  return kite;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A 3D cuboid-shaped bounded area (bounding box).
 *
 * There are a number of convenience functions to get locations and points on the Bounds. Currently we do not
 * store these with the Bounds3 instance, since we want to lower the memory footprint.
 *
 * minX, minY, minZ, maxX, maxY, and maxZ are actually stored. We don't do x,y,z,width,height,depth because this can't properly express
 * semi-infinite bounds (like a half-plane), or easily handle what Bounds3.NOTHING and Bounds3.EVERYTHING do with
 * the constructive solid areas.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Bounds3',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Vector3'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  require( 'DOT/Vector3' );

  /**
   * Creates a 3-dimensional bounds (bounding box).
   * @constructor
   * @public
   *
   * @param {number} minX - The intial minimum X coordinate of the bounds.
   * @param {number} minY - The intial minimum Y coordinate of the bounds.
   * @param {number} minZ - The intial minimum Z coordinate of the bounds.
   * @param {number} maxX - The intial maximum X coordinate of the bounds.
   * @param {number} maxY - The intial maximum Y coordinate of the bounds.
   * @param {number} maxZ - The intial maximum Z coordinate of the bounds.
   */
  function Bounds3( minX, minY, minZ, maxX, maxY, maxZ ) {
    assert && assert( maxY !== undefined, 'Bounds3 requires 4 parameters' );

    // @public {number} - The minimum X coordinate of the bounds.
    this.minX = minX;

    // @public {number} - The minimum Y coordinate of the bounds.
    this.minY = minY;

    // @public {number} - The minimum Z coordinate of the bounds.
    this.minZ = minZ;

    // @public {number} - The maximum X coordinate of the bounds.
    this.maxX = maxX;

    // @public {number} - The maximum Y coordinate of the bounds.
    this.maxY = maxY;

    // @public {number} - The maximum Z coordinate of the bounds.
    this.maxZ = maxZ;

    phetAllocation && phetAllocation( 'Bounds3' );
  }

  dot.register( 'Bounds3', Bounds3 );

  inherit( Object, Bounds3, {
    // @public (read-only) - Helps to identify the dimension of the bounds
    isBounds: true,
    dimension: 3,

    /*---------------------------------------------------------------------------*
     * Properties
     *---------------------------------------------------------------------------*/

    /**
     * The width of the bounds, defined as maxX - minX.
     * @public
     *
     * @returns {number}
     */
    getWidth: function() { return this.maxX - this.minX; },
    get width() { return this.getWidth(); },

    /**
     * The height of the bounds, defined as maxY - minY.
     * @public
     *
     * @returns {number}
     */
    getHeight: function() { return this.maxY - this.minY; },
    get height() { return this.getHeight(); },

    /**
     * The depth of the bounds, defined as maxZ - minZ.
     * @public
     *
     * @returns {number}
     */
    getDepth: function() { return this.maxZ - this.minZ; },
    get depth() { return this.getDepth(); },

    /*
     * Convenience locations
     * upper is in terms of the visual layout in Scenery and other programs, so the minY is the "upper", and minY is the "lower"
     *
     *             minX (x)     centerX        maxX
     *          ---------------------------------------
     * minY (y) | upperLeft   upperCenter   upperRight
     * centerY  | centerLeft    center      centerRight
     * maxY     | lowerLeft   lowerCenter   lowerRight
     */

    /**
     * Alias for minX, when thinking of the bounds as an (x,y,z,width,height,depth) cuboid.
     * @public
     *
     * @returns {number}
     */
    getX: function() { return this.minX; },
    get x() { return this.getX(); },

    /**
     * Alias for minY, when thinking of the bounds as an (x,y,z,width,height,depth) cuboid.
     * @public
     *
     * @returns {number}
     */
    getY: function() { return this.minY; },
    get y() { return this.getY(); },

    /**
     * Alias for minZ, when thinking of the bounds as an (x,y,z,width,height,depth) cuboid.
     * @public
     *
     * @returns {number}
     */
    getZ: function() { return this.minZ; },
    get z() { return this.getZ(); },

    /**
     * Alias for minX, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMinX: function() { return this.minX; },

    /**
     * Alias for minY, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMinY: function() { return this.minY; },

    /**
     * Alias for minZ, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMinZ: function() { return this.minZ; },

    /**
     * Alias for maxX, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMaxX: function() { return this.maxX; },

    /**
     * Alias for maxY, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMaxY: function() { return this.maxY; },

    /**
     * Alias for maxZ, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMaxZ: function() { return this.maxZ; },

    /**
     * Alias for minX, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getLeft: function() { return this.minX; },
    get left() { return this.minX; },

    /**
     * Alias for minY, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getTop: function() { return this.minY; },
    get top() { return this.minY; },

    /**
     * Alias for minZ, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getBack: function() { return this.minZ; },
    get back() { return this.minZ; },

    /**
     * Alias for maxX, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getRight: function() { return this.maxX; },
    get right() { return this.maxX; },

    /**
     * Alias for maxY, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getBottom: function() { return this.maxY; },
    get bottom() { return this.maxY; },

    /**
     * Alias for maxZ, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getFront: function() { return this.maxZ; },
    get front() { return this.maxZ; },

    /**
     * The horizontal (X-coordinate) center of the bounds, averaging the minX and maxX.
     * @public
     *
     * @returns {number}
     */
    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },
    get centerX() { return this.getCenterX(); },

    /**
     * The vertical (Y-coordinate) center of the bounds, averaging the minY and maxY.
     * @public
     *
     * @returns {number}
     */
    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },
    get centerY() { return this.getCenterY(); },

    /**
     * The depthwise (Z-coordinate) center of the bounds, averaging the minZ and maxZ.
     * @public
     *
     * @returns {number}
     */
    getCenterZ: function() { return ( this.maxZ + this.minZ ) / 2; },
    get centerZ() { return this.getCenterZ(); },

    /**
     * The point (centerX, centerY, centerZ), in the center of the bounds.
     * @public
     *
     * @returns {Vector3}
     */
    getCenter: function() { return new dot.Vector3( this.getCenterX(), this.getCenterY(), this.getCenterZ() ); },
    get center() { return this.getCenter(); },

    /**
     * Whether we have negative width, height or depth. Bounds3.NOTHING is a prime example of an empty Bounds3.
     * Bounds with width = height = depth = 0 are considered not empty, since they include the single (0,0,0) point.
     * @public
     *
     * @returns {boolean}
     */
    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0 || this.getDepth() < 0; },

    /**
     * Whether our minimums and maximums are all finite numbers. This will exclude Bounds3.NOTHING and Bounds3.EVERYTHING.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.minZ ) && isFinite( this.maxX ) && isFinite( this.maxY ) && isFinite( this.maxZ );
    },

    /**
     * Whether this bounds has a non-zero area (non-zero positive width, height and depth).
     * @public
     *
     * @returns {boolean}
     */
    hasNonzeroArea: function() {
      return this.getWidth() > 0 && this.getHeight() > 0 && this.getDepth() > 0;
    },

    /**
     * Whether this bounds has a finite and non-negative width, height and depth.
     * @public
     *
     * @returns {boolean}
     */
    isValid: function() {
      return !this.isEmpty() && this.isFinite();
    },

    /**
     * Whether the coordinates are contained inside the bounding box, or are on the boundary.
     * @public
     *
     * @param {number} x - X coordinate of the point to check
     * @param {number} y - Y coordinate of the point to check
     * @param {number} z - Z coordinate of the point to check
     * @returns {boolean}
     */
    containsCoordinates: function( x, y, z ) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY && this.minZ <= z && z <= this.maxZ;
    },

    /**
     * Whether the point is contained inside the bounding box, or is on the boundary.
     * @public
     *
     * @param {Vector3} point
     * @returns {boolean}
     */
    containsPoint: function( point ) {
      return this.containsCoordinates( point.x, point.y, point.z );
    },

    /**
     * Whether this bounding box completely contains the bounding box passed as a parameter. The boundary of a box is
     * considered to be "contained".
     * @public
     *
     * @param {Bounds3} bounds
     * @returns {boolean}
     */
    containsBounds: function( bounds ) {
      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY && this.minZ <= bounds.minZ && this.maxZ >= bounds.maxZ;
    },

    /**
     * Whether this and another bounding box have any points of intersection (including touching boundaries).
     * @public
     *
     * @param {Bounds3} bounds
     * @returns {boolean}
     */
    intersectsBounds: function( bounds ) {
      // TODO: more efficient way of doing this?
      return !this.intersection( bounds ).isEmpty();
    },

    /**
     * Debugging string for the bounds.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + '),z:(' + this.minZ + ',' + this.maxZ + ')]';
    },

    /**
     * Exact equality comparison between this bounds and another bounds.
     * @public
     *
     * @param {Bounds3} other
     * @returns {boolean} - Whether the two bounds are equal
     */
    equals: function( other ) {
      return this.minX === other.minX && this.minY === other.minY && this.minZ === other.minZ && this.maxX === other.maxX && this.maxY === other.maxY && this.maxZ === other.maxZ;
    },

    /**
     * Approximate equality comparison between this bounds and another bounds.
     * @public
     *
     * @param {Bounds3} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two bounds has no min/max with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      epsilon = epsilon !== undefined ? epsilon : 0;
      var thisFinite = this.isFinite();
      var otherFinite = other.isFinite();
      if ( thisFinite && otherFinite ) {
        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity
        return Math.abs( this.minX - other.minX ) < epsilon &&
               Math.abs( this.minY - other.minY ) < epsilon &&
               Math.abs( this.minZ - other.minZ ) < epsilon &&
               Math.abs( this.maxX - other.maxX ) < epsilon &&
               Math.abs( this.maxY - other.maxY ) < epsilon &&
               Math.abs( this.maxZ - other.maxZ ) < epsilon;
      }
      else if ( thisFinite !== otherFinite ) {
        return false; // one is finite, the other is not. definitely not equal
      }
      else if ( this === other ) {
        return true; // exact same instance, must be equal
      }
      else {
        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both
        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&
               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&
               ( isFinite( this.minZ + other.minZ ) ? ( Math.abs( this.minZ - other.minZ ) < epsilon ) : ( this.minZ === other.minZ ) ) &&
               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&
               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) ) &&
               ( isFinite( this.maxZ + other.maxZ ) ? ( Math.abs( this.maxZ - other.maxZ ) < epsilon ) : ( this.maxZ === other.maxZ ) );
      }
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this bounds, or if a bounds is passed in, set that bounds's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a bounds is provided. This will return a new bounds, and
     * will not modify this bounds.
     *
     * @param {Bounds3} [bounds] - If not provided, creates a new Bounds3 with filled in values. Otherwise, fills in the
     *                             values of the provided bounds so that it equals this bounds.
     * @returns {Bounds3}
     */
    copy: function( bounds ) {
      if ( bounds ) {
        return bounds.set( this );
      }
      else {
        return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ );
      }
    },

    /**
     * The smallest bounds that contains both this bounds and the input bounds, returned as a copy.
     * @public
     *
     * This is the immutable form of the function includeBounds(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Bounds3} bounds
     * @returns {Bounds3}
     */
    union: function( bounds ) {
      return new Bounds3(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.min( this.minZ, bounds.minZ ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY ),
        Math.max( this.maxZ, bounds.maxZ )
      );
    },

    /**
     * The smallest bounds that is contained by both this bounds and the input bounds, returned as a copy.
     * @public
     *
     * This is the immutable form of the function constrainBounds(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Bounds3} bounds
     * @returns {Bounds3}
     */
    intersection: function( bounds ) {
      return new Bounds3(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.max( this.minZ, bounds.minZ ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY ),
        Math.min( this.maxZ, bounds.maxZ )
      );
    },
    // TODO: difference should be well-defined, but more logic is needed to compute

    /**
     * The smallest bounds that contains this bounds and the point (x,y,z), returned as a copy.
     * @public
     *
     * This is the immutable form of the function addCoordinates(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Bounds3}
     */
    withCoordinates: function( x, y, z ) {
      return new Bounds3(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.min( this.minZ, z ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y ),
        Math.max( this.maxZ, z )
      );
    },

    /**
     * The smallest bounds that contains this bounds and the input point, returned as a copy.
     * @public
     *
     * This is the immutable form of the function addPoint(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Vector3} point
     * @returns {Bounds3}
     */
    withPoint: function( point ) {
      return this.withCoordinates( point.x, point.y, point.z );
    },

    /**
     * A copy of this bounds, with minX replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMinX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} minX
     * @returns {Bounds3}
     */
    withMinX: function( minX ) {
      return new Bounds3( minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ );
    },

    /**
     * A copy of this bounds, with minY replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMinY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} minY
     * @returns {Bounds3}
     */
    withMinY: function( minY ) {
      return new Bounds3( this.minX, minY, this.minZ, this.maxX, this.maxY, this.maxZ );
    },

    /**
     * A copy of this bounds, with minZ replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMinZ(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} minZ
     * @returns {Bounds3}
     */
    withMinZ: function( minZ ) {
      return new Bounds3( this.minX, this.minY, minZ, this.maxX, this.maxY, this.maxZ );
    },

    /**
     * A copy of this bounds, with maxX replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMaxX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} maxX
     * @returns {Bounds3}
     */
    withMaxX: function( maxX ) {
      return new Bounds3( this.minX, this.minY, this.minZ, maxX, this.maxY, this.maxZ );
    },

    /**
     * A copy of this bounds, with maxY replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMaxY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} maxY
     * @returns {Bounds3}
     */
    withMaxY: function( maxY ) {
      return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, maxY, this.maxZ );
    },

    /**
     * A copy of this bounds, with maxZ replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMaxZ(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} maxZ
     * @returns {Bounds3}
     */
    withMaxZ: function( maxZ ) {
      return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, this.maxY, maxZ );
    },

    /**
     * A copy of this bounds, with the minimum values rounded down to the nearest integer, and the maximum values
     * rounded up to the nearest integer. This causes the bounds to expand as necessary so that its boundaries
     * are integer-aligned.
     * @public
     *
     * This is the immutable form of the function roundOut(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @returns {Bounds3}
     */
    roundedOut: function() {
      return new Bounds3(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.floor( this.minZ ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY ),
        Math.ceil( this.maxZ )
      );
    },

    /**
     * A copy of this bounds, with the minimum values rounded up to the nearest integer, and the maximum values
     * rounded down to the nearest integer. This causes the bounds to contract as necessary so that its boundaries
     * are integer-aligned.
     * @public
     *
     * This is the immutable form of the function roundIn(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @returns {Bounds3}
     */
    roundedIn: function() {
      return new Bounds3(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.ceil( this.minZ ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY ),
        Math.floor( this.maxZ )
      );
    },

    /**
     * A bounding box (still axis-aligned) that contains the transformed shape of this bounds, applying the matrix as
     * an affine transformation.
     * @pubic
     *
     * NOTE: bounds.transformed( matrix ).transformed( inverse ) may be larger than the original box, if it includes
     * a rotation that isn't a multiple of $\pi/2$. This is because the returned bounds may expand in area to cover
     * ALL of the corners of the transformed bounding box.
     *
     * This is the immutable form of the function transform(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Matrix4} matrix
     * @returns {Bounds3}
     */
    transformed: function( matrix ) {
      return this.copy().transform( matrix );
    },

    /**
     * A bounding box that is expanded on all sides by the specified amount.)
     * @public
     *
     * This is the immutable form of the function dilate(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} d
     * @returns {Bounds3}
     */
    dilated: function( d ) {
      return new Bounds3( this.minX - d, this.minY - d, this.minZ - d, this.maxX + d, this.maxY + d, this.maxZ + d );
    },

    /**
     * A bounding box that is expanded horizontally (on the left and right) by the specified amount.
     * @public
     *
     * This is the immutable form of the function dilateX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds3}
     */
    dilatedX: function( x ) {
      return new Bounds3( this.minX - x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );
    },

    /**
     * A bounding box that is expanded vertically (on the top and bottom) by the specified amount.
     * @public
     *
     * This is the immutable form of the function dilateY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds3}
     */
    dilatedY: function( y ) {
      return new Bounds3( this.minX, this.minY - y, this.minZ, this.maxX, this.maxY + y, this.maxZ );
    },

    /**
     * A bounding box that is expanded depth-wise (on the front and back) by the specified amount.
     * @public
     *
     * This is the immutable form of the function dilateZ(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} z
     * @returns {Bounds3}
     */
    dilatedZ: function( z ) {
      return new Bounds3( this.minX, this.minY, this.minZ - z, this.maxX, this.maxY, this.maxZ + z );
    },

    /**
     * A bounding box that is expanded on all sides, with different amounts of expansion along each axis.
     * Will be identical to the bounds returned by calling bounds.dilatedX( x ).dilatedY( y ).dilatedZ( z ).
     * @public
     *
     * This is the immutable form of the function dilateXYZ(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x - Amount to dilate horizontally (for each side)
     * @param {number} y - Amount to dilate vertically (for each side)
     * @param {number} z - Amount to dilate depth-wise (for each side)
     * @returns {Bounds3}
     */
    dilatedXYZ: function( x, y, z ) {
      return new Bounds3( this.minX - x, this.minY - y, this.minZ - z, this.maxX + x, this.maxY + y, this.maxZ + z );
    },

    /**
     * A bounding box that is contracted on all sides by the specified amount.
     * @public
     *
     * This is the immutable form of the function erode(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} amount
     * @returns {Bounds3}
     */
    eroded: function( d ) { return this.dilated( -d ); },

    /**
     * A bounding box that is contracted horizontally (on the left and right) by the specified amount.
     * @public
     *
     * This is the immutable form of the function erodeX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds3}
     */
    erodedX: function( x ) { return this.dilatedX( -x ); },

    /**
     * A bounding box that is contracted vertically (on the top and bottom) by the specified amount.
     * @public
     *
     * This is the immutable form of the function erodeY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds3}
     */
    erodedY: function( y ) { return this.dilatedY( -y ); },

    /**
     * A bounding box that is contracted depth-wise (on the front and back) by the specified amount.
     * @public
     *
     * This is the immutable form of the function erodeZ(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} z
     * @returns {Bounds3}
     */
    erodedZ: function( z ) { return this.dilatedZ( -z ); },

    /**
     * A bounding box that is contracted on all sides, with different amounts of contraction along each axis.
     * @public
     *
     * This is the immutable form of the function erodeXYZ(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x - Amount to erode horizontally (for each side)
     * @param {number} y - Amount to erode vertically (for each side)
     * @param {number} z - Amount to erode depth-wise (for each side)
     * @returns {Bounds3}
     */
    erodedXYZ: function( x, y, z ) { return this.dilatedXYZ( -x, -y, -z ); },

    /**
     * Our bounds, translated horizontally by x, returned as a copy.
     * @public
     *
     * This is the immutable form of the function shiftX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds3}
     */
    shiftedX: function( x ) {
      return new Bounds3( this.minX + x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );
    },

    /**
     * Our bounds, translated vertically by y, returned as a copy.
     * @public
     *
     * This is the immutable form of the function shiftY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds3}
     */
    shiftedY: function( y ) {
      return new Bounds3( this.minX, this.minY + y, this.minZ, this.maxX, this.maxY + y, this.maxZ );
    },

    /**
     * Our bounds, translated depth-wise by z, returned as a copy.
     * @public
     *
     * This is the immutable form of the function shiftZ(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} z
     * @returns {Bounds3}
     */
    shiftedZ: function( z ) {
      return new Bounds3( this.minX, this.minY, this.minZ + z, this.maxX, this.maxY, this.maxZ + z );
    },

    /**
     * Our bounds, translated by (x,y,z), returned as a copy.
     * @public
     *
     * This is the immutable form of the function shift(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Bounds3}
     */
    shifted: function( x, y, z ) {
      return new Bounds3( this.minX + x, this.minY + y, this.minZ + z, this.maxX + x, this.maxY + y, this.maxZ + z );
    },

    /*---------------------------------------------------------------------------*
     * Mutable operations
     *
     * All mutable operations should call one of the following:
     *   setMinMax, setMinX, setMinY, setMinZ, setMaxX, setMaxY, setMaxZ
     *---------------------------------------------------------------------------*/

    /**
     * Sets each value for this bounds, and returns itself.
     * @public
     *
     * @param {number} minX
     * @param {number} minY
     * @param {number} minZ
     * @param {number} maxX
     * @param {number} maxY
     * @param {number} maxZ
     * @returns {Bounds3}
     */
    setMinMax: function( minX, minY, minZ, maxX, maxY, maxZ ) {
      this.minX = minX;
      this.minY = minY;
      this.minZ = minZ;
      this.maxX = maxX;
      this.maxY = maxY;
      this.maxZ = maxZ;
      return this;
    },

    /**
     * Sets the value of minX.
     * @public
     *
     * This is the mutable form of the function withMinX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} minX
     * @returns {Bounds3}
     */
    setMinX: function( minX ) {
      this.minX = minX;
      return this;
    },

    /**
     * Sets the value of minY.
     * @public
     *
     * This is the mutable form of the function withMinY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} minY
     * @returns {Bounds3}
     */
    setMinY: function( minY ) {
      this.minY = minY;
      return this;
    },

    /**
     * Sets the value of minZ.
     * @public
     *
     * This is the mutable form of the function withMinZ(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} minZ
     * @returns {Bounds3}
     */
    setMinZ: function( minZ ) {
      this.minZ = minZ;
      return this;
    },

    /**
     * Sets the value of maxX.
     * @public
     *
     * This is the mutable form of the function withMaxX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} maxX
     * @returns {Bounds3}
     */
    setMaxX: function( maxX ) {
      this.maxX = maxX;
      return this;
    },

    /**
     * Sets the value of maxY.
     * @public
     *
     * This is the mutable form of the function withMaxY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} maxY
     * @returns {Bounds3}
     */
    setMaxY: function( maxY ) {
      this.maxY = maxY;
      return this;
    },

    /**
     * Sets the value of maxZ.
     * @public
     *
     * This is the mutable form of the function withMaxZ(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} maxZ
     * @returns {Bounds3}
     */
    setMaxZ: function( maxZ ) {
      this.maxZ = maxZ;
      return this;
    },

    /**
     * Sets the values of this bounds to be equal to the input bounds.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds3} bounds
     * @returns {Bounds3}
     */
    set: function( bounds ) {
      return this.setMinMax( bounds.minX, bounds.minY, bounds.minZ, bounds.maxX, bounds.maxY, bounds.maxZ );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input bounds.
     * @public
     *
     * This is the mutable form of the function union(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds3} bounds
     * @returns {Bounds3}
     */
    includeBounds: function( bounds ) {
      return this.setMinMax(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.min( this.minZ, bounds.minZ ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY ),
        Math.max( this.maxZ, bounds.maxZ )
      );
    },

    /**
     * Modifies this bounds so that it is the largest bounds contained both in its original bounds and in the input bounds.
     * @public
     *
     * This is the mutable form of the function intersection(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds3} bounds
     * @returns {Bounds3}
     */
    constrainBounds: function( bounds ) {
      return this.setMinMax(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.max( this.minZ, bounds.minZ ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY ),
        Math.min( this.maxZ, bounds.maxZ )
      );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input point (x,y,z).
     * @public
     *
     * This is the mutable form of the function withCoordinates(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Bounds3}
     */
    addCoordinates: function( x, y, z ) {
      return this.setMinMax(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.min( this.minZ, z ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y ),
        Math.max( this.maxZ, z )
      );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input point.
     * @public
     *
     * This is the mutable form of the function withPoint(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Vector3} point
     * @returns {Bounds3}
     */
    addPoint: function( point ) {
      return this.addCoordinates( point.x, point.y, point.z );
    },

    /**
     * Modifies this bounds so that its boundaries are integer-aligned, rounding the minimum boundaries down and the
     * maximum boundaries up (expanding as necessary).
     * @public
     *
     * This is the mutable form of the function roundedOut(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @returns {Bounds3}
     */
    roundOut: function() {
      return this.setMinMax(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.floor( this.minZ ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY ),
        Math.ceil( this.maxZ )
      );
    },

    /**
     * Modifies this bounds so that its boundaries are integer-aligned, rounding the minimum boundaries up and the
     * maximum boundaries down (contracting as necessary).
     * @public
     *
     * This is the mutable form of the function roundedIn(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @returns {Bounds3}
     */
    roundIn: function() {
      return this.setMinMax(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.ceil( this.minZ ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY ),
        Math.floor( this.maxZ )
      );
    },

    /**
     * Modifies this bounds so that it would fully contain a transformed version if its previous value, applying the
     * matrix as an affine transformation.
     * @pubic
     *
     * NOTE: bounds.transform( matrix ).transform( inverse ) may be larger than the original box, if it includes
     * a rotation that isn't a multiple of $\pi/2$. This is because the bounds may expand in area to cover
     * ALL of the corners of the transformed bounding box.
     *
     * This is the mutable form of the function transformed(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Matrix4} matrix
     * @returns {Bounds3}
     */
    transform: function( matrix ) {
      // do nothing
      if ( this.isEmpty() ) {
        return this;
      }

      // optimization to bail for identity matrices
      if ( matrix.isIdentity() ) {
        return this;
      }

      var minX = Number.POSITIVE_INFINITY;
      var minY = Number.POSITIVE_INFINITY;
      var minZ = Number.POSITIVE_INFINITY;
      var maxX = Number.NEGATIVE_INFINITY;
      var maxY = Number.NEGATIVE_INFINITY;
      var maxZ = Number.NEGATIVE_INFINITY;

      // using mutable vector so we don't create excessive instances of Vector2 during this
      // make sure all 4 corners are inside this transformed bounding box
      var vector = new dot.Vector3();

      function withIt( vector ) {
        minX = Math.min( minX, vector.x );
        minY = Math.min( minY, vector.y );
        minZ = Math.min( minZ, vector.z );
        maxX = Math.max( maxX, vector.x );
        maxY = Math.max( maxY, vector.y );
        maxZ = Math.max( maxZ, vector.z );
      }

      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.minY, this.minZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.maxY, this.minZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.minY, this.minZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.maxY, this.minZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.minY, this.maxZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.maxY, this.maxZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.minY, this.maxZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.maxY, this.maxZ ) ) );
      return this.setMinMax( minX, minY, minZ, maxX, maxY, maxZ );
    },

    /**
     * Expands this bounds on all sides by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilated(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} d
     * @returns {Bounds3}
     */
    dilate: function( d ) {
      return this.setMinMax( this.minX - d, this.minY - d, this.minZ - d, this.maxX + d, this.maxY + d, this.maxZ + d );
    },

    /**
     * Expands this bounds horizontally (left and right) by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilatedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds3}
     */
    dilateX: function( x ) {
      return this.setMinMax( this.minX - x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );
    },

    /**
     * Expands this bounds vertically (top and bottom) by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilatedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds3}
     */
    dilateY: function( y ) {
      return this.setMinMax( this.minX, this.minY - y, this.minZ, this.maxX, this.maxY + y, this.maxZ );
    },

    /**
     * Expands this bounds depth-wise (front and back) by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilatedZ(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} z
     * @returns {Bounds3}
     */
    dilateZ: function( z ) {
      return this.setMinMax( this.minX, this.minY, this.minZ - z, this.maxX, this.maxY, this.maxZ + z );
    },

    /**
     * Expands this bounds independently along each axis. Will be equal to calling
     * bounds.dilateX( x ).dilateY( y ).dilateZ( z ).
     * @public
     *
     * This is the mutable form of the function dilatedXYZ(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Bounds3}
     */
    dilateXYZ: function( x, y, z ) {
      return this.setMinMax( this.minX - x, this.minY - y, this.minZ - z, this.maxX + x, this.maxY + y, this.maxZ + z );
    },

    /**
     * Contracts this bounds on all sides by the specified amount.
     * @public
     *
     * This is the mutable form of the function eroded(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} d
     * @returns {Bounds3}
     */
    erode: function( d ) { return this.dilate( -d ); },

    /**
     * Contracts this bounds horizontally (left and right) by the specified amount.
     * @public
     *
     * This is the mutable form of the function erodedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds3}
     */
    erodeX: function( x ) { return this.dilateX( -x ); },

    /**
     * Contracts this bounds vertically (top and bottom) by the specified amount.
     * @public
     *
     * This is the mutable form of the function erodedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds3}
     */
    erodeY: function( y ) { return this.dilateY( -y ); },

    /**
     * Contracts this bounds depth-wise (front and back) by the specified amount.
     * @public
     *
     * This is the mutable form of the function erodedZ(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} z
     * @returns {Bounds3}
     */
    erodeZ: function( z ) { return this.dilateZ( -z ); },

    /**
     * Contracts this bounds independently along each axis. Will be equal to calling
     * bounds.erodeX( x ).erodeY( y ).erodeZ( z ).
     * @public
     *
     * This is the mutable form of the function erodedXYZ(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Bounds3}
     */
    erodeXYZ: function( x, y, z ) { return this.dilateXYZ( -x, -y, -z ); },

    /**
     * Translates our bounds horizontally by x.
     * @public
     *
     * This is the mutable form of the function shiftedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds3}
     */
    shiftX: function( x ) {
      return this.setMinMax( this.minX + x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );
    },

    /**
     * Translates our bounds vertically by y.
     * @public
     *
     * This is the mutable form of the function shiftedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds3}
     */
    shiftY: function( y ) {
      return this.setMinMax( this.minX, this.minY + y, this.minZ, this.maxX, this.maxY + y, this.maxZ );
    },

    /**
     * Translates our bounds depth-wise by z.
     * @public
     *
     * This is the mutable form of the function shiftedZ(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} z
     * @returns {Bounds3}
     */
    shiftZ: function( z ) {
      return this.setMinMax( this.minX, this.minY, this.minZ + z, this.maxX, this.maxY, this.maxZ + z );
    },

    /**
     * Translates our bounds by (x,y,z).
     * @public
     *
     * This is the mutable form of the function shifted(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Bounds3}
     */
    shift: function( x, y, z ) {
      return this.setMinMax( this.minX + x, this.minY + y, this.minZ + z, this.maxX + x, this.maxY + y, this.maxZ + z );
    }
  }, {
    /**
     * Returns a new Bounds3 object, with the cuboid (3d rectangle) construction with x, y, z, width, height and depth.
     * @public
     *
     * @param {number} x - The minimum value of X for the bounds.
     * @param {number} y - The minimum value of Y for the bounds.
     * @param {number} z - The minimum value of Z for the bounds.
     * @param {number} width - The width (maxX - minX) of the bounds.
     * @param {number} height - The height (maxY - minY) of the bounds.
     * @param {number} depth - The depth (maxZ - minZ) of the bounds.
     * @returns {Bounds3}
     */
    cuboid: function( x, y, z, width, height, depth ) {
      return new Bounds3( x, y, z, x + width, y + height, z + depth );
    },

    /**
     * Returns a new Bounds3 object that only contains the specified point (x,y,z). Useful for being dilated to form a
     * bounding box around a point. Note that the bounds will not be "empty" as it contains (x,y,z), but it will have
     * zero area.
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Bounds3}
     */
    point: function( x, y, z ) {
      return new Bounds3( x, y, z, x, y, z );
    }
  } );

  Poolable.mixin( Bounds3, {
    defaultFactory: function() { return Bounds3.NOTHING.copy(); },
    constructorDuplicateFactory: function( pool ) {
      return function( minX, minY, minZ, maxX, maxY, maxZ ) {
        if ( pool.length ) {
          return pool.pop().setMinMax( minX, minY, minZ, maxX, maxY, maxZ );
        }
        else {
          return new Bounds3( minX, minY, minZ, maxX, maxY, maxZ );
        }
      };
    }
  } );

  /**
   * A contant Bounds3 with minimums = $\infty$, maximums = $-\infty$, so that it represents "no bounds whatsoever".
   * @public
   *
   * This allows us to take the union (union/includeBounds) of this and any other Bounds3 to get the other bounds back,
   * e.g. Bounds3.NOTHING.union( bounds ).equals( bounds ). This object naturally serves as the base case as a union of
   * zero bounds objects.
   *
   * Additionally, intersections with NOTHING will always return a Bounds3 equivalent to NOTHING.
   *
   * @constant {Bounds3} NOTHING
   */
  Bounds3.NOTHING = new Bounds3( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );

  /**
   * A contant Bounds3 with minimums = $-\infty$, maximums = $\infty$, so that it represents "all bounds".
   * @public
   *
   * This allows us to take the intersection (intersection/constrainBounds) of this and any other Bounds3 to get the
   * other bounds back, e.g. Bounds3.EVERYTHING.intersection( bounds ).equals( bounds ). This object naturally serves as
   * the base case as an intersection of zero bounds objects.
   *
   * Additionally, unions with EVERYTHING will always return a Bounds3 equivalent to EVERYTHING.
   *
   * @constant {Bounds3} EVERYTHING
   */
  Bounds3.EVERYTHING = new Bounds3( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );

  return Bounds3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A complex number fhat is immutable. Extends Vector2 for many common operations that need to treat the complex number
 * as a vector $\begin{bmatrix} a \\ b \end{bmatrix}$ for the real number $a+bi$.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Chris Malley
 */

define( 'DOT/Complex',['require','DOT/dot','PHET_CORE/inherit','DOT/Vector2'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );

  /**
   * Creates a complex number, that has both a real and imaginary part.
   * @constructor
   * @public
   *
   * @param {number} real - The real part. For a complex number $a+bi$, this should be $a$.
   * @param {number} imaginary - The imaginary part. For a complex number $a+bi$, this should be $b$.
   */
  function Complex( real, imaginary ) {
    Vector2.call( this, real, imaginary );

    // @public {number} - The real part. For a complex number $a+bi$, this is $a$.
    this.real = real;

    // @public {number} - The imaginary part. For a complex number $a+bi$, this is $b$.
    this.imaginary = imaginary;
  }

  dot.register( 'Complex', Complex );

  // Inheriting Vector2 for now since many times we may want to treat the complex number as a vector
  // ideally, we should have Vector2-likeness be a mixin?
  // we also inherit the immutable form since we add 'real' and 'imaginary' properties,
  // without adding extra logic to mutators in Vector2
  inherit( Vector2.Immutable, Complex, {
    /**
     * The phase / argument of the complex number.
     * @public
     *
     * @returns {number}
     */
    phase: Vector2.prototype.angle,

    /**
     * Complex multiplication.
     * @public
     *
     * @param {Complex} c
     * @returns {Complex}
     */
    times: function( c ) {
      return new Complex( this.real * c.real - this.imaginary * c.imaginary, this.real * c.imaginary + this.imaginary * c.real );
    },

    /**
     * Complex division.
     * @public
     *
     * @param {Complex} c
     * @returns {Complex}
     */
    dividedBy: function( c ) {
      var cMag = c.magnitudeSquared();
      return new Complex(
        ( this.real * c.real + this.imaginary * c.imaginary ) / cMag,
        ( this.imaginary * c.real - this.real * c.imaginary ) / cMag
      );
    },

    /**
     * Square root.
     * @public
     *
     * @returns {Complex}
     */
    sqrt: function() {
      var mag = this.magnitude();
      return new Complex( Math.sqrt( ( mag + this.real ) / 2 ),
        ( this.imaginary >= 0 ? 1 : -1 ) * Math.sqrt( ( mag - this.real ) / 2 ) );
    },

    /**
     * Complex conjugate.
     * @public
     *
     * @returns {Complex}
     */
    conjugate: function() {
      return new Complex( this.real, -this.imaginary );
    },

    /**
     * Takes e to the power of this complex number. $e^{a+bi}=e^a\cos b + i\sin b$.
     * @public
     *
     * @returns {Complex}
     */
    exponentiated: function() {
      return Complex.createPolar( Math.exp( this.real ), this.imaginary );
    },

    /**
     * Debugging string for the complex number (provides real and imaginary parts).
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return 'Complex(' + this.x + ', ' + this.y + ')';
    }
  }, {
    /**
     * Constructs a complex number from just the real part (assuming the imaginary part is 0).
     * @public
     *
     * @param {number} real
     * @returns {Complex}
     */
    real: function( real ) {
      return new Complex( real, 0 );
    },

    /**
     * Constructs a complex number from just the imaginary part (assuming the real part is 0).
     * @public
     *
     * @param {number} imaginary
     * @returns {Complex}
     */
    imaginary: function( imaginary ) {
      return new Complex( 0, imaginary );
    },

    /**
     * Constructs a complex number from the polar form. For a magnitude $r$ and phase $\varphi$, this will be
     * $\cos\varphi+i r\sin\varphi$.
     * @public
     *
     * @param {number} magnitude
     * @param {number} phase
     * @returns {Complex}
     */
    createPolar: function( magnitude, phase ) {
      return new Complex( magnitude * Math.cos( phase ), magnitude * Math.sin( phase ) );
    }
  } );

  /**
   * Immutable constant $0$.
   * @public
   *
   * @constant {Complex} ZERO
   */
  Complex.ZERO = new Complex( 0, 0 );

  /**
   * Immutable constant $1$.
   * @public
   *
   * @constant {Complex} ONE
   */
  Complex.ONE = new Complex( 1, 0 );

  /**
   * Immutable constant $i$, the imaginary unit.
   * @public
   *
   * @constant {Complex} ONE
   */
  Complex.I = new Complex( 0, 1 );

  return Complex;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Construction of 2D convex hulls from a list of points.
 *
 * For example:
 * #begin canvasExample grahamScan 256x128
 * #on
 * var points = _.range( 50 ).map( function() {
 *   return new dot.Vector2( 5 + ( 256 - 10 ) * Math.random(), 5 + ( 128 - 10 ) * Math.random() );
 * } );
 * var hullPoints = dot.ConvexHull2.grahamScan( points, false );
 * #off
 * context.beginPath();
 * hullPoints.forEach( function( point ) {
 *   context.lineTo( point.x, point.y );
 * } );
 * context.closePath();
 * context.fillStyle = '#eee';
 * context.fill();
 * context.strokeStyle = '#f00';
 * context.stroke();
 *
 * context.beginPath();
 * points.forEach( function( point ) {
 *   context.arc( point.x, point.y, 2, 0, Math.PI * 2, false );
 *   context.closePath();
 * } );
 * context.fillStyle = '#00f';
 * context.fill();
 * #end canvasExample
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/ConvexHull2',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  // counter-clockwise turn if > 0, clockwise turn if < 0, collinear if === 0.
  function ccw( p1, p2, p3 ) {
    return p2.minus( p1 ).crossScalar( p3.minus( p1 ) );
  }

  var ConvexHull2 = {
    // TODO testing: all collinear, multiple ways of having same angle, etc.

    /**
     * Given multiple points, this performs a Graham Scan (http://en.wikipedia.org/wiki/Graham_scan) to identify an
     * ordered list of points which define the minimal polygon that contains all of the points.
     * @public
     *
     * @param {Array.<Vector2>} points
     * @param {boolean} includeCollinear - If a point is along an edge of the convex hull (not at one of its vertices),
     *                                     should it be included?
     * @returns {Array.<Vector2>}
     */
    grahamScan: function( points, includeCollinear ) {
      if ( points.length <= 2 ) {
        return points;
      }

      // find the point 'p' with the lowest y value
      var minY = Number.POSITIVE_INFINITY;
      var p = null;
      _.each( points, function( point ) {
        if ( point.y <= minY ) {
          // if two points have the same y value, take the one with the lowest x
          if ( point.y === minY && p ) {
            if ( point.x < p.x ) {
              p = point;
            }
          }
          else {
            minY = point.y;
            p = point;
          }
        }
      } );

      // sorts the points by their angle. Between 0 and PI
      points = _.sortBy( points, function( point ) {
        return point.minus( p ).angle();
      } );

      // remove p from points (relies on the above statement making a defensive copy)
      points.splice( _.indexOf( points, p ), 1 );

      // our result array
      var result = [ p ];

      _.each( points, function( point ) {
        // ignore points equal to our starting point
        if ( p.x === point.x && p.y === point.y ) { return; }

        function isRightTurn() {
          if ( result.length < 2 ) {
            return false;
          }
          var cross = ccw( result[ result.length - 2 ], result[ result.length - 1 ], point );
          return includeCollinear ? ( cross < 0 ) : ( cross <= 0 );
        }

        while ( isRightTurn() ) {
          result.pop();
        }
        result.push( point );
      } );

      return result;
    }
  };

  dot.register( 'ConvexHull2', ConvexHull2 );

  return ConvexHull2;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Eigensystem decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * Eigenvalues and eigenvectors of a real matrix.
 * <P>
 * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is
 * diagonal and the eigenvector matrix V is orthogonal.
 * I.e. A = V.times(D.times(V.transpose())) and
 * V.times(V.transpose()) equals the identity matrix.
 * <P>
 * If A is not symmetric, then the eigenvalue matrix D is block diagonal
 * with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
 * lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The
 * columns of V represent the eigenvectors in the sense that A*V = V*D,
 * i.e. A.times(V) equals V.times(D).  The matrix V may be badly
 * conditioned, or even singular, so the validity of the equation
 * A = V*D*inverse(V) depends upon V.cond().
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/EigenvalueDecomposition',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var Float32Array = window.Float32Array || Array;

  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency

  function EigenvalueDecomposition( matrix ) {
    var i;
    var j;

    var A = matrix.entries;
    this.n = matrix.getColumnDimension(); // Row and column dimension (square matrix).
    var n = this.n;
    this.V = new Float32Array( n * n ); // Array for internal storage of eigenvectors.

    // Arrays for internal storage of eigenvalues.
    this.d = new Float32Array( n );
    this.e = new Float32Array( n );

    this.issymmetric = true;
    for ( j = 0; (j < n) && this.issymmetric; j++ ) {
      for ( i = 0; (i < n) && this.issymmetric; i++ ) {
        this.issymmetric = (A[ i * this.n + j ] === A[ j * this.n + i ]);
      }
    }

    if ( this.issymmetric ) {
      for ( i = 0; i < n; i++ ) {
        for ( j = 0; j < n; j++ ) {
          this.V[ i * this.n + j ] = A[ i * this.n + j ];
        }
      }

      // Tridiagonalize.
      this.tred2();

      // Diagonalize.
      this.tql2();

    }
    else {
      this.H = new Float32Array( n * n ); // Array for internal storage of nonsymmetric Hessenberg form.
      this.ort = new Float32Array( n ); // // Working storage for nonsymmetric algorithm.

      for ( j = 0; j < n; j++ ) {
        for ( i = 0; i < n; i++ ) {
          this.H[ i * this.n + j ] = A[ i * this.n + j ];
        }
      }

      // Reduce to Hessenberg form.
      this.orthes();

      // Reduce Hessenberg to real Schur form.
      this.hqr2();
    }
  }

  dot.register( 'EigenvalueDecomposition', EigenvalueDecomposition );

  EigenvalueDecomposition.prototype = {
    constructor: EigenvalueDecomposition,

    // Return the eigenvector matrix
    getV: function() {
      return this.V.copy();
    },

    // {Array} Return the real parts of the eigenvalues
    getRealEigenvalues: function() {
      return this.d;
    },

    // {Array} Return the imaginary parts of the eigenvalues
    getImagEigenvalues: function() {
      return this.e;
    },

    // Return the block diagonal eigenvalue matrix
    getD: function() {
      var n = this.n;
      var d = this.d;
      var e = this.e;

      var X = new dot.Matrix( n, n );
      var D = X.entries;
      for ( var i = 0; i < n; i++ ) {
        for ( var j = 0; j < n; j++ ) {
          D[ i * this.n + j ] = 0.0;
        }
        D[ i * this.n + i ] = d[ i ];
        if ( e[ i ] > 0 ) {
          D[ i * this.n + i + 1 ] = e[ i ];
        }
        else if ( e[ i ] < 0 ) {
          D[ i * this.n + i - 1 ] = e[ i ];
        }
      }
      return X;
    },

    // Symmetric Householder reduction to tridiagonal form.
    tred2: function() {
      var n = this.n;
      var V = this.V;
      var d = this.d;
      var e = this.e;
      var i;
      var j;
      var k;
      var f;
      var g;
      var h;

      //  This is derived from the Algol procedures tred2 by
      //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
      //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
      //  Fortran subroutine in EISPACK.

      for ( j = 0; j < n; j++ ) {
        d[ j ] = V[ (n - 1) * n + j ];
      }

      // Householder reduction to tridiagonal form.

      for ( i = n - 1; i > 0; i-- ) {

        // Scale to avoid under/overflow.

        var scale = 0.0;
        h = 0.0;
        for ( k = 0; k < i; k++ ) {
          scale = scale + Math.abs( d[ k ] );
        }
        if ( scale === 0.0 ) {
          e[ i ] = d[ i - 1 ];
          for ( j = 0; j < i; j++ ) {
            d[ j ] = V[ (i - 1) * n + j ];
            V[ i * this.n + j ] = 0.0;
            V[ j * this.n + i ] = 0.0;
          }
        }
        else {

          // Generate Householder vector.

          for ( k = 0; k < i; k++ ) {
            d[ k ] /= scale;
            h += d[ k ] * d[ k ];
          }
          f = d[ i - 1 ];
          g = Math.sqrt( h );
          if ( f > 0 ) {
            g = -g;
          }
          e[ i ] = scale * g;
          h = h - f * g;
          d[ i - 1 ] = f - g;
          for ( j = 0; j < i; j++ ) {
            e[ j ] = 0.0;
          }

          // Apply similarity transformation to remaining columns.

          for ( j = 0; j < i; j++ ) {
            f = d[ j ];
            V[ j * this.n + i ] = f;
            g = e[ j ] + V[ j * n + j ] * f;
            for ( k = j + 1; k <= i - 1; k++ ) {
              g += V[ k * n + j ] * d[ k ];
              e[ k ] += V[ k * n + j ] * f;
            }
            e[ j ] = g;
          }
          f = 0.0;
          for ( j = 0; j < i; j++ ) {
            e[ j ] /= h;
            f += e[ j ] * d[ j ];
          }
          var hh = f / (h + h);
          for ( j = 0; j < i; j++ ) {
            e[ j ] -= hh * d[ j ];
          }
          for ( j = 0; j < i; j++ ) {
            f = d[ j ];
            g = e[ j ];
            for ( k = j; k <= i - 1; k++ ) {
              V[ k * n + j ] -= (f * e[ k ] + g * d[ k ]);
            }
            d[ j ] = V[ (i - 1) * n + j ];
            V[ i * this.n + j ] = 0.0;
          }
        }
        d[ i ] = h;
      }

      // Accumulate transformations.

      for ( i = 0; i < n - 1; i++ ) {
        V[ (n - 1) * n + i ] = V[ i * n + i ];
        V[ i * n + i ] = 1.0;
        h = d[ i + 1 ];
        if ( h !== 0.0 ) {
          for ( k = 0; k <= i; k++ ) {
            d[ k ] = V[ k * n + (i + 1) ] / h;
          }
          for ( j = 0; j <= i; j++ ) {
            g = 0.0;
            for ( k = 0; k <= i; k++ ) {
              g += V[ k * n + (i + 1) ] * V[ k * n + j ];
            }
            for ( k = 0; k <= i; k++ ) {
              V[ k * n + j ] -= g * d[ k ];
            }
          }
        }
        for ( k = 0; k <= i; k++ ) {
          V[ k * n + (i + 1) ] = 0.0;
        }
      }
      for ( j = 0; j < n; j++ ) {
        d[ j ] = V[ (n - 1) * n + j ];
        V[ (n - 1) * n + j ] = 0.0;
      }
      V[ (n - 1) * n + (n - 1) ] = 1.0;
      e[ 0 ] = 0.0;
    },

    // Symmetric tridiagonal QL algorithm.
    tql2: function() {
      var n = this.n;
      var V = this.V;
      var d = this.d;
      var e = this.e;
      var i;
      var j;
      var k;
      var l;
      var g;
      var p;
      var iter;

      //  This is derived from the Algol procedures tql2, by
      //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
      //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
      //  Fortran subroutine in EISPACK.

      for ( i = 1; i < n; i++ ) {
        e[ i - 1 ] = e[ i ];
      }
      e[ n - 1 ] = 0.0;

      var f = 0.0;
      var tst1 = 0.0;
      var eps = Math.pow( 2.0, -52.0 );
      for ( l = 0; l < n; l++ ) {

        // Find small subdiagonal element

        tst1 = Math.max( tst1, Math.abs( d[ l ] ) + Math.abs( e[ l ] ) );
        var m = l;
        while ( m < n ) {
          if ( Math.abs( e[ m ] ) <= eps * tst1 ) {
            break;
          }
          m++;
        }

        // If m === l, d[l] is an eigenvalue,
        // otherwise, iterate.

        if ( m > l ) {
          iter = 0;
          do {
            iter = iter + 1;  // (Could check iteration count here.)

            // Compute implicit shift

            g = d[ l ];
            p = (d[ l + 1 ] - g) / (2.0 * e[ l ]);
            var r = dot.Matrix.hypot( p, 1.0 );
            if ( p < 0 ) {
              r = -r;
            }
            d[ l ] = e[ l ] / (p + r);
            d[ l + 1 ] = e[ l ] * (p + r);
            var dl1 = d[ l + 1 ];
            var h = g - d[ l ];
            for ( i = l + 2; i < n; i++ ) {
              d[ i ] -= h;
            }
            f = f + h;

            // Implicit QL transformation.

            p = d[ m ];
            var c = 1.0;
            var c2 = c;
            var c3 = c;
            var el1 = e[ l + 1 ];
            var s = 0.0;
            var s2 = 0.0;
            for ( i = m - 1; i >= l; i-- ) {
              c3 = c2;
              c2 = c;
              s2 = s;
              g = c * e[ i ];
              h = c * p;
              r = dot.Matrix.hypot( p, e[ i ] );
              e[ i + 1 ] = s * r;
              s = e[ i ] / r;
              c = p / r;
              p = c * d[ i ] - s * g;
              d[ i + 1 ] = h + s * (c * g + s * d[ i ]);

              // Accumulate transformation.

              for ( k = 0; k < n; k++ ) {
                h = V[ k * n + (i + 1) ];
                V[ k * n + (i + 1) ] = s * V[ k * n + i ] + c * h;
                V[ k * n + i ] = c * V[ k * n + i ] - s * h;
              }
            }
            p = -s * s2 * c3 * el1 * e[ l ] / dl1;
            e[ l ] = s * p;
            d[ l ] = c * p;

            // Check for convergence.

          } while ( Math.abs( e[ l ] ) > eps * tst1 );
        }
        d[ l ] = d[ l ] + f;
        e[ l ] = 0.0;
      }

      // Sort eigenvalues and corresponding vectors.

      for ( i = 0; i < n - 1; i++ ) {
        k = i;
        p = d[ i ];
        for ( j = i + 1; j < n; j++ ) {
          if ( d[ j ] < p ) {
            k = j;
            p = d[ j ];
          }
        }
        if ( k !== i ) {
          d[ k ] = d[ i ];
          d[ i ] = p;
          for ( j = 0; j < n; j++ ) {
            p = V[ j * this.n + i ];
            V[ j * this.n + i ] = V[ j * n + k ];
            V[ j * n + k ] = p;
          }
        }
      }
    },

    // Nonsymmetric reduction to Hessenberg form.
    orthes: function() {
      var n = this.n;
      var V = this.V;
      var H = this.H;
      var ort = this.ort;
      var i;
      var j;
      var m;
      var f;
      var g;

      //  This is derived from the Algol procedures orthes and ortran,
      //  by Martin and Wilkinson, Handbook for Auto. Comp.,
      //  Vol.ii-Linear Algebra, and the corresponding
      //  Fortran subroutines in EISPACK.

      var low = 0;
      var high = n - 1;

      for ( m = low + 1; m <= high - 1; m++ ) {

        // Scale column.

        var scale = 0.0;
        for ( i = m; i <= high; i++ ) {
          scale = scale + Math.abs( H[ i * n + (m - 1) ] );
        }
        if ( scale !== 0.0 ) {

          // Compute Householder transformation.

          var h = 0.0;
          for ( i = high; i >= m; i-- ) {
            ort[ i ] = H[ i * n + (m - 1) ] / scale;
            h += ort[ i ] * ort[ i ];
          }
          g = Math.sqrt( h );
          if ( ort[ m ] > 0 ) {
            g = -g;
          }
          h = h - ort[ m ] * g;
          ort[ m ] = ort[ m ] - g;

          // Apply Householder similarity transformation
          // H = (I-u*u'/h)*H*(I-u*u')/h)

          for ( j = m; j < n; j++ ) {
            f = 0.0;
            for ( i = high; i >= m; i-- ) {
              f += ort[ i ] * H[ i * this.n + j ];
            }
            f = f / h;
            for ( i = m; i <= high; i++ ) {
              H[ i * this.n + j ] -= f * ort[ i ];
            }
          }

          for ( i = 0; i <= high; i++ ) {
            f = 0.0;
            for ( j = high; j >= m; j-- ) {
              f += ort[ j ] * H[ i * this.n + j ];
            }
            f = f / h;
            for ( j = m; j <= high; j++ ) {
              H[ i * this.n + j ] -= f * ort[ j ];
            }
          }
          ort[ m ] = scale * ort[ m ];
          H[ m * n + (m - 1) ] = scale * g;
        }
      }

      // Accumulate transformations (Algol's ortran).

      for ( i = 0; i < n; i++ ) {
        for ( j = 0; j < n; j++ ) {
          V[ i * this.n + j ] = (i === j ? 1.0 : 0.0);
        }
      }

      for ( m = high - 1; m >= low + 1; m-- ) {
        if ( H[ m * n + (m - 1) ] !== 0.0 ) {
          for ( i = m + 1; i <= high; i++ ) {
            ort[ i ] = H[ i * n + (m - 1) ];
          }
          for ( j = m; j <= high; j++ ) {
            g = 0.0;
            for ( i = m; i <= high; i++ ) {
              g += ort[ i ] * V[ i * this.n + j ];
            }
            // Double division avoids possible underflow
            g = (g / ort[ m ]) / H[ m * n + (m - 1) ];
            for ( i = m; i <= high; i++ ) {
              V[ i * this.n + j ] += g * ort[ i ];
            }
          }
        }
      }
    },

    // Complex scalar division.
    cdiv: function( xr, xi, yr, yi ) {
      var r;
      var d;
      if ( Math.abs( yr ) > Math.abs( yi ) ) {
        r = yi / yr;
        d = yr + r * yi;
        this.cdivr = (xr + r * xi) / d;
        this.cdivi = (xi - r * xr) / d;
      }
      else {
        r = yr / yi;
        d = yi + r * yr;
        this.cdivr = (r * xr + xi) / d;
        this.cdivi = (r * xi - xr) / d;
      }
    },

    // Nonsymmetric reduction from Hessenberg to real Schur form.
    hqr2: function() {
      var n;
      var V = this.V;
      var d = this.d;
      var e = this.e;
      var H = this.H;
      var i;
      var j;
      var k;
      var l;
      var m;
      var iter;

      //  This is derived from the Algol procedure hqr2,
      //  by Martin and Wilkinson, Handbook for Auto. Comp.,
      //  Vol.ii-Linear Algebra, and the corresponding
      //  Fortran subroutine in EISPACK.

      // Initialize

      var nn = this.n;
      n = nn - 1;
      var low = 0;
      var high = nn - 1;
      var eps = Math.pow( 2.0, -52.0 );
      var exshift = 0.0;
      var p = 0;
      var q = 0;
      var r = 0;
      var s = 0;
      var z = 0;
      var t;
      var w;
      var x;
      var y;

      // Store roots isolated by balanc and compute matrix norm

      var norm = 0.0;
      for ( i = 0; i < nn; i++ ) {
        if ( i < low || i > high ) {
          d[ i ] = H[ i * n + i ];
          e[ i ] = 0.0;
        }
        for ( j = Math.max( i - 1, 0 ); j < nn; j++ ) {
          norm = norm + Math.abs( H[ i * this.n + j ] );
        }
      }

      // Outer loop over eigenvalue index

      iter = 0;
      while ( n >= low ) {

        // Look for single small sub-diagonal element

        l = n;
        while ( l > low ) {
          s = Math.abs( H[ (l - 1) * n + (l - 1) ] ) + Math.abs( H[ l * n + l ] );
          if ( s === 0.0 ) {
            s = norm;
          }
          if ( Math.abs( H[ l * n + (l - 1) ] ) < eps * s ) {
            break;
          }
          l--;
        }

        // Check for convergence
        // One root found

        if ( l === n ) {
          H[ n * n + n ] = H[ n * n + n ] + exshift;
          d[ n ] = H[ n * n + n ];
          e[ n ] = 0.0;
          n--;
          iter = 0;

          // Two roots found

        }
        else if ( l === n - 1 ) {
          w = H[ n * n + n - 1 ] * H[ (n - 1) * n + n ];
          p = (H[ (n - 1) * n + (n - 1) ] - H[ n * n + n ]) / 2.0;
          q = p * p + w;
          z = Math.sqrt( Math.abs( q ) );
          H[ n * n + n ] = H[ n * n + n ] + exshift;
          H[ (n - 1) * n + (n - 1) ] = H[ (n - 1) * n + (n - 1) ] + exshift;
          x = H[ n * n + n ];

          // Real pair

          if ( q >= 0 ) {
            if ( p >= 0 ) {
              z = p + z;
            }
            else {
              z = p - z;
            }
            d[ n - 1 ] = x + z;
            d[ n ] = d[ n - 1 ];
            if ( z !== 0.0 ) {
              d[ n ] = x - w / z;
            }
            e[ n - 1 ] = 0.0;
            e[ n ] = 0.0;
            x = H[ n * n + n - 1 ];
            s = Math.abs( x ) + Math.abs( z );
            p = x / s;
            q = z / s;
            r = Math.sqrt( p * p + q * q );
            p = p / r;
            q = q / r;

            // Row modification

            for ( j = n - 1; j < nn; j++ ) {
              z = H[ (n - 1) * n + j ];
              H[ (n - 1) * n + j ] = q * z + p * H[ n * n + j ];
              H[ n * n + j ] = q * H[ n * n + j ] - p * z;
            }

            // Column modification

            for ( i = 0; i <= n; i++ ) {
              z = H[ i * n + n - 1 ];
              H[ i * n + n - 1 ] = q * z + p * H[ i * n + n ];
              H[ i * n + n ] = q * H[ i * n + n ] - p * z;
            }

            // Accumulate transformations

            for ( i = low; i <= high; i++ ) {
              z = V[ i * n + n - 1 ];
              V[ i * n + n - 1 ] = q * z + p * V[ i * n + n ];
              V[ i * n + n ] = q * V[ i * n + n ] - p * z;
            }

            // Complex pair

          }
          else {
            d[ n - 1 ] = x + p;
            d[ n ] = x + p;
            e[ n - 1 ] = z;
            e[ n ] = -z;
          }
          n = n - 2;
          iter = 0;

          // No convergence yet

        }
        else {

          // Form shift

          x = H[ n * n + n ];
          y = 0.0;
          w = 0.0;
          if ( l < n ) {
            y = H[ (n - 1) * n + (n - 1) ];
            w = H[ n * n + n - 1 ] * H[ (n - 1) * n + n ];
          }

          // Wilkinson's original ad hoc shift

          if ( iter === 10 ) {
            exshift += x;
            for ( i = low; i <= n; i++ ) {
              H[ i * n + i ] -= x;
            }
            s = Math.abs( H[ n * n + n - 1 ] ) + Math.abs( H[ (n - 1) * n + n - 2 ] );
            x = y = 0.75 * s;
            w = -0.4375 * s * s;
          }

          // MATLAB's new ad hoc shift

          if ( iter === 30 ) {
            s = (y - x) / 2.0;
            s = s * s + w;
            if ( s > 0 ) {
              s = Math.sqrt( s );
              if ( y < x ) {
                s = -s;
              }
              s = x - w / ((y - x) / 2.0 + s);
              for ( i = low; i <= n; i++ ) {
                H[ i * n + i ] -= s;
              }
              exshift += s;
              x = y = w = 0.964;
            }
          }

          iter = iter + 1;   // (Could check iteration count here.)

          // Look for two consecutive small sub-diagonal elements

          m = n - 2;
          while ( m >= l ) {
            z = H[ m * n + m ];
            r = x - z;
            s = y - z;
            p = (r * s - w) / H[ (m + 1) * n + m ] + H[ m * n + m + 1 ];
            q = H[ (m + 1) * n + m + 1 ] - z - r - s;
            r = H[ (m + 2) * n + m + 1 ];
            s = Math.abs( p ) + Math.abs( q ) + Math.abs( r );
            p = p / s;
            q = q / s;
            r = r / s;
            if ( m === l ) {
              break;
            }
            if ( Math.abs( H[ m * n + (m - 1) ] ) * (Math.abs( q ) + Math.abs( r )) <
                 eps * (Math.abs( p ) * (Math.abs( H[ (m - 1) * n + m - 1 ] ) + Math.abs( z ) +
                                         Math.abs( H[ (m + 1) * n + m + 1 ] ))) ) {
              break;
            }
            m--;
          }

          for ( i = m + 2; i <= n; i++ ) {
            H[ i * n + i - 2 ] = 0.0;
            if ( i > m + 2 ) {
              H[ i * n + i - 3 ] = 0.0;
            }
          }

          // Double QR step involving rows l:n and columns m:n

          for ( k = m; k <= n - 1; k++ ) {
            var notlast = (k !== n - 1);
            if ( k !== m ) {
              p = H[ k * n + k - 1 ];
              q = H[ (k + 1) * n + k - 1 ];
              r = (notlast ? H[ (k + 2) * n + k - 1 ] : 0.0);
              x = Math.abs( p ) + Math.abs( q ) + Math.abs( r );
              if ( x !== 0.0 ) {
                p = p / x;
                q = q / x;
                r = r / x;
              }
            }
            if ( x === 0.0 ) {
              break;
            }
            s = Math.sqrt( p * p + q * q + r * r );
            if ( p < 0 ) {
              s = -s;
            }
            if ( s !== 0 ) {
              if ( k !== m ) {
                H[ k * n + k - 1 ] = -s * x;
              }
              else if ( l !== m ) {
                H[ k * n + k - 1 ] = -H[ k * n + k - 1 ];
              }
              p = p + s;
              x = p / s;
              y = q / s;
              z = r / s;
              q = q / p;
              r = r / p;

              // Row modification

              for ( j = k; j < nn; j++ ) {
                p = H[ k * n + j ] + q * H[ (k + 1) * n + j ];
                if ( notlast ) {
                  p = p + r * H[ (k + 2) * n + j ];
                  H[ (k + 2) * n + j ] = H[ (k + 2) * n + j ] - p * z;
                }
                H[ k * n + j ] = H[ k * n + j ] - p * x;
                H[ (k + 1) * n + j ] = H[ (k + 1) * n + j ] - p * y;
              }

              // Column modification

              for ( i = 0; i <= Math.min( n, k + 3 ); i++ ) {
                p = x * H[ i * n + k ] + y * H[ i * n + k + 1 ];
                if ( notlast ) {
                  p = p + z * H[ i * n + k + 2 ];
                  H[ i * n + k + 2 ] = H[ i * n + k + 2 ] - p * r;
                }
                H[ i * n + k ] = H[ i * n + k ] - p;
                H[ i * n + k + 1 ] = H[ i * n + k + 1 ] - p * q;
              }

              // Accumulate transformations

              for ( i = low; i <= high; i++ ) {
                p = x * V[ i * n + k ] + y * V[ i * n + k + 1 ];
                if ( notlast ) {
                  p = p + z * V[ i * n + k + 2 ];
                  V[ i * n + k + 2 ] = V[ i * n + k + 2 ] - p * r;
                }
                V[ i * n + k ] = V[ i * n + k ] - p;
                V[ i * n + k + 1 ] = V[ i * n + k + 1 ] - p * q;
              }
            }  // (s !== 0)
          }  // k loop
        }  // check convergence
      }  // while (n >= low)

      // Backsubstitute to find vectors of upper triangular form

      if ( norm === 0.0 ) {
        return;
      }

      for ( n = nn - 1; n >= 0; n-- ) {
        p = d[ n ];
        q = e[ n ];

        // Real vector

        if ( q === 0 ) {
          l = n;
          H[ n * n + n ] = 1.0;
          for ( i = n - 1; i >= 0; i-- ) {
            w = H[ i * n + i ] - p;
            r = 0.0;
            for ( j = l; j <= n; j++ ) {
              r = r + H[ i * this.n + j ] * H[ j * n + n ];
            }
            if ( e[ i ] < 0.0 ) {
              z = w;
              s = r;
            }
            else {
              l = i;
              if ( e[ i ] === 0.0 ) {
                if ( w !== 0.0 ) {
                  H[ i * n + n ] = -r / w;
                }
                else {
                  H[ i * n + n ] = -r / (eps * norm);
                }

                // Solve real equations

              }
              else {
                x = H[ i * n + i + 1 ];
                y = H[ (i + 1) * n + i ];
                q = (d[ i ] - p) * (d[ i ] - p) + e[ i ] * e[ i ];
                t = (x * s - z * r) / q;
                H[ i * n + n ] = t;
                if ( Math.abs( x ) > Math.abs( z ) ) {
                  H[ (i + 1) * n + n ] = (-r - w * t) / x;
                }
                else {
                  H[ (i + 1) * n + n ] = (-s - y * t) / z;
                }
              }

              // Overflow control

              t = Math.abs( H[ i * n + n ] );
              if ( (eps * t) * t > 1 ) {
                for ( j = i; j <= n; j++ ) {
                  H[ j * n + n ] = H[ j * n + n ] / t;
                }
              }
            }
          }

          // Complex vector

        }
        else if ( q < 0 ) {
          l = n - 1;

          // Last vector component imaginary so matrix is triangular

          if ( Math.abs( H[ n * n + n - 1 ] ) > Math.abs( H[ (n - 1) * n + n ] ) ) {
            H[ (n - 1) * n + (n - 1) ] = q / H[ n * n + n - 1 ];
            H[ (n - 1) * n + n ] = -(H[ n * n + n ] - p) / H[ n * n + n - 1 ];
          }
          else {
            this.cdiv( 0.0, -H[ (n - 1) * n + n ], H[ (n - 1) * n + (n - 1) ] - p, q );
            H[ (n - 1) * n + (n - 1) ] = this.cdivr;
            H[ (n - 1) * n + n ] = this.cdivi;
          }
          H[ n * n + n - 1 ] = 0.0;
          H[ n * n + n ] = 1.0;
          for ( i = n - 2; i >= 0; i-- ) {
            var ra;
            var sa;
            var vr;
            var vi;
            ra = 0.0;
            sa = 0.0;
            for ( j = l; j <= n; j++ ) {
              ra = ra + H[ i * this.n + j ] * H[ j * n + n - 1 ];
              sa = sa + H[ i * this.n + j ] * H[ j * n + n ];
            }
            w = H[ i * n + i ] - p;

            if ( e[ i ] < 0.0 ) {
              z = w;
              r = ra;
              s = sa;
            }
            else {
              l = i;
              if ( e[ i ] === 0 ) {
                this.cdiv( -ra, -sa, w, q );
                H[ i * n + n - 1 ] = this.cdivr;
                H[ i * n + n ] = this.cdivi;
              }
              else {

                // Solve complex equations

                x = H[ i * n + i + 1 ];
                y = H[ (i + 1) * n + i ];
                vr = (d[ i ] - p) * (d[ i ] - p) + e[ i ] * e[ i ] - q * q;
                vi = (d[ i ] - p) * 2.0 * q;
                if ( vr === 0.0 && vi === 0.0 ) {
                  vr = eps * norm * (Math.abs( w ) + Math.abs( q ) +
                                     Math.abs( x ) + Math.abs( y ) + Math.abs( z ));
                }
                this.cdiv( x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi );
                H[ i * n + n - 1 ] = this.cdivr;
                H[ i * n + n ] = this.cdivi;
                if ( Math.abs( x ) > (Math.abs( z ) + Math.abs( q )) ) {
                  H[ (i + 1) * n + n - 1 ] = (-ra - w * H[ i * n + n - 1 ] + q * H[ i * n + n ]) / x;
                  H[ (i + 1) * n + n ] = (-sa - w * H[ i * n + n ] - q * H[ i * n + n - 1 ]) / x;
                }
                else {
                  this.cdiv( -r - y * H[ i * n + n - 1 ], -s - y * H[ i * n + n ], z, q );
                  H[ (i + 1) * n + n - 1 ] = this.cdivr;
                  H[ (i + 1) * n + n ] = this.cdivi;
                }
              }

              // Overflow control
              t = Math.max( Math.abs( H[ i * n + n - 1 ] ), Math.abs( H[ i * n + n ] ) );
              if ( (eps * t) * t > 1 ) {
                for ( j = i; j <= n; j++ ) {
                  H[ j * n + n - 1 ] = H[ j * n + n - 1 ] / t;
                  H[ j * n + n ] = H[ j * n + n ] / t;
                }
              }
            }
          }
        }
      }

      // Vectors of isolated roots
      for ( i = 0; i < nn; i++ ) {
        if ( i < low || i > high ) {
          for ( j = i; j < nn; j++ ) {
            V[ i * this.n + j ] = H[ i * this.n + j ];
          }
        }
      }

      // Back transformation to get eigenvectors of original matrix
      for ( j = nn - 1; j >= low; j-- ) {
        for ( i = low; i <= high; i++ ) {
          z = 0.0;
          for ( k = low; k <= Math.min( j, high ); k++ ) {
            z = z + V[ i * n + k ] * H[ k * n + j ];
          }
          V[ i * this.n + j ] = z;
        }
      }
    }
  };

  return EigenvalueDecomposition;
} );

// Copyright 2013-2014, University of Colorado Boulder

/**
 * Function for doing a linear mapping between two domains ('a' and 'b').
 * <p>
 * Example usage:
 * <code>
 * var f = new dot.LinearFunction( 0, 100, 0, 200 );
 * f( 50 ); // 100
 * f.inverse( 100 ); // 50
 * </code>
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'DOT/LinearFunction',['require','DOT/dot','DOT/Util'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  // modules
  require( 'DOT/Util' );

  /**
   * @param {Number} a1
   * @param {Number} a2
   * @param {Number} b1
   * @param {Number} b2
   * @param {Boolean} clamp clamp the result to the provided ranges, false by default
   * @constructor
   */
  function LinearFunction( a1, a2, b1, b2, clamp ) {

    clamp = _.isUndefined( clamp ) ? false : clamp;

    /*
     * Linearly interpolate two points and evaluate the line equation for a third point.
     * f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>
     * Optionally clamp the result to the range [b1,b2].
     */
    var map = function( a1, a2, b1, b2, a3, clamp ) {
      var b3 = dot.Util.linear( a1, a2, b1, b2, a3 );
      if ( clamp ) {
        var max = Math.max( b1, b2 );
        var min = Math.min( b1, b2 );
        b3 = dot.Util.clamp( b3, min, max );
      }
      return b3;
    };

    // Maps from a to b.
    var evaluate = function( a3 ) {
      return map( a1, a2, b1, b2, a3, clamp );
    };

    // Maps from b to a.
    evaluate.inverse = function( b3 ) {
      return map( b1, b2, a1, a2, b3, clamp );
    };

    return evaluate; // return the evaluation function, so we use sites look like: f(a) f.inverse(b)
  }

  dot.register( 'LinearFunction', LinearFunction );

  return LinearFunction;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * LU decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/LUDecomposition',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var Float32Array = window.Float32Array || Array;

  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency

  function LUDecomposition( matrix ) {
    var i;
    var j;
    var k;

    this.matrix = matrix;

    // TODO: size!
    this.LU = matrix.getArrayCopy();
    var LU = this.LU;
    this.m = matrix.getRowDimension();
    var m = this.m;
    this.n = matrix.getColumnDimension();
    var n = this.n;
    this.piv = new Uint32Array( m );
    for ( i = 0; i < m; i++ ) {
      this.piv[ i ] = i;
    }
    this.pivsign = 1;
    var LUcolj = new Float32Array( m );

    // Outer loop.

    for ( j = 0; j < n; j++ ) {

      // Make a copy of the j-th column to localize references.
      for ( i = 0; i < m; i++ ) {
        LUcolj[ i ] = LU[ matrix.index( i, j ) ];
      }

      // Apply previous transformations.

      for ( i = 0; i < m; i++ ) {
        // Most of the time is spent in the following dot product.
        var kmax = Math.min( i, j );
        var s = 0.0;
        for ( k = 0; k < kmax; k++ ) {
          var ik = matrix.index( i, k );
          s += LU[ ik ] * LUcolj[ k ];
        }

        LUcolj[ i ] -= s;
        LU[ matrix.index( i, j ) ] = LUcolj[ i ];
      }

      // Find pivot and exchange if necessary.

      var p = j;
      for ( i = j + 1; i < m; i++ ) {
        if ( Math.abs( LUcolj[ i ] ) > Math.abs( LUcolj[ p ] ) ) {
          p = i;
        }
      }
      if ( p !== j ) {
        for ( k = 0; k < n; k++ ) {
          var pk = matrix.index( p, k );
          var jk = matrix.index( j, k );
          var t = LU[ pk ];
          LU[ pk ] = LU[ jk ];
          LU[ jk ] = t;
        }
        k = this.piv[ p ];
        this.piv[ p ] = this.piv[ j ];
        this.piv[ j ] = k;
        this.pivsign = -this.pivsign;
      }

      // Compute multipliers.

      if ( j < m && LU[ this.matrix.index( j, j ) ] !== 0.0 ) {
        for ( i = j + 1; i < m; i++ ) {
          LU[ matrix.index( i, j ) ] /= LU[ matrix.index( j, j ) ];
        }
      }
    }
  }

  dot.register( 'LUDecomposition', LUDecomposition );

  LUDecomposition.prototype = {
    constructor: LUDecomposition,

    isNonsingular: function() {
      for ( var j = 0; j < this.n; j++ ) {
        var index = this.matrix.index( j, j );
        if ( this.LU[ index ] === 0 ) {
          return false;
        }
      }
      return true;
    },

    getL: function() {
      var result = new dot.Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          if ( i > j ) {
            result.entries[ result.index( i, j ) ] = this.LU[ this.matrix.index( i, j ) ];
          }
          else if ( i === j ) {
            result.entries[ result.index( i, j ) ] = 1.0;
          }
          else {
            result.entries[ result.index( i, j ) ] = 0.0;
          }
        }
      }
      return result;
    },

    getU: function() {
      var result = new dot.Matrix( this.n, this.n );
      for ( var i = 0; i < this.n; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          if ( i <= j ) {
            result.entries[ result.index( i, j ) ] = this.LU[ this.matrix.index( i, j ) ];
          }
          else {
            result.entries[ result.index( i, j ) ] = 0.0;
          }
        }
      }
      return result;
    },

    getPivot: function() {
      var p = new Uint32Array( this.m );
      for ( var i = 0; i < this.m; i++ ) {
        p[ i ] = this.piv[ i ];
      }
      return p;
    },

    getDoublePivot: function() {
      var vals = new Float32Array( this.m );
      for ( var i = 0; i < this.m; i++ ) {
        vals[ i ] = this.piv[ i ];
      }
      return vals;
    },

    det: function() {
      if ( this.m !== this.n ) {
        throw new Error( 'Matrix must be square.' );
      }
      var d = this.pivsign;
      for ( var j = 0; j < this.n; j++ ) {
        d *= this.LU[ this.matrix.index( j, j ) ];
      }
      return d;
    },

    solve: function( matrix ) {
      var i;
      var j;
      var k;
      if ( matrix.getRowDimension() !== this.m ) {
        throw new Error( 'Matrix row dimensions must agree.' );
      }
      if ( !this.isNonsingular() ) {
        throw new Error( 'Matrix is singular.' );
      }

      // Copy right hand side with pivoting
      var nx = matrix.getColumnDimension();
      var Xmat = matrix.getArrayRowMatrix( this.piv, 0, nx - 1 );

      // Solve L*Y = B(piv,:)
      for ( k = 0; k < this.n; k++ ) {
        for ( i = k + 1; i < this.n; i++ ) {
          for ( j = 0; j < nx; j++ ) {
            Xmat.entries[ Xmat.index( i, j ) ] -= Xmat.entries[ Xmat.index( k, j ) ] * this.LU[ this.matrix.index( i, k ) ];
          }
        }
      }

      // Solve U*X = Y;
      for ( k = this.n - 1; k >= 0; k-- ) {
        for ( j = 0; j < nx; j++ ) {
          Xmat.entries[ Xmat.index( k, j ) ] /= this.LU[ this.matrix.index( k, k ) ];
        }
        for ( i = 0; i < k; i++ ) {
          for ( j = 0; j < nx; j++ ) {
            Xmat.entries[ Xmat.index( i, j ) ] -= Xmat.entries[ Xmat.index( k, j ) ] * this.LU[ this.matrix.index( i, k ) ];
          }
        }
      }
      return Xmat;
    }
  };

  return LUDecomposition;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Tests whether a reference is to an array.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/isArray',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function isArray( array ) {
    // yes, this is actually how to do this. see http://stackoverflow.com/questions/4775722/javascript-check-if-object-is-array
    return Object.prototype.toString.call( array ) === '[object Array]';
  }

  phetCore.register( 'isArray', isArray );

  return isArray;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * SVD decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/SingularValueDecomposition',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var Float32Array = window.Float32Array || Array;

  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency

  function SingularValueDecomposition( matrix ) {
    this.matrix = matrix;

    var Arg = matrix;

    // Derived from LINPACK code.
    // Initialize.
    var A = Arg.getArrayCopy();
    this.m = Arg.getRowDimension();
    this.n = Arg.getColumnDimension();
    var m = this.m;
    var n = this.n;

    var min = Math.min;
    var max = Math.max;
    var pow = Math.pow;
    var abs = Math.abs;

    /* Apparently the failing cases are only a proper subset of (m<n),
     so let's not throw error.  Correct fix to come later?
     if (m<n) {
     throw new IllegalArgumentException("Jama SVD only works for m >= n"); }
     */
    var nu = min( m, n );
    this.s = new Float32Array( min( m + 1, n ) );
    var s = this.s;
    this.U = new Float32Array( m * nu );
    var U = this.U;
    this.V = new Float32Array( n * n );
    var V = this.V;
    var e = new Float32Array( n );
    var work = new Float32Array( m );
    var wantu = true;
    var wantv = true;

    var i;
    var j;
    var k;
    var t;
    var f;

    var cs;
    var sn;

    var hypot = dot.Matrix.hypot;

    // Reduce A to bidiagonal form, storing the diagonal elements
    // in s and the super-diagonal elements in e.

    var nct = min( m - 1, n );
    var nrt = max( 0, min( n - 2, m ) );
    for ( k = 0; k < max( nct, nrt ); k++ ) {
      if ( k < nct ) {

        // Compute the transformation for the k-th column and
        // place the k-th diagonal in s[k].
        // Compute 2-norm of k-th column without under/overflow.
        s[ k ] = 0;
        for ( i = k; i < m; i++ ) {
          s[ k ] = hypot( s[ k ], A[ i * n + k ] );
        }
        if ( s[ k ] !== 0.0 ) {
          if ( A[ k * n + k ] < 0.0 ) {
            s[ k ] = -s[ k ];
          }
          for ( i = k; i < m; i++ ) {
            A[ i * n + k ] /= s[ k ];
          }
          A[ k * n + k ] += 1.0;
        }
        s[ k ] = -s[ k ];
      }
      for ( j = k + 1; j < n; j++ ) {
        if ( (k < nct) && (s[ k ] !== 0.0) ) {

          // Apply the transformation.

          t = 0;
          for ( i = k; i < m; i++ ) {
            t += A[ i * n + k ] * A[ i * n + j ];
          }
          t = -t / A[ k * n + k ];
          for ( i = k; i < m; i++ ) {
            A[ i * n + j ] += t * A[ i * n + k ];
          }
        }

        // Place the k-th row of A into e for the
        // subsequent calculation of the row transformation.

        e[ j ] = A[ k * n + j ];
      }
      if ( wantu && (k < nct) ) {

        // Place the transformation in U for subsequent back
        // multiplication.

        for ( i = k; i < m; i++ ) {
          U[ i * nu + k ] = A[ i * n + k ];
        }
      }
      if ( k < nrt ) {

        // Compute the k-th row transformation and place the
        // k-th super-diagonal in e[k].
        // Compute 2-norm without under/overflow.
        e[ k ] = 0;
        for ( i = k + 1; i < n; i++ ) {
          e[ k ] = hypot( e[ k ], e[ i ] );
        }
        if ( e[ k ] !== 0.0 ) {
          if ( e[ k + 1 ] < 0.0 ) {
            e[ k ] = -e[ k ];
          }
          for ( i = k + 1; i < n; i++ ) {
            e[ i ] /= e[ k ];
          }
          e[ k + 1 ] += 1.0;
        }
        e[ k ] = -e[ k ];
        if ( (k + 1 < m) && (e[ k ] !== 0.0) ) {

          // Apply the transformation.

          for ( i = k + 1; i < m; i++ ) {
            work[ i ] = 0.0;
          }
          for ( j = k + 1; j < n; j++ ) {
            for ( i = k + 1; i < m; i++ ) {
              work[ i ] += e[ j ] * A[ i * n + j ];
            }
          }
          for ( j = k + 1; j < n; j++ ) {
            t = -e[ j ] / e[ k + 1 ];
            for ( i = k + 1; i < m; i++ ) {
              A[ i * n + j ] += t * work[ i ];
            }
          }
        }
        if ( wantv ) {

          // Place the transformation in V for subsequent
          // back multiplication.

          for ( i = k + 1; i < n; i++ ) {
            V[ i * n + k ] = e[ i ];
          }
        }
      }
    }

    // Set up the final bidiagonal matrix or order p.

    var p = min( n, m + 1 );
    if ( nct < n ) {
      s[ nct ] = A[ nct * n + nct ];
    }
    if ( m < p ) {
      s[ p - 1 ] = 0.0;
    }
    if ( nrt + 1 < p ) {
      e[ nrt ] = A[ nrt * n + p - 1 ];
    }
    e[ p - 1 ] = 0.0;

    // If required, generate U.

    if ( wantu ) {
      for ( j = nct; j < nu; j++ ) {
        for ( i = 0; i < m; i++ ) {
          U[ i * nu + j ] = 0.0;
        }
        U[ j * nu + j ] = 1.0;
      }
      for ( k = nct - 1; k >= 0; k-- ) {
        if ( s[ k ] !== 0.0 ) {
          for ( j = k + 1; j < nu; j++ ) {
            t = 0;
            for ( i = k; i < m; i++ ) {
              t += U[ i * nu + k ] * U[ i * nu + j ];
            }
            t = -t / U[ k * nu + k ];
            for ( i = k; i < m; i++ ) {
              U[ i * nu + j ] += t * U[ i * nu + k ];
            }
          }
          for ( i = k; i < m; i++ ) {
            U[ i * nu + k ] = -U[ i * nu + k ];
          }
          U[ k * nu + k ] = 1.0 + U[ k * nu + k ];
          for ( i = 0; i < k - 1; i++ ) {
            U[ i * nu + k ] = 0.0;
          }
        }
        else {
          for ( i = 0; i < m; i++ ) {
            U[ i * nu + k ] = 0.0;
          }
          U[ k * nu + k ] = 1.0;
        }
      }
    }

    // If required, generate V.

    if ( wantv ) {
      for ( k = n - 1; k >= 0; k-- ) {
        if ( (k < nrt) && (e[ k ] !== 0.0) ) {
          for ( j = k + 1; j < nu; j++ ) {
            t = 0;
            for ( i = k + 1; i < n; i++ ) {
              t += V[ i * n + k ] * V[ i * n + j ];
            }
            t = -t / V[ (k + 1) * n + k ];
            for ( i = k + 1; i < n; i++ ) {
              V[ i * n + j ] += t * V[ i * n + k ];
            }
          }
        }
        for ( i = 0; i < n; i++ ) {
          V[ i * n + k ] = 0.0;
        }
        V[ k * n + k ] = 1.0;
      }
    }

    // Main iteration loop for the singular values.

    var pp = p - 1;
    var iter = 0;
    var eps = pow( 2.0, -52.0 );
    var tiny = pow( 2.0, -966.0 );
    while ( p > 0 ) {
      var kase;

      // Here is where a test for too many iterations would go.
      if ( iter > 500 ) {
        break;
      }

      // This section of the program inspects for
      // negligible elements in the s and e arrays.  On
      // completion the variables kase and k are set as follows.

      // kase = 1   if s(p) and e[k-1] are negligible and k<p
      // kase = 2   if s(k) is negligible and k<p
      // kase = 3   if e[k-1] is negligible, k<p, and
      //        s(k), ..., s(p) are not negligible (qr step).
      // kase = 4   if e(p-1) is negligible (convergence).

      for ( k = p - 2; k >= -1; k-- ) {
        if ( k === -1 ) {
          break;
        }
        if ( abs( e[ k ] ) <=
             tiny + eps * (abs( s[ k ] ) + abs( s[ k + 1 ] )) ) {
          e[ k ] = 0.0;
          break;
        }
      }
      if ( k === p - 2 ) {
        kase = 4;
      }
      else {
        var ks;
        for ( ks = p - 1; ks >= k; ks-- ) {
          if ( ks === k ) {
            break;
          }
          t = (ks !== p ? abs( e[ ks ] ) : 0) +
              (ks !== k + 1 ? abs( e[ ks - 1 ] ) : 0);
          if ( abs( s[ ks ] ) <= tiny + eps * t ) {
            s[ ks ] = 0.0;
            break;
          }
        }
        if ( ks === k ) {
          kase = 3;
        }
        else if ( ks === p - 1 ) {
          kase = 1;
        }
        else {
          kase = 2;
          k = ks;
        }
      }
      k++;

      // Perform the task indicated by kase.

      switch( kase ) {

        // Deflate negligible s(p).

        case 1:
        {
          f = e[ p - 2 ];
          e[ p - 2 ] = 0.0;
          for ( j = p - 2; j >= k; j-- ) {
            t = hypot( s[ j ], f );
            cs = s[ j ] / t;
            sn = f / t;
            s[ j ] = t;
            if ( j !== k ) {
              f = -sn * e[ j - 1 ];
              e[ j - 1 ] = cs * e[ j - 1 ];
            }
            if ( wantv ) {
              for ( i = 0; i < n; i++ ) {
                t = cs * V[ i * n + j ] + sn * V[ i * n + p - 1 ];
                V[ i * n + p - 1 ] = -sn * V[ i * n + j ] + cs * V[ i * n + p - 1 ];
                V[ i * n + j ] = t;
              }
            }
          }
        }
          break;

        // Split at negligible s(k).

        case 2:
        {
          f = e[ k - 1 ];
          e[ k - 1 ] = 0.0;
          for ( j = k; j < p; j++ ) {
            t = hypot( s[ j ], f );
            cs = s[ j ] / t;
            sn = f / t;
            s[ j ] = t;
            f = -sn * e[ j ];
            e[ j ] = cs * e[ j ];
            if ( wantu ) {
              for ( i = 0; i < m; i++ ) {
                t = cs * U[ i * nu + j ] + sn * U[ i * nu + k - 1 ];
                U[ i * nu + k - 1 ] = -sn * U[ i * nu + j ] + cs * U[ i * nu + k - 1 ];
                U[ i * nu + j ] = t;
              }
            }
          }
        }
          break;

        // Perform one qr step.

        case 3:
        {

          // Calculate the shift.

          var scale = max( max( max( max( abs( s[ p - 1 ] ), abs( s[ p - 2 ] ) ), abs( e[ p - 2 ] ) ), abs( s[ k ] ) ), abs( e[ k ] ) );
          var sp = s[ p - 1 ] / scale;
          var spm1 = s[ p - 2 ] / scale;
          var epm1 = e[ p - 2 ] / scale;
          var sk = s[ k ] / scale;
          var ek = e[ k ] / scale;
          var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
          var c = (sp * epm1) * (sp * epm1);
          var shift = 0.0;
          if ( (b !== 0.0) || (c !== 0.0) ) {
            shift = Math.sqrt( b * b + c );
            if ( b < 0.0 ) {
              shift = -shift;
            }
            shift = c / (b + shift);
          }
          f = (sk + sp) * (sk - sp) + shift;
          var g = sk * ek;

          // Chase zeros.

          for ( j = k; j < p - 1; j++ ) {
            t = hypot( f, g );
            cs = f / t;
            sn = g / t;
            if ( j !== k ) {
              e[ j - 1 ] = t;
            }
            f = cs * s[ j ] + sn * e[ j ];
            e[ j ] = cs * e[ j ] - sn * s[ j ];
            g = sn * s[ j + 1 ];
            s[ j + 1 ] = cs * s[ j + 1 ];
            if ( wantv ) {
              for ( i = 0; i < n; i++ ) {
                t = cs * V[ i * n + j ] + sn * V[ i * n + j + 1 ];
                V[ i * n + j + 1 ] = -sn * V[ i * n + j ] + cs * V[ i * n + j + 1 ];
                V[ i * n + j ] = t;
              }
            }
            t = hypot( f, g );
            cs = f / t;
            sn = g / t;
            s[ j ] = t;
            f = cs * e[ j ] + sn * s[ j + 1 ];
            s[ j + 1 ] = -sn * e[ j ] + cs * s[ j + 1 ];
            g = sn * e[ j + 1 ];
            e[ j + 1 ] = cs * e[ j + 1 ];
            if ( wantu && (j < m - 1) ) {
              for ( i = 0; i < m; i++ ) {
                t = cs * U[ i * nu + j ] + sn * U[ i * nu + j + 1 ];
                U[ i * nu + j + 1 ] = -sn * U[ i * nu + j ] + cs * U[ i * nu + j + 1 ];
                U[ i * nu + j ] = t;
              }
            }
          }
          e[ p - 2 ] = f;
          iter = iter + 1;
        }
          break;

        // Convergence.

        case 4:
        {

          // Make the singular values positive.

          if ( s[ k ] <= 0.0 ) {
            s[ k ] = (s[ k ] < 0.0 ? -s[ k ] : 0.0);
            if ( wantv ) {
              for ( i = 0; i <= pp; i++ ) {
                V[ i * n + k ] = -V[ i * n + k ];
              }
            }
          }

          // Order the singular values.

          while ( k < pp ) {
            if ( s[ k ] >= s[ k + 1 ] ) {
              break;
            }
            t = s[ k ];
            s[ k ] = s[ k + 1 ];
            s[ k + 1 ] = t;
            if ( wantv && (k < n - 1) ) {
              for ( i = 0; i < n; i++ ) {
                t = V[ i * n + k + 1 ];
                V[ i * n + k + 1 ] = V[ i * n + k ];
                V[ i * n + k ] = t;
              }
            }
            if ( wantu && (k < m - 1) ) {
              for ( i = 0; i < m; i++ ) {
                t = U[ i * nu + k + 1 ];
                U[ i * nu + k + 1 ] = U[ i * nu + k ];
                U[ i * nu + k ] = t;
              }
            }
            k++;
          }
          iter = 0;
          p--;
        }
          break;
      }
    }
  }

  dot.register( 'SingularValueDecomposition', SingularValueDecomposition );

  SingularValueDecomposition.prototype = {
    constructor: SingularValueDecomposition,

    getU: function() {
      return new dot.Matrix( this.m, Math.min( this.m + 1, this.n ), this.U, true ); // the "fast" flag added, since U is Float32Array
    },

    getV: function() {
      return new dot.Matrix( this.n, this.n, this.V, true );
    },

    getSingularValues: function() {
      return this.s;
    },

    getS: function() {
      var result = new dot.Matrix( this.n, this.n );
      for ( var i = 0; i < this.n; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          result.entries[ result.index( i, j ) ] = 0.0;
        }
        result.entries[ result.index( i, i ) ] = this.s[ i ];
      }
      return result;
    },

    norm2: function() {
      return this.s[ 0 ];
    },

    cond: function() {
      return this.s[ 0 ] / this.s[ Math.min( this.m, this.n ) - 1 ];
    },

    rank: function() {
      // changed to 23 from 52 (bits of mantissa), since we are using floats here!
      var eps = Math.pow( 2.0, -23.0 );
      var tol = Math.max( this.m, this.n ) * this.s[ 0 ] * eps;
      var r = 0;
      for ( var i = 0; i < this.s.length; i++ ) {
        if ( this.s[ i ] > tol ) {
          r++;
        }
      }
      return r;
    }
  };

  return SingularValueDecomposition;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * QR decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/QRDecomposition',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var Float32Array = window.Float32Array || Array;

  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency

  dot.QRDecomposition = function QRDecomposition( matrix ) {
    this.matrix = matrix;

    // TODO: size!
    this.QR = matrix.getArrayCopy();
    var QR = this.QR;
    this.m = matrix.getRowDimension();
    var m = this.m;
    this.n = matrix.getColumnDimension();
    var n = this.n;

    this.Rdiag = new Float32Array( n );

    var i;
    var j;
    var k;

    // Main loop.
    for ( k = 0; k < n; k++ ) {
      // Compute 2-norm of k-th column without under/overflow.
      var nrm = 0;
      for ( i = k; i < m; i++ ) {
        nrm = dot.Matrix.hypot( nrm, QR[ this.matrix.index( i, k ) ] );
      }

      if ( nrm !== 0.0 ) {
        // Form k-th Householder vector.
        if ( QR[ this.matrix.index( k, k ) ] < 0 ) {
          nrm = -nrm;
        }
        for ( i = k; i < m; i++ ) {
          QR[ this.matrix.index( i, k ) ] /= nrm;
        }
        QR[ this.matrix.index( k, k ) ] += 1.0;

        // Apply transformation to remaining columns.
        for ( j = k + 1; j < n; j++ ) {
          var s = 0.0;
          for ( i = k; i < m; i++ ) {
            s += QR[ this.matrix.index( i, k ) ] * QR[ this.matrix.index( i, j ) ];
          }
          s = -s / QR[ this.matrix.index( k, k ) ];
          for ( i = k; i < m; i++ ) {
            QR[ this.matrix.index( i, j ) ] += s * QR[ this.matrix.index( i, k ) ];
          }
        }
      }
      this.Rdiag[ k ] = -nrm;
    }
  };
  var QRDecomposition = dot.QRDecomposition;

  QRDecomposition.prototype = {
    constructor: QRDecomposition,

    isFullRank: function() {
      for ( var j = 0; j < this.n; j++ ) {
        if ( this.Rdiag[ j ] === 0 ) {
          return false;
        }
      }
      return true;
    },

    getH: function() {
      var result = new dot.Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          if ( i >= j ) {
            result.entries[ result.index( i, j ) ] = this.QR[ this.matrix.index( i, j ) ];
          }
          else {
            result.entries[ result.index( i, j ) ] = 0.0;
          }
        }
      }
      return result;
    },

    getR: function() {
      var result = new dot.Matrix( this.n, this.n );
      for ( var i = 0; i < this.n; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          if ( i < j ) {
            result.entries[ result.index( i, j ) ] = this.QR[ this.matrix.index( i, j ) ];
          }
          else if ( i === j ) {
            result.entries[ result.index( i, j ) ] = this.Rdiag[ i ];
          }
          else {
            result.entries[ result.index( i, j ) ] = 0.0;
          }
        }
      }
      return result;
    },

    getQ: function() {
      var i;
      var j;
      var k;
      var result = new dot.Matrix( this.m, this.n );
      for ( k = this.n - 1; k >= 0; k-- ) {
        for ( i = 0; i < this.m; i++ ) {
          result.entries[ result.index( i, k ) ] = 0.0;
        }
        result.entries[ result.index( k, k ) ] = 1.0;
        for ( j = k; j < this.n; j++ ) {
          if ( this.QR[ this.matrix.index( k, k ) ] !== 0 ) {
            var s = 0.0;
            for ( i = k; i < this.m; i++ ) {
              s += this.QR[ this.matrix.index( i, k ) ] * result.entries[ result.index( i, j ) ];
            }
            s = -s / this.QR[ this.matrix.index( k, k ) ];
            for ( i = k; i < this.m; i++ ) {
              result.entries[ result.index( i, j ) ] += s * this.QR[ this.matrix.index( i, k ) ];
            }
          }
        }
      }
      return result;
    },

    solve: function( matrix ) {
      if ( matrix.getRowDimension() !== this.m ) {
        throw new Error( 'Matrix row dimensions must agree.' );
      }
      if ( !this.isFullRank() ) {
        throw new Error( 'Matrix is rank deficient.' );
      }

      var i;
      var j;
      var k;

      // Copy right hand side
      var nx = matrix.getColumnDimension();
      var X = matrix.getArrayCopy();

      // Compute Y = transpose(Q)*matrix
      for ( k = 0; k < this.n; k++ ) {
        for ( j = 0; j < nx; j++ ) {
          var s = 0.0;
          for ( i = k; i < this.m; i++ ) {
            s += this.QR[ this.matrix.index( i, k ) ] * X[ matrix.index( i, j ) ];
          }
          s = -s / this.QR[ this.matrix.index( k, k ) ];
          for ( i = k; i < this.m; i++ ) {
            X[ matrix.index( i, j ) ] += s * this.QR[ this.matrix.index( i, k ) ];
          }
        }
      }

      // Solve R*X = Y;
      for ( k = this.n - 1; k >= 0; k-- ) {
        for ( j = 0; j < nx; j++ ) {
          X[ matrix.index( k, j ) ] /= this.Rdiag[ k ];
        }
        for ( i = 0; i < k; i++ ) {
          for ( j = 0; j < nx; j++ ) {
            X[ matrix.index( i, j ) ] -= X[ matrix.index( k, j ) ] * this.QR[ this.matrix.index( i, k ) ];
          }
        }
      }
      return new dot.Matrix( this.n, nx, X, true ).getMatrix( 0, this.n - 1, 0, nx - 1 );
    }
  };

  return QRDecomposition;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Arbitrary-dimensional matrix, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Matrix',['require','DOT/dot','PHET_CORE/isArray','DOT/SingularValueDecomposition','DOT/LUDecomposition','DOT/QRDecomposition','DOT/EigenvalueDecomposition','DOT/Vector2','DOT/Vector3','DOT/Vector4'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var Float32Array = window.Float32Array || Array;

  var isArray = require( 'PHET_CORE/isArray' );

  require( 'DOT/SingularValueDecomposition' );
  require( 'DOT/LUDecomposition' );
  require( 'DOT/QRDecomposition' );
  require( 'DOT/EigenvalueDecomposition' );
  require( 'DOT/Vector2' );
  require( 'DOT/Vector3' );
  require( 'DOT/Vector4' );

  function Matrix( m, n, filler, fast ) {
    this.m = m;
    this.n = n;

    var size = m * n;
    this.size = size;
    var i;

    if ( fast ) {
      this.entries = filler;
    }
    else {
      if ( !filler ) {
        filler = 0;
      }

      // entries stored in row-major format
      this.entries = new Float32Array( size );

      if ( isArray( filler ) ) {
        assert && assert( filler.length === size );

        for ( i = 0; i < size; i++ ) {
          this.entries[ i ] = filler[ i ];
        }
      }
      else {
        for ( i = 0; i < size; i++ ) {
          this.entries[ i ] = filler;
        }
      }
    }
  }

  dot.register( 'Matrix', Matrix );

  /** sqrt(a^2 + b^2) without under/overflow. **/
  Matrix.hypot = function hypot( a, b ) {
    var r;
    if ( Math.abs( a ) > Math.abs( b ) ) {
      r = b / a;
      r = Math.abs( a ) * Math.sqrt( 1 + r * r );
    }
    else if ( b !== 0 ) {
      r = a / b;
      r = Math.abs( b ) * Math.sqrt( 1 + r * r );
    }
    else {
      r = 0.0;
    }
    return r;
  };

  Matrix.prototype = {
    constructor: Matrix,

    copy: function() {
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.size; i++ ) {
        result.entries[ i ] = this.entries[ i ];
      }
      return result;
    },

    getArray: function() {
      return this.entries;
    },

    getArrayCopy: function() {
      return new Float32Array( this.entries );
    },

    getRowDimension: function() {
      return this.m;
    },

    getColumnDimension: function() {
      return this.n;
    },

    // TODO: inline this places if we aren't using an inlining compiler! (check performance)
    index: function( i, j ) {
      return i * this.n + j;
    },

    get: function( i, j ) {
      return this.entries[ this.index( i, j ) ];
    },

    set: function( i, j, s ) {
      this.entries[ this.index( i, j ) ] = s;
    },

    getMatrix: function( i0, i1, j0, j1 ) {
      var result = new Matrix( i1 - i0 + 1, j1 - j0 + 1 );
      for ( var i = i0; i <= i1; i++ ) {
        for ( var j = j0; j <= j1; j++ ) {
          result.entries[ result.index( i - i0, j - j0 ) ] = this.entries[ this.index( i, j ) ];
        }
      }
      return result;
    },

    // getMatrix (int[] r, int j0, int j1)
    getArrayRowMatrix: function( r, j0, j1 ) {
      var result = new Matrix( r.length, j1 - j0 + 1 );
      for ( var i = 0; i < r.length; i++ ) {
        for ( var j = j0; j <= j1; j++ ) {
          result.entries[ result.index( i, j - j0 ) ] = this.entries[ this.index( r[ i ], j ) ];
        }
      }
      return result;
    },

    // allow passing in a pre-constructed matrix
    transpose: function( result ) {
      result = result || new Matrix( this.n, this.m );
      assert && assert( result.m === this.n );
      assert && assert( result.n === this.m );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          result.entries[ result.index( j, i ) ] = this.entries[ this.index( i, j ) ];
        }
      }
      return result;
    },

    norm1: function() {
      var f = 0;
      for ( var j = 0; j < this.n; j++ ) {
        var s = 0;
        for ( var i = 0; i < this.m; i++ ) {
          s += Math.abs( this.entries[ this.index( i, j ) ] );
        }
        f = Math.max( f, s );
      }
      return f;
    },

    norm2: function() {
      return (new dot.SingularValueDecomposition( this ).norm2());
    },

    normInf: function() {
      var f = 0;
      for ( var i = 0; i < this.m; i++ ) {
        var s = 0;
        for ( var j = 0; j < this.n; j++ ) {
          s += Math.abs( this.entries[ this.index( i, j ) ] );
        }
        f = Math.max( f, s );
      }
      return f;
    },

    normF: function() {
      var f = 0;
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          f = Matrix.hypot( f, this.entries[ this.index( i, j ) ] );
        }
      }
      return f;
    },

    uminus: function() {
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          result.entries[ result.index( i, j ) ] = -this.entries[ this.index( i, j ) ];
        }
      }
      return result;
    },

    plus: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = result.index( i, j );
          result.entries[ index ] = this.entries[ index ] + matrix.entries[ index ];
        }
      }
      return result;
    },

    plusEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = result.index( i, j );
          this.entries[ index ] = this.entries[ index ] + matrix.entries[ index ];
        }
      }
      return this;
    },

    minus: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          result.entries[ index ] = this.entries[ index ] - matrix.entries[ index ];
        }
      }
      return result;
    },

    minusEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[ index ] = this.entries[ index ] - matrix.entries[ index ];
        }
      }
      return this;
    },

    arrayTimes: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = result.index( i, j );
          result.entries[ index ] = this.entries[ index ] * matrix.entries[ index ];
        }
      }
      return result;
    },

    arrayTimesEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[ index ] = this.entries[ index ] * matrix.entries[ index ];
        }
      }
      return this;
    },

    arrayRightDivide: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          result.entries[ index ] = this.entries[ index ] / matrix.entries[ index ];
        }
      }
      return result;
    },

    arrayRightDivideEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[ index ] = this.entries[ index ] / matrix.entries[ index ];
        }
      }
      return this;
    },

    arrayLeftDivide: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          result.entries[ index ] = matrix.entries[ index ] / this.entries[ index ];
        }
      }
      return result;
    },

    arrayLeftDivideEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[ index ] = matrix.entries[ index ] / this.entries[ index ];
        }
      }
      return this;
    },

    times: function( matrixOrScalar ) {
      var result;
      var i;
      var j;
      var k;
      var s;
      var matrix;
      if ( matrixOrScalar.isMatrix ) {
        matrix = matrixOrScalar;
        if ( matrix.m !== this.n ) {
          throw new Error( 'Matrix inner dimensions must agree.' );
        }
        result = new Matrix( this.m, matrix.n );
        var matrixcolj = new Float32Array( this.n );
        for ( j = 0; j < matrix.n; j++ ) {
          for ( k = 0; k < this.n; k++ ) {
            matrixcolj[ k ] = matrix.entries[ matrix.index( k, j ) ];
          }
          for ( i = 0; i < this.m; i++ ) {
            s = 0;
            for ( k = 0; k < this.n; k++ ) {
              s += this.entries[ this.index( i, k ) ] * matrixcolj[ k ];
            }
            result.entries[ result.index( i, j ) ] = s;
          }
        }
        return result;
      }
      else {
        s = matrixOrScalar;
        result = new Matrix( this.m, this.n );
        for ( i = 0; i < this.m; i++ ) {
          for ( j = 0; j < this.n; j++ ) {
            result.entries[ result.index( i, j ) ] = s * this.entries[ this.index( i, j ) ];
          }
        }
        return result;
      }
    },

    timesEquals: function( s ) {
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[ index ] = s * this.entries[ index ];
        }
      }
      return this;
    },

    solve: function( matrix ) {
      return (this.m === this.n ? (new dot.LUDecomposition( this )).solve( matrix ) :
              (new dot.QRDecomposition( this )).solve( matrix ));
    },

    solveTranspose: function( matrix ) {
      return this.transpose().solve( matrix.transpose() );
    },

    inverse: function() {
      return this.solve( Matrix.identity( this.m, this.m ) );
    },

    det: function() {
      return new dot.LUDecomposition( this ).det();
    },

    rank: function() {
      return new dot.SingularValueDecomposition( this ).rank();
    },

    cond: function() {
      return new dot.SingularValueDecomposition( this ).cond();
    },

    trace: function() {
      var t = 0;
      for ( var i = 0; i < Math.min( this.m, this.n ); i++ ) {
        t += this.entries[ this.index( i, i ) ];
      }
      return t;
    },

    checkMatrixDimensions: function( matrix ) {
      if ( matrix.m !== this.m || matrix.n !== this.n ) {
        throw new Error( 'Matrix dimensions must agree.' );
      }
    },

    toString: function() {
      var result = '';
      result += 'dim: ' + this.getRowDimension() + 'x' + this.getColumnDimension() + '\n';
      for ( var row = 0; row < this.getRowDimension(); row++ ) {
        for ( var col = 0; col < this.getColumnDimension(); col++ ) {
          result += this.get( row, col ) + ' ';
        }
        result += '\n';
      }
      return result;
    },

    // returns a vector that is contained in the specified column
    extractVector2: function( column ) {
      assert && assert( this.m === 2 ); // rows should match vector dimension
      return new dot.Vector2( this.get( 0, column ), this.get( 1, column ) );
    },

    // returns a vector that is contained in the specified column
    extractVector3: function( column ) {
      assert && assert( this.m === 3 ); // rows should match vector dimension
      return new dot.Vector3( this.get( 0, column ), this.get( 1, column ), this.get( 2, column ) );
    },

    // returns a vector that is contained in the specified column
    extractVector4: function( column ) {
      assert && assert( this.m === 4 ); // rows should match vector dimension
      return new dot.Vector4( this.get( 0, column ), this.get( 1, column ), this.get( 2, column ), this.get( 3, column ) );
    },

    // Sets the current matrix to the values of the listed column vectors (Vector3).
    setVectors3: function( vectors ) {
      var m = 3;
      var n = vectors.length;

      assert && assert( this.m === m );
      assert && assert( this.n === n );

      for ( var i = 0; i < n; i++ ) {
        var vector = vectors[ i ];
        this.entries[ i ] = vector.x;
        this.entries[ i + n ] = vector.y;
        this.entries[ i + 2 * n ] = vector.z;
      }

      return this;
    },

    isMatrix: true
  };

  Matrix.identity = function( m, n ) {
    var result = new Matrix( m, n );
    for ( var i = 0; i < m; i++ ) {
      for ( var j = 0; j < n; j++ ) {
        result.entries[ result.index( i, j ) ] = (i === j ? 1.0 : 0.0);
      }
    }
    return result;
  };

  Matrix.rowVector2 = function( vector ) {
    return new Matrix( 1, 2, [ vector.x, vector.y ] );
  };

  Matrix.rowVector3 = function( vector ) {
    return new Matrix( 1, 3, [ vector.x, vector.y, vector.z ] );
  };

  Matrix.rowVector4 = function( vector ) {
    return new Matrix( 1, 4, [ vector.x, vector.y, vector.z, vector.w ] );
  };

  Matrix.rowVector = function( vector ) {
    if ( vector.isVector2 ) {
      return Matrix.rowVector2( vector );
    }
    else if ( vector.isVector3 ) {
      return Matrix.rowVector3( vector );
    }
    else if ( vector.isVector4 ) {
      return Matrix.rowVector4( vector );
    }
    else {
      throw new Error( 'undetected type of vector: ' + vector.toString() );
    }
  };

  Matrix.columnVector2 = function( vector ) {
    return new Matrix( 2, 1, [ vector.x, vector.y ] );
  };

  Matrix.columnVector3 = function( vector ) {
    return new Matrix( 3, 1, [ vector.x, vector.y, vector.z ] );
  };

  Matrix.columnVector4 = function( vector ) {
    return new Matrix( 4, 1, [ vector.x, vector.y, vector.z, vector.w ] );
  };

  Matrix.columnVector = function( vector ) {
    if ( vector.isVector2 ) {
      return Matrix.columnVector2( vector );
    }
    else if ( vector.isVector3 ) {
      return Matrix.columnVector3( vector );
    }
    else if ( vector.isVector4 ) {
      return Matrix.columnVector4( vector );
    }
    else {
      throw new Error( 'undetected type of vector: ' + vector.toString() );
    }
  };

  /**
   * Create a Matrix where each column is a vector
   */

  Matrix.fromVectors2 = function( vectors ) {
    var dimension = 2;
    var n = vectors.length;
    var data = new Float32Array( dimension * n );

    for ( var i = 0; i < n; i++ ) {
      var vector = vectors[ i ];
      data[ i ] = vector.x;
      data[ i + n ] = vector.y;
    }

    return new Matrix( dimension, n, data, true );
  };

  Matrix.fromVectors3 = function( vectors ) {
    var dimension = 3;
    var n = vectors.length;
    var data = new Float32Array( dimension * n );

    for ( var i = 0; i < n; i++ ) {
      var vector = vectors[ i ];
      data[ i ] = vector.x;
      data[ i + n ] = vector.y;
      data[ i + 2 * n ] = vector.z;
    }

    return new Matrix( dimension, n, data, true );
  };

  Matrix.fromVectors4 = function( vectors ) {
    var dimension = 4;
    var n = vectors.length;
    var data = new Float32Array( dimension * n );

    for ( var i = 0; i < n; i++ ) {
      var vector = vectors[ i ];
      data[ i ] = vector.x;
      data[ i + n ] = vector.y;
      data[ i + 2 * n ] = vector.z;
      data[ i + 3 * n ] = vector.w;
    }

    return new Matrix( dimension, n, data, true );
  };

  return Matrix;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Fast 3x3 matrix computations at the lower level, including an SVD implementation that is fully stable.
 * Overall, it uses a heavily mutable style, passing in the object where the result(s) will be stored.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/MatrixOps3',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  /*
   * Matrices are stored as flat typed arrays with row-major indices. For example, for a 3x3:
   * [0] [1] [2]
   * [3] [4] [5]
   * [6] [7] [8]
   *
   * NOTE: We assume the typed arrays are AT LEAST as long as necessary (but could be longer). This allows us to use
   * an array as big as the largest one we'll need.
   */

  // constants
  var SQRT_HALF = Math.sqrt( 0.5 );

  var MatrixOps3 = {
    // use typed arrays if possible
    Array: dot.FastArray,

    /*---------------------------------------------------------------------------*
     * 3x3 matrix math
     *----------------------------------------------------------------------------*/

    /*
     * From 0-indexed row and column indices, returns the index into the flat array
     *
     * @param {number} row
     * @param {number} col
     */
    index3: function( row, col ) {
      assert && assert( row >= 0 && row < 3 );
      assert && assert( col >= 0 && col < 3 );
      return 3 * row + col;
    },

    /*
     * Copies one matrix into another
     *
     * @param {FastMath.Array} matrix - [input] 3x3 Matrix
     * @param {FastMath.Array} result - [output] 3x3 Matrix
     */
    set3: function( matrix, result ) {
      assert && assert( matrix.length >= 9 );
      assert && assert( result.length >= 9 );
      result[ 0 ] = matrix[ 0 ];
      result[ 1 ] = matrix[ 1 ];
      result[ 2 ] = matrix[ 2 ];
      result[ 3 ] = matrix[ 3 ];
      result[ 4 ] = matrix[ 4 ];
      result[ 5 ] = matrix[ 5 ];
      result[ 6 ] = matrix[ 6 ];
      result[ 7 ] = matrix[ 7 ];
      result[ 8 ] = matrix[ 8 ];
    },

    /*
     * Writes the transpose of the input matrix into the result matrix (in-place modification is OK)
     *
     * @param {FastMath.Array} matrix - [input] 3x3 Matrix
     * @param {FastMath.Array} result - [output] 3x3 Matrix
     */
    transpose3: function( matrix, result ) {
      assert && assert( matrix.length >= 9 );
      assert && assert( result.length >= 9 );
      var m1 = matrix[ 3 ];
      var m2 = matrix[ 6 ];
      var m3 = matrix[ 1 ];
      var m5 = matrix[ 7 ];
      var m6 = matrix[ 2 ];
      var m7 = matrix[ 5 ];
      result[ 0 ] = matrix[ 0 ];
      result[ 1 ] = m1;
      result[ 2 ] = m2;
      result[ 3 ] = m3;
      result[ 4 ] = matrix[ 4 ];
      result[ 5 ] = m5;
      result[ 6 ] = m6;
      result[ 7 ] = m7;
      result[ 8 ] = matrix[ 8 ];
    },

    /*
     * The determinant of a 3x3 matrix
     *
     * @param {FastMath.Array} matrix - [input] 3x3 Matrix
     * @returns {number} - The determinant. 0 indicates a singular (non-invertible) matrix.
     */
    det3: function( matrix ) {
      assert && assert( matrix.length >= 9 );
      return matrix[ 0 ] * matrix[ 4 ] * matrix[ 8 ] + matrix[ 1 ] * matrix[ 5 ] * matrix[ 6 ] +
             matrix[ 2 ] * matrix[ 3 ] * matrix[ 7 ] - matrix[ 2 ] * matrix[ 4 ] * matrix[ 6 ] -
             matrix[ 1 ] * matrix[ 3 ] * matrix[ 8 ] - matrix[ 0 ] * matrix[ 5 ] * matrix[ 7 ];
    },

    /*
     * Writes the matrix multiplication ( left * right ) into result. (in-place modification is OK)
     *
     * @param {FastMath.Array} left - [input] 3x3 Matrix
     * @param {FastMath.Array} right - [input] 3x3 Matrix
     * @param {FastMath.Array} result - [output] 3x3 Matrix
     */
    mult3: function( left, right, result ) {
      assert && assert( left.length >= 9 );
      assert && assert( right.length >= 9 );
      assert && assert( result.length >= 9 );
      var m0 = left[ 0 ] * right[ 0 ] + left[ 1 ] * right[ 3 ] + left[ 2 ] * right[ 6 ];
      var m1 = left[ 0 ] * right[ 1 ] + left[ 1 ] * right[ 4 ] + left[ 2 ] * right[ 7 ];
      var m2 = left[ 0 ] * right[ 2 ] + left[ 1 ] * right[ 5 ] + left[ 2 ] * right[ 8 ];
      var m3 = left[ 3 ] * right[ 0 ] + left[ 4 ] * right[ 3 ] + left[ 5 ] * right[ 6 ];
      var m4 = left[ 3 ] * right[ 1 ] + left[ 4 ] * right[ 4 ] + left[ 5 ] * right[ 7 ];
      var m5 = left[ 3 ] * right[ 2 ] + left[ 4 ] * right[ 5 ] + left[ 5 ] * right[ 8 ];
      var m6 = left[ 6 ] * right[ 0 ] + left[ 7 ] * right[ 3 ] + left[ 8 ] * right[ 6 ];
      var m7 = left[ 6 ] * right[ 1 ] + left[ 7 ] * right[ 4 ] + left[ 8 ] * right[ 7 ];
      var m8 = left[ 6 ] * right[ 2 ] + left[ 7 ] * right[ 5 ] + left[ 8 ] * right[ 8 ];
      result[ 0 ] = m0;
      result[ 1 ] = m1;
      result[ 2 ] = m2;
      result[ 3 ] = m3;
      result[ 4 ] = m4;
      result[ 5 ] = m5;
      result[ 6 ] = m6;
      result[ 7 ] = m7;
      result[ 8 ] = m8;
    },

    /*
     * Writes the matrix multiplication ( transpose( left ) * right ) into result. (in-place modification is OK)
     *
     * @param {FastMath.Array} left - [input] 3x3 Matrix
     * @param {FastMath.Array} right - [input] 3x3 Matrix
     * @param {FastMath.Array} result - [output] 3x3 Matrix
     */
    mult3LeftTranspose: function( left, right, result ) {
      assert && assert( left.length >= 9 );
      assert && assert( right.length >= 9 );
      assert && assert( result.length >= 9 );
      var m0 = left[ 0 ] * right[ 0 ] + left[ 3 ] * right[ 3 ] + left[ 6 ] * right[ 6 ];
      var m1 = left[ 0 ] * right[ 1 ] + left[ 3 ] * right[ 4 ] + left[ 6 ] * right[ 7 ];
      var m2 = left[ 0 ] * right[ 2 ] + left[ 3 ] * right[ 5 ] + left[ 6 ] * right[ 8 ];
      var m3 = left[ 1 ] * right[ 0 ] + left[ 4 ] * right[ 3 ] + left[ 7 ] * right[ 6 ];
      var m4 = left[ 1 ] * right[ 1 ] + left[ 4 ] * right[ 4 ] + left[ 7 ] * right[ 7 ];
      var m5 = left[ 1 ] * right[ 2 ] + left[ 4 ] * right[ 5 ] + left[ 7 ] * right[ 8 ];
      var m6 = left[ 2 ] * right[ 0 ] + left[ 5 ] * right[ 3 ] + left[ 8 ] * right[ 6 ];
      var m7 = left[ 2 ] * right[ 1 ] + left[ 5 ] * right[ 4 ] + left[ 8 ] * right[ 7 ];
      var m8 = left[ 2 ] * right[ 2 ] + left[ 5 ] * right[ 5 ] + left[ 8 ] * right[ 8 ];
      result[ 0 ] = m0;
      result[ 1 ] = m1;
      result[ 2 ] = m2;
      result[ 3 ] = m3;
      result[ 4 ] = m4;
      result[ 5 ] = m5;
      result[ 6 ] = m6;
      result[ 7 ] = m7;
      result[ 8 ] = m8;
    },

    /*
     * Writes the matrix multiplication ( left * transpose( right ) ) into result. (in-place modification is OK)
     *
     * @param {FastMath.Array} left - [input] 3x3 Matrix
     * @param {FastMath.Array} right - [input] 3x3 Matrix
     * @param {FastMath.Array} result - [output] 3x3 Matrix
     */
    mult3RightTranspose: function( left, right, result ) {
      assert && assert( left.length >= 9 );
      assert && assert( right.length >= 9 );
      assert && assert( result.length >= 9 );
      var m0 = left[ 0 ] * right[ 0 ] + left[ 1 ] * right[ 1 ] + left[ 2 ] * right[ 2 ];
      var m1 = left[ 0 ] * right[ 3 ] + left[ 1 ] * right[ 4 ] + left[ 2 ] * right[ 5 ];
      var m2 = left[ 0 ] * right[ 6 ] + left[ 1 ] * right[ 7 ] + left[ 2 ] * right[ 8 ];
      var m3 = left[ 3 ] * right[ 0 ] + left[ 4 ] * right[ 1 ] + left[ 5 ] * right[ 2 ];
      var m4 = left[ 3 ] * right[ 3 ] + left[ 4 ] * right[ 4 ] + left[ 5 ] * right[ 5 ];
      var m5 = left[ 3 ] * right[ 6 ] + left[ 4 ] * right[ 7 ] + left[ 5 ] * right[ 8 ];
      var m6 = left[ 6 ] * right[ 0 ] + left[ 7 ] * right[ 1 ] + left[ 8 ] * right[ 2 ];
      var m7 = left[ 6 ] * right[ 3 ] + left[ 7 ] * right[ 4 ] + left[ 8 ] * right[ 5 ];
      var m8 = left[ 6 ] * right[ 6 ] + left[ 7 ] * right[ 7 ] + left[ 8 ] * right[ 8 ];
      result[ 0 ] = m0;
      result[ 1 ] = m1;
      result[ 2 ] = m2;
      result[ 3 ] = m3;
      result[ 4 ] = m4;
      result[ 5 ] = m5;
      result[ 6 ] = m6;
      result[ 7 ] = m7;
      result[ 8 ] = m8;
    },

    /*
     * Writes the matrix multiplication ( transpose( left ) * transpose( right ) ) into result.
     * (in-place modification is OK)
     * NOTE: This is equivalent to transpose( right * left ).
     *
     * @param {FastMath.Array} left - [input] 3x3 Matrix
     * @param {FastMath.Array} right - [input] 3x3 Matrix
     * @param {FastMath.Array} result - [output] 3x3 Matrix
     */
    mult3BothTranspose: function( left, right, result ) {
      assert && assert( left.length >= 9 );
      assert && assert( right.length >= 9 );
      assert && assert( result.length >= 9 );
      var m0 = left[ 0 ] * right[ 0 ] + left[ 3 ] * right[ 1 ] + left[ 6 ] * right[ 2 ];
      var m1 = left[ 0 ] * right[ 3 ] + left[ 3 ] * right[ 4 ] + left[ 6 ] * right[ 5 ];
      var m2 = left[ 0 ] * right[ 6 ] + left[ 3 ] * right[ 7 ] + left[ 6 ] * right[ 8 ];
      var m3 = left[ 1 ] * right[ 0 ] + left[ 4 ] * right[ 1 ] + left[ 7 ] * right[ 2 ];
      var m4 = left[ 1 ] * right[ 3 ] + left[ 4 ] * right[ 4 ] + left[ 7 ] * right[ 5 ];
      var m5 = left[ 1 ] * right[ 6 ] + left[ 4 ] * right[ 7 ] + left[ 7 ] * right[ 8 ];
      var m6 = left[ 2 ] * right[ 0 ] + left[ 5 ] * right[ 1 ] + left[ 8 ] * right[ 2 ];
      var m7 = left[ 2 ] * right[ 3 ] + left[ 5 ] * right[ 4 ] + left[ 8 ] * right[ 5 ];
      var m8 = left[ 2 ] * right[ 6 ] + left[ 5 ] * right[ 7 ] + left[ 8 ] * right[ 8 ];
      result[ 0 ] = m0;
      result[ 1 ] = m1;
      result[ 2 ] = m2;
      result[ 3 ] = m3;
      result[ 4 ] = m4;
      result[ 5 ] = m5;
      result[ 6 ] = m6;
      result[ 7 ] = m7;
      result[ 8 ] = m8;
    },

    /*
     * Writes the product ( matrix * vector ) into result. (in-place modification is OK)
     *
     * @param {FastMath.Array} matrix - [input] 3x3 Matrix
     * @param {Vector3} vector - [input]
     * @param {Vector3} result - [output]
     */
    mult3Vector3: function( matrix, vector, result ) {
      assert && assert( matrix.length >= 9 );
      var x = matrix[ 0 ] * vector.x + matrix[ 1 ] * vector.y + matrix[ 2 ] * vector.z;
      var y = matrix[ 3 ] * vector.x + matrix[ 4 ] * vector.y + matrix[ 5 ] * vector.z;
      var z = matrix[ 6 ] * vector.x + matrix[ 7 ] * vector.y + matrix[ 8 ] * vector.z;
      result.x = x;
      result.y = y;
      result.z = z;
    },

    /*
     * Swaps two columns in a matrix, negating one of them to maintain the sign of the determinant.
     *
     * @param {FastMath.Array} matrix - [input] 3x3 Matrix
     * @param {number} idx0 - In the range [0,2]
     * @param {number} idx1 - In the range [0,2]
     */
    swapNegateColumn: function( matrix, idx0, idx1 ) {
      assert && assert( matrix.length >= 9 );
      var tmp0 = matrix[ idx0 ];
      var tmp1 = matrix[ idx0 + 3 ];
      var tmp2 = matrix[ idx0 + 6 ];

      matrix[ idx0 ] = matrix[ idx1 ];
      matrix[ idx0 + 3 ] = matrix[ idx1 + 3 ];
      matrix[ idx0 + 6 ] = matrix[ idx1 + 6 ];

      matrix[ idx1 ] = -tmp0;
      matrix[ idx1 + 3 ] = -tmp1;
      matrix[ idx1 + 6 ] = -tmp2;
    },

    /*
     * Sets the result matrix to the identity.
     *
     * @param {FastMath.Array} result - [output] 3x3 Matrix
     */
    setIdentity3: function( result ) {
      result[ 0 ] = result[ 4 ] = result[ 8 ] = 1; // diagonal
      result[ 1 ] = result[ 2 ] = result[ 3 ] = result[ 5 ] = result[ 6 ] = result[ 7 ] = 0; // non-diagonal
    },

    /*
     * Sets the result matrix to the Givens rotation (performs a rotation between two components). Instead of an angle,
     * the 'cos' and 'sin' values are passed in directly since we skip the trigonometry almost everywhere we can.
     *
     * See http://en.wikipedia.org/wiki/Givens_rotation (note that we use the other sign convention for the sin)
     *
     * @param {FastMath.Array} result - [output] 3x3 Matrix
     * @param {number} cos - [input] The cosine of the Givens rotation angle
     * @param {number} sin - [input] The sine of the Givens rotation angle
     * @param {number} idx0 - [input] The smaller row/column index
     * @param {number} idx1 - [input] The larger row/column index
     */
    setGivens3: function( result, cos, sin, idx0, idx1 ) {
      assert && assert( idx0 < idx1 );
      this.setIdentity3( result );
      result[ this.index3( idx0, idx0 ) ] = cos;
      result[ this.index3( idx1, idx1 ) ] = cos;
      result[ this.index3( idx0, idx1 ) ] = sin;
      result[ this.index3( idx1, idx0 ) ] = -sin;
    },

    /*
     * Efficiently pre-multiples the matrix in-place by the specified Givens rotation (matrix <= rotation * matrix).
     * Equivalent to using setGivens3 and mult3.
     *
     * @param {FastMath.Array} result - [input AND output] 3x3 Matrix
     * @param {number} cos - [input] The cosine of the Givens rotation angle
     * @param {number} sin - [input] The sine of the Givens rotation angle
     * @param {number} idx0 - [input] The smaller row/column index
     * @param {number} idx1 - [input] The larger row/column index
     */
    preMult3Givens: function( matrix, cos, sin, idx0, idx1 ) {
      var baseA = idx0 * 3;
      var baseB = idx1 * 3;
      // lexicographically in column-major order for "affine" section
      var a = cos * matrix[ baseA + 0 ] + sin * matrix[ baseB + 0 ];
      var b = cos * matrix[ baseB + 0 ] - sin * matrix[ baseA + 0 ];
      var c = cos * matrix[ baseA + 1 ] + sin * matrix[ baseB + 1 ];
      var d = cos * matrix[ baseB + 1 ] - sin * matrix[ baseA + 1 ];
      var e = cos * matrix[ baseA + 2 ] + sin * matrix[ baseB + 2 ];
      var f = cos * matrix[ baseB + 2 ] - sin * matrix[ baseA + 2 ];
      matrix[ baseA + 0 ] = a;
      matrix[ baseB + 0 ] = b;
      matrix[ baseA + 1 ] = c;
      matrix[ baseB + 1 ] = d;
      matrix[ baseA + 2 ] = e;
      matrix[ baseB + 2 ] = f;
    },

    /*
     * Efficiently post-multiples the matrix in-place by the transpose of the specified Givens rotation
     * (matrix <= matrix * rotation^T).
     * Equivalent to using setGivens3 and mult3RightTranspose.
     *
     * @param {FastMath.Array} result - [input AND output] 3x3 Matrix
     * @param {number} cos - [input] The cosine of the Givens rotation angle
     * @param {number} sin - [input] The sine of the Givens rotation angle
     * @param {number} idx0 - [input] The smaller row/column index
     * @param {number} idx1 - [input] The larger row/column index
     */
    postMult3Givens: function( matrix, cos, sin, idx0, idx1 ) {
      // lexicographically in row-major order for the "transposed affine" section
      var a = cos * matrix[ idx0 + 0 ] + sin * matrix[ idx1 + 0 ];
      var b = cos * matrix[ idx1 + 0 ] - sin * matrix[ idx0 + 0 ];
      var c = cos * matrix[ idx0 + 3 ] + sin * matrix[ idx1 + 3 ];
      var d = cos * matrix[ idx1 + 3 ] - sin * matrix[ idx0 + 3 ];
      var e = cos * matrix[ idx0 + 6 ] + sin * matrix[ idx1 + 6 ];
      var f = cos * matrix[ idx1 + 6 ] - sin * matrix[ idx0 + 6 ];
      matrix[ idx0 + 0 ] = a;
      matrix[ idx1 + 0 ] = b;
      matrix[ idx0 + 3 ] = c;
      matrix[ idx1 + 3 ] = d;
      matrix[ idx0 + 6 ] = e;
      matrix[ idx1 + 6 ] = f;
    },

    /*
     * Zeros out the [idx0,idx1] and [idx1,idx0] entries of the matrix mS by applying a Givens rotation as part of the
     * Jacobi iteration. In addition, the Givens rotation is prepended to mQ so we can track the accumulated rotations
     * applied (this is how we get V in the SVD).
     *
     * @param {FastMath.Array} mS - [input AND output] Symmetric 3x3 Matrix
     * @param {FastMath.Array} mQ - [input AND output] Unitary 3x3 Matrix
     * @param {number} idx0 - [input] The smaller row/column index
     * @param {number} idx1 - [input] The larger row/column index
     */
    applyJacobi3: function( mS, mQ, idx0, idx1 ) {
      // submatrix entries for idx0,idx1
      var a11 = mS[ 3 * idx0 + idx0 ];
      var a12 = mS[ 3 * idx0 + idx1 ]; // we assume mS is symmetric, so we don't need a21
      var a22 = mS[ 3 * idx1 + idx1 ];

      // Approximate givens angle, see https://graphics.cs.wisc.edu/Papers/2011/MSTTS11/SVD_TR1690.pdf (section 2.3)
      // "Computing the Singular Value Decomposition of 3x3 matrices with minimal branching and elementary floating point operations"
      // Aleka McAdams, Andrew Selle, Rasmus Tamstorf, Joseph Teran, Eftychios Sifakis
      var lhs = a12 * a12;
      var rhs = a11 - a22;
      rhs = rhs * rhs;
      var useAngle = lhs < rhs;
      var w = 1 / Math.sqrt( lhs + rhs );
      // NOTE: exact Givens angle is 0.5 * Math.atan( 2 * a12 / ( a11 - a22 ) ), but clamped to withing +-Math.PI / 4
      var cos = useAngle ? ( w * ( a11 - a22 ) ) : SQRT_HALF;
      var sin = useAngle ? ( w * a12 ) : SQRT_HALF;

      // S' = Q * S * transpose( Q )
      this.preMult3Givens( mS, cos, sin, idx0, idx1 );
      this.postMult3Givens( mS, cos, sin, idx0, idx1 );

      // Q' = Q * mQ
      this.preMult3Givens( mQ, cos, sin, idx0, idx1 );
    },

    /*
     * The Jacobi method, which in turn zeros out all the non-diagonal entries repeatedly until mS converges into
     * a diagonal matrix. We track the applied Givens rotations in mQ, so that when given mS and mQ=identity, we will
     * maintain the value mQ * mS * mQ^T
     *
     * @param {FastMath.Array} mS - [input AND output] Symmetric 3x3 Matrix
     * @param {FastMath.Array} mQ - [input AND output] Unitary 3x3 Matrix
     * @param {number} n - [input] The number of iterations to run
     */
    jacobiIteration3: function( mS, mQ, n ) {
      // for 3x3, we eliminate non-diagonal entries iteratively
      for ( var i = 0; i < n; i++ ) {
        this.applyJacobi3( mS, mQ, 0, 1 );
        this.applyJacobi3( mS, mQ, 0, 2 );
        this.applyJacobi3( mS, mQ, 1, 2 );
      }
    },

    /*
     * One step in computing the QR decomposition. Zeros out the (row,col) entry in 'r', while maintaining the
     * value of (q * r). We will end up with an orthogonal Q and upper-triangular R (or in the SVD case,
     * R will be diagonal)
     *
     * @param {FastMath.Array} q - [input AND ouput] 3x3 Matrix
     * @param {FastMath.Array} r - [input AND ouput] 3x3 Matrix
     * @param {number} row - [input] The row of the entry to zero out
     * @param {number} col - [input] The column of the entry to zero out
     */
    qrAnnihilate3: function( q, r, row, col ) {
      assert && assert( row > col ); // only in the lower-triangular area

      var epsilon = 0.0000000001;
      var cos;
      var sin;

      var diagonalValue = r[ this.index3( col, col ) ];
      var targetValue = r[ this.index3( row, col ) ];
      var diagonalSquared = diagonalValue * diagonalValue;
      var targetSquared = targetValue * targetValue;

      // handle the case where both (row,col) and (col,col) are very small (would cause instabilities)
      if ( diagonalSquared + targetSquared < epsilon ) {
        cos = diagonalValue > 0 ? 1 : 0;
        sin = 0;
      }
      else {
        var rsqr = 1 / Math.sqrt( diagonalSquared + targetSquared );
        cos = rsqr * diagonalValue;
        sin = rsqr * targetValue;
      }

      this.preMult3Givens( r, cos, sin, col, row );
      this.postMult3Givens( q, cos, sin, col, row );
    },

    /*
     * 3x3 Singular Value Decomposition, handling singular cases.
     * Based on https://graphics.cs.wisc.edu/Papers/2011/MSTTS11/SVD_TR1690.pdf
     * "Computing the Singular Value Decomposition of 3x3 matrices with minimal branching and elementary floating point operations"
     * Aleka McAdams, Andrew Selle, Rasmus Tamstorf, Joseph Teran, Eftychios Sifakis
     *
     * @param {FastMath.Array} a - [input] 3x3 Matrix that we want the SVD of.
     * @param {number} jacobiIterationCount - [input] How many Jacobi iterations to run (larger is more accurate to a point)
     * @param {FastMath.Array} resultU - [output] 3x3 U matrix (unitary)
     * @param {FastMath.Array} resultSigma - [output] 3x3 diagonal matrix of singular values
     * @param {FastMath.Array} resultV - [output] 3x3 V matrix (unitary)
     */
    svd3: function( a, jacobiIterationCount, resultU, resultSigma, resultV ) {
      // shorthands
      var q = resultU;
      var v = resultV;
      var r = resultSigma;

      // for now, use 'r' as our S == transpose( A ) * A, so we don't have to use scratch matrices
      this.mult3LeftTranspose( a, a, r );
      // we'll accumulate into 'q' == transpose( V ) during the Jacobi iteration
      this.setIdentity3( q );

      // Jacobi iteration turns Q into V^T and R into Sigma^2 (we'll ditch R since the QR decomposition will be beter)
      this.jacobiIteration3( r, q, jacobiIterationCount );
      // final determination of V
      this.transpose3( q, v ); // done with this 'q' until we reuse the scratch matrix later below for the QR decomposition

      this.mult3( a, v, r ); // R = AV

      // Sort columns of R and V based on singular values (needed for the QR step, and useful anyways).
      // Their product will remain unchanged.
      var mag0 = r[ 0 ] * r[ 0 ] + r[ 3 ] * r[ 3 ] + r[ 6 ] * r[ 6 ]; // column vector magnitudes
      var mag1 = r[ 1 ] * r[ 1 ] + r[ 4 ] * r[ 4 ] + r[ 7 ] * r[ 7 ];
      var mag2 = r[ 2 ] * r[ 2 ] + r[ 5 ] * r[ 5 ] + r[ 8 ] * r[ 8 ];
      var tmpMag;
      if ( mag0 < mag1 ) {
        // swap magnitudes
        tmpMag = mag0;
        mag0 = mag1;
        mag1 = tmpMag;
        this.swapNegateColumn( r, 0, 1 );
        this.swapNegateColumn( v, 0, 1 );
      }
      if ( mag0 < mag2 ) {
        // swap magnitudes
        tmpMag = mag0;
        mag0 = mag2;
        mag2 = tmpMag;
        this.swapNegateColumn( r, 0, 2 );
        this.swapNegateColumn( v, 0, 2 );
      }
      if ( mag1 < mag2 ) {
        this.swapNegateColumn( r, 1, 2 );
        this.swapNegateColumn( v, 1, 2 );
      }

      // QR decomposition
      this.setIdentity3( q ); // reusing Q now for the QR
      // Zero out all three strictly lower-triangular values. Should turn the matrix diagonal
      this.qrAnnihilate3( q, r, 1, 0 );
      this.qrAnnihilate3( q, r, 2, 0 );
      this.qrAnnihilate3( q, r, 2, 1 );

      // checks for a singular U value, we'll add in the needed 1 entries to make sure our U is orthogonal
      var bigEpsilon = 0.001; // they really should be around 1
      if ( q[ 0 ] * q[ 0 ] + q[ 1 ] * q[ 1 ] + q[ 2 ] * q[ 2 ] < bigEpsilon ) {
        q[ 0 ] = 1;
      }
      if ( q[ 3 ] * q[ 3 ] + q[ 4 ] * q[ 4 ] + q[ 5 ] * q[ 5 ] < bigEpsilon ) {
        q[ 4 ] = 1;
      }
      if ( q[ 6 ] * q[ 6 ] + q[ 7 ] * q[ 7 ] + q[ 8 ] * q[ 8 ] < bigEpsilon ) {
        q[ 8 ] = 1;
      }
    },

    /*---------------------------------------------------------------------------*
     * 3xN matrix math
     *----------------------------------------------------------------------------*/

    /*
     * Sets the 3xN result matrix to be made out of column vectors
     *
     * @param {Array.<Vector3>} columnVectors - [input] List of 3D column vectors
     * @param {FastMath.Array} result - [output] 3xN Matrix, where N is the number of column vectors
     */
    setVectors3: function( columnVectors, result ) {
      var m = 3;
      var n = columnVectors.length;

      assert && assert( result.length >= m * n, 'Array length check' );

      for ( var i = 0; i < n; i++ ) {
        var vector = columnVectors[ i ];
        result[ i ] = vector.x;
        result[ i + n ] = vector.y;
        result[ i + 2 * n ] = vector.z;
      }
    },

    /*
     * Retrieves column vector values from a 3xN matrix.
     *
     * @param {number} m - [input] The number of rows in the matrix (sanity check, should always be 3)
     * @param {number} n - [input] The number of columns in the matrix
     * @param {FastMath.Array} matrix - [input] 3xN Matrix
     * @param {number} columnIndex - [input] 3xN Matrix
     * @param {Vector3} result - [output] Vector to store the x,y,z
     */
    getColumnVector3: function( m, n, matrix, columnIndex, result ) {
      assert && assert( m === 3 && columnIndex < n );

      result.x = matrix[ columnIndex ];
      result.y = matrix[ columnIndex + n ];
      result.z = matrix[ columnIndex + 2 * n ];
    },

    /*---------------------------------------------------------------------------*
     * Arbitrary dimension matrix math
     *----------------------------------------------------------------------------*/

    /*
     * From 0-indexed row and column indices, returns the index into the flat array
     *
     * @param {number} m - Number of rows in the matrix
     * @param {number} n - Number of columns in the matrix
     * @param {number} row
     * @param {number} col
     */
    index: function( m, n, row, col ) {
      return n * row + col;
    },

    /*
     * Writes the transpose of the matrix into the result.
     *
     * @param {number} m - Number of rows in the original matrix
     * @param {number} n - Number of columns in the original matrix
     * @param {FastMath.Array} matrix - [input] MxN Matrix
     * @param {FastMath.Array} result - [output] NxM Matrix
     */
    transpose: function( m, n, matrix, result ) {
      assert && assert( matrix.length >= m * n );
      assert && assert( result.length >= n * m );
      assert && assert( matrix !== result, 'In-place modification not implemented yet' );

      for ( var row = 0; row < m; row++ ) {
        for ( var col = 0; col < n; col++ ) {
          result[ m * col + row ] = matrix[ n * row + col ];
        }
      }
    },

    /*
     * Writes the matrix multiplication of ( left * right ) into result
     *
     * @param {number} m - Number of rows in the left matrix
     * @param {number} n - Number of columns in the left matrix, number of rows in the right matrix
     * @param {number} p - Number of columns in the right matrix
     * @param {FastMath.Array} left - [input] MxN Matrix
     * @param {FastMath.Array} right - [input] NxP Matrix
     * @param {FastMath.Array} result - [output] MxP Matrix
     */
    mult: function( m, n, p, left, right, result ) {
      assert && assert( left.length >= m * n );
      assert && assert( right.length >= n * p );
      assert && assert( result.length >= m * p );
      assert && assert( left !== result && right !== result, 'In-place modification not implemented yet' );

      for ( var row = 0; row < m; row++ ) {
        for ( var col = 0; col < p; col++ ) {
          var x = 0;
          for ( var k = 0; k < n; k++ ) {
            x += left[ this.index( m, n, row, k ) ] * right[ this.index( n, p, k, col ) ];
          }
          result[ this.index( m, p, row, col ) ] = x;
        }
      }
    },

    /*
     * Writes the matrix multiplication of ( left * transpose( right ) ) into result
     *
     * @param {number} m - Number of rows in the left matrix
     * @param {number} n - Number of columns in the left matrix, number of columns in the right matrix
     * @param {number} p - Number of rows in the right matrix
     * @param {FastMath.Array} left - [input] MxN Matrix
     * @param {FastMath.Array} right - [input] PxN Matrix
     * @param {FastMath.Array} result - [output] MxP Matrix
     */
    multRightTranspose: function( m, n, p, left, right, result ) {
      assert && assert( left.length >= m * n );
      assert && assert( right.length >= n * p );
      assert && assert( result.length >= m * p );
      assert && assert( left !== result && right !== result, 'In-place modification not implemented yet' );

      for ( var row = 0; row < m; row++ ) {
        for ( var col = 0; col < p; col++ ) {
          var x = 0;
          for ( var k = 0; k < n; k++ ) {
            x += left[ this.index( m, n, row, k ) ] * right[ this.index( p, n, col, k ) ];
          }
          result[ this.index( m, p, row, col ) ] = x;
        }
      }
    },

    /*
     * Writes the matrix into the result, permuting the columns.
     *
     * @param {number} m - Number of rows in the original matrix
     * @param {number} n - Number of columns in the original matrix
     * @param {FastMath.Array} matrix - [input] MxN Matrix
     * @param {Permutation} permutation - [input] Permutation
     * @param {FastMath.Array} result - [output] MxN Matrix
     */
    permuteColumns: function( m, n, matrix, permutation, result ) {
      assert && assert( matrix !== result, 'In-place modification not implemented yet' );
      assert && assert( matrix.length >= m * n );
      assert && assert( result.length >= m * n );

      for ( var col = 0; col < n; col++ ) {
        var permutedColumnIndex = permutation.indices[ col ];
        for ( var row = 0; row < m; row++ ) {
          result[ this.index( m, n, row, col ) ] = matrix[ this.index( m, n, row, permutedColumnIndex ) ];
        }
      }
    }
  };
  dot.register( 'MatrixOps3', MatrixOps3 );

  return MatrixOps3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * An immutable permutation that can permute an array
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Permutation',['require','DOT/dot','PHET_CORE/isArray','DOT/Util'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var isArray = require( 'PHET_CORE/isArray' );
  require( 'DOT/Util' ); // for rangeInclusive

  // Creates a permutation that will rearrange a list so that newList[i] = oldList[permutation[i]]
  function Permutation( indices ) {
    this.indices = indices;
  }

  dot.register( 'Permutation', Permutation );

  // An identity permutation with a specific number of elements
  Permutation.identity = function( size ) {
    assert && assert( size >= 0 );
    var indices = new Array( size );
    for ( var i = 0; i < size; i++ ) {
      indices[ i ] = i;
    }
    return new Permutation( indices );
  };

  // lists all permutations that have a given size
  Permutation.permutations = function( size ) {
    var result = [];
    Permutation.forEachPermutation( dot.rangeInclusive( 0, size - 1 ), function( integers ) {
      result.push( new Permutation( integers ) );
    } );
    return result;
  };

  /**
   * Call our function with each permutation of the provided list PREFIXED by prefix, in lexicographic order
   *
   * @param array   List to generate permutations of
   * @param prefix   Elements that should be inserted at the front of each list before each call
   * @param callback Function to call
   */
  function recursiveForEachPermutation( array, prefix, callback ) {
    if ( array.length === 0 ) {
      callback( prefix );
    }
    else {
      for ( var i = 0; i < array.length; i++ ) {
        var element = array[ i ];

        // remove the element from the array
        var nextArray = array.slice( 0 );
        nextArray.splice( i, 1 );

        // add it into the prefix
        var nextPrefix = prefix.slice( 0 );
        nextPrefix.push( element );

        recursiveForEachPermutation( nextArray, nextPrefix, callback );
      }
    }
  }

  Permutation.forEachPermutation = function( array, callback ) {
    recursiveForEachPermutation( array, [], callback );
  };

  Permutation.prototype = {
    constructor: Permutation,

    size: function() {
      return this.indices.length;
    },

    apply: function( arrayOrInt ) {
      if ( isArray( arrayOrInt ) ) {
        if ( arrayOrInt.length !== this.size() ) {
          throw new Error( 'Permutation length ' + this.size() + ' not equal to list length ' + arrayOrInt.length );
        }

        // permute it as an array
        var result = new Array( arrayOrInt.length );
        for ( var i = 0; i < arrayOrInt.length; i++ ) {
          result[ i ] = arrayOrInt[ this.indices[ i ] ];
        }
        return result;
      }
      else {
        // permute a single index
        return this.indices[ arrayOrInt ];
      }
    },

    // The inverse of this permutation
    inverted: function() {
      var newPermutation = new Array( this.size() );
      for ( var i = 0; i < this.size(); i++ ) {
        newPermutation[ this.indices[ i ] ] = i;
      }
      return new Permutation( newPermutation );
    },

    withIndicesPermuted: function( indices ) {
      var result = [];
      var that = this;
      Permutation.forEachPermutation( indices, function( integers ) {
        var oldIndices = that.indices;
        var newPermutation = oldIndices.slice( 0 );

        for ( var i = 0; i < indices.length; i++ ) {
          newPermutation[ indices[ i ] ] = oldIndices[ integers[ i ] ];
        }
        result.push( new Permutation( newPermutation ) );
      } );
      return result;
    },

    toString: function() {
      return 'P[' + this.indices.join( ', ' ) + ']';
    }
  };

  Permutation.testMe = function( console ) {
    var a = new Permutation( [ 1, 4, 3, 2, 0 ] );
    console.log( a.toString() );

    var b = a.inverted();
    console.log( b.toString() );

    console.log( b.withIndicesPermuted( [ 0, 3, 4 ] ).toString() );

    console.log( Permutation.permutations( 4 ).toString() );
  };

  return Permutation;
} );

// Copyright 2014, University of Colorado Boulder

/**
 * A mathematical plane in 3 dimensions determined by a normal vector to the plane and the distance to the closest
 * point on the plane to the origin
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Plane3',['require','DOT/dot','DOT/Vector3'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var Vector3 = require( 'DOT/Vector3' );

  /*
   * @constructor
   * @param {Vector3} normal - A normal vector (perpendicular) to the plane
   * @param {number} distance - The signed distance to the plane from the origin, so that normal.times( distance )
   *                            will be a point on the plane.
   */
  function Plane3( normal, distance ) {
    this.normal = normal;
    this.distance = distance;

    assert && assert( Math.abs( normal.magnitude() - 1 ) < 0.01 );

    phetAllocation && phetAllocation( 'Plane3' );
  }

  dot.register( 'Plane3', Plane3 );

  Plane3.prototype = {
    constructor: Plane3,

    /*
     * @param {Ray3} ray
     * @returns The intersection {Vector3} of the ray with the plane
     */
    intersectWithRay: function( ray ) {
      return ray.pointAtDistance( ray.distanceToPlane( this ) );
    }
  };

  Plane3.XY = new Plane3( new Vector3( 0, 0, 1 ), 0 );
  Plane3.XZ = new Plane3( new Vector3( 0, 1, 0 ), 0 );
  Plane3.YZ = new Plane3( new Vector3( 1, 0, 0 ), 0 );

  /*
   * @param {Vector3} a - first point
   * @param {Vector3} b - second point
   * @param {Vector3} c - third point
   */
  Plane3.fromTriangle = function( a, b, c ) {
    var normal = ( c.minus( a ) ).cross( b.minus( a ) );
    if ( normal.magnitude() === 0 ) {
      return null;
    }
    normal.normalize();

    return new Plane3( normal, normal.dot( a ) );
  };

  return Plane3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Quaternion, see http://en.wikipedia.org/wiki/Quaternion
 *
 * TODO: convert from JME-style parameterization into classical mathematical description?
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Quaternion',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector3','DOT/Matrix3','DOT/Util'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var Poolable = require( 'PHET_CORE/Poolable' );
  require( 'DOT/Vector3' );
  require( 'DOT/Matrix3' );
  require( 'DOT/Util' );

  function Quaternion( x, y, z, w ) {
    this.setXYZW( x, y, z, w );

    phetAllocation && phetAllocation( 'Quaternion' );
  }

  dot.register( 'Quaternion', Quaternion );

  Quaternion.prototype = {
    constructor: Quaternion,

    isQuaternion: true,

    setXYZW: function( x, y, z, w ) {
      this.x = x !== undefined ? x : 0;
      this.y = y !== undefined ? y : 0;
      this.z = z !== undefined ? z : 0;
      this.w = w !== undefined ? w : 1;
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *----------------------------------------------------------------------------*/

    plus: function( quat ) {
      return new Quaternion( this.x + quat.x, this.y + quat.y, this.z + quat.z, this.w + quat.w );
    },

    timesScalar: function( s ) {
      return new Quaternion( this.x * s, this.y * s, this.z * s, this.w * s );
    },

    // standard quaternion multiplication (hamilton product)
    timesQuaternion: function( quat ) {
      // TODO: note why this is the case? product noted everywhere is the other one mentioned!
      // mathematica-style
//        return new Quaternion(
//                this.x * quat.x - this.y * quat.y - this.z * quat.z - this.w * quat.w,
//                this.x * quat.y + this.y * quat.x + this.z * quat.w - this.w * quat.z,
//                this.x * quat.z - this.y * quat.w + this.z * quat.x + this.w * quat.y,
//                this.x * quat.w + this.y * quat.z - this.z * quat.y + this.w * quat.x
//        );

      // JME-style
      return new Quaternion(
        this.x * quat.w - this.z * quat.y + this.y * quat.z + this.w * quat.x,
        -this.x * quat.z + this.y * quat.w + this.z * quat.x + this.w * quat.y,
        this.x * quat.y - this.y * quat.x + this.z * quat.w + this.w * quat.z,
        -this.x * quat.x - this.y * quat.y - this.z * quat.z + this.w * quat.w
      );

      /*
       Mathematica!
       In[13]:= Quaternion[-0.0, -0.0024999974, 0.0, 0.9999969] ** Quaternion[-0.9864071, 0.0016701065, -0.0050373166, 0.16423558]
       Out[13]= Quaternion[-0.164231, 0.00750332, 0.00208069, -0.986391]

       In[17]:= Quaternion[-0.0024999974, 0.0, 0.9999969, 0] ** Quaternion[0.0016701065, -0.0050373166, 0.16423558, -0.9864071]
       Out[17]= Quaternion[-0.164239, -0.986391, 0.00125951, 0.00750332]

       JME contains the rearrangement of what is typically called {w,x,y,z}
       */
    },

    timesVector3: function( v ) {
      if ( v.magnitude() === 0 ) {
        return new dot.Vector3();
      }

      // TODO: optimization?
      return new dot.Vector3(
        this.w * this.w * v.x + 2 * this.y * this.w * v.z - 2 * this.z * this.w * v.y + this.x * this.x * v.x + 2 * this.y * this.x * v.y + 2 * this.z * this.x * v.z - this.z * this.z * v.x - this.y * this.y * v.x,
        2 * this.x * this.y * v.x + this.y * this.y * v.y + 2 * this.z * this.y * v.z + 2 * this.w * this.z * v.x - this.z * this.z * v.y + this.w * this.w * v.y - 2 * this.x * this.w * v.z - this.x * this.x * v.y,
        2 * this.x * this.z * v.x + 2 * this.y * this.z * v.y + this.z * this.z * v.z - 2 * this.w * this.y * v.x - this.y * this.y * v.z + 2 * this.w * this.x * v.y - this.x * this.x * v.z + this.w * this.w * v.z
      );
    },

    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    magnitudeSquared: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },

    normalized: function() {
      var magnitude = this.magnitude();
      assert && assert( magnitude !== 0, 'Cannot normalize a zero-magnitude quaternion' );
      return this.timesScalar( 1 / magnitude );
    },

    negated: function() {
      return new Quaternion( -this.x, -this.y, -this.z, -this.w );
    },

    toRotationMatrix: function() {
      // see http://en.wikipedia.org/wiki/Rotation_matrix#Quaternion

      var norm = this.magnitudeSquared();
      var flip = ( norm === 1 ) ? 2 : ( norm > 0 ) ? 2 / norm : 0;

      var xx = this.x * this.x * flip;
      var xy = this.x * this.y * flip;
      var xz = this.x * this.z * flip;
      var xw = this.w * this.x * flip;
      var yy = this.y * this.y * flip;
      var yz = this.y * this.z * flip;
      var yw = this.w * this.y * flip;
      var zz = this.z * this.z * flip;
      var zw = this.w * this.z * flip;

      return dot.Matrix3.dirtyFromPool().columnMajor(
        1 - ( yy + zz ),
        ( xy + zw ),
        ( xz - yw ),
        ( xy - zw ),
        1 - ( xx + zz ),
        ( yz + xw ),
        ( xz + yw ),
        ( yz - xw ),
        1 - ( xx + yy )
      );
    }
  };

  Quaternion.fromEulerAngles = function( yaw, roll, pitch ) {
    var sinPitch = Math.sin( pitch * 0.5 );
    var cosPitch = Math.cos( pitch * 0.5 );
    var sinRoll = Math.sin( roll * 0.5 );
    var cosRoll = Math.cos( roll * 0.5 );
    var sinYaw = Math.sin( yaw * 0.5 );
    var cosYaw = Math.cos( yaw * 0.5 );

    var a = cosRoll * cosPitch;
    var b = sinRoll * sinPitch;
    var c = cosRoll * sinPitch;
    var d = sinRoll * cosPitch;

    return new Quaternion(
      a * sinYaw + b * cosYaw,
      d * cosYaw + c * sinYaw,
      c * cosYaw - d * sinYaw,
      a * cosYaw - b * sinYaw
    );
  };

  Quaternion.fromRotationMatrix = function( matrix ) {
    var v00 = matrix.m00();
    var v01 = matrix.m01();
    var v02 = matrix.m02();
    var v10 = matrix.m10();
    var v11 = matrix.m11();
    var v12 = matrix.m12();
    var v20 = matrix.m20();
    var v21 = matrix.m21();
    var v22 = matrix.m22();

    // from graphics gems code
    var trace = v00 + v11 + v22;
    var sqt;

    // we protect the division by s by ensuring that s>=1
    if ( trace >= 0 ) {
      sqt = Math.sqrt( trace + 1 );
      return new Quaternion(
        ( v21 - v12 ) * 0.5 / sqt,
        ( v02 - v20 ) * 0.5 / sqt,
        ( v10 - v01 ) * 0.5 / sqt,
        0.5 * sqt
      );
    }
    else if ( ( v00 > v11 ) && ( v00 > v22 ) ) {
      sqt = Math.sqrt( 1 + v00 - v11 - v22 );
      return new Quaternion(
        sqt * 0.5,
        ( v10 + v01 ) * 0.5 / sqt,
        ( v02 + v20 ) * 0.5 / sqt,
        ( v21 - v12 ) * 0.5 / sqt
      );
    }
    else if ( v11 > v22 ) {
      sqt = Math.sqrt( 1 + v11 - v00 - v22 );
      return new Quaternion(
        ( v10 + v01 ) * 0.5 / sqt,
        sqt * 0.5,
        ( v21 + v12 ) * 0.5 / sqt,
        ( v02 - v20 ) * 0.5 / sqt
      );
    }
    else {
      sqt = Math.sqrt( 1 + v22 - v00 - v11 );
      return new Quaternion(
        ( v02 + v20 ) * 0.5 / sqt,
        ( v21 + v12 ) * 0.5 / sqt,
        sqt * 0.5,
        ( v10 - v01 ) * 0.5 / sqt
      );
    }
  };

  /**
   * Find a quaternion that transforms a unit vector A into a unit vector B. There
   * are technically multiple solutions, so this only picks one.
   *
   * @param a Unit vector A
   * @param b Unit vector B
   * @return A quaternion s.t. Q * A = B
   */
  Quaternion.getRotationQuaternion = function( a, b ) {
    return Quaternion.fromRotationMatrix( dot.Matrix3.rotateAToB( a, b ) );
  };

  // spherical linear interpolation - blending two quaternions
  Quaternion.slerp = function( a, b, t ) {
    // if they are identical, just return one of them
    if ( a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w ) {
      return a;
    }

    var dot = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;

    if ( dot < 0 ) {
      b = b.negated();
      dot = -dot;
    }

    // how much of each quaternion should be contributed
    var ratioA = 1 - t;
    var ratioB = t;

    // tweak them if necessary
    if ( ( 1 - dot ) > 0.1 ) {
      var theta = Math.acos( dot );
      var invSinTheta = ( 1 / Math.sin( theta ) );

      ratioA = ( Math.sin( ( 1 - t ) * theta ) * invSinTheta );
      ratioB = ( Math.sin( ( t * theta ) ) * invSinTheta );
    }

    return new Quaternion(
      ratioA * a.x + ratioB * b.x,
      ratioA * a.y + ratioB * b.y,
      ratioA * a.z + ratioB * b.z,
      ratioA * a.w + ratioB * b.w
    );
  };

  Poolable.mixin( Quaternion, {
    defaultFactory: function() { return new Quaternion(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y, z, w ) {
        if ( pool.length ) {
          return pool.pop().set( x, y, z, w );
        }
        else {
          return new Quaternion( x, y, z, w );
        }
      };
    }
  } );

  return Quaternion;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Random number generator with an optional seed.
 *
 * @author John Blanco
 * @author Mohamed Safi
 * @author Aaron Davis
 * @author Sam Reid
 */
define( 'DOT/Random',['require','DOT/Util','DOT/dot'],function( require ) {
  'use strict';

  // modules
  var Util = require( 'DOT/Util' );
  var dot = require( 'DOT/dot' );

  function Random( options ) {
    options = _.extend( {

      // {Tandem} for deterministic playback in randomized sims
      tandem: null,

      // {number|null} seed for the random number generator.
      //               when seed is null, Math.random() is used
      seed: null,

      // {boolean} if true, use the seed specified statically in the preloads for replicable playback in phet-io
      // this is a convenience option since it will be a common occurrence to use the replicable playback seed
      // if staticSeed and seed are both specified, there will be an assertion error.
      staticSeed: false

    }, options );

    if ( options.seed !== null && options.staticSeed ) {
      assert && assert( false, 'cannot specify seed and useChipperSeed, use one or the other' );
    }

    var seed = options.staticSeed ? window.phet.chipper.randomSeed : options.seed;
    this.setSeed( seed );

    options.tandem && options.tandem.addInstance( this );
  }

  dot.register( 'Random', Random );

  Random.prototype = {

    constructor: Random,

    /**
     * Re-seed the random number generator, or null to use Math.random()
     * @param seed
     */
    setSeed: function( seed ) {
      this.seed = seed;

      // Use "new" to create a local prng without altering Math.random.
      this.seedrandom = this.seed !== null ? new Math.seedrandom( this.seed + '' ) : null;
    },

    getSeed: function() {
      return this.seed;
    },

    random: function() {
      return this.seed === null ? Math.random() : this.seedrandom();
    },

    nextBoolean: function() {
      return this.random() >= 0.5;
    },

    nextInt: function( n ) {
      var value = this.random() * n;
      return value | 0; // convert to int
    },

    nextDouble: function() {
      var vv = this.random();
      return vv;
    },

    /**
     * @public
     * @returns {number}
     * // TODO: Seed this
     */
    nextGaussian: function() {
      // random gaussian with mean = 0 and standard deviation = 1
      return Util.boxMullerTransform( 0, 1 );
    }
  };

  return Random;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * 3-dimensional ray
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Ray3',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  function Ray3( position, direction ) {
    this.position = position;
    this.direction = direction;
  }

  dot.register( 'Ray3', Ray3 );

  Ray3.prototype = {
    constructor: Ray3,

    shifted: function( distance ) {
      return new Ray3( this.pointAtDistance( distance ), this.direction );
    },

    pointAtDistance: function( distance ) {
      return this.position.plus( this.direction.timesScalar( distance ) );
    },

    // @param {Plane3} plane
    distanceToPlane: function( plane ) {
      return ( plane.distance - this.position.dot( plane.normal ) ) / this.direction.dot( plane.normal );
    },

    toString: function() {
      return this.position.toString() + ' => ' + this.direction.toString();
    }
  };

  return Ray3;
} );

// Copyright 2013-2014, University of Colorado Boulder

/**
 * A 2D rectangle-shaped bounded area, with a convenience name and constructor. Totally functionally
 * equivalent to Bounds2, but with a different constructor.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Rectangle',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );

  function Rectangle( x, y, width, height ) {
    assert && assert( height !== undefined, 'Rectangle requires 4 parameters' );
    Bounds2.call( this, x, y, x + width, y + height );
  }

  dot.register( 'Rectangle', Rectangle );

  inherit( Bounds2, Rectangle );

  return Rectangle;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * A sphere in 3 dimensions (NOT a 3-sphere).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Sphere3',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  /*
   * @constructor
   * @param {Vector3} center - The center of the sphere
   * @param {number} radius - The radius of the sphere
   */
  function Sphere3( center, radius ) {
    this.center = center;
    this.radius = radius;

    assert && assert( radius >= 0 );

    phetAllocation && phetAllocation( 'Sphere3' );
  }

  dot.register( 'Sphere3', Sphere3 );

  Sphere3.prototype = {
    constructor: Sphere3,

    /*
     * @param {Ray3} ray - The ray to intersect with the sphere
     * @param {number} epsilon - A small varing-point value to be used to handle intersections tangent to the sphere
     * @returns An intersection result { distance, hitPoint, normal, fromOutside }, or null if the sphere is behind the ray
     */
    intersect: function( ray, epsilon ) {
      var raydir = ray.direction;
      var pos = ray.position;
      var centerToRay = pos.minus( this.center );

      // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)
      var tmp = raydir.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this.radius * this.radius );
      if ( det < epsilon ) {
        // ray misses sphere entirely
        return null;
      }

      var base = raydir.dot( this.center ) - raydir.dot( pos );
      var sqt = Math.sqrt( det ) / 2;

      // the "first" entry point distance into the sphere. if we are inside the sphere, it is behind us
      var ta = base - sqt;

      // the "second" entry point distance
      var tb = base + sqt;

      if ( tb < epsilon ) {
        // sphere is behind ray, so don't return an intersection
        return null;
      }

      var hitPositionB = ray.pointAtDistance( tb );
      var normalB = hitPositionB.minus( this.center ).normalized();

      if ( ta < epsilon ) {
        // we are inside the sphere
        // in => out
        return {
          distance: tb,
          hitPoint: hitPositionB,
          normal: normalB.negated(),
          fromOutside: false
        };
      }
      else {
        // two possible hits
        var hitPositionA = ray.pointAtDistance( ta );
        var normalA = hitPositionA.minus( this.center ).normalized();

        // close hit, we have out => in
        return {
          distance: ta,
          hitPoint: hitPositionA,
          normal: normalA,
          fromOutside: true
        };
      }
    },

    /*
     * @param {Ray3} ray - The ray to intersect with the sphere
     * @param {number} epsilon - A small varing-point value to be used to handle intersections tangent to the sphere
     * @returns An array of intersection results like { distance, hitPoint, normal, fromOutside }. Will be 0 or 2, with
     *          the "proper" intersection first, if applicable (closest in front of the ray).
     */
    intersections: function( ray, epsilon ) {
      var raydir = ray.direction;
      var pos = ray.position;
      var centerToRay = pos.minus( this.center );

      // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)
      var tmp = raydir.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this.radius * this.radius );
      if ( det < epsilon ) {
        // ray misses sphere entirely
        return [];
      }

      var base = raydir.dot( this.center ) - raydir.dot( pos );
      var sqt = Math.sqrt( det ) / 2;

      // the "first" entry point distance into the sphere. if we are inside the sphere, it is behind us
      var ta = base - sqt;

      // the "second" entry point distance
      var tb = base + sqt;

      if ( tb < epsilon ) {
        // sphere is behind ray, so don't return an intersection
        return [];
      }

      var hitPositionB = ray.pointAtDistance( tb );
      var normalB = hitPositionB.minus( this.center ).normalized();

      var hitPositionA = ray.pointAtDistance( ta );
      var normalA = hitPositionA.minus( this.center ).normalized();

      var resultB = {
        distance: tb,
        hitPoint: hitPositionB,
        normal: normalB.negated(),
        fromOutside: false
      };
      var resultA = {
        distance: ta,
        hitPoint: hitPositionA,
        normal: normalA,
        fromOutside: true
      };
      if ( ta < epsilon ) {
        // we are inside the sphere
        // in => out

        return [ resultB, resultA ];
      }
      else {
        // two possible hits

        // close hit, we have out => in
        return [ resultA, resultB ];
      }
    }
  };

  return Sphere3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Forward and inverse transforms with 4x4 matrices, allowing flexibility including affine and perspective transformations.
 *
 * Methods starting with 'transform' will apply the transform from our
 * primary matrix, while methods starting with 'inverse' will apply the transform from the inverse of our matrix.
 *
 * Generally, this means transform.inverseThing( transform.transformThing( thing ) ).equals( thing ).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Transform4',['require','DOT/dot','AXON/Events','PHET_CORE/inherit','DOT/Matrix4','DOT/Vector3','DOT/Ray3'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var Events = require( 'AXON/Events' );
  var inherit = require( 'PHET_CORE/inherit' );

  require( 'DOT/Matrix4' );
  require( 'DOT/Vector3' );
  require( 'DOT/Ray3' );

  var scratchMatrix = new dot.Matrix4();

  function checkMatrix( matrix ) {
    return ( matrix instanceof dot.Matrix4 ) && matrix.isFinite();
  }

  /**
   * Creates a transform based around an initial matrix.
   * @constructor
   * @public
   *
   * @param {Matrix4} matrix
   */
  function Transform4( matrix ) {
    Events.call( this );

    // @private {Matrix4} - The primary matrix used for the transform
    this.matrix = dot.Matrix4.IDENTITY.copy();

    // @private {Matrix4} - The inverse of the primary matrix, computed lazily
    this.inverse = dot.Matrix4.IDENTITY.copy();

    // @private {Matrix4} - The transpose of the primary matrix, computed lazily
    this.matrixTransposed = dot.Matrix4.IDENTITY.copy();

    // @private {Matrix4} - The inverse of the transposed primary matrix, computed lazily
    this.inverseTransposed = dot.Matrix4.IDENTITY.copy();


    // @private {boolean} - Whether this.inverse has been computed based on the latest primary matrix
    this.inverseValid = true;

    // @private {boolean} - Whether this.matrixTransposed has been computed based on the latest primary matrix
    this.transposeValid = true;

    // @private {boolean} - Whether this.inverseTransposed has been computed based on the latest primary matrix
    this.inverseTransposeValid = true;

    if ( matrix ) {
      this.setMatrix( matrix );
    }

    phetAllocation && phetAllocation( 'Transform4' );
  }

  dot.register( 'Transform4', Transform4 );

  inherit( Events, Transform4, {
    /*---------------------------------------------------------------------------*
     * mutators
     *---------------------------------------------------------------------------*/

    /**
     * Sets the value of the primary matrix directly from a Matrix4. Does not change the Matrix4 instance of this
     * Transform4.
     * @public
     *
     * @param {Matrix4} matrix
     */
    setMatrix: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      // copy the matrix over to our matrix
      this.matrix.set( matrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * This should be called after our internal matrix is changed. It marks the other dependent matrices as invalid,
     * and sends out notifications of the change.
     * @private
     */
    invalidate: function() {
      // sanity check
      assert && assert( this.matrix.isFinite() );

      // dependent matrices now invalid
      this.inverseValid = false;
      this.transposeValid = false;
      this.inverseTransposeValid = false;

      this.trigger0( 'change' );
    },

    /**
     * Modifies the primary matrix such that: this.matrix = matrix * this.matrix.
     * @public
     *
     * @param {Matrix4} matrix
     */
    prepend: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      // In the absence of a prepend-multiply function in Matrix4, copy over to a scratch matrix instead
      // TODO: implement a prepend-multiply directly in Matrix4 for a performance increase
      scratchMatrix.set( this.matrix );
      this.matrix.set( matrix );
      this.matrix.multiplyMatrix( scratchMatrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * Modifies the primary matrix such that: this.matrix = this.matrix * matrix
     * @public
     *
     * @param {Matrix4} matrix
     */
    append: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      this.matrix.multiplyMatrix( matrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * Like prepend(), but prepends the other transform's matrix.
     * @public
     *
     * @param {Transform4} transform
     */
    prependTransform: function( transform ) {
      this.prepend( transform.matrix );
    },

    /**
     * Like append(), but appends the other transform's matrix.
     * @public
     *
     * @param {Transform4} transform
     */
    appendTransform: function( transform ) {
      this.append( transform.matrix );
    },

    /**
     * Sets the transform of a Canvas context to be equivalent to the 2D affine part of this transform.
     * @public
     *
     * @param {CanvasRenderingContext2D} context
     */
    applyToCanvasContext: function( context ) {
      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m03(), this.matrix.m13() );
    },

    /*---------------------------------------------------------------------------*
     * getters
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this transform.
     * @public
     *
     * @returns {Transform4}
     */
    copy: function() {
      var transform = new Transform4( this.matrix );

      transform.inverse = this.inverse;
      transform.matrixTransposed = this.matrixTransposed;
      transform.inverseTransposed = this.inverseTransposed;

      transform.inverseValid = this.inverseValid;
      transform.transposeValid = this.transposeValid;
      transform.inverseTransposeValid = this.inverseTransposeValid;
    },

    /**
     * Returns the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix4}
     */
    getMatrix: function() {
      return this.matrix;
    },

    /**
     * Returns the inverse of the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix4}
     */
    getInverse: function() {
      if ( !this.inverseValid ) {
        this.inverseValid = true;

        this.inverse.set( this.matrix );
        this.inverse.invert();
      }
      return this.inverse;
    },

    /**
     * Returns the transpose of the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix4}
     */
    getMatrixTransposed: function() {
      if ( !this.transposeValid ) {
        this.transposeValid = true;

        this.matrixTransposed.set( this.matrix );
        this.matrixTransposed.transpose();
      }
      return this.matrixTransposed;
    },

    /**
     * Returns the inverse of the transpose of matrix of this transform.
     * @public
     *
     * @returns {Matrix4}
     */
    getInverseTransposed: function() {
      if ( !this.inverseTransposeValid ) {
        this.inverseTransposeValid = true;

        this.inverseTransposed.set( this.getInverse() ); // triggers inverse to be valid
        this.inverseTransposed.transpose();
      }
      return this.inverseTransposed;
    },

    /**
     * Returns whether our primary matrix is known to be an identity matrix. If false is returned, it doesn't necessarily
     * mean our matrix isn't an identity matrix, just that it is unlikely in normal usage.
     * @public
     *
     * @returns {boolean}
     */
    isIdentity: function() {
      return this.matrix.type === dot.Matrix4.Types.IDENTITY;
    },

    /**
     * Returns whether any components of our primary matrix are either infinite or NaN.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return this.matrix.isFinite();
    },

    /*---------------------------------------------------------------------------*
     * forward transforms (for Vector3 or scalar)
     *---------------------------------------------------------------------------*/

    /**
     * Transforms a 3-dimensional vector like it is a point with a position (translation is applied).
     * @public
     *
     * For an affine matrix $M$, the result is the homogeneous multiplication $M\begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix}$.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    transformPosition3: function( v ) {
      return this.matrix.timesVector3( v );
    },

    /**
     * Transforms a 3-dimensional vector like position is irrelevant (translation is not applied).
     * @public
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    transformDelta3: function( v ) {
      return this.matrix.timesRelativeVector3( v );
    },

    /**
     * Transforms a 3-dimensional vector like it is a normal to a surface (so that the surface is transformed, and the new
     * normal to the surface at the transformed point is returned).
     * @public
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    transformNormal3: function( v ) {
      return this.getInverse().timesTransposeVector3( v );
    },

    /**
     * Returns the x-coordinate difference for two transformed vectors, which add the x-coordinate difference of the input
     * x (and same y,z values) beforehand.
     * @public
     *
     * @param {number} x
     * @returns {number}
     */
    transformDeltaX: function( x ) {
      return this.transformDelta3( new dot.Vector3( x, 0, 0 ) ).x;
    },

    /**
     * Returns the y-coordinate difference for two transformed vectors, which add the y-coordinate difference of the input
     * y (and same x,z values) beforehand.
     * @public
     *
     * @param {number} y
     * @returns {number}
     */
    transformDeltaY: function( y ) {
      return this.transformDelta3( new dot.Vector3( 0, y, 0 ) ).y;
    },

    /**
     * Returns the z-coordinate difference for two transformed vectors, which add the z-coordinate difference of the input
     * z (and same x,y values) beforehand.
     * @public
     *
     * @param {number} z
     * @returns {number}
     */
    transformDeltaZ: function( z ) {
      return this.transformDelta3( new dot.Vector3( 0, 0, z ) ).z;
    },

    /**
     * Returns a transformed ray.
     * @pubic
     *
     * @param {Ray3} ray
     * @returns {Ray3}
     */
    transformRay: function( ray ) {
      return new dot.Ray3(
        this.transformPosition3( ray.position ),
        this.transformPosition3( ray.position.plus( ray.direction ) ).minus( this.transformPosition3( ray.position ) ) );
    },

    /*---------------------------------------------------------------------------*
     * inverse transforms (for Vector3 or scalar)
     *---------------------------------------------------------------------------*/

    /**
     * Transforms a 3-dimensional vector by the inverse of our transform like it is a point with a position (translation is applied).
     * @public
     *
     * For an affine matrix $M$, the result is the homogeneous multiplication $M^{-1}\begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix}$.
     *
     * This is the inverse of transformPosition3().
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    inversePosition3: function( v ) {
      return this.getInverse().timesVector3( v );
    },

    /**
     * Transforms a 3-dimensional vector by the inverse of our transform like position is irrelevant (translation is not applied).
     * @public
     *
     * This is the inverse of transformDelta3().
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    inverseDelta3: function( v ) {
      // inverse actually has the translation rolled into the other coefficients, so we have to make this longer
      return this.inversePosition3( v ).minus( this.inversePosition3( dot.Vector3.ZERO ) );
    },

    /**
     * Transforms a 3-dimensional vector by the inverse of our transform like it is a normal to a curve (so that the
     * curve is transformed, and the new normal to the curve at the transformed point is returned).
     * @public
     *
     * This is the inverse of transformNormal3().
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    inverseNormal3: function( v ) {
      return this.matrix.timesTransposeVector3( v );
    },

    /**
     * Returns the x-coordinate difference for two inverse-transformed vectors, which add the x-coordinate difference of the input
     * x (and same y,z values) beforehand.
     * @public
     *
     * This is the inverse of transformDeltaX().
     *
     * @param {number} x
     * @returns {number}
     */
    inverseDeltaX: function( x ) {
      return this.inverseDelta3( new dot.Vector3( x, 0, 0 ) ).x;
    },

    /**
     * Returns the y-coordinate difference for two inverse-transformed vectors, which add the y-coordinate difference of the input
     * y (and same x,z values) beforehand.
     * @public
     *
     * This is the inverse of transformDeltaY().
     *
     * @param {number} y
     * @returns {number}
     */
    inverseDeltaY: function( y ) {
      return this.inverseDelta3( new dot.Vector3( 0, y, 0 ) ).y;
    },

    /**
     * Returns the z-coordinate difference for two inverse-transformed vectors, which add the z-coordinate difference of the input
     * z (and same x,y values) beforehand.
     * @public
     *
     * This is the inverse of transformDeltaZ().
     *
     * @param {number} z
     * @returns {number}
     */
    inverseDeltaZ: function( z ) {
      return this.inverseDelta3( new dot.Vector3( 0, 0, z ) ).z;
    },

    /**
     * Returns an inverse-transformed ray.
     * @pubic
     *
     * This is the inverse of transformRay()
     *
     * @param {Ray3} ray
     * @returns {Ray3}
     */
    inverseRay: function( ray ) {
      return new dot.Ray3(
        this.inversePosition3( ray.position ),
        this.inversePosition3( ray.position.plus( ray.direction ) ).minus( this.inversePosition3( ray.position ) )
      );
    }
  } );

  return Transform4;
} );

// Copyright 2013-2015, University of Colorado Boulder

define( 'DOT/main',[
  'DOT/dot',
  'DOT/BinPacker',
  'DOT/Bounds2',
  'DOT/Bounds3',
  'DOT/Complex',
  'DOT/ConvexHull2',
  'DOT/Dimension2',
  'DOT/EigenvalueDecomposition',
  'DOT/LinearFunction',
  'DOT/LUDecomposition',
  'DOT/Matrix',
  'DOT/Matrix3',
  'DOT/Matrix4',
  'DOT/MatrixOps3',
  'DOT/Permutation',
  'DOT/Plane3',
  'DOT/QRDecomposition',
  'DOT/Quaternion',
  'DOT/Random',
  'DOT/Ray2',
  'DOT/Ray3',
  'DOT/Rectangle',
  'DOT/SingularValueDecomposition',
  'DOT/Sphere3',
  'DOT/Transform3',
  'DOT/Transform4',
  'DOT/Util',
  'DOT/Vector2',
  'DOT/Vector3',
  'DOT/Vector4'
], function( dot ) {
  'use strict';
  return dot;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A DerivedProperty is computed based on other properties.  This implementation inherits from Property to (a) simplify
 * implementation and (b) ensure it remains consistent. Note that the setters should not be called directly, so the
 * setters (set, reset and es5 setter) throw an error if used directly.
 *
 * @author Sam Reid
 */

define( 'AXON/DerivedProperty',['require','AXON/Property','AXON/axon','PHET_CORE/inherit'],function( require ) {
  'use strict';

  // modules
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );

  function equalsFunction( a, b ) {
    return a === b;
  }

  function notFunction( a ) {
    return !a;
  }

  function conjunctionWithProperty( value, property ) {
    return value && property.value;
  }

  function disjunctionWithProperty( value, property ) {
    return value || property.value;
  }

  function addWithProperty( value, property ) {
    return value + property.value;
  }

  function multiplyWithProperty( value, property ) {
    return value * property.value;
  }

  /**
   * @param {Property[]} dependencies - properties that this property's value is derived from
   * @param {function} derivation - function that derives this property's value, expects args in the same order as dependencies
   * @param {Object} [options] - see Property
   * @constructor
   */
  function DerivedProperty( dependencies, derivation, options ) {

    this.dependencies = dependencies; // @private

    // @private Keep track of each dependency and only update the changed value, for speed
    this.dependencyValues = dependencies.map( function( property ) {return property.get();} );

    var initialValue = derivation.apply( null, this.dependencyValues );
    Property.call( this, initialValue, options );

    var derivedProperty = this;

    // @private Keep track of listeners so they can be detached
    this.dependencyListeners = [];

    for ( var i = 0; i < dependencies.length; i++ ) {
      var dependency = dependencies[ i ];
      (function( dependency, i ) {
        var listener = function( newValue ) {
          derivedProperty.dependencyValues[ i ] = newValue;
          Property.prototype.set.call( derivedProperty, derivation.apply( null, derivedProperty.dependencyValues ) );
        };
        derivedProperty.dependencyListeners.push( listener );
        dependency.lazyLink( listener );
      })( dependency, i );
    }
  }

  axon.register( 'DerivedProperty', DerivedProperty );

  return inherit( Property, DerivedProperty, {

    // @public
    dispose: function() {

      Property.prototype.dispose.call( this );

      // Unlink from dependent properties
      for ( var i = 0; i < this.dependencies.length; i++ ) {
        var dependency = this.dependencies[ i ];
        dependency.unlink( this.dependencyListeners[ i ] );
      }
      this.dependencies = null;
      this.dependencyListeners = null;
      this.dependencyValues = null;
    },

    /**
     * Override the mutators to provide an error message.  These should not be called directly,
     * the value should only be modified when the dependencies change.
     * @param value
     * @override
     * @public
     */
    set: function( value ) { throw new Error( 'Cannot set values directly to a derived property, tried to set: ' + value ); },

    /**
     * Override the mutators to provide an error message.  These should not be called directly, the value should only be modified
     * when the dependencies change. Keep the newValue output in the string so the argument won't be stripped by minifier
     * (which would cause crashes like https://github.com/phetsims/axon/issues/15)
     * @param newValue
     * @override
     * @public
     */
    set value( newValue ) { throw new Error( 'Cannot es5-set values directly to a derived property, tried to set: ' + newValue ); },

    /**
     * Override get value as well to satisfy the linter which wants get/set pairs (even though it just uses the same code as the superclass).
     * @returns {*}
     * @override
     * @public
     */
    get value() {return Property.prototype.get.call( this );},

    /**
     * Override the mutators to provide an error message.  These should not be called directly,
     * the value should only be modified when the dependencies change.
     * @override
     * @public
     */
    reset: function() { throw new Error( 'Cannot reset a derived property directly' ); }
  }, {

    /**
     * Creates a derived boolean property whose value is true iff firstProperty's value is equal to secondPropert's
     * value.
     * @public
     *
     * @param {Property.<*>} firstProperty
     * @param {Property.<*>} secondProperty
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<boolean>}
     */
    valueEquals: function( firstProperty, secondProperty, options ) {
      return new DerivedProperty( [ firstProperty, secondProperty ], equalsFunction, options );
    },

    /**
     * Creates a derived boolean property whose value is true iff every input property value is true.
     * @public
     *
     * @param {Array.<Property.<boolean>>} properties
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<boolean>}
     */
    and: function( properties, options ) {
      return new DerivedProperty( properties, _.reduce.bind( null, properties, conjunctionWithProperty, true ), options ); // TODO: fix
    },

    /**
     * Creates a derived boolean property whose value is true iff any input property value is true.
     * @public
     *
     * @param {Array.<Property.<boolean>>} properties
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<boolean>}
     */
    or: function( properties, options ) {
      return new DerivedProperty( properties, _.reduce.bind( null, properties, disjunctionWithProperty, false ), options );
    },

    /**
     * Creates a derived number property whose value is the sum of all input property values (or 0 if no properties
     * are specified).
     * @public
     *
     * @param {Array.<Property.<number>>}
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<number>}
     */
    sum: function( properties, options ) {
      return new DerivedProperty( properties, _.reduce.bind( null, properties, addWithProperty, 0 ), options );
    },

    /**
     * Creates a derived number property whose value is the sum of both input property values.
     * @public
     *
     * @param {Property.<number>} firstProperty
     * @param {Property.<number>} secondProperty
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<number>}
     */
    plus: function( firstProperty, secondProperty, options ) {
      return DerivedProperty.sum( [ firstProperty, secondProperty ], options );
    },

    /**
     * Creates a derived number property whose value is the product of all input property values (or 1 if no properties
     * are specified).
     * @public
     *
     * @param {Array.<Property.<number>>}
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<number>}
     */
    product: function( properties, options ) {
      return new DerivedProperty( properties, _.reduce.bind( null, properties, multiplyWithProperty, 1 ), options );
    },

    /**
     * Creates a derived number property whose value is the product of both input property values.
     * @public
     *
     * @param {Property.<number>} firstProperty
     * @param {Property.<number>} secondProperty
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<number>}
     */
    times: function( firstProperty, secondProperty, options ) {
      return DerivedProperty.product( [ firstProperty, secondProperty ], options );
    },

    /**
     * Creates a derived boolean property whose value is true iff firstProperty's value is strictly less than the input
     * numeric value.
     * @public
     *
     * @param {Property.<number>} property
     * @param {number} number
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<boolean>}
     */
    lessThanNumber: function( property, number, options ) {
      return new DerivedProperty( [ property ], function( value ) { return value < number; }, options );
    },

    /**
     * Creates a derived boolean property whose value is true iff firstProperty's value is less than or equal to the
     * input numeric value.
     * @public
     *
     * @param {Property.<number>} property
     * @param {number} number
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<boolean>}
     */
    lessThanEqualNumber: function( property, number, options ) {
      return new DerivedProperty( [ property ], function( value ) { return value <= number; }, options );
    },

    /**
     * Creates a derived boolean property whose value is true iff firstProperty's value is strictly greater than the
     * input numeric value.
     * @public
     *
     * @param {Property.<number>} property
     * @param {number} number
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<boolean>}
     */
    greaterThanNumber: function( property, number, options ) {
      return new DerivedProperty( [ property ], function( value ) { return value > number; }, options );
    },

    /**
     * Creates a derived boolean property whose value is true iff firstProperty's value is greater than or equal to the
     * input numeric value.
     * @public
     *
     * @param {Property.<number>} property
     * @param {number} number
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<boolean>}
     */
    greaterThanEqualNumber: function( property, number, options ) {
      return new DerivedProperty( [ property ], function( value ) { return value >= number; }, options );
    },

    /**
     * Creates a derived boolean property whose value is true iff the property's value is falsy.
     * @public
     *
     * @param {Property.<*>} property
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<boolean>}
     */
    derivedNot: function( property, options ) {
      return new DerivedProperty( [ property ], notFunction, options );
    },

    /**
     * Creates a derived property whose value is values[ property.value ].
     * @public
     *
     * @param {Property.<*>} property
     * @param {Object} values
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {Property.<*>}
     */
    mapValues: function( property, values, options ) {
      return new DerivedProperty( [ property ], function( value ) { return values[ value ]; }, options );
    }
  } );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * An observable array of items.
 * <p>
 * Because the array is observable, we must be careful about the possibility of concurrent-modification errors.
 * Any time we iterate over the array, we must iterate over a copy, because callback may be modifying the array.
 *
 * @author Sam Reid
 * @author Chris Malley
 */
define( 'AXON/ObservableArray',['require','AXON/Property','AXON/axon','PHET_CORE/inherit','AXON/Emitter'],function( require ) {
  'use strict';

  // modules
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );

  /**
   * @param {[]} array
   * @param {Object} [options]
   * @constructor
   */
  function ObservableArray( array, options ) {

    // Special case that the user supplied options but no array
    if ( array instanceof Object && !(array instanceof Array) ) {
      options = array;
      array = null;
    }

    this._options = _.extend( {
      allowDuplicates: false, // are duplicate items allowed in the array?
      tandem: null            // Tandem is supported here.  This line doesn't do anything different than leaving tandem as undefined
                              // but this entry serves as an indicator that tandem is supported here.
    }, options );

    this._array = array || []; // @private internal, do not access directly
    this._addedListeners = []; // @private listeners called when an item is added
    this._removedListeners = []; // @private listeners called when an item is removed

    this.lengthProperty = new Property( this._array.length ); // @public (read-only) observe this, but don't set it

    // @private Store the initial array, if any, for resetting, see #4
    this.initialArray = array ? array.slice() : [];

    // @private Event stream for signifying begin/end of callbacks
    this.startedCallbacksForItemAddedEmitter = new Emitter();
    this.endedCallbacksForItemAddedEmitter = new Emitter();
    this.startedCallbacksForItemRemovedEmitter = new Emitter();
    this.endedCallbacksForItemRemovedEmitter = new Emitter();

    options && options.tandem && options.tandem.addInstance( this );
    this.disposeObservableArray = function() {
      options && options.tandem && options.tandem.removeInstance( this );
    };
  }

  axon.register( 'ObservableArray', ObservableArray );

  return inherit( Object, ObservableArray, {

    // @public
    dispose: function() {
      this.disposeObservableArray();
    },

    /**
     * Restore the array back to its initial state
     * Note: if an item is in the current array and original array, it is removed and added back
     * This may or may not change in the future, see #4
     * @public
     */
    reset: function() {
      for ( var i = 0; i < this._array.length; i++ ) {
        this._fireItemRemoved( this._array[ i ] );
      }
      this._array = this.initialArray.slice();
      for ( i = 0; i < this._array.length; i++ ) {
        this._fireItemAdded( this._array[ i ] );
      }
    },

    // @public
    get length() { return this._array.length; },

    /**
     * Adds a listener that will be notified when an item is added to the list.
     * @param listener function( item, observableArray )
     * @public
     */
    addItemAddedListener: function( listener ) {
      assert && assert( this._addedListeners.indexOf( listener ) === -1 ); // listener is not already registered
      this._addedListeners.push( listener );
    },

    /**
     * Removes a listener that was added via addItemAddedListener.
     * @param listener
     * @public
     */
    removeItemAddedListener: function( listener ) {
      var index = this._addedListeners.indexOf( listener );
      assert && assert( index !== -1 ); // listener is registered
      this._addedListeners.splice( index, 1 );
    },

    /**
     * Adds a listener that will be notified when an item is removed from the list.
     * @param listener function( item, observableArray )
     * @public
     */
    addItemRemovedListener: function( listener ) {
      assert && assert( this._removedListeners.indexOf( listener ) === -1 ); // listener is not already registered
      this._removedListeners.push( listener );
    },

    /**
     * Removes a listener that was added via addItemRemovedListener.
     * @param listener
     * @public
     */
    removeItemRemovedListener: function( listener ) {
      var index = this._removedListeners.indexOf( listener );
      assert && assert( index !== -1 ); // listener is registered
      this._removedListeners.splice( index, 1 );
    },

    /**
     * Convenience function for adding both types of listeners in one shot.
     * @param itemAddedListener
     * @param itemRemovedListener
     * @public
     */
    addListeners: function( itemAddedListener, itemRemovedListener ) {
      this.addItemAddedListener( itemAddedListener );
      this.addItemRemovedListener( itemRemovedListener );
    },

    // @private Internal: called when an item is added.
    _fireItemAdded: function( item ) {
      this.startedCallbacksForItemAddedEmitter.emit1( item );

      //Signify that an item was added to the list
      var copy = this._addedListeners.slice( 0 ); // operate on a copy, firing could result in the listeners changing
      for ( var i = 0; i < copy.length; i++ ) {
        copy[ i ]( item, this );
      }

      this.endedCallbacksForItemAddedEmitter.emit();
    },

    // Internal: called when an item is removed.
    _fireItemRemoved: function( item ) {

      this.startedCallbacksForItemRemovedEmitter.emit1( item );

      //Signify that an item was removed from the list
      var copy = this._removedListeners.slice( 0 ); // operate on a copy, firing could result in the listeners changing
      for ( var i = 0; i < copy.length; i++ ) {
        copy[ i ]( item, this );
      }

      this.endedCallbacksForItemRemovedEmitter.emit();
    },

    /**
     * Adds an item to the end of the array.
     * This is a convenience function, and is the same as push.
     * @param item
     * @public
     */
    add: function( item ) {
      this.push( item );
    },

    /**
     * Add items to the end of the array.
     * This is a convenience function, and is the same as push.
     * @param {Array} items
     * @public
     */
    addAll: function( items ) {
      for ( var i = 0; i < items.length; i++ ) {
        this.add( items[ i ] );
      }
    },

    /**
     * Removes the first occurrence of an item from the array.
     * If duplicates are allowed (see options.allowDuplicates) you may need to call this multiple
     * times to totally purge item from the array.
     * @param item
     * @public
     */
    remove: function( item ) {
      var index = this._array.indexOf( item );
      if ( index !== -1 ) {
        this._array.splice( index, 1 );
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
    },

    /**
     * Removes the first occurrence of each item in the specified array.
     * @param {Array} list a list of items to remove
     * @see ObservableArray.remove
     * @public
     */
    removeAll: function( list ) {
      for ( var i = 0; i < list.length; i++ ) {
        var item = list[ i ];
        this.remove( item );
      }
    },

    /**
     * Pushes an item onto the end of the array.
     * @param item
     * @throws Error if duplicates are not allowed (see options.allowDuplicates) and item is already in the array
     * @public
     */
    push: function( item ) {
      if ( !this._options.allowDuplicates && this.contains( item ) ) {
        throw new Error( 'duplicates are not allowed' );
      }
      this._array.push( item );
      this.lengthProperty.set( this._array.length );
      this._fireItemAdded( item );
    },

    /**
     * Removes an item from the end of the array and returns it.
     * @returns {*}
     * @public
     */
    pop: function() {
      var item = this._array.pop();
      if ( item !== undefined ) {
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
      return item;
    },

    /**
     * Removes an item from the beginning of the array and returns it.
     * @returns {*}
     * @public
     */
    shift: function() {
      var item = this._array.shift();
      if ( item !== undefined ) {
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
      return item;
    },

    /**
     * Does the array contain the specified item?
     * @param item
     * @returns {boolean}
     * @public
     */
    contains: function( item ) {
      return this.indexOf( item ) !== -1;
    },

    /**
     * Gets an item at the specified index.
     * @param index
     * @returns {*} the item, or undefined if there is no item at the specified index
     * @public
     */
    get: function( index ) {
      return this._array[ index ];
    },

    /**
     * Gets the index of a specified item.
     * @param item
     * @returns {*} -1 if item is not in the array
     * @public
     */
    indexOf: function( item ) {
      return this._array.indexOf( item );
    },

    /**
     * Removes all items from the array.
     * @public
     */
    clear: function() {
      var copy = this._array.slice( 0 );
      for ( var i = 0; i < copy.length; i++ ) {
        this.remove( copy[ i ] );
      }
    },

    /**
     * Applies a callback function to each item in the array
     * @param callback function(item)
     * @public
     */
    forEach: function( callback ) {
      this._array.slice().forEach( callback ); // do this on a copy of the array, in case callbacks involve array modification
    },

    /**
     * Maps the values in this ObservableArray using the specified function, and returns a new ObservableArray for chaining.
     * @param mapFunction
     * @returns {axon.ObservableArray}
     * @public
     */
    map: function( mapFunction ) {
      return new axon.ObservableArray( this._array.map( mapFunction ) );
    },

    /**
     * Filters the values in this ObservableArray using the predicate function, and returns a new ObservableArray for chaining.
     * @param predicate
     * @returns {axon.ObservableArray}
     * @public
     */
    filter: function( predicate ) {
      return new axon.ObservableArray( this._array.filter( predicate ) );
    },

    /**
     * Starting with the initial value, combine values from this ObservableArray to come up with a composite result.
     * Same as foldLeft.  In underscore this is called _.reduce aka _.foldl or _.inject
     * @param value
     * @param combiner
     * @returns {*}
     * @public
     */
    reduce: function( value, combiner ) {
      for ( var i = 0; i < this._array.length; i++ ) {
        value = combiner( value, this._array[ i ] );
      }
      return value;
    },

    /**
     * Return the underlying array
     * @returns {*|Array}
     * @public
     */
    getArray: function() {
      return this._array;
    }
  } );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * PropertySet facilitates creation and use of multiple named Property instances.  There are still several API design issues in question, but this
 * class is ready for use.
 *
 * A PropertySet is a set of Property instances that provides support for:
 * -Easily creating several properties using an object literal (hash)
 * -Resetting them as a group
 * -Set multiple values at once, using propertySet.set({x:100,y:200,name:'alice'});
 * -Support for derived properties, which appear with the same interface as basic properties
 * -Convenient toString that prints e.g., PropertySet{name:'larry',age:101,kids:['alice','bob']}
 * -Wiring up to listen to multiple properties simultaneously
 * -Add properties after the PropertySet is created?  Don't forget to add to the key list as well.
 * -Remove properties that were added using addProperty or the constructor
 *
 * Sample usage:
 * var p = new PropertySet( {name: 'larry', age: 100, kids: ['alice', 'bob']} );
 * p.nameProperty.link( function( n ) {console.log( 'hello ' + n );} );
 * p.name = 'jensen';
 * p.age = 101;//Happy Birthday!
 * console.log( p );
 * p.reset();
 * console.log( p );
 * p.set({name:'clark',age:102,kids:['alice','bob','charlie']});
 *
 * How would this be done without PropertySet (for comparison)?
 * //Normally would be created in a class but that is omitted here for brevity.
 * var p ={name: new Property('larry'), age: new Property('age'), kids: new Property(['alice','bob'])}
 * p.reset = function(){
 *   this.name.reset();
 *   this.age.reset();
 *   this.kids.reset();
 * }
 * p.name.set('clark');
 * p.age.set('102');
 * p.kids.set(['alice','bob','charlie']);
 *
 * Note: If a subclass ever substitutes a property like this: person.ageProperty = new Property(person.age), then it would break the getter/setter
 * @author Sam Reid
 */

define( 'AXON/PropertySet',['require','AXON/Property','AXON/DerivedProperty','AXON/Multilink','AXON/Events','AXON/axon','PHET_CORE/inherit'],function( require ) {
  'use strict';

  // modules
  var Property = require( 'AXON/Property' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var Multilink = require( 'AXON/Multilink' );
  var Events = require( 'AXON/Events' );
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );

  // constants
  var SUFFIX = 'Property';

  /**
   * PropertySet main constructor
   * @param {Object} values - a hash: keys are the names of properties, values are initial property values. Eg { name: 'Curly', age: 40 }
   * @param {Object} [options]
   * @constructor
   */
  function PropertySet( values, options ) {

    options = _.extend( {
      tandemSet: {} // a hash, keys are a subset of the keys in values, and the value associated with each key is a {Tandem} tandem
    }, options );

    // Verify that the tandemSet doesn't contain bogus keys. filter should return 0 tandemSet keys that are not in values.
    assert && assert( _.filter( _.keys( options.tandemSet ), function( key ) {
        var isBad = !values.hasOwnProperty( key );
        if ( isBad ) { console.error( 'bad tandem key: ' + key ); }
        return isBad;
      } ).length === 0, 'Some tandem keys do not appear in the PropertySet' );

    var propertySet = this;

    Events.call( this );

    // @private Keep track of the keys so we know which to reset
    this.keys = [];

    Object.getOwnPropertyNames( values ).forEach( function( value ) {
      propertySet.addProperty( value, values[ value ], options.tandemSet[ value ] );
    } );
  }

  axon.register( 'PropertySet', PropertySet );

  return inherit( Events, PropertySet, {

    /**
     * Adds a new property to this PropertySet
     * @param {string} propertyName
     * @param {*} value the property's initial value
     * @param {Tandem} [tandem]
     * @public
     */
    addProperty: function( propertyName, value, tandem ) {
      this[ propertyName + SUFFIX ] = new Property( value, { tandem: tandem } );
      this.addGetterAndSetter( propertyName );
      this.keys.push( propertyName );
    },

    /**
     * Remove any property (whether a derived property or not) that was added to this PropertySet
     * @param {String} propertyName
     * @public
     */
    removeProperty: function( propertyName ) {

      //Remove from the keys (only for non-derived properties)
      var index = this.keys.indexOf( propertyName );
      if ( index !== -1 ) {
        this.keys.splice( index, 1 );
      }

      this[ propertyName + SUFFIX ].dispose();

      //Unregister the Property instance from the PropertySet
      delete this[ propertyName + SUFFIX ];

      //Unregister the getter/setter, if they exist
      delete this[ propertyName ];
    },

    /**
     * Adds a getter and setter using ES5 get/set syntax, similar to https://gist.github.com/dandean/1292057, same as in github/Atlas
     * @param {string} propertyName
     * @public
     */
    addGetterAndSetter: function( propertyName ) {
      var property = this[ propertyName + SUFFIX ];

      Object.defineProperty( this, propertyName, {

        // Getter proxies to Model#get()...
        get: function() { return property.get();},

        // Setter proxies to Model#set(attributes)
        set: function( value ) { property.set( value );},

        // Make it configurable and enumerable so it's easy to override...
        configurable: true,
        enumerable: true
      } );
    },

    /**
     * Adds an ES5 getter to a property.
     * @param {string} propertyName
     * @public
     */
    addGetter: function( propertyName ) {
      var property = this[ propertyName + SUFFIX ];

      Object.defineProperty( this, propertyName, {

        get: function() { return property.get();},

        // Make it configurable and enumerable so it's easy to override...
        configurable: true,
        enumerable: true
      } );
    },

    // @public Resets all of the properties associated with this PropertySet
    reset: function() {
      var propertySet = this;
      this.keys.forEach( function( key ) {
        propertySet[ key + SUFFIX ].reset();
      } );
    },

    /**
     * Creates a DerivedProperty from the given property property names and derivation.
     * @param {string[]} propertyNames
     * @param {function} derivation
     * @param {Tandem} [tandem]
     * @returns {DerivedProperty}
     * @public
     */
    toDerivedProperty: function( propertyNames, derivation, tandem ) {
      return new DerivedProperty( this.getProperties( propertyNames ), derivation, { tandem: tandem } );
    },

    /**
     * Adds a derived property to the property set.
     * @param {string} propertyName name for the derived property
     * @param {string[]} dependencyNames names of the properties that it depends on
     * @param {function} derivation function that expects args in the same order as dependencies
     * @param {Tandem} [tandem]
     * @public
     */
    addDerivedProperty: function( propertyName, dependencyNames, derivation, tandem ) {
      this[ propertyName + SUFFIX ] = this.toDerivedProperty( dependencyNames, derivation, tandem );
      this.addGetter( propertyName );
    },

    /**
     * Returns an array of the requested properties.
     * @param propertyNames
     * @returns {*}
     * @private
     */
    getProperties: function( propertyNames ) {
      var propertySet = this;
      return propertyNames.map( function( propertyName ) {
        var propertyKey = propertyName + SUFFIX;
        assert && assert( propertySet.hasOwnProperty( propertyKey ) );
        return propertySet[ propertyKey ];
      } );
    },

    /**
     * Set all of the values specified in the object hash
     * Allows you to use this form:
     * puller.set( {x: knot.x, y: knot.y, knot: knot} );
     *
     * instead of this:
     * puller.x.value = knot.x;
     * puller.y.value = knot.y;
     * puller.knot.value = knot;
     *
     * Throws an error if you try to set a value for which there is no property.
     *
     * @param {Object} values - see example above
     * @public
     */
    setValues: function( values ) {
      var propertySet = this;
      Object.getOwnPropertyNames( values ).forEach( function( propertyName ) {
        if ( typeof(propertySet[ propertyName + SUFFIX ] === 'Property') ) {
          propertySet[ propertyName + SUFFIX ].set( values[ propertyName ] );
        }
        else {
          throw new Error( 'property not found: ' + propertyName );
        }
      } );
    },

    /**
     * Get a JS object literal with all the current values of the properties in this property set, say for serialization.
     * @see set
     * @public
     * TODO: this works well to serialize numbers, strings, booleans.  How to handle complex state values such as Vector2 or nested Property?  Maybe that must be up to the client code.
     * TODO: This was named 'get' to mirror the 'set' method above, but I'm concerned this will make them difficult to find/replace and may confuse with real getters & setters.  Maybe setState/getState would be better?
     */
    getValues: function() {
      var state = {};
      for ( var i = 0; i < this.keys.length; i++ ) {
        var key = this.keys[ i ];
        state[ key ] = this.property( key ).value;
      }
      return state;
    },

    /**
     * Link to a property by name, see https://github.com/phetsims/axon/issues/16
     * @param {string} propertyName the name of the property to link to
     * @param {function }observer the callback to link to the property
     * @public
     */
    link: function( propertyName, observer ) {
      this[ propertyName + SUFFIX ].link( observer );
    },

    /**
     * Unlink for a property by name, see https://github.com/phetsims/axon/issues/16
     * @param {string} propertyName the name of the property to link to
     * @param {function} observer the callback to link to the property
     * @public
     */
    unlink: function( propertyName, observer ) {
      this[ propertyName + SUFFIX ].unlink( observer );
    },

    /**
     * Link an attribute to a property by name.  Return a handle to the observer so it can be removed using unlink().
     * @param {string} propertyName the property to link to
     * @param {Object} object the object for which the attribute will be set
     * @param {string} attributeName the name of the attribute to set on the object
     * @public
     */
    linkAttribute: function( propertyName, object, attributeName ) {
      return this.property( propertyName ).linkAttribute( object, attributeName );
    },

    /**
     * Unlink an observer added with linkAttribute.  Note: the args of linkAttribute do not match the args of
     * unlinkAttribute: here, you must pass the observer handle returned by linkAttribute rather than object and attributeName
     * @param {string} propertyName - the name of the property that the observer will be removed from
     * @param {function} observer
     * @public
     */
    unlinkAttribute: function( propertyName, observer ) {
      this.property( propertyName ).unlink( observer );
    },

    /**
     * Registers an observer with multiple properties, then notifies the observer immediately.
     * @param {string[]} propertyNames
     * @param {function} observer no params, returns nothing
     * @public
     */
    multilink: function( propertyNames, observer ) {
      return new Multilink( this.getProperties( propertyNames ), observer, false );
    },

    // @public
    lazyMultilink: function( propertyNames, observer ) {
      return new Multilink( this.getProperties( propertyNames ), observer, true );
    },

    /**
     * Removes the multilink from this PropertySet.
     * Same as calling dispose() on the multilink
     * @param {Multilink} multilink
     * @public
     */
    unmultilink: function( multilink ) {
      multilink.dispose();
    },

    // @public
    toString: function() {
      var text = 'PropertySet{';
      var propertySet = this;
      for ( var i = 0; i < this.keys.length; i++ ) {
        var key = this.keys[ i ];
        text = text + key + ':' + propertySet[ key ].toString();
        if ( i < this.keys.length - 1 ) {
          text = text + ',';
        }
      }
      return text + '}';
    },

    /**
     * Unlinks all observers from all Property instances.
     * @public
     */
    unlinkAll: function() {
      var propertySet = this;
      this.keys.forEach( function( key ) {
        propertySet[ key + SUFFIX ].unlinkAll();
      } );
    },

    /**
     * Get a property by name, see https://github.com/phetsims/axon/issues/16
     * @param {string} propertyName the name of the property to get
     * @deprecated see https://github.com/phetsims/axon/issues/43
     * @public
     */
    property: function( propertyName ) {
      return this[ propertyName + SUFFIX ];
    },

    /**
     * When the PropertySet is no longer used by the sim, it can be eliminated.  All Properties are disposed.
     * @public
     */
    dispose: function() {
      for ( var i = 0; i < this.keys.length; i++ ) {
        this[ this.keys[ i ] + SUFFIX ].dispose();
      }
    }
  } );
} );

// Copyright 2013-2015, University of Colorado Boulder

define( 'AXON/main',[
  'AXON/axon',
  'AXON/Property',
  'AXON/DerivedProperty',
  'AXON/Emitter',
  'AXON/Events',
  'AXON/ObservableArray',
  'AXON/PropertySet',
  'AXON/Multilink'
], function( axon ) {
  'use strict';
  return axon;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Creates an array of results from an iterator that takes a callback.
 *
 * For instance, if calling a function f( g ) will call g( 1 ), g( 2 ), and g( 3 ),
 * collect( function( callback ) { f( callback ); } );
 * will return [1,2,3].
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/collect',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function collect( iterate ) {
    assert && assert( typeof iterate === 'function' );
    var result = [];
    iterate( function( ob ) {
      result.push( ob );
    } );
    return result;
  }

  phetCore.register( 'collect', collect );

  return collect;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Scans through potential event properties on an object to detect prefixed forms, and returns the first match.
 *
 * E.g. currently:
 * phetCore.detectPrefixEvent( document, 'fullscreenchange' ) === 'webkitfullscreenchange'
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/detectPrefixEvent',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  // @returns the best String str where obj['on'+str] !== undefined, or returns undefined if that is not available
  function detectPrefixEvent( obj, name, isEvent ) {
    if ( obj[ 'on' + name ] !== undefined ) { return name; }

    // Chrome planning to not introduce prefixes in the future, hopefully we will be safe
    if ( obj[ 'on' + 'moz' + name ] !== undefined ) { return 'moz' + name; }
    if ( obj[ 'on' + 'Moz' + name ] !== undefined ) { return 'Moz' + name; } // some prefixes seem to have all-caps?
    if ( obj[ 'on' + 'webkit' + name ] !== undefined ) { return 'webkit' + name; }
    if ( obj[ 'on' + 'ms' + name ] !== undefined ) { return 'ms' + name; }
    if ( obj[ 'on' + 'o' + name ] !== undefined ) { return 'o' + name; }
    return undefined;
  }

  phetCore.register( 'detectPrefixEvent', detectPrefixEvent );

  return detectPrefixEvent;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Abstraction for timed-event series that helps with variable frame-rates. Useful for things that need to happen at a
 * specific rate real-time regardless of the frame-rate.
 *
 * An EventTimer is created with a specific event "model" that determines when events occur, and a callback that will
 * be triggered for each event (with its time elapsed since it should have occurred).
 *
 * To run the EventTimer, call step( realTimeElapsed ), and it will call your callback for every event that would have
 * occurred over that time-frame (possibly zero).
 *
 * For example, create a timer with a constant rate that it will fire events every 1 time units:
 *
 * var timer = new phetCore.EventTimer( new phetCore.EventTimer.ConstantEventModel( 1 ), function( timeElapsed ) {
 *   console.log( 'event with timeElapsed: ' + timeElapsed );
 * } );
 *
 * Stepping once for 1.5 time units will fire once (0.5 seconds since the "end" of the step), and will be 0.5 seconds
 * from the next step:
 *
 * timer.step( 1.5 );
 * > event with timeElapsed: 0.5
 *
 * Stepping for a longer time will result in more events:
 *
 * timer.step( 6 );
 * > event with timeElapsed: 5.5
 * > event with timeElapsed: 4.5
 * > event with timeElapsed: 3.5
 * > event with timeElapsed: 2.5
 * > event with timeElapsed: 1.5
 * > event with timeElapsed: 0.5
 *
 * A step with zero time will trigger no events:
 *
 * timer.step( 0 );
 *
 * The timer will fire an event once it reaches the exact point in time:
 *
 * timer.step( 1.5 );
 * > event with timeElapsed: 1
 * > event with timeElapsed: 0
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/EventTimer',['require','PHET_CORE/phetCore','PHET_CORE/inherit'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );
  var inherit = require( 'PHET_CORE/inherit' );

  /*
   * Create an event timer with a specific model (determines the time between events), and a callback to be called
   * for events.
   * @public
   *
   * @param {Object with getPeriodBeforeNextEvent(): Number} eventModel: getPeriodBeforeNextEvent() will be called at
   *    the start and after every event to determine the time required to pass by before the next event occurs.
   * @param {function} eventCallback( timeElapsed ): Will be called for every event. The timeElapsed passed in as the
   *    only argument denotes the time elapsed since the event would have occurred. E.g. if we step for 5 seconds and
   *    our event would have occurred 1 second into that step, the timeElapsed will be 4 seconds, since after the end
   *    of the 5 seconds the event would have happened 4 seconds ago.
   */
  function EventTimer( eventModel, eventCallback ) {
    assert && assert( typeof eventCallback === 'function', 'EventTimer requires a callback' );

    // @private
    this.eventModel = eventModel;
    this.eventCallback = eventCallback;

    // @private
    this.timeBeforeNextEvent = this.eventModel.getPeriodBeforeNextEvent();
  }

  phetCore.register( 'EventTimer', EventTimer );

  inherit( Object, EventTimer, {
    /**
     * Steps the timer forward by a certain amount of time. This may cause 0 or more events to actually occur.
     * @public
     *
     * @param {number} dt
     */
    step: function( dt ) {
      while ( dt >= this.timeBeforeNextEvent ) {
        dt -= this.timeBeforeNextEvent;
        this.timeBeforeNextEvent = this.eventModel.getPeriodBeforeNextEvent();

        // how much time has elapsed since this event began
        this.eventCallback( dt );
      }

      // use up the remaining DT
      this.timeBeforeNextEvent -= dt;
    }
  } );

  /*
   * Event model that will fire events at a constant rate. An event will occur every 1/rate time units.
   * @public
   *
   * @param {number} rate
   */
  EventTimer.ConstantEventModel = inherit( Object, function ConstantEventRate( rate ) {
    assert && assert( typeof rate === 'number',
      'The rate should be a number' );
    assert && assert( rate > 0,
      'We need to have a strictly positive rate in order to prevent infinite loops.' );

    this.rate = rate;
  }, {
    // @public
    getPeriodBeforeNextEvent: function() {
      return 1 / this.rate;
    }
  } );

  /*
   * Event model that will fire events averaging a certain rate, but with the time between events being uniformly
   * random.
   * @public
   *
   * The pseudoRandomNumberSource, when called, should generate uniformly distributed random numbers in the range [0,1).
   *
   * @param {number} rate
   * @param {function} pseudoRandomNumberSource() : Number
   */
  EventTimer.UniformEventModel = inherit( Object, function UniformEventModel( rate, pseudoRandomNumberSource ) {
    assert && assert( typeof rate === 'number',
      'The rate should be a number' );
    assert && assert( typeof pseudoRandomNumberSource === 'function',
      'The pseudo-random number source should be a function' );
    assert && assert( rate > 0,
      'We need to have a strictly positive rate in order to prevent infinite loops.' );

    this.rate = rate;
    this.pseudoRandomNumberSource = pseudoRandomNumberSource;
  }, {
    // @public
    getPeriodBeforeNextEvent: function() {
      var uniformRandomNumber = this.pseudoRandomNumberSource();
      assert && assert( typeof uniformRandomNumber === 'number' &&
      uniformRandomNumber >= 0 && uniformRandomNumber < 1,
        'Our uniform random number is outside of its expected range with a value of ' + uniformRandomNumber );

      // sample the exponential distribution
      return uniformRandomNumber * 2 / this.rate;
    }
  } );

  /*
   * Event model that will fire events corresponding to a Poisson process with the specified rate.
   * The pseudoRandomNumberSource, when called, should generate uniformly distributed random numbers in the range [0,1).
   * @public
   *
   * @param {number} rate
   * @param {function} pseudoRandomNumberSource() : number
   */
  EventTimer.PoissonEventModel = inherit( Object, function PoissonEventModel( rate, pseudoRandomNumberSource ) {
    assert && assert( typeof rate === 'number',
      'The time between events should be a number' );
    assert && assert( typeof pseudoRandomNumberSource === 'function',
      'The pseudo-random number source should be a function' );
    assert && assert( rate > 0,
      'We need to have a strictly positive poisson rate in order to prevent infinite loops.' );

    this.rate = rate;
    this.pseudoRandomNumberSource = pseudoRandomNumberSource;
  }, {
    // @public
    getPeriodBeforeNextEvent: function() {
      // A poisson process can be described as having an independent exponential distribution for the time between
      // consecutive events.
      // see http://en.wikipedia.org/wiki/Exponential_distribution#Generating_exponential_variates and
      // http://en.wikipedia.org/wiki/Poisson_process

      var uniformRandomNumber = this.pseudoRandomNumberSource();
      assert && assert( typeof uniformRandomNumber === 'number' &&
      uniformRandomNumber >= 0 && uniformRandomNumber < 1,
        'Our uniform random number is outside of its expected range with a value of ' + uniformRandomNumber );

      // sample the exponential distribution
      return -Math.log( uniformRandomNumber ) / this.rate;
    }
  } );

  return EventTimer;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Loads a script
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/loadScript',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  /*
   * Load a script. The only required argument is src, and can be specified either as
   * loadScript( "<url>" ) or loadScript( { src: "<url>", ... other options ... } ).
   *
   * Arguments:
   *   src:         The source of the script to load
   *   callback:    A callback to call (with no arguments) once the script is loaded and has been executed
   *   async:       Whether the script should be loaded asynchronously. Defaults to true
   *   cacheBuster: Whether the URL should have an appended query string to work around caches
   */
  function loadScript( args ) {
    // handle a string argument
    if ( typeof args === 'string' ) {
      args = { src: args };
    }

    var src = args.src;
    var callback = args.callback;
    var async = args.async === undefined ? true : args.async;
    var cacheBuster = args.cacheBuster === undefined ? false : args.cacheBuster;

    var called = false;

    var script = document.createElement( 'script' );
    script.type = 'text/javascript';
    script.async = async;
    script.onload = script.onreadystatechange = function() {
      var state = this.readyState;
      if ( state && state !== 'complete' && state !== 'loaded' ) {
        return;
      }

      if ( !called ) {
        called = true;

        if ( callback ) {
          callback();
        }
      }
    };

    // make sure things aren't cached, just in case
    script.src = src + ( cacheBuster ? '?random=' + Math.random().toFixed( 10 ) : '' );

    var other = document.getElementsByTagName( 'script' )[ 0 ];
    other.parentNode.insertBefore( script, other );
  }

  phetCore.register( 'loadScript', loadScript );

  return loadScript;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Creates an array of arrays, which consists of pairs of objects from the input array without duplication.
 *
 * For example, phetCore.pairs( [ 'a', 'b', 'c' ] ) will return:
 * [ [ 'a', 'b' ], [ 'a', 'c' ], [ 'b', 'c' ] ]
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/pairs',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function pairs( array ) {
    var result = [];
    var length = array.length;
    if ( length > 1 ) {
      for ( var i = 0; i < length - 1; i++ ) {
        var first = array[ i ];
        for ( var j = i + 1; j < length; j++ ) {
          result.push( [ first, array[ j ] ] );
        }
      }
    }
    return result;
  }

  phetCore.register( 'pairs', pairs );

  return pairs;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Partitions an array into two arrays: the first contains all elements that satisfy the predicate, and the second
 * contains all the (other) elements that do not satisfy the predicate.
 *
 * e.g. partition( [1,2,3,4], function( n ) { return n % 2 === 0; } ) will return [[2,4],[1,3]]
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/partition',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function partition( array, predicate ) {
    assert && assert( array instanceof Array );
    assert && assert( typeof predicate === 'function' );

    var satisfied = [];
    var unsatisfied = [];
    var length = array.length;
    for ( var i = 0; i < length; i++ ) {
      if ( predicate( array[ i ] ) ) {
        satisfied.push( array[ i ] );
      }
      else {
        unsatisfied.push( array[ i ] );
      }
    }

    return [ satisfied, unsatisfied ];
  }

  phetCore.register( 'partition', partition );

  return partition;
} );
// Copyright 2013-2015, University of Colorado Boulder

define( 'PHET_CORE/main',[
  'PHET_CORE/phetCore',
  'PHET_CORE/arrayRemove',
  'PHET_CORE/cleanArray',
  'PHET_CORE/collect',
  'PHET_CORE/detectPrefix',
  'PHET_CORE/detectPrefixEvent',
  'PHET_CORE/escapeHTML',
  'PHET_CORE/EventTimer',
  'PHET_CORE/extend',
  'PHET_CORE/inherit',
  'PHET_CORE/isArray',
  'PHET_CORE/loadScript',
  'PHET_CORE/pairs',
  'PHET_CORE/partition',
  'PHET_CORE/phetAllocation',
  'PHET_CORE/platform',
  'PHET_CORE/Poolable'
], function( phetCore ) {
  'use strict';
  return phetCore;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Configuration file for development and production deployments.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

require.config( {
  // depends on all of Scenery, Kite, Dot, Axon and phet-core
  deps: [ 'main', 'KITE/main', 'DOT/main', 'AXON/main', 'PHET_CORE/main' ],

  paths: {

    // plugins
    image: '../../chipper/js/requirejs-plugins/image',

    // third-party libs
    text: '../../sherpa/lib/text-2.0.12',

    SCENERY: '.',
    KITE: '../../kite/js',
    DOT: '../../dot/js',
    PHET_CORE: '../../phet-core/js',
    AXON: '../../axon/js'
  },

  // optional cache buster to make browser refresh load all included scripts, can be disabled with ?cacheBuster=false
  urlArgs: Date.now()
} );

define("config", function(){});

 window.scenery = require( 'main' ); window.kite = require( 'KITE/main' ); window.dot = require( 'DOT/main' ); window.axon = require( 'AXON/main' ); window.phetCore = require( 'PHET_CORE/main' ); scenery.Util.polyfillRequestAnimationFrame(); }());
