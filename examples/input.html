<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1"/>
  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>Input - Scenery Example</title>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- Scenery code -->
  <script src="../build/scenery.min.js"></script>

  <style type="text/css">
    /* Let content go to the edges */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: #fff;
      overflow: hidden;
    }

    /* Have the #main div cover the entire viewport */
    #main {
      position: absolute;
      left: 0;
      top: 0;
      background-color: #fff;
      z-index: 0;
    }

  </style>
</head>

<body>

<!-- our scene graph will be in this div -->
<div id="main">
</div>

<script>

  // initialize our scene
  var scene = new scenery.Node();
  var display = new scenery.Display( scene, {
    container: document.getElementById( 'main' )
  } );
  display.initializeFullscreenEvents(); // set up listeners on the document
  display.resizeOnWindowResize(); // keep the display size linked to the window size

  var inactiveColor = '#ccc';
  var activeColor = '#8f8';
  var strokeColor = '#000';

  var buttonText = new scenery.Text( 'outside released', {
    fontSize: 14,
    centerX: 0,
    centerY: 0
  } );
  var buttonBackground = scenery.Rectangle.bounds( buttonText.bounds.dilatedXY( 20, 10 ), {
    stroke: strokeColor
  } );
  var buttonNode = new scenery.Node( {
    children: [ buttonBackground, buttonText ],
    cursor: 'pointer',
    left: 10,
    top: 10
  } );
  scene.addChild( buttonNode );

  var fireNode = new scenery.Rectangle( 0, 0, buttonNode.height, buttonNode.height, {
    opacity: 0,
    fill: 'red',
    left: buttonNode.right + 10,
    top: buttonNode.top
  } );
  scene.addChild( fireNode );

  var buttonListener = new scenery.FireListener( {
    press: function() { console.log( 'press' ); },
    release: function() { console.log( 'release' ); },
    drag: function() { console.log( 'drag' ); },
    fire: function() { console.log( 'fire' ); fireNode.opacity = 1; }
  } );
  buttonNode.addInputListener( buttonListener );

  axon.Property.multilink( [ buttonListener.isOverProperty, buttonListener.isPressedProperty ], function( isOver, isPressed ) {
    var isActive = isOver || isPressed;
    buttonBackground.fill = isActive ? activeColor : inactiveColor;
    buttonText.text = ( isOver ? 'inside' : 'outside' ) + ' ' + ( isPressed ? 'pressed' : 'released' );
    buttonText.center = new dot.Vector2();
  } );




  var interruptText = new scenery.Text( 'Interrupt All', {
    fontSize: 14,
    centerX: 0,
    centerY: 0
  } );
  var interruptBackground = scenery.Rectangle.bounds( interruptText.bounds.dilatedXY( 20, 10 ), {
    stroke: strokeColor
  } );
  var interruptNode = new scenery.Node( {
    children: [ interruptBackground, interruptText ],
    cursor: 'pointer',
    left: buttonNode.left,
    top: buttonNode.bottom + 10
  } );
  scene.addChild( interruptNode );

  var interruptListener = new scenery.FireListener( {
    fire: function() {
      scene.interruptSubtreeInput();
    }
  } );
  interruptNode.addInputListener( interruptListener );
  interruptBackground.fill = new axon.DerivedProperty( [ interruptListener.isHighlightedProperty ], function( isHighlighted ) {
    return isHighlighted ? activeColor : inactiveColor;
  } );





  var simpleDragNode = new scenery.Circle( 30, {
    fill: 'red',
    stroke: strokeColor,
    cursor: 'pointer',
    x: 300,
    y: 100
  } );
  scene.addChild( simpleDragNode );
  simpleDragNode.addInputListener( new scenery.DragListener( { translateNode: true } ) );





  var transformContainer = new scenery.Node( {
    scale: 1.5,
    rotation: Math.PI / 4,
    x: 100,
    y: 50
  } );
  scene.addChild( transformContainer );
  var transformedDragNode = new scenery.Rectangle( 0, 0, 50, 25, {
    fill: '#08F',
    stroke: strokeColor,
    cursor: 'pointer',
    x: 120,
    y: -40
  } );
  transformContainer.addChild( transformedDragNode );
  transformedDragNode.addInputListener( new scenery.DragListener( { translateNode: true } ) );





  var constrainBounds = new dot.Bounds2( 50, 0, 200, 100 );
  transformContainer.addChild( scenery.Rectangle.bounds( constrainBounds, {
    stroke: strokeColor,
    lineDash: [ 5, 5 ]
  } ) );
  var constrainedNode = new scenery.Circle( 20, {
    fill: '#2f2',
    cursor: 'pointer',
    stroke: strokeColor,
    center: constrainBounds.center
  } );
  transformContainer.addChild( constrainedNode );
  constrainedNode.addInputListener( new scenery.DragListener( {
    translateNode: true,
    dragBounds: constrainBounds.eroded( constrainedNode.radius )
  } ) );





  var objectGraphic = new scenery.Path( kite.Shape.regularPolygon( 6, 20 ), {
    fill: '#f3f',
    stroke: strokeColor
  } );

  var objectTransform = new dot.Transform3( dot.Matrix3.scaling( 2 ).timesMatrix( dot.Matrix3.translation( 100, 50 ) ) );
  var objects = new axon.ObservableArray(); // {ObservableArray.<Property.<Vector2>>}
  var objectNodes = []; // Node with { model: {Property.<Vector2>}, dragListener: {DragListener} }
  function getObjectNode( object ) {
    return objectNodes.filter( function( objectNode ) { return objectNode.model === object; } )[ 0 ];
  }
  objects.addItemAddedListener( function( newObject ) {
    var objectNode = new scenery.Node( {
      children: [ objectGraphic ],
      cursor: 'pointer',
      scale: 1.3
    } );
    objectNode.model = newObject;
    newObject.link( function( position ) {
      objectNode.translation = objectTransform.transformPosition2( position );
    } );
    objectNodes.push( objectNode );
    scene.addChild( objectNode );

    var dragListener = new scenery.DragListener( {
      transform: objectTransform,
      locationProperty: newObject,
      targetNode: objectNode,
      release: function() {
        if ( objectButton.containsPoint( objectNode.center ) ) {
          objects.remove( newObject );
        }
      }
    } );
    objectNode.addInputListener( dragListener );
    objectNode.dragListener = dragListener;
  } );
  objects.addItemRemovedListener( function( removedObject ) {
    var objectNode = getObjectNode( removedObject );
    scene.removeChild( objectNode );
    objectNode.interruptSubtreeInput(); // Removing it, so we interrupt any drags that it is involved in
    phetCore.arrayRemove( objectNodes, objectNode );
  } );

  var objectButton = scenery.Rectangle.roundedBounds( objectGraphic.bounds.dilated( 10 ), 10, 10, {
    children: [ objectGraphic ],
    left: interruptNode.left,
    top: interruptNode.bottom + 10,
    fill: '#eee',
    stroke: strokeColor,
    cursor: 'pointer'
  } );
  scene.addChild( objectButton );

  objectButton.addInputListener( {
    down: function( event ) {
      var modelPosition = objectTransform.inversePosition2( event.pointer.point );
      var newObject = new axon.Property( modelPosition );
      objects.push( newObject );
      getObjectNode( newObject ).dragListener.press( event );
    }
  } );


  var innerRadius = 20;
  var outerRadius = 50;
  var halfAngle = Math.PI / 8;
  var rotationShape = new kite.Shape().arc( 0, 0, innerRadius, -halfAngle, halfAngle, false )
                                      .arc( 0, 0, outerRadius, halfAngle, -halfAngle, true )
                                      .close();
  var touchAmount = 10;
  var touchCenterOffset = touchAmount * Math.sqrt( 2 ) * 1.5;
  var rotationTouchShape = new kite.Shape().arc( -touchCenterOffset, 0, touchCenterOffset + innerRadius - touchAmount, -halfAngle, halfAngle, false )
                                           .arc( -touchCenterOffset, 0, touchCenterOffset + outerRadius + touchAmount, halfAngle, -halfAngle, true )
                                           .close();
  var rotationNode = new scenery.Path( rotationShape, {
    fill: '#f80',
    stroke: strokeColor,
    cursor: 'pointer',
    touchArea: rotationTouchShape
  } );
  var rotationProperty = new axon.Property( 0 );
  rotationProperty.linkAttribute( rotationNode, 'rotation' );
  var initialDragRotation;
  rotationNode.addInputListener( new scenery.DragListener( {
    applyOffset: false,
    drag: function( event ) {
      rotationProperty.value = this.modelPoint.angle() - this.initialLocalPoint.angle();
    }
  } ) );

  var rotationContainer = new scenery.Node( {
    children: [
      new scenery.Circle( 3, { fill: 'black' } ),
      new scenery.Circle( 0.5 * ( innerRadius + outerRadius ), { stroke: strokeColor, lineWidth: 0.25 } ),
      rotationNode
    ],
    x: 210,
    y: 60
  } );
  scene.addChild( rotationContainer );





  var trackerNode = new scenery.Path( kite.Shape.regularPolygon( 5, 20 ), {
    fill: '#3ff',
    stroke: strokeColor,
    rotation: -Math.PI / 2,
    cursor: 'pointer'
  } );
  trackerNode.addInputListener( new scenery.DragListener( {
    trackAncestors: true,
    translateNode: true
  } ) );

  var trackerContainer = new scenery.Circle( 30, {
    children: [ trackerNode ],
    stroke: strokeColor,
    lineDash: [ 2, 2 ]
  } );
  scene.addChild( trackerContainer );

  /*---------------------------------------------------------------------------*
   * main loop
   *----------------------------------------------------------------------------*/

  var elapsedTime = 0;
  display.updateOnRequestAnimationFrame( function( dt ) {
    elapsedTime += dt;

    fireNode.opacity *= Math.pow( 0.2, dt );
    trackerContainer.translation = dot.Vector2.createPolar( 20, elapsedTime ).plusXY( 75, 325 );
  } );

</script>

</body>
</html>
