<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport"
          content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

    <!-- runs in full-screen mode on iOS devices -->
    <meta name="apple-mobile-web-app-capable" content="yes">

    <title></title>
    
    <link rel="stylesheet" href="../contrib/bootstrap-2.2.2.css">
    
    <script src="../contrib/jquery-1.8.3.min.js"></script>
    <script src="../contrib/underscore-1.4.3-min.js"></script>
    <script src="../contrib/bootstrap-2.2.2.js"></script>
    <script src="../contrib/stats.min.js"></script>
    <!--<script src="../concatenated.js"></script>-->
    <script src="../concatenated.js"></script>
    <!--<script src="../phet-scene-min.js"></script>-->
    <style type="text/css">
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #ff0;
            overflow: hidden;
        }
        
        #main {
            position: absolute;
            left: 0;
            top: 0;
            background-color: #fff;
            z-index: 0;
            padding: none !important;
        }

    </style>
</head>

<body id="home">

<div>
    <div id="main" >
    </div>
</div>

<script>

var main = $( '#main' );

var scene = new phet.scene.Scene( main );
scene.initializeFullscreenEvents();
scene.resizeOnWindowResize();

var container = new phet.scene.Node();
scene.root.addChild( container );

for( var i = 0; i < 100; i++ ) {
    (function(){
        // TODO: declarative syntax
        var node = new phet.scene.Node();
        node.setShape( phet.scene.Shape.regularPolygon( 6, 22 ) );
        node.setFill( '#ff0000' );
        node.setStroke( '#000000' );
        container.addChild( node );
        
        node.translate( Math.random() * 500, Math.random() * 500 );
        
        
        
        var dragging = false;
        var lastDragPoint = null;
        var beforeDragTranslation = node.translation;
        
        var dragListener = {
            up: function( finger, event ) {
                endDrag( finger );
            },
            
            cancel: function( finger, event ) {
                endDrag( finger );
                
                // since it's a cancel event, go back!
                node.translation = beforeDragTranslation;
            },
            
            move: function( finger, event ) {
                node.translate( finger.point.minus( lastDragPoint ) );
                lastDragPoint = finger.point;
            }
        };
        
        function startDrag( finger ) {
            node.setFill( '#0000ff' );
            
            finger.dragging = true;
            
            finger.addListener( dragListener );
            
            beforeDragTranslation = node.translation;
            lastDragPoint = finger.point;
        }
        
        function endDrag( finger ) {
            node.setFill( '#ff0000' );
            
            finger.removeListener( dragListener );
            finger.dragging = false;
        }
        
        function tryToSnag( finger ) {
            // only start dragging if the finger isn't dragging anything, we aren't being dragged, and if it's a mouse it's button is down
            if( !dragging && !finger.dragging ) {
                startDrag( finger );
            }
        }
        
        node.addInputListener( {
            down: function( finger, event ) {
                tryToSnag( finger );
            },
            
            enter: function( finger, event ) {
                if( !finger.isMouse ) {
                    tryToSnag( finger );
                }
            }
        } );
    })();
}

var stats = new Stats();
stats.setMode( 0 ); // 0: fps, 1: ms
stats.domElement.style.position = 'absolute';
stats.domElement.style.right = '0';
stats.domElement.style.top = '0';
document.body.appendChild( stats.domElement );


var lastTime = 0;
var timeElapsed = 0;
function tick() {
    window.requestAnimationFrame( tick, main[0] );
    
    var timeNow = new Date().getTime();
    if ( lastTime != 0 ) {
        timeElapsed = (timeNow - lastTime) / 1000.0;
    }
    lastTime = timeNow;
    
    stats.begin();
    scene.updateScene();
    stats.end();
}
window.requestAnimationFrame( tick, main[0] );


</script>

</body>
</html>