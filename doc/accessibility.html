<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Accessible Content in Scenery</title>

  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-responsive-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shThemeDefault.css">
  <link rel="stylesheet" href="../assets/scenery.css">

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../aqua/js/pageload-connector.js"></script>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- For the styling -->
  <script src="../../sherpa/lib/bootstrap-2.2.2.js"></script>

  <script src="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.js"></script>
  <script src="../../sherpa/lib/syntaxhighlighter-3.0.83/shBrushJScript.js"></script>
  <script src="../../sherpa/lib/syntaxhighlighter-3.0.83/shBrushXml.js"></script>

  <!-- MathJax config -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});





















  </script>

  <script type="text/javascript"
          src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../build/scenery.min.js"></script>


  <script type="text/javascript">
    scenery.Util.polyfillRequestAnimationFrame();

    function docExample( id, draw ) {
      var $container = $( '#' + id );
      var scene = new scenery.Node();
      var display = new scenery.Display( scene, {
        width: $container.width(),
        height: $container.height()
      } );
      $container[ 0 ].appendChild( display.domElement );
      draw( scene, display );
      display.updateDisplay();
      var $code = $( '<pre class="brush: js"></pre>' );
      $code.text( draw.toString().match( /\/\*START\*\/((.|\n)*)\/\*END\*\// )[ 1 ] );
      $container.after( $code );

      var pdomHTMLBlock = $( display.domElement ).find( '.accessibility' )[ 0 ].outerHTML; // get the pDOM
      var formattedPDOM = pdomHTMLBlock.replace( new RegExp( '<[/]?\\w*[ >]', 'g' ), '\n$&' ); // add breaks in the string
      var $PDOMcode = $( '<pre class="brush: html"></pre>' ).text( formattedPDOM );

      $code.after( $PDOMcode ).after( $( '<br/><p>And the pDOM representation</p>' ) );
    }
  </script>

  <style type="text/css">

    .exampleScene {
      margin: 15px auto;
      border: 1px solid black;
      position: relative;
      left: 0;
      top: 0;
    }

    #sidebar {
      background-color: #eee;
      position: fixed;
      z-index: 10;
      top: 41px;
      left: 0;
      bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #bbb;
      box-shadow: 0 0 20px #ccc;
      -webkit-box-shadow: 0 0 20px #ccc;
      -moz-box-shadow: 0 0 20px #ccc;
    }

    #apiList {
      background-color: #eee;
      position: relative;
      border: 1px solid #bbb;
      border-left: none;
      padding: 10px;
    }

    .ph2 {
      font-weight: bold;
      font-size: 18px;
    }

    .navlink {
      font-weight: bold;
    }

    .sublink {
      padding-left: 1em;
    }

    .args {
      font-weight: normal;
      font-size: 80%;
    }

    footer {
      maring-left: 2em;
      background-color: #191919;
    }
  </style>

</head>

<body>
<div class="navbar navbar-inverse navbar-static-top">
  <div class="navbar-inner">
    <a class="brand" href="/scenery">Scenery</a>
    <ul class="nav">
      <li><a href="../">Home</a></li>
      <li class="active"><a href="../doc">Documentation</a></li>
      <li><a href="../examples">Examples</a></li>
      <li><a href="../tests">Tests</a></li>
    </ul>
  </div>
</div>

<div class="row-fluid">
  <div class="span3"></div>
  <div class="span6">
    <div class="page-header" style="text-align: center;">
      <h1>Accessible Content in Scenery</h1>
      <div class="span3"></div>

    </div>

  </div>
</div>
<div class="row-fluid">
  <div class="span3" id="apiList">
    <!--<div class="ph2"><a href="#pDOM">The Parallel DOM</a></div>-->
    <!--<div class="ph2"><a href="#overall-structure">Type Structure</a></div>-->

    <div class="ph2"><a href="#a11y-api">The Accessibility API</a></div>
    <div class="navlink"><a href="#ex-basic">A Basic Example</a></div>
    <div class="sublink"><a href="#ex-basic">tagName</a></div>
    <div class="sublink"><a href="#ex-basic">innerContent</a></div>

    <div class="navlink"><a href="#ex-all-siblings">Multiple DOM Elements per Node</a></div>
    <div class="sublink"><a href="#ex-all-siblings">labelTagName</a></div>
    <div class="sublink"><a href="#ex-all-siblings">labelContent</a></div>
    <div class="sublink"><a href="#ex-all-siblings">descriptionTagName</a></div>
    <div class="sublink"><a href="#ex-all-siblings">descriptionContent</a></div>
    <div class="sublink"><a href="#container-tag">containerTagName</a></div>
    <div class="sublink"><a href="#append-siblings">appendLabel</a></div>
    <div class="sublink"><a href="#append-siblings">appendDescription</a></div>

    <div class="navlink"><a href="#keyboard-nav">Keyboard Navigation</a></div>
    <div class="sublink"><a href="#input">inputType</a></div>
    <div class="sublink"><a href="#input">inputValue</a></div>
    <div class="sublink"><a href="#input">accessibleChecked</a></div>
    <div class="sublink"><a href="#input">addAccessibleInputListener()</a></div>
    <div class="sublink"><a href="#focus">focusable</a></div>
    <div class="sublink"><a href="#focus">accessibleVisible</a></div>
    <div class="sublink"><a href="#focus">accessibleContentDisplayed</a></div>
    <div class="sublink"><a href="#focus">focus()</a></div>
    <div class="sublink"><a href="#focus">blur()</a></div>

    <div class="navlink"><a href="#static-descriptions">Static Descriptions</a></div>
    <div class="sublink"><a href="#accessible-name">Accessible Name</a></div>
    <div class="sublink"><a href="#accessible-name">ariaLabel</a></div>
    <div class="sublink"><a href="#accessible-name">aria-labelledby</a></div>
    <div class="sublink"><a href="#ordering">accessibleOrder</a></div>

    <div class="navlink"><a href="#dynamic-descriptions">Dynamic Descriptions</a></div>
    <div class="sublink"><a href="#dynamic-descriptions">UtteranceQueue</a></div>


    <div class="ph2"><a href="#a11y-strings">Handling A11y Specific strings</a></div>
    <div class="ph2"><a href="#a11y-resources">Resources for Further Understanding</a></div>


  </div>
  <div class="span6">

    <p>
      Any Node in scenery, even those that are not visible or pickable, can have accessible content. The accessible
      content will represent the node in the parallel DOM tree.
    </p>

    <h2 id="pDOM">The Parallel DOM</h2>

    <p>
      The traditional renderings of PhET sims (svg, canvas, webgl) hold very little semantic data as to what is inside
      the rendered graphic. They are a single, graphical element in the html. The pDOM ( parallel DOM (document object
      model)) pulls semantic data from the Scenery scene graph and adds it to an separate html structure that is
      accessible to assistive technologies. When we say pDOM, think an html manifestation of the graphical
      <code>Node</code>
      content in the phetsim.
    </p>
    <p>
      This html acts as just another input/output modality to a simulation's model. You can interact with it to control
      the simulation, and you can get information out of it, as the pDOM is updated in real time in response to changes
      in the model.
    </p>
    <p>
      The parallel DOM is an invisible structure that runs alongside scenery. It is a basic HTML document that
      represents active scenery elements. It provides an interface to accessible technologies so that they receive
      a snapshot of the display at a given state. It is dynamic and the DOM tree will update with changes to the
      scene. Any node that has accessible content specified will be represented in the parallel DOM. The HTML structure
      is used so that scenery can rely on semantic HTML accessibility conventions. This way, scenery can push some of
      the accessibility work load to the browser and AT for providing keyboard navigation and auditory descriptions.
    </p>

    <h2 id="overall-structure">Overall Code structure</h2>

    <p>Note: <i>a11y</i> is a synonym for accessibility.</p>

    <p>Accessibility.js is a trait that is added to <code>Node.js</code>, so all we have to do is pass in a11y specific
      options
      like normal into the Parent.call() or mutate() function calls.</p>

    <p>The DAG features of the a11y side of Scenery are handled parallel to <code>Node</code>s in Scenery. Each <code>Node</code>
      with the
      Accessibility trait added to its prototype has N AccessibleInstances based on the number of times it has been
      added to the scene graph. The pDOM elements of each <code>Node</code> are created and handled with AccessiblePeer.
      There is
      a 1x1 relationship of AccessibleInstance and AccessiblePeer.</p>


    <h2 id="a11y-api">The Accessible Node API</h2>

    <p>Below explains how to use the accessibility functionality of scenery. For more information and up-to-date api
      documentation, see <a href="https://github.com/phetsims/scenery/blob/master/js/accessibility/Accessibility.js#L4">
        the source code</a>. On the side bar, options are categorized by
      where they are introduced and explained. In this file there is little "traditional" documentation, rather
      example based explanation. The source code is the best place for specifics and implementation.
    </p>

    <h3 id="ex-basic">A Basic Example</h3>

    <p>The primary way that developers will interact with a11y is through options passed through to <code>Node.js</code>.
      First off, each <code>Node</code> that wants content in the pDOM will need an html element in the pDOM to
      represent it.
      To do this, use the <code>tagName</code> option:</p>
    <div id="example-accessibleTag" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-accessibleTag', function( scene, display ) {
        /*START*/
        var a11yNode = new scenery.Rectangle( 0, 0, 64, 64, {
          fill: 'blue',

          // a11y
          tagName: 'p',
          innerContent: 'I am a beautiful, blue rectangle.'
        } );
        scene.addChild( a11yNode );
        display.updateOnRequestAnimationFrame();
        /*END*/
      } );
    </script>

    <p>Above is a simple scenery <code>Rectangle</code>, that is represented as a paragraph tag in the pDOM.
      I also gave the <code>&lt;p&gt;</code> text content inside the html element.</p>

    <h3 id="ex-all-siblings">Multiple DOM Elements per Node</h3>

    <p>Although a Node has a primary DOM element that represents it in the pDOM, other DOM Elements can provide
      supplemental information to convey to assistive technology. Label and Description elements can be added, as well
      as a parent element to contain all DOM Element siblings for a node. In total a Node can have up to four DOM
      Elements: the primary sibling, label sibling, description sibling, and the container parent. Here is an
      example of a <code>Node</code> that uses all of it's elements to provide the fullest semantic picture of the sim
      to the pDOM.
    </p>

    <div id="example-all-siblings" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-all-siblings', function( scene, display ) {
        /*START*/
        var a11yNode = new scenery.Rectangle( 0, 0, 64, 64, {
          fill: 'blue',

          // a11y
          tagName: 'button',
          innerContent: 'Remove Wall',
          labelTagName: 'h3',
          labelContent: 'Press the remove wall button below.',
          descriptionTagName: 'p',
          descriptionContent: 'Play with or without the wall.'
        } );

        scene.addChild( a11yNode );
        a11yNode.addChild( new scenery.Text( 'Remove Wall', { stroke: 'white', center: a11yNode.center } ) );
        display.updateOnRequestAnimationFrame();
        /*END*/
      } );
    </script>

    <p>A few notes here:</p>
    <ul>
      <li id="container-tag">Although a container parent wasn't explicitly added, the a11y api automatically adds a
        container when there is
        more than one sibling. The default <code>containerTagName</code> is stored in <code>AccessibilityUtil</code>.
      </li>
      <li>Taking the above bullet one step further, description and label tags have defaults too (see
        <code>AccessibilityUtil</code>).
        Specifying a "*Content" option without the "*TagName" option will produce an element of the default.
      </li>
      <li>Having a label, and inner content here is a bit redundant, but the API is flexible enough to work for many
        cases.
      </li>
      <li id="append-siblings">By default the description and label tags come before the primary sibling, you can change
        this with
        <code>appendLabel</code> and <code>appendDescription</code> options.
      </li>
    </ul>


    <h3 id="keyboard-nav">Keyboard Navigation</h3>
    <p>Part of making a PhET simulation accessible is adding keyboard navigation to it. This is an essential part
      of the process because it vastly increased the number of input devices that can interact with a phetsim.
      The a11y api supports keyboard navigation only on the Node's primary sibling.
      A general philosophy to follow is to have the DOM Element hold as much semantic information as possible.
      For example, if there is a button in the sim, it is an obvious choice to use a "button" element as the
      Node's primary sibling tag. Another solution that works, although it is much worse, would be to choose
      a div, and then add listeners manually to control that div like a button. In general try to pick
      semantic html elements that will assist in conveying as much meaning as possible to the user. Although
      it is possible to use the ARIA spec to improve accessible experience, it should not be thought of as
      the first answer (<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA">further
        reading</a> on ARIA will be useful to know). Addressing semantics any further goes beyond
      the scope of this document.
    </p>

    <h4 id="input">Input types</h4>
    <p>If you specify a <code>tagName: 'input'</code>, then use the <code>inputType</code> option to fill in the "type"
      attribute of the element. There are also <code>inputValue</code> and <code>accessibleChecked</code> options to
      manipulate specific and common (that we found) attributes of input tags. If you need more control of the primary
      DOM element's attributes, see <code>Node.setAccessibleAttribute()</code>.
    </p>
    <p></p>
    <div id="example-input-type" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-input-type', function( scene, display ) {
        /*START*/
        var a11yNode = new scenery.Node( {
          fill: 'blue',

          // a11y
          tagName: 'input',
          inputType: 'checkbox',
          labelContent: 'Toggle sim state'
        } );

        scene.addChild( a11yNode );
        display.updateOnRequestAnimationFrame();
        /*END*/
      } );
    </script>

    <p>The above example is a Node whose pDOM representation is that of a basic checkbox. In order to give it
      interactive
      functionality, use <code>Node.addAccessibleInputListener()</code>. The function takes in type
      <code>Object.&lt;string, function&gt;</code> where the key is the name of the DOM Event you want to listen to.
      This
      event is more often than not different than the listener needed for a mouse. Don't forget to remove the listener
      the listener
      when the <code>Node</code> is disposed with <code>Node.removeAccessibleInputListener()</code>.
    </p>

    <h4 id="focus">Focus</h4>

    <p>All interactive elements in the pDOM receive keyboard focus, but not all sim objects are interactive. For
      example, the Sweater in BASE is a dynamic content object because it's electrons can be transferred to
      a balloon. Even so it is not directly interacted with by the user, thus the sweater never receives focus.</p>
    <p>
      When an element in the pDOM is focused, a focus highlight is rendered in the simulation to support
      keyboard navigation. For more complex interactions, type <code>input</code>, or other native, focusable
      elements may not work. Other tag names can be focussed with the <code>focusable</code> option. This
      will add a tab index of 0 to the element. Focusable elements can be manually focussed and blurred using the
      <code>Node.focus()</code> and <code>Node.blur()</code> functions. If a specific focus highlight is desired, a
      <code>Node</code> or <code>Shape</code> can be passed into the <code>focusHighlight</code> option.
    </p>

    <p>
      Visibility in the pDOM and the focus order is directly effected by <code>Node.visible</code>, but can
      also be toggled independently with the option <code>Node.accessibleVisible</code>. When set to true this
      will hide content from screen readers and remove the element from focus order.
    </p>


    <h3 id="static-descriptions">Static Descriptions</h3>

    <h4 id="accessible-name">A Note About Accessible Name</h4>
    <p>The Accessible Name of an element is how assistive technology identifies an element in the browser's
      accessibility tree. Diving into the nuance of this idea goes beyond the scope of this document, but
      understanding this is imperative to successfully creating the "static" descriptions in PhET Sims.
      <a href="https://developer.paciellogroup.com/blog/2017/04/what-is-an-accessible-name/">Here</a> is a
      short article that describes very simple an briefly the different ways an element gets an accessible name.
    </p>
    <p>Here is an overview about the various ways to set the accessible name. As the sim developer, it is your
      responsibility to make sure that each interactive element has an accessible name.
    </p>
    <ul>
      <li>Element's Content: Example <code>&lt;button&gt;My Button&lt;/button&gt;</code>. The inner text within the
        button's opening and closing tags is the button element's accessible name.
      </li>
      <li><code>label</code> Element: a label element can be associated with an interactive input type that does
        not have inner content in order to provide the input with an accessible name. A label is preferred naming
        method when the sim interaction has visible text-based identifying it on screen. A label element can only
        be associated with "labelable" elements like
        <a href="http://w3c.github.io/html/sec-forms.html#labelable-element.">typical interactive HTML elements</a>.
        It cannot, for example, be associated with a div with role="checkbox". When a visible text-based label does
        not exist on screen, other labeling options can be considered.
      </li>
      <li><code>aria-label</code> Attribute: is an ARIA attribute that can provide an accessible name. For the a11y
        api use the <code>ariaLabel</code> option to set the value of said attribute on the primary sibling.
      </li>
      <li>
        <code>aria-labelledby</code> Attribute: <code>aria-labelledby</code> can be used to associate an HTML
        element other than the label element to another element. The elements do not have to be right beside each
        other. In a PhET Sim one might want to associate a heading element with a region or group. For example,
        an H2 heading is associated with the Play Area region through an <code>aria-labelledby</code> attribute.
        With this association the H2's content, "Play Area", provides the region with an accessible name in the
        Accessibility Tree which is accessed by assistive technology. <strong>TODO: the a11y api docs to come. Also
        add describedby?</strong>
      </li>
    </ul>

    <h4 id="ordering">Ordering</h4>
    To manipulate the order in the pDOM, use <code>Node.accessibleOrder = []</code>. As of this writing,
    <code>accessibleOrder</code> only supports ordering of direct children. Whatever is specified by the option will go
    first, followed by all of children in scene graph rendering order. Currently there is work in progress to support
    the ordering of accessible subtrees, not just children, see
    <a href="https://github.com/phetsims/scenery-phet/issues/365">this github issue</a> for more information.
    <strong>TODO: update doc on completiong of that issue</strong>

    <h3 id="dynamic-descriptions">Dynamic Descriptions</h3>

    <p>All interactive alerts are powered with the <code>aria-live</code> attribute. PhET uses the UtteranceQueue
      singleton to manage alerts and send them to assistive technology.</p>

    <p>TODO: make sure it is clear the difference between dynamic state information (conveyed in the pDOM), and dynamic
      interactive alerts.
    </p>

    <h2 id="a11y-strings">A11y Specific Strings</h2>
    <p>Accessibility specific strings are not yet translatable. That being said PhET has every intention of getting to
      the point where they are, we just don't have the infrastructure set up yet. Keeping that in mind, please follow
      the
      following conventions. This will help us greatly when it comes time to move these a11y strings into the
      translatable
      strings json file.
    </p>
    <ul>
      <li>We currently store a11y strings in a js file, name this file <code>{{SIM}}A11yStrings.js</code>.</li>
      <li>When using these strings, please think of it with the same convention and lint rule mind set as with the
        <code>string!</code> plugin. This means:
        <ul>
          <li>Name a11y string keys without the "String" at the end of the key.</li>
          <li>Have variable names that end in "String" when declaring.</li>
          <li>Declare all a11y strings at the top of the file (like their own module)</li>
          <li>String keys should hold an object with a "value" key that stores the a11y string. This is the same
            convention as with other PhET strings, but see <code>OhmsLawA11yStrings.js</code> for an example.
          </li>
        </ul>
      </li>
    </ul>
    <h2 id="a11y-resources">Resources for Further Understanding</h2>

    <p>Please discuss developer related questions or problems with @jessegreenberg, @zepumph, or @mbarlow12 and
      update this document accordingly to help those who follow in your footsteps. Also @terracoda is a great
      resource on questions about ARIA and accessibility in general.
    </p>
    <ul>
      <li><a href="https://drive.google.com/file/d/0B44Uycdx6JGdRFpXcDJqZl9BUk0/view">Screen Reader Support for a
        Complex Interactive Science Simulation</a></li>
      <li><a href="http://scholarworks.csun.edu/handle/10211.3/190214">Description Strategies to Make an Interactive
        Science Simulation Accessible</a></li>
    </ul>


  </div>


</div>

<footer style="background-color: #191919;">
  <a class="brand" href="/scenery">Scenery</a>
</footer>

<script type="text/javascript">
  SyntaxHighlighter.all();
</script>
</body>
</html>
