<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- runs in full-screen mode on iOS devices -->
  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>Documentation - Scenery</title>
  
  <link rel="stylesheet" href="../contrib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../contrib/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../contrib/syntaxhighlighter-3.0.83/shThemeDefault.css">
  
  <!-- jQuery and LoDash are dependencies -->
  <script src="../contrib/jquery-1.8.3.min.js"></script>
  <script src="../contrib/lodash.min-1.0.0-rc.3.js"></script>
  
  <!-- For the styling -->
  <script src="../contrib/bootstrap-2.2.2.js"></script>
  
  <script src="../contrib/syntaxhighlighter-3.0.83/shCore.js"></script>
  <script src="../contrib/syntaxhighlighter-3.0.83/shBrushJScript.js"></script>
  <script src="../contrib/syntaxhighlighter-3.0.83/shBrushXml.js"></script>
  
  <!-- MathJax config -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../dist/development/scenery.js"></script>
  
  <script type="text/javascript">
    scenery.Util.polyfillRequestAnimationFrame();
    
    function docExample( id, draw ) {
      var $container = $( '#' + id );
      var scene = new scenery.Scene( $container );
      draw( scene );
      scene.updateScene();
      var $code = $( '<pre class="brush: js"></pre>' );
      $code.text( draw.toString().match( /\/\*START\*\/((.|\n)*)\/\*END\*\// )[1] );
      $container.after( $code );
    }
  </script>
  
  <style type="text/css">
    
    .exampleScene {
      margin: 15px auto;
      border: 1px solid black;
    }
    
    #sidebar {
      background-color: #eee;
      position: fixed;
      z-index: 10;
      top: 41px; left: 0; bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #bbb;
      box-shadow: 0 0 20px #ccc; -webkit-box-shadow: 0 0 20px #ccc; -moz-box-shadow: 0 0 20px #ccc;
    }
    
    #apiList {
      background-color: #eee;
      position: relative;
      border: 1px solid #bbb;
      border-left: none;
      padding: 10px;
    }
    
    .ph2 {
      font-weight: bold;
      font-size: 18px;
    }
    
    .navlink {
      font-weight: bold;
    }
    
    .sublink {
      padding-left: 1em;
    }
  </style>
  
</head>

<body>
  <div class="navbar navbar-inverse navbar-static-top">
    <div class="navbar-inner">
      <a class="brand" href="../">Scenery</a>
      <ul class="nav">
        <li><a href="../">Home</a></li>
        <li class="active"><a href="../doc">Documentation</a></li>
        <li><a href="../examples">Examples</a></li>
        <li><a href="../tests">Tests</a></li>
      </ul>
    </div>
  </div>
  
  <div class="row-fluid">
    <div class="span3"></div>
    <div class="span6">
      <div class="page-header" style="text-align: center;">
        <h1>Scenery Documentation</h1>
      </div>
      
      <p class="lead" style="color: #a00;">Currently incomplete!</p>
      
      TODO: coordinate frame notes
      
    </div>
    <div class="span3"></div>
  </div>
  
  <div class="row-fluid">
    <div class="span3" id="apiList">
      <div class="ph2"><a href="#api">Scenery API</a></div>
      
      <a class="navlink" href="#node">Node</a><br>
      <a class="sublink" href="#node-options">(options)</a><br>
      <a class="sublink" href="#node-children">children</a><br>
      <a class="sublink" href="#node-parents">parents</a><br>
      <a class="sublink" href="#node-addChild">addChild</a><br>
      <a class="sublink" href="#node-insertChild">insertChild</a><br>
      <a class="sublink" href="#node-removeChild">removeChild</a><br>
      <a class="sublink" href="#node-detach">detach</a><br>
      <a class="sublink" href="#node-cursor">cursor</a><br>
      <a class="sublink" href="#node-visible">visible</a><br>
      <a class="sublink" href="#node-pickable">pickable</a><br>
      <a class="sublink" href="#node-translation">translation</a><br>
      <a class="sublink" href="#node-translate">translate</a><br>
      <a class="sublink" href="#node-x">x</a><br>
      <a class="sublink" href="#node-y">y</a><br>
      <a class="sublink" href="#node-rotation">rotation</a><br>
      <a class="sublink" href="#node-rotate">rotate</a><br>
      <a class="sublink" href="#node-rotateAround">rotateAround</a><br>
      <a class="sublink" href="#node-scale">scale</a><br>
      <a class="sublink" href="#node-bounds">bounds</a><br>
      <a class="sublink" href="#node-selfBounds">selfBounds</a><br>
      <a class="sublink" href="#node-childBounds">childBounds</a><br>
      <a class="sublink" href="#node-left">left</a><br>
      <a class="sublink" href="#node-right">right</a><br>
      <a class="sublink" href="#node-top">top</a><br>
      <a class="sublink" href="#node-bottom">bottom</a><br>
      <a class="sublink" href="#node-centerX">centerX</a><br>
      <a class="sublink" href="#node-centerY">centerY</a><br>
      <a class="sublink" href="#node-renderer">renderer</a><br>
      <a class="sublink" href="#node-rendererOptions">rendererOptions</a><br>
      <a class="sublink" href="#node-layerSplit">layerSplit</a><br>
      <a class="sublink" href="#node-layerSplitBefore">layerSplitBefore</a><br>
      <a class="sublink" href="#node-layerSplitAfter">layerSplitAfter</a><br>
      
      <a class="navlink" href="#scene">Scene</a><br>
      <a class="sublink" href="#scene-options">(options)</a><br>
      <a class="sublink" href="#scene-updateScene">updateScene</a><br>
      <a class="sublink" href="#scene-dispose">dispose</a><br>
      <a class="sublink" href="#scene-renderToCanvas">renderToCanvas</a><br>
      <a class="sublink" href="#scene-canvasSnapshot">canvasSnapshot</a><br>
      <a class="sublink" href="#scene-canvasDataURL">canvasDataURL</a><br>
      <a class="sublink" href="#scene-updateOnRequestAnimationFrame">updateOnRequestAnimationFrame</a><br>
      <a class="sublink" href="#scene-initializeStandaloneEvents">initializeStandaloneEvents</a><br>
      <a class="sublink" href="#scene-initializeFullscreenEvents">initializeFullscreenEvents</a><br>
      <a class="sublink" href="#scene-getDebugHTML">getDebugHTML</a><br>
      <a class="sublink" href="#scene-popupDebug">popupDebug</a><br>
      
      <a class="navlink" href="#fillable">Fillable</a><br>
      <a class="sublink" href="#fillable-fill">fill</a><br>
      
      <a class="navlink" href="#strokable">Strokable</a><br>
      <a class="sublink" href="#strokable-stroke">stroke</a><br>
      <a class="sublink" href="#strokable-lineWidth">lineWidth</a><br>
      <a class="sublink" href="#strokable-lineCap">lineCap</a><br>
      <a class="sublink" href="#strokable-lineJoin">lineJoin</a><br>
      <a class="sublink" href="#strokable-lineDash">lineDash</a><br>
      
      <a class="navlink" href="#path">Path</a><br>
      <a class="sublink" href="#path-shape">shape</a><br>
      
      <a class="navlink" href="#image">Image</a><br>
      <a class="sublink" href="#image-image">image</a><br>
      
      <a class="navlink" href="#text">Text</a><br>
      <a class="sublink" href="#text-options">(options)</a><br>
      <a class="sublink" href="#text-text">text</a><br>
      <a class="sublink" href="#text-font">font</a><br>
      <a class="sublink" href="#text-fontWeight">fontWeight</a><br>
      <a class="sublink" href="#text-fontFamily">fontFamily</a><br>
      <a class="sublink" href="#text-fontStretch">fontStretch</a><br>
      <a class="sublink" href="#text-fontStyle">fontStyle</a><br>
      <a class="sublink" href="#text-fontSize">fontSize</a><br>
      <a class="sublink" href="#text-lineHeight">lineHeight</a><br>
      <a class="sublink" href="#text-textAlign">textAlign</a><br>
      <a class="sublink" href="#text-textBaseline">textBaseline</a><br>
      <a class="sublink" href="#text-direction">direction</a><br>
      
      <a class="navlink" href="#dom">DOM</a><br>
      <a class="sublink" href="#dom-element">element</a><br>
      <a class="sublink" href="#dom-interactive">interactive</a><br>
      
      <a class="navlink" href="#pointer">Pointer</a><br>
      
      <a class="navlink" href="#font">Font</a><br>
      
      <a class="navlink" href="#linearGradient">LinearGradient</a><br>
      <a class="sublink" href="#linearGradient-addColorStop">addColorStop</a><br>
      <a class="sublink" href="#linearGradient-setTransformMatrix">setTransformMatrix</a><br>
      
      <a class="navlink" href="#radialGradient">RadialGradient</a><br>
      <a class="sublink" href="#radialGradient-addColorStop">addColorStop</a><br>
      <a class="sublink" href="#radialGradient-setTransformMatrix">setTransformMatrix</a><br>
      
      <a class="navlink" href="#pattern">Pattern</a><br>
      <a class="sublink" href="#pattern-setTransformMatrix">setTransformMatrix</a><br>
      
      <a class="navlink" href="#vbox">VBox</a><br>
      
    </div>
    <div class="span6">
      <h2 id="tutorials">Tutorials</h2>
      
      <p>If you are just starting out, see the <a href="a-tour-of-scenery.html">Tour of Scenery</a></p>
      
      <h2 id="dependencies">Dependencies</h2>
      
      <strong>External</strong> dependencies (please provide these in your page before loading Scenery):
      <ul>
        <li><a href="http://jquery.com/">jQuery</a> for parts of DOM manipulation.</li>
        <li><a href="http://lodash.com/">Lo-Dash</a> for utility functions, as a replacement for <a href="http://underscorejs.org/">Underscore.js</a>.</li>
        <li>[optional] <a href="https://code.google.com/p/canvg/">Canvg</a>, for supporting SVG &#8594; Canvas operations, like <a href="#scene-renderToCanvas">scene.renderToCanvas</a></li>
      </ul>
      
      <strong>Internal</strong> dependencies:
      <ul>
        <li><a href="https://github.com/phetsims/assert">assert</a> for assertion handling. If you want assertions different from the defaults, include <a href="https://github.com/phiggins42/has.js/">has.js</a>.</li>
        <li><a href="https://github.com/phetsims/phet-core">phet-core</a> for other utility functions.</li>
        <li><a href="../../dot">Dot</a> for math.</li>
        <li><a href="../../kite">Kite</a> for shapes.</li>
      </ul>
      
      <h2 id="api">Scenery API</h2>
      
      <h3 id="node" class="section">Node</h3>
      
      <p>
        A default node can be created with <code>new scenery.Node()</code>, but usually a parameter object is
        given, for example <code>new scenery.Node( { x: 20, y: 100 } )</code>. Below are all of the available
        parameter object options:
      </p>
      
      <h4 id="node-options">Node Options</h4>
      A Node (and Node subtypes) have the following parameter object options available, executed in in the order listed.
      
      <ul>
        <li><a href="#node-children">children</a>: A list of children to add (in order)</li>
        <li><a href="#node-cursor">cursor</a>: Will display the specified CSS cursor when the mouse is over this Node or one of its descendents. The Scene needs to have input listeners attached with an initialize method first.</li>
        <li><a href="#node-visible">visible</a>: If false, this node (and its children) will not be displayed (or get input events)</li>
        <li><a href="#node-pickable">pickable</a>: If false, this node (and its children) will not get input events</li>
        <li><a href="#node-translation">translation</a>: Sets the translation of the node to either the specified <a href="../../dot/doc#vector2">dot.Vector2</a> value, or the x,y values from an object (e.g. translation: { x: 1, y: 2 } )</li>
        <li><a href="#node-x">x</a>: Sets the x-translation of the node</li>
        <li><a href="#node-y">y</a>: Sets the y-translation of the node</li>
        <li><a href="#node-rotation">rotation</a>: Sets the rotation of the node in radians</li>
        <li><a href="#node-scale">scale</a>: Sets the scale of the node. Supports either a number (same x-y scale), or a <a href="../../dot/doc#vector2">dot.Vector2</a> / object with ob.x and ob.y to set the scale for each axis independently</li>
        <li><a href="#node-left">left</a>: Sets the x-translation so that the left (min X) of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-right">right</a>: Sets the x-translation so that the right (max X) of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-top">top</a>: Sets the y-translation so that the top (min Y) of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-bottom">bottom</a>: Sets the y-translation so that the bottom (min Y) of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-centerX">centerX</a>: Sets the x-translation so that the horizontal center of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-centerY">centerY</a>: Sets the y-translation so that the vertical center of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-renderer">renderer</a>: Forces Scenery to use the specific renderer (canvas/svg) to display this node (and if possible, children). Accepts both strings (e.g. 'canvas', 'svg', etc.) or actual Renderer objects (e.g. Renderer.Canvas, Renderer.SVG, etc.)</li>
        <li><a href="#node-rendererOptions">rendererOptions</a>: Parameter object that is passed to the created layer, and can affect how the layering process works.</li>
        <li><a href="#node-layerSplit">layerSplit</a>: Forces a split between layers before and after this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.</li>
        <li><a href="#node-layerSplitBefore">layerSplitBefore</a>: Forces a split between layers before this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.</li>
        <li><a href="#node-layerSplitAfter">layerSplitAfter</a>: Forces a split between layers after this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.</li>
      </ul>
      
      <h4 id="node-children">node.children</h4>
      <p>
        <code>node.children</code> is a getter/setter linked to <code>node.getChildren()</code> and <code>node.setChildren( children )</code>.
        This will return a copy of node's array of children, in rendering
        order (later children render above previous children). Making changes to the returned array will not change node's children.
      </p>
      <p>
        This can also be used when creating a Node:
      </p>
      <div id="example-children" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-children', function( scene ) {
/*START*/
scene.addChild( new scenery.Node( {
  // an array of children can be specified, so no
  // reference to the container node is needed
  children: [
    // gray rectangle on the left
    new scenery.Path( {
      shape: kite.Shape.rectangle( 0, 0, 64, 64 ),
      fill: '#aaa'
    } ),
    
    // later nodes in the array will show up on top
    // of previous nodes
    new scenery.Text( 'Children', {
      font: '20px sans-serif',
      centerX: 64,
      centerY: 32
    } )
  ]
} ) );
/*END*/ } );
      </script>
      
      <h4 id="node-parents">node.parents</h4>
      <p>
        <code>node.parents</code> or <code>node.getParents()</code> will return an array of parent nodes, but <strong>order is not significant</strong>.
      </p>
      
      <h4 id="node-addChild">node.addChild( childNode )</h4>
      <p>
        Appends childNode to node's list of children. childNode will be displayed above node and node's other children.
      </p>
      
      <h4 id="node-insertChild">node.insertChild( index, childNode )</h4>
      <p>
        Inserts childNode into node's children at the specified index. <code>node.insertChild( 0, childNode )</code> will make childNode the first child, and
        <code>node.insertChild( node.children.length, childNode )</code> is the same as <code>node.addChild( childNode )</code>.
      </p>
      
      <h4 id="node-removeChild">node.removeChild( childNode )</h4>
      <p>
        Removes childNode from node's children.
      </p>
      
      <h4 id="node-detach">node.detach()</h4>
      <p>
        Removes this node from all of its parents.
      </p>
      
      <h4 id="node-cursor">node.cursor</h4>
      <p>
        <code>node.cursor</code> is a getter/setter linked to <code>node.getCursor()</code> and <code>node.setCursor( cursor )</code>.
        By default it is null (default cursor), but this can be set to
        the string for any <a href="https://developer.mozilla.org/en-US/docs/CSS/cursor">CSS cursor value</a>. There is
        <a href="../examples/cursors.html">a cursor example page</a> that demos a number of available cursors.
      </p>
      <p>
        The cursor is updated whenever <a href="#scene-updateCursor">scene.updateCursor</a> or <a href="#scene-updateScene">scene.updateScene</a> is called, and event initialization like <a href="#scene-initializeStandaloneEvents">scene.initializeStandaloneEvents</a> should be added so Scenery can track the mouse input.
      </p>
      <div id="example-cursor" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-cursor', function( scene ) {
/*START*/
scene.addChild( new scenery.Path( {
  shape: kite.Shape.regularPolygon( 6, 25 ),
  x: 64, y: 32,
  fill: '#88f',
  cursor: 'pointer' // classic hand
} ) );
/*END*/
// event initialization needed for cursor to work
scene.initializeStandaloneEvents();

// and update on every frame
scene.updateOnRequestAnimationFrame();
} );
      </script>
      
      <h4 id="node-visible">node.visible</h4>
      <p>
        <code>node.visible</code> is a getter/setter linked to <code>node.isVisible()</code> and <code>node.setVisible( boolean )</code>.
        Nodes are by default visible, but when invisible they will not
        be displayed and will not be pickable (no input events will be targeted to them).
      </p>
      
      <h4 id="node-pickable">node.pickable</h4>
      <p>
        <code>node.pickable</code> is a getter/setter linked to <code>node.isPickable()</code> and <code>node.setPickable( boolean )</code>.
        Nodes that are not pickable will no longer have input events targeted to them, and <a href="#node-trailUnderPoint">node.trailUnderPoint</a>
        will not include them.
      </p>
      <p>
        This is useful for semi-transparent overlays or other visual elements that should be displayed but should not prevent objects below from being
        manipulated by user input.
      </p>
      
      <h4 id="node-translation">node.translation</h4>
      <p>
        Getting the translation: <code>node.translation</code> or <code>node.getTranslation()</code>. It always returns a <a href="../../dot/doc#vector2">dot.Vector2</a> instance representing
        the translation part of the node's transform. See <a href="../../dot/doc#matrix3-getTranslation">dot.Matrix3.getTranslation</a> for more information.
      </p>
      <p>
        Setting the translation: <code>node.translation = translation</code>, <code>node.setTranslation( translation )</code> or <code>node.setTranslation( x, y )</code>.
        In both instances, <code>translation</code> can be either a <a href="../../dot/doc#vector2">dot.Vector2</a> or an object literal like <code>{ x: 5, y: 10 }</code>.
      </p>
      
      <h4 id="node-translate">node.translate( x, y )</h4>
      <p>
        Translates the node relatively by <code>x</code> and <code>y</code>. In addition to <code>node.translate( x, y )</code>, <code>node.translate( translation )</code>
        can be used, where <code>transform</code> is either a <a href="../../dot/doc#vector2">dot.Vector2</a> or an object like <code>{ x: 5, y: 10 }</code>
      </p>
      
      <h4 id="node-x">node.x</h4>
      <p>
        <code>node.x</code> gets or sets the node's x-translation with <code>node.getX()</code> and <code>node.setX( x )</code>. Accessing <code>node.x</code> is equivalent
        to <code>node.translation.x</code>, and setting <code>node.x</code> is equivalent to <code>node.setTranslation( x, node.y )</code>.
      </p>
      
      <h4 id="node-y">node.y</h4>
      <p>
        <code>node.y</code> gets or sets the node's y-translation with <code>node.getY()</code> and <code>node.setY( y )</code>. Accessing <code>node.y</code> is equivalent
        to <code>node.translation.y</code>, and setting <code>node.y</code> is equivalent to <code>node.setTranslation( node.x, y )</code>.
      </p>
      
      <h4 id="node-rotation">node.rotation</h4>
      <p>
        <code>node.rotation</code> gets or sets the node's rotation with <code>node.getRotation()</code> and <code>node.setRotation( radians )</code>. All rotations are
        handled in radians ($\pi$ is a 180-degree rotation). If you wish to rotate a node by a specific rotation
        (instead of setting its rotation), use <a href="#node-rotate">node.rotate</a>
      </p>
      
      <h4 id="node-rotate">node.rotate( radians, [prepend] )</h4>
      <p>
        Rotates the node's transform. By default the rotation is appended to the node's transform, but the optional <code>prepend</code> boolean flag can be added for the rotation
        to be prepended to the node's transform.
      </p>
      
      <h4 id="node-rotateAround">node.rotateAround( point, angle )</h4>
      <p>
        Rotates the node by <code>angle</code> in radians around the <a href="../../dot/doc#vector2">dot.Vector2</a> <code>point</code>. <code>point</code> should be in the node's parent coordinate frame.
      </p>
      
      <h4 id="node-scale">node.scale( x, y, [prepend] )</h4>
      <p>
        Scales the node in each axis. By default the scale is appended to the node's transform, but the optional <code>prepend</code> boolean flag can be added for the
        scale to be prepended to the node's transform.
      </p>
      <p>
        <code>node.scale( s )</code> will scale by <code>s</code> in both dimensions, and is equivalent to <code>node.scale( s, s )</code>
      </p>
      
      <h4 id="node-bounds">node.bounds</h4>
      <p>
        Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node (and its children) in the parent coordinate frame. Also available with <code>node.getBounds()</code>.
        <!-- TODO: add an example -->
      </p>
      
      <h4 id="node-selfBounds">node.selfBounds</h4>
      <p>
        Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node (without its children) in the local coordinate frame. Also available with <code>node.getSelfBounds()</code>.
        <!-- TODO: add an example -->
      </p>
      
      <h4 id="node-childBounds">node.childBounds</h4>
      <p>
        Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node's children (without include the node's selfBounds) in the local coordinate frame. Also available with <code>node.getChildBounds()</code>.
        <!-- TODO: add an example -->
      </p>
      
      <h4 id="node-left">node.left</h4>
      <p>
        <code>node.left</code> gets or sets the left bound (minimum x value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getLeft()</code> and <code>node.setLeft( x )</code>. Setting this left bound effectively translates the node horizontally.
      </p>
      
      <h4 id="node-right">node.right</h4>
      <p>
        <code>node.right</code> gets or sets the right bound (maximum x value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getRight()</code> and <code>node.setRight( x )</code>. Setting this right bound effectively translates the node horizontally.
      </p>
      
      <h4 id="node-top">node.top</h4>
      <p>
        <code>node.top</code> gets or sets the top bound (minimum y value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getTop()</code> and <code>node.setTop( y )</code>. Setting this top bound effectively translates the node vertically.
      </p>
      
      <h4 id="node-bottom">node.bottom</h4>
      <p>
        <code>node.bottom</code> gets or sets the bottom bound (maximum y value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getBottom()</code> and <code>node.setBottom( y )</code>. Setting this bottom bound effectively translates the node vertically.
      </p>
      
      <h4 id="node-centerX">node.centerX</h4>
      <p>
        <code>node.centerX</code> gets or sets the horizontal center of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getCenterX()</code> and <code>node.setCenterX( x )</code>. Setting centerX effectively translates the node horizontally.
      </p>
      
      <h4 id="node-centerY">node.centerY</h4>
      <p>
        <code>node.centerY</code> gets or sets the vertical center of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getCenterY()</code> and <code>node.setCenterY( y )</code>. Setting centerY effectively translates the node vertically.
      </p>
      
      <h4 id="node-renderer">node.renderer</h4>
      <p>
        <code>node.renderer</code> gets or sets the preferred rendering backend for the node (and children) using <code>node.getRenderer()</code> or <code>node.setRenderer( renderer )</code>.
      </p>
      <p>
        It will always return a <a href="#renderer">Renderer</a> object back, but setting the renderer can be done either with an <a href="#renderer">Renderer</a> reference or
        a string (either <code>'canvas'</code>, <code>'svg'</code>, <code>'dom'</code> or <code>'webgl'</code>). Manually specifying a renderer may preclude future
        performance/quality tradeoffs from being automatically made.
      </p>
      <p>
        Setting a renderer will have this node and its children use that renderer if they support it. This may be impossible (for instance, <a href="#path">Paths</a> do not support the <code>'dom'</code> renderer, and <a href="#dom">DOM nodes</a> do not support the <code>'canvas'</code> renderer).
      </p>
      <p>
        This renderer (if non-null) will override any renderers set on ancestor nodes. Effectively, a node's renderer will be decided by whatever the closest ancestor
        renderer that is compatible, or the scene default.
      </p>
      <p>
        <code>node.hasRenderer()</code> is a convenience function to determine if this is set on the node.
      </p>
      
      <h4 id="node-rendererOptions">node.rendererOptions</h4>
      <p>
        <code>node.rendererOptions</code> gets or sets options for the specified <a href="#node-renderer">renderer</a> using
        <code>node.getRendererOptions()</code> or <code>node.setRendererOptions( renderer )</code>.
        Setting <a href="#node-rendererOptions">rendererOptions</a> without setting <a href="#node-renderer">renderer</a> will have no effect, and may in future
        versions throw an error. If this option and the <a href="#node-renderer">renderer</a> is set, this node will have layer boundaries inserted before and after.
        <!-- TODO: docs of rendererOptions for different layers -->
      </p>
      
      <h4 id="node-layerSplit">node.layerSplit</h4>
      <p>
        Setter backed by <code>node.setLayerSplit( boolean )</code> that will set both <a href="#node-layerSplitBefore">layerSplitBefore</a> and
        <a href="#node-layerSplitAfter">layerSplitAfter</a> at the same time.
      </p>
      <p>
        Setting to true will cause anything rendered before or after to be in a separate layer from this node and its children.
      </p>
      
      <h4 id="node-layerSplitBefore">node.layerSplitBefore</h4>
      <p>
        Setter backed by <code>node.setLayerSplitBefore( boolean )</code> that, when set to true, will cause anything rendered before this node to
        be in a separate layer from this node and its children.
      </p>
      
      <h4 id="node-layerSplitAfter">node.layerSplitAfter</h4>
      <p>
        Setter backed by <code>node.setLayerSplitAfter( boolean )</code> that, when set to true, will cause anything rendered after this node to
        be in a separate layer from this node and its children.
      </p>
      

      <h3 id="scene" class="section">Scene</h3>
      <p>
        The Scene is the "entry point" of a scene graph. Scene extends Node, so all of its methods and options
        are inherited, see <a href="#node">Node</a> above.
        A scene is created with <code>new scenery.Scene( $container, [options] )</code>, where <code>$container</code>
        is a block-level DOM element (typically a div) wrapped with jQuery that all scene graphics
        (Canvas, SVG, etc.) are placed within.
        This element must be a positioned element (non-'static' CSS position, see
        the <a href="https://developer.mozilla.org/en-US/docs/CSS/position">MDN docs</a>), and should have a set width and height.
      </p>

      <h4 id="scene-options">Scene Options</h4>
      A Scene has the following options for the parameter object, in addition to all of <a href="#node-options">Node's options</a>:

      <ul>
        <li><a href="#scene-allowSceneOverflow">allowSceneOverflow</a> (default false): usually anything displayed outside of this $main (DOM/CSS3 transformed SVG) is hidden with CSS overflow</li>
        <li><a href="#scene-allowCSSHacks">allowCSSHacks</a> (default true): applies styling that prevents mobile browser graphical issues</li>
        <li><a href="#scene-allowDevicePixelRatioScaling">allowDevicePixelRatioScaling</a> (default false): allows underlying canvases (Canvas, WebGL) to increase in size to maintain sharpness on high-density displays</li>
        <li><a href="#scene-enablePointerEvents">enablePointerEvents</a> (default true): allows pointer events / MSPointerEvent to be used on supported platforms.</li>
        <li><a href="#scene-preferredSceneLayerType">preferredSceneLayerType</a> (default ???): sets the preferred type of layer to be created if there are multiple options.</li>
        <li><a href="#scene-width">width</a> (default currentWidth): override the main container's width</li>
        <li><a href="#scene-height">height</a> (default currentHeight): override the main container's height</li>
      </ul>
      
      <h4 id="scene-updateScene">scene.updateScene()</h4>
      <p>
        This redraws and/or repositions whatever rendering backends are being used to display the scene.
        It should be called whenever the scene's display should reflect new changes, generally on each
        <a href="https://developer.mozilla.org/en-US/docs/DOM/window.requestAnimationFrame">requestAnimationFrame</a>.
      </p>
      
      <h4 id="scene-dispose">scene.dispose()</h4>
      <p>
        Disposes of all of the scene's necessary resources and listeners, so that it should be able to be
        garbage collected if no more references are to the Scene. Call this once you no longer need a scene.
      </p>
      
      <h4 id="scene-renderToCanvas">scene.renderToCanvas( canvas, context, callback )</h4>
      <p>
        Renders all applicable layers that support Canvas output to the specified <code>canvas</code> (with
        the specified <code>context</code>). The <code>context</code> is specified in addition to the canvas
        to support any custom parameters that were given in context creation.
      </p>
      <p>
        <code>callback()</code> is called once the Scene is fully rendered to the canvas. Generally this is
        immediate (if the layers are canvas/webgl), or delayed (if a layer contains SVG content). Including
        the <a href="https://code.google.com/p/canvg/">Canvg</a> library is necessary for rendering SVG
        content to Canvas.
      </p>
      <p>
        DOM content is currently not supported for renderToCanvas.
      </p>
      
      <h4 id="scene-canvasSnapshot">scene.canvasSnapshot( callback )</h4>
      <p>
        Asynchronously draws the scene to a canvas with the same size as the scene
        (using <a href="#scene-renderToCanvas">renderToCanvas</a>, and calls <code>callback( canvas, imageData )</code>
        once it is fully written. <code>imageData</code> is of type <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#imagedata">ImageData</a>, from the Canvas specification.
      </p>
      <p>
        If any origin-dirty content (like cross-domain images without <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>) are included in the Scene, this operation will throw a security error.
      </p>
      
      <h4 id="scene-canvasDataURL">scene.canvasDataURL( callback )</h4>
      <p>
        Asynchronously draws the scene to an image (using <a href="#scene-canvasSnapshot">scene.canvasSnapshot</a>),
        and calls <code>callback( dataURL )</code> with the
        <a href="https://developer.mozilla.org/en-US/docs/data_URIs">data URI</a> for the image. Generally
        this is a PNG. Does not support origin-dirty content (see <a href="#scene-canvasSnapshot">canvasSnapshot</a>)
        inside the scene.
      </p>
      
      <h4 id="scene-updateOnRequestAnimationFrame">scene.updateOnRequestAnimationFrame( [element] )</h4>
      <p>
        A simple way of setting up <a href="#scene-updateScene">scene.updateScene</a> to be called using
        requestAnimationFrame. More advanced applications will want to handle this themselves.
      </p>
      
      <h4 id="scene-initializeStandaloneEvents">scene.initializeStandaloneEvents()</h4>
      <p>
        Attaches event listeners onto the scene's containing block-level element, and forwards them to
        the scene's input event handling system. This or <a href="scene-initializeFullscreenEvents">initializeFullscreenEvents</a> is necessary for cursor handling and input/pointer events.
      </p>
      
      <h4 id="scene-initializeFullscreenEvents">scene.initializeFullscreenEvents()</h4>
      <p>
        Attaches event listeners onto the containing document, and forwards them to
        the scene's input event handling system. This or <a href="scene-initializeStandaloneEvents">initializeStandaloneEvents</a> is necessary for cursor handling and input/pointer events.
      </p>
      <p>
        This may call <a href="https://developer.mozilla.org/en-US/docs/DOM/event.preventDefault">preventDefault</a>
        on events unrelated to the scene, so <a href="scene-initializeFullscreenEvents">initializeFullscreenEvents</a>
        should only be used when the scene takes up the entire screen.
      </p>
      
      <h4 id="scene-getDebugHTML">scene.getDebugHTML()</h4>
      <p>
        Returns an HTML string of debugging information that shows all of the nodes (their constructor type
        names), and all layering information.
      </p>
      
      <h4 id="scene-popupDebug">scene.popupDebug()</h4>
      <p>
        Pops the information from <a href="#scene-getDebugHTML">getDebugHTML</a> into a new window.
      </p>
      
      <h3 id="fillable" class="section">Fillable</h3>
      <p>
        A mix-in for <a href="#node">Node</a> subtypes that can be filled with a color/gradient/pattern.
      </p>
      
      <h4 id="fillable-fill">fill</h4>
      <p>
        <a href="#fillable">Fillable</a> nodes provide a single <code>node.fill</code> getter and setter
        that uses <code>node.getFill()</code> and <code>node.setFill( fill )</code>. <code>node.hasFill()</code>
        is also available as a quick check, and a null fill is interpreted as not having a fill.
      </p>
      <p>
        <code>fill</code> can currently be either a string (interpreted as a <a href="http://www.w3.org/TR/css3-color/">CSS color</a>), or an instance of a
        <a href="#linearGradient">LinearGradient</a>, <a href="#radialGradient">RadialGradient</a> or
        <a href="#pattern">Pattern</a>.
      </p>
      
      <h3 id="strokable" class="section">Strokable</h3>
      <p>
        A mix-in for <a href="#node">Node</a> subtypes that can be stroked (outlined) along a border with a color/gradient/pattern.
      </p>
      
      <h4 id="strokable-stroke">stroke</h4>
      <p>
        <code>node.stroke</code> is a getter and setter
        that uses <code>node.getStroke()</code> and <code>node.setStroke( stroke )</code>. <code>node.hasStroke()</code>
        is also available as a quick check, and a null stroke is interpreted as not having a stroke.
      </p>
      <p>
        <code>stroke</code> can currently be either a string (interpreted as a <a href="http://www.w3.org/TR/css3-color/">CSS color</a>), or an instance of a
        <a href="#linearGradient">LinearGradient</a>, <a href="#radialGradient">RadialGradient</a> or
        <a href="#pattern">Pattern</a>.
      </p>
      
      <h4 id="strokable-lineWidth">lineWidth</h4>
      <p>
        <code>node.lineWidth</code> (<code>node.getLineWidth()</code>, <code>node.setLineWidth( lineWidth )</code>)
        controls the thickness of the stroke.
      </p>
      
      <h4 id="strokable-lineCap">lineCap</h4>
      <p>
        <code>node.lineCap</code> (<code>node.getLineCap()</code>, <code>node.setLineCap( lineCap )</code>)
        controls the shape of end-caps, and uses the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-linecap">Canvas lineCap definitions</a> of <code>'butt'</code> (default),
        <code>'round'</code> and <code>'square'</code>.
      </p>
      <div id="example-lineCap" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-lineCap', function( scene ) {
scene.addChild( new scenery.Text( 'butt', {
  fontSize: 14,
  centerX: 256/6,
  y: 20
} ) );
scene.addChild( new scenery.Text( 'square', {
  fontSize: 14,
  centerX: 256*3/6,
  y: 20
} ) );
scene.addChild( new scenery.Text( 'round', {
  fontSize: 14,
  centerX: 256*5/6,
  y: 20
} ) );
/*START*/
var shape = kite.Shape.lineSegment( 0, 50, 0, 70 );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256/6,
  stroke: '#000',
  lineWidth: 30,
  lineCap: 'butt'
} ) );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256*3/6,
  stroke: '#000',
  lineWidth: 30,
  lineCap: 'square'
} ) );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256*5/6,
  stroke: '#000',
  lineWidth: 30,
  lineCap: 'round'
} ) );
/*END*/
// add a red highlight
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256/6,
  stroke: '#f00'
} ) );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256*3/6,
  stroke: '#f00'
} ) );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256*5/6,
  stroke: '#f00'
} ) );
} );
      </script>
      
      <h4 id="strokable-lineJoin">lineJoin</h4>
      <p>
        <code>node.lineJoin</code> (<code>node.getLineJoin()</code>, <code>node.setLineJoin( lineJoin )</code>)
        controls the shape of segment joins, and uses the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-linejoin">Canvas lineJoin definitions</a> of <code>'miter'</code> (default),
        <code>'round'</code> and <code>'bevel'</code>.
      </p>
      <div id="example-lineJoin" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-lineJoin', function( scene ) {
scene.addChild( new scenery.Text( 'miter', {
  fontSize: 14,
  centerX: 256/6,
  y: 20
} ) );
scene.addChild( new scenery.Text( 'bevel', {
  fontSize: 14,
  centerX: 256*3/6,
  y: 20
} ) );
scene.addChild( new scenery.Text( 'round', {
  fontSize: 14,
  centerX: 256*5/6,
  y: 20
} ) );
/*START*/
var shape = new kite.Shape().moveTo( -30, 80 ).lineTo( 0, 50 ).lineTo( 30, 80 );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256/6,
  stroke: '#000',
  lineWidth: 25,
  lineJoin: 'miter'
} ) );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256*3/6,
  stroke: '#000',
  lineWidth: 25,
  lineJoin: 'bevel'
} ) );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256*5/6,
  stroke: '#000',
  lineWidth: 25,
  lineJoin: 'round'
} ) );
/*END*/
// add a red highlight
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256/6,
  stroke: '#f00'
} ) );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256*3/6,
  stroke: '#f00'
} ) );
scene.addChild( new scenery.Path( {
  shape: shape,
  x: 256*5/6,
  stroke: '#f00'
} ) );
} );
      </script>
      
      <h4 id="strokable-lineDash">lineDash</h4>
      <p>
        <code>node.lineDash</code> (<code>node.getLineDash()</code>, <code>node.setLineDash( lineDash )</code>)
        controls any dashing of the stroke (or null for no dashing), and uses the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-setlinedash">Canvas setLineDash</a> handling
        as an even-length array of dash lengths.
      </p>
      
      <div id="example-lineDash" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-lineDash', function( scene ) {
/*START*/
scene.addChild( new scenery.Path( {
  shape: kite.Shape.regularPolygon( 6, 25 ),
  x: 32, y: 32,
  stroke: '#000',
  lineWidth: 3,
  lineDash: [ 10, 5 ]
} ) );
/*END*/
} );
      </script>
      
      <h3 id="path" class="section">Path</h3>
      <p>
        Path is a <a href="#node">Node</a> subtype that includes the <a href="#fillable">Fillable</a> and
        <a href="#strokable">Strokable</a> mixins. The main displayed behavior is controlled by its single
        additional option <a href="#path-shape">shape</a> along with the <a href="#fillable-fill">fill</a>
        and <a href="#strokable-stroke">stroke</a> options.
      </p>
      <p>
        A path is constructed with <code>new scenery.Path( options )</code>, where <code>options</code>
        is the standard <a href="#node">Node</a> parameter object, where the <a href="#path-shape">shape</a>
        should be specified.
      </p>
      
      <h4 id="path-shape">shape</h4>
      <p>
        <code>node.shape</code> (<code>node.getShape()</code>, <code>node.setShape( shape )</code>)
        controls the shape of this path, and is an instance of <a href="../../kite">Kite</a>'s
        <a href="../../kite/doc#shape">Shape</a>.
      </p>
      
      <h3 id="image" class="section">Image</h3>
      <p>
        Image is a <a href="#node">Node</a> subtype that displays a single image in either Canvas,
        SVG or DOM. An image node is constructed with <code>new scenery.Image( image, [options] )</code>,
        where <code>image</code> is as described in <a href="#image-image">image</a>, and
        <code>options</code> is the normal <a href="#node-options">options parameter object</a>.
      </p>
      <div id="example-image" class="exampleScene" style="width: 130px; height: 85px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-image', function( scene ) {
var url = 'http://phet.colorado.edu/sims/my-solar-system/my-solar-system-thumbnail.png';
/*START*/
scene.addChild( new scenery.Image( url ) );
/*END*/
scene.updateOnRequestAnimationFrame();
} );
      </script>
      
      <h4 id="image-image">image</h4>
      <p>
        <code>node.image</code> (<code>node.getImage()</code>, <code>node.setImage( image )</code>)
        gets or sets the 'image' of the Image node. It can be one of the following:
      </p>
      <ul>
        <li>
          A <strong>String</strong>, treated as a URL and loads the image. <strong>Bounds-based mutators
          like <a href="#node-left">left</a> and <a href="#node-centerY">centerY</a> will not work</strong>,
          since the image will not have the correct dimensions on node construction.
        </li>
        <li>
          A <strong>HTMLImageElement</strong> will be used directly. If the image is not loaded yet,
          the bounds-based mutators (as noted above for the String case) will not work properly.
        </li>
        <li>
          A <strong>HTMLCanvasElement</strong> can also be used, but will force the node to use
          a Canvas renderer.
        </li>
      </ul>
      
      <h3 id="text" class="section">Text</h3>
      <p>
        Text is a <a href="#node">Node</a> subtype that (currently) displays a single line of text
        in Canvas or SVG. DOM and multiline support is planned. It also mixes in
        <a href="#fillable">Fillable</a>, so it should support fill colors, gradients and patterns.
        The default fill is <code>'#000'</code>, so text is black by default.
        Stroking support is planned.
      </p>
      <p>
        Text nodes are constructed with <code>new scenery.Text( text, [options] )</code>, where
        <code>text</code> is described by <a href="#text-text">text</a>, and <code>options</code>
        is the standard <a href="#node">Node</a> parameter object.
      </p>
      <div id="example-text" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-text', function( scene ) {
/*START*/
scene.addChild( new scenery.Text( 'Some text', {
  font: '20px sans-serif',
  centerX: 128, centerY: 32
} ) );
/*END*/
} );
      </script>
      
      <h4 id="text-options">Text Options</h4>
      <p>
        A <a href="#text">Text</a> node has the following parameter object options, in addition to
        the ones from <a href="#fillable">Fillable</a>
      </p>
      <ul>
        <li><a href="#text-text">text</a></li>
        <li><a href="#text-font">font</a></li>
        <li><a href="#text-fontWeight">fontWeight</a></li>
        <li><a href="#text-fontFamily">fontFamily</a></li>
        <li><a href="#text-fontStretch">fontStretch</a></li>
        <li><a href="#text-fontStyle">fontStyle</a></li>
        <li><a href="#text-fontSize">fontSize</a></li>
        <li><a href="#text-lineHeight">lineHeight</a></li>
        <li><a href="#text-textAlign">textAlign</a></li>
        <li><a href="#text-textBaseline">textBaseline</a></li>
        <li><a href="#text-direction">direction</a></li>
      </ul>
      
      <h4 id="text-text">text</h4>
      <p>
        <code>node.text</code> (<code>node.getText()</code>, <code>node.setText( string )</code>)
        gets or sets the string text.
      </p>
      
      <h4 id="text-font">font</h4>
      <p>
        <code>node.font</code> (<code>node.getFont()</code>, <code>node.setFont( font )</code>)
        gets or sets the entire font. This can be a <a href="#font">Font</a> object, or a String
        that is interpreted as a <a href="http://www.w3.org/TR/css3-fonts/">CSS font</a>.
        Node that Canvas places <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-font">restrictions</a> on the possible interpreted values, so
        only those should be set on a <a href="#text">Text</a> node.
      </p>
      
      <h4 id="text-fontWeight">fontWeight</h4>
      <p>
        <code>node.fontWeight</code> (<code>node.getFontWeight()</code>, <code>node.setFontWeight( weight )</code>)
        gets or sets the <a href="#font-weight">font weight</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      
      <h4 id="text-fontFamily">fontFamily</h4>
      <p>
        <code>node.fontFamily</code> (<code>node.getFontFamily()</code>, <code>node.setFontFamily( family )</code>)
        gets or sets the <a href="#font-family">font family</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      
      <h4 id="text-fontStretch">fontStretch</h4>
      <p>
        <code>node.fontStretch</code> (<code>node.getFontStretch()</code>, <code>node.setFontStretch( stretch )</code>)
        gets or sets the <a href="#font-stretch">font stretch</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      
      <h4 id="text-fontStyle">fontStyle</h4>
      <p>
        <code>node.fontStyle</code> (<code>node.getFontStyle()</code>, <code>node.setFontStyle( style )</code>)
        gets or sets the <a href="#font-style">font style</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      
      <h4 id="text-fontSize">fontSize</h4>
      <p>
        <code>node.fontSize</code> (<code>node.getFontSize()</code>, <code>node.setFontSize( size )</code>)
        gets or sets the <a href="#font-size">font size</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      
      <h4 id="text-lineHeight">lineHeight</h4>
      <p>
        <code>node.lineHeight</code> (<code>node.getLineHeight()</code>, <code>node.setLineHeight( lineHeight )</code>)
        gets or sets the <a href="#font-lineHeight">line height</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      
      <h4 id="text-textAlign">textAlign</h4>
      <p>
        <code>node.textAlign</code> (<code>node.getTextAlign()</code>, <code>node.setTextAlign( align )</code>)
        sets the text horizontal alignment compared to the origin point. It should take on values from
        Canvas's <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-textalign">context.textAlign</a>, although in practice the default <code>'start'</code> is best to use.
        Other values may not behave as expected yet across rendering backends.
      </p>
      
      <h4 id="text-textBaseline">textBaseline</h4>
      <p>
        <code>node.textBaseline</code> (<code>node.getTextBaseline()</code>, <code>node.setTextBaseline( baseline )</code>)
        sets the text baseline position compared to the origin point. It should take on values from
        Canvas's <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-textbaseline">context.textBaseline</a>, although in practice it should be constrained to
        <code>'alphabetic'</code>, <code>'ideographic'</code>, <code>'hanging'</code> or <code>'middle'</code>,
        as those are supported in the SVG renderer.
      </p>
      
      <h4 id="text-direction">direction</h4>
      <p>
        <code>node.direction</code> (<code>node.getDirection()</code>, <code>node.setDirection( direction )</code>)
        sets the LTR or RTL direction of the text. It should take on values from
        Canvas's <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-direction">context.direction</a>, but <strong>proper bounds and renderer compatibility is not ensured yet</strong>
      </p>
      
      <h3 id="dom" class="section">DOM</h3>
      <p>
        DOM is a subtype of <a href="#node">Node</a> that positions a DOM element inside the scene using
        <a href="http://www.w3.org/TR/css3-transforms/">CSS transforms</a>. If the element is attached somewhere
        else, it will be removed and added into the DOM within the <a href="#scene">scene</a>'s container
        block-level element.
      </p>
      <p>
        DOM nodes should be constructed by passing in the DOM element, along with a parameter object if desired:
        <code>new scenery.DOM( element, [options] )</code>
      </p>
      <div id="example-dom" class="exampleScene" style="width: 256px; height: 128px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-dom', function( scene ) {
/*START*/
var element = document.createElement( 'form' );
element.innerHTML = '<label>Type in me:</label><input type="text">';
scene.addChild( new scenery.DOM( element, { x: 30, rotation: Math.PI / 6 } ) );
/*END*/
} );
      </script>
      
      <h4 id="dom-element">element</h4>
      <p>
        <code>node.element</code> (<code>node.getElement()</code>, <code>node.setElement( domElement )</code>)
        controls the displayed DOM element. If the element is a block-level element, it should have a specified
        width and height.
      </p>
      
      <h4 id="dom-interactive">interactive</h4>
      <p>
        <code>node.interactive</code> (<code>node.getInteractive()</code>, <code>node.setInteractive( boolean )</code>),
        when set to true, will signal to Scenery's event system that preventDefault() should not be called
        on DOM events when the DOM node is the event target.
      </p>
      
      <h3 id="pointer" class="section">Pointer</h3>
      
      
      <h3 id="font" class="section">Font</h3>
      
      
      <h3 id="linearGradient" class="section">LinearGradient</h3>
      <p>
        A LinearGradient can be used in place of a color for any <a href="#fillable-fill">fill</a> or
        <a href="#strokable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
      </p>
      <p>
        LinearGradient is constructed and used very similarly to Canvas's
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createlineargradient">context.createLinearGradient</a>, with
        <code>new scenery.LinearGradient( x0, y0, x1, y1 )</code> where the gradient goes from (x0,y0) to
        (x1,y1), and then <a href="#linearGradient-addColorStop">color stops</a> can be added.
      </p>
      <div id="example-linearGradient" class="exampleScene" style="width: 128px; height: 128px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-linearGradient', function( scene ) {
/*START*/
scene.addChild( new scenery.Path( {
  shape: kite.Shape.rectangle( 0, 0, 128, 128 ),
  
  // upper-left to lower-right
  fill: new scenery.LinearGradient( 0, 0, 128, 128 )
                   .addColorStop( 0, '#888' )
                   .addColorStop( 0.4, '#000' )
                   .addColorStop( 1, '#555' )
} ) );
scene.addChild( new scenery.Text( 'A', {
  fontSize: 80,
  centerX: 64, centerY: 64,
  
  // left to right
  fill: new scenery.LinearGradient( 0, 0, 55, 0 )
                   .addColorStop( 0, '#f00' )
                   .addColorStop( 1, '#ff0' )
} ) );
/*END*/
} );
      </script>
      
      <h4 id="linearGradient-addColorStop">addColorStop( ratio, color )</h4>
      <p>
        Adds a point of color along the gradient, where a ratio of 0 is a color point at (x0,y0) and
        a ratio of 1 is a color point at (x1,y1).
      </p>
      
      <h4 id="linearGradient-setTransformMatrix">setTransformMatrix( matrix )</h4>
      <p>
        Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
        the gradient as it is applied. This should only be done before adding it as a fill/stroke to
        any nodes.
      </p>
      
      <h3 id="radialGradient" class="section">RadialGradient</h3>
      <p>
        A RadialGradient can be used in place of a color for any <a href="#fillable-fill">fill</a> or
        <a href="#strokable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
      </p>
      <p>
        RadialGradient is constructed and used very similarly to Canvas's
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createradialgradient">context.createRadialGradient</a>, with
        <code>new scenery.RadialGradient( x0, y0, r0, x1, y1, r1 )</code> where the gradient handled between
        two circles, one centered at (x0,y0) with a radius r0, and the other at (x1,y1) with a radius r1.
        Due to SVG compatibility, this is slightly constricted, as the smaller circle needs to be completely
        within the larger circle. Then <a href="#radialGradient-addColorStop">color stops</a> can be added.
      </p>
      <div id="example-radialGradient" class="exampleScene" style="width: 128px; height: 128px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-radialGradient', function( scene ) {
/*START*/
scene.addChild( new scenery.Path( {
  shape: kite.Shape.rectangle( 0, 0, 128, 128 ),
  
  // starts at a 10-px radius circle and expands out nonuniformly
  fill: new scenery.RadialGradient( 32, 32, 10, 64, 64, 90 )
                   .addColorStop( 0, '#05f' )
                   .addColorStop( 0.5, '#306' )
                   .addColorStop( 1, '#000' )
} ) );

var transparent = 'rgba(255,255,255,0)';
var letter = '#fff';
scene.addChild( new scenery.Text( 'A', {
  fontSize: 80,
  centerX: 64, centerY: 64,
  
  // concentric circles
  fill: new scenery.RadialGradient( 25, -30, 0, 25, -30, 50 )
                   .addColorStop( 0, transparent )
                   .addColorStop( 0.1, letter )
                   .addColorStop( 0.2, transparent )
                   .addColorStop( 0.3, letter )
                   .addColorStop( 0.4, transparent )
                   .addColorStop( 0.5, letter )
                   .addColorStop( 0.6, transparent )
                   .addColorStop( 1, letter )
} ) );
/*END*/
} );
      </script>
      
      <h4 id="radialGradient-addColorStop">addColorStop( ratio, color )</h4>
      <p>
        Adds a point of color along the gradient, where a ratio of 0 is a color point at (x0,y0) and
        a ratio of 1 is a color point at (x1,y1).
      </p>
      
      <h4 id="radialGradient-setTransformMatrix">setTransformMatrix( matrix )</h4>
      <p>
        Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
        the gradient as it is applied. This should only be done before adding it as a fill/stroke to
        any nodes.
      </p>
      
      <h3 id="pattern" class="section">Pattern</h3>
      <p>
        A Pattern can be used in place of a color for any <a href="#fillable-fill">fill</a> or
        <a href="#strokable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
      </p>
      <p>
        Pattern is constructed and used very similarly to Canvas's
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createpattern">context.createPattern</a>, with
        <code>new scenery.Pattern( image )</code> where <code>image</code> is an HTMLImageElement.
      </p>
      <div id="example-pattern" class="exampleScene" style="width: 256px; height: 256px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-pattern', function( scene ) {
var loadedImg = document.createElement( 'img' );
loadedImg.addEventListener( 'load', function() {
/*START*/
scene.addChild( new scenery.Path( {
  shape: kite.Shape.roundRectangle( 10, 10, 236, 236, 64, 64 ),
  
  // tile the image, and rotate it 30 degrees, and scale it down
  fill: new scenery.Pattern( loadedImg ).setTransformMatrix(
    dot.Matrix3.rotation2( Math.PI / 6 )
               .timesMatrix( dot.Matrix3.scale( 0.5 ) ) ),
  stroke: '#000'
} ) );
/*END*/
scene.updateScene();
} );
loadedImg.src = 'http://phet.colorado.edu/images/phet-logo-yellow.png';
// loadedImg.src = 'http://phet.colorado.edu/sims/plate-tectonics/plate-tectonics-thumbnail.png';
} );
      </script>
      
      <h4 id="pattern-setTransformMatrix">setTransformMatrix( matrix )</h4>
      <p>
        Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
        the gradient as it is applied. This should only be done before adding it as a fill/stroke to
        any nodes.
      </p>
      
      <h3 id="vbox" class="section">VBox</h3>
      
      
    </div>
    <div class="span3"></div>
  </div>
  
  <script type="text/javascript">
    SyntaxHighlighter.all();
  </script>
</body>
</html>
