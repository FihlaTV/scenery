
Just for the layering branch!
=============================



Default layer types, so that we can specify "svg under here if possible" - in LayerState

DAG support
  Multiple views for free
    Support possibly for multiple scene roots?
  For node actions that involve the layer reference, instead just fire off events to listeners
  DOM is an issue for DAG support - unless we can duplicate it?


Node:
  Self can be rendered to different layers
    Children for even more layers
    On an event that changes potential layering, fire an event somehow that reaches all applicable scenes
  
  Has LayerStrategy: called during layering from each relevant scene.


Issues
======

DAG handling for SVG (how to duplicate) or DOM

Design
======

DAG:
  * fewer checks needed during render for layers
  * lighter weight nodes
  Node
    |store list of parents -- prevent duplicates, with Set
    |disallow duplicates in children (they would be same position and everything)
    allow listeners from scenes (or others), that trigger for any descendants (i.e. invalidate a finger and you have 20 region invalidations to scene)
    constructor wraps parameters as children for convenience
  Layer
    store pick paths (with indices of each child for disambiguation? - not necessary if we disallow duplicate children) of beginning and end?
  Scene
    accelerated indexing of layers (find a layer given a pick path)
    add listeners to 'root' to pick up invalidations, etc.
    scene responsible for knowing layer start/end, handles drawing with this in mind

LayerState:
  - compacts layers as necessary (don't instantiate until something hasSelf())
  push/pop preferredLayerType
  switchToType()
  markSelf() -- when node hasSelf(), ensure that we finalize a layer switch
  query current layer type
  other queries

Node:
  LayerStrategy (called during layering from each relevant scene), default uses node._supportedLayerTypes
  ability to fire an event with a callback that all registered layers / scenes will respond to (so you can technically get singleton scene references)

DOM:
  Hoisting of interactive DOM nodes
    - HoistedDOMLayer that adds (2147483647/2) to its z-index
      Pro:
        layering will work in the browser
      Con:
        have to add a listener in the capture phase of the listener to flag the event as hitting the interactive node?
        need to check for 'interactive' flag?
        Events system may need to discard anything in the region of an interactive node's bounds?
    - Either delegate (just set transform) or have inline with just SVG over (with pointer-events)


API Usage
=========

// implicit layering switches due to node types

// force SVG layer(s) under node where possible
node.layerStrategy.setPreferredLayerType( scenery.LayerType.SVG );

// force a layer split before / after
node.layerStrategy.setSplitBefore( true );
node.layerStrategy.setSplitAfter( true );

// performance caching (new node, so we can do render path changes?)
var cacheNode = new CanvasLayerCache( node ) {{
  // internal to CanvasLayerCache:
  cacheNode.layerStrategy = new CanvasCachingStrategy( ... ) {{
    // internal to CanvasCachingStrategy
    preferredLayerType = CacheLayer( ... domElement ... )?
  }};
}} // paints into canvas(es), with custom layer type


