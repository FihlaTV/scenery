

Bugs:
    Browser bugs? (get Canary / Aurora):
        miterLimit off in Chrome 24.0.1312.52 m
            ** Seems to be using default SVG miterLimit of 4
            Test stroking with shear to see if global transforms are applied?
            SVG miterLimit calculation in https://svgwg.org/svg2-draft/painting.html
            Canvas spec note at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#trace-a-path
        bevel instead of miter on the "close" part of the hex: Firefox 18.0.1
        Chrome 24.0.1312.52 m bug in zooming fillText() -- mobile Safari OK (maybe different from webkit, since it's not antialiased?)
        Report rgba alpha precision "bug" - spec says rgba(255,255,255,0.1112049520495820495802495) should not lose any digits on inspection after setting on context
    * for canvas, create a drawing function that exhibits all differences?

Questions / Open Topics:
    Re-evaluate ES5 getter/setter
    
    https://travis-ci.org/ for continuous integration?
    
    Event handling for DOM events, etc.
    Persistent (DOM,SVG) painting and updates for nodes
    JSDoc?
    
    Something like _.extend that will work on ES5 setter/getter pairs in the future? Maybe $.extend?
    Should enter / exit events be fired before / after touch up/down events, or never?
        Follow DOM convention
        Add click event
    Name? Scenery? Artist names?
    
    Packing everything into 1 HTML file -- is it possible with data URLs? If there are size limits, can we split images/audio and recombine?

Next:
    * Layers: preferredLayerType -- layer factories instead of types?
    * Polyfills into own namespace
    * More documentation
    * Switch underscore.js to LoDash? see http://lodash.com/
    * Switch to jQuery 2?
    * Examine Raphael JS for SVG support and code
    * Event dispatch
        * Examine Kinect event system, delegate events, pointer events spec, jQuery .on with bind / capture
        * Add pickable flag?
        * For up/down events, is enter/exit necessary? -- see Question above
        * Freeze event handlers, a la the DOM 3 Events spec? Or copy Piccolo?
        * Best pattern for handling drags / more persistence? Add listeners directly to finger?
            * Standard flags on fingers for whether they are performing an operation? dragging, etc.
            * A way to 'cancel' the operation a finger is currently doing, so it can switch to a different one?
    * Layering proof-of-concepts, advantages (performance, DOM integration, etc.)
    * DOM nodes
        * Handle correct layering of DOM nodes inside a layer, etc.
        * How to get the size before adding to the document tree? Impossible?
            * Document fragments (test this)
    * Events
        * Investigate hit testing against DOM nodes
    * IE9 Performance
        * Get DebugContext to work with Easel for performance comparison?
            * Or just test Scene vs Custom here ... huge performance drop
        * "strict mode" removal wasn't effective
    * Accessibility / shadow DOM
        see http://www.paciellogroup.com/blog/2011/12/html5-canvas-accessibility-discussions-2009-2011/
    * WebGL Layer (we can get even faster rendering for shapes here, if it exists)
    * Benchmarks using http://benchmarkjs.com/
    * Modularization if possible (extract out math, others)

Incomplete:
    Node:
        Sub-tree opacity (like setTransparency in Piccolo)
            'transparency', 'opacity', or 'alpha'?
        Canvas fill gradients / patterns
            Can this be abstracted across SVG / WebGL layers also? -- probably WebGL _much_ more efficiently with shaders
        For prepend-flags, set in parameter object instead of boolean flag? (somewhat hard-to-read code)
        Refactor fill / stroke code in Node so that it can be used by subclasses, e.g. Text, etc.
        Visibility interaction with dirty paint / bounds, and events based on that
            Scene.updateLayer shouldn't be called if only invisible nodes were changed
        Don't send mark updates on invisible layers? Visibility change causes repaint?
        General optimization and organization so we can extract "self" from child rendering bounds, what is repainted, etc. better.
    Shapes:
        Quadratic curve offsets need implementation improvement (32 sub-quadratics is too costly)
        Not implemented: arc, arcTo, ellipse, cubic bezier
        Features not implemented: precise intersection with bounding box (not just intersection of bounds)
        Nonzero/evenodd support (not yet implemented in browsers)
        Self-intersection in 'stroked' path
        SVG / WebGL
    Text:
        Handling multi-line strings
        SVG / WebGL / DOM options
    Scene:
        refreshLayers() implementation (currently rebuilds all layers, but should be optimized so it doesn't need to redraw as much)
        Foundation for multiple view implementations
    Build:
        Add JSHint into Sublime Text with plugin?
    Misc:
        Vet recursive bounds code against empty area
        License on files

User interaction Design:
    * Do invisible nodes get picked?
    * Mouse enter/exit needs to trigger for node add/remove
        * Does it make sense to hit-test every frame for this?
    Can swipe "through" an object to start dragging it
    Can simultaneously move multiple objects / controls
    Can zoom / pan -- how to determine when user gestures can do this?
    * with DOM elements, can we essentially "PSwing" the event forwarding and emulate mouse/touch behavior? will CSS :hover work?

Performance:
    Framebuffer with context.drawImage( bufferContext, 0, 0 );
    Consider child counts, so that we can decide which layers to keep in a layer rebuild?
    Piece improvements with direct piece.render calls instead of switch? -- profile
    Improved Dirty regions
        * not full union of bounding boxes
        * Kd-tree / quadtree acceleration if child count is high? 
    Caching nodes with off-screen canvases for performance
    Improve quadratic bezier offset curve computation
    Combining fills and strokes (or other state optimization -- fills require ensuring CCW/CW stays the same, so we need flags to whitelist)
    Efficiency checks for fullRender using the functional style => imperative
    Automated benchmarks
    Investigate whether bounding boxes can be smaller based on clip shapes
    Non-automated performance tests:
        * Compare Matrix3 Float32Array v. Array (Array seems slightly faster possibly?)
        * Consider a Canvas 2D context delegate to examine drawing calls for Easel / Scene / Custom / etc.
    Checklists:
        http://www.html5rocks.com/en/tutorials/canvas/performance/

Features:
    * User interaction
    Accessibility and shadow DOM see html5 scene graph google doc
    Retina-screen handling
    AnimateTo-style animation
    Clipping => Dead region handling (clipping needs to be stored in a shape array since it can only be intersected or reset in Canvas)
    Color handling?
    Investigate DAG version?
    Include MathJax text?
    WebGL Layers
    Property change events for nodes?

Cleanliness / Debugging:
    *** Debug layer
    Ability to create a debugging dump of scene graph
    Code style should match https://github.com/rwldrn/idiomatic.js

Other:
    Pull requests to underscore.js for FunctionalUtils wishlist
    Implement Bouncy example from the wishlist
    Highlighting and indexing of TODO items
