

Bugs:
    Browser bugs?:
        miterLimit off in Chrome 24.0.1312.52 m
        bevel instead of miter on the "close" part of the hex: Firefox 18.0.1
        Chrome 24.0.1312.52 m bug in zooming fillText() -- mobile Safari OK (maybe different from webkit, since it's not antialiased?)

Next:
    * Layering proof-of-concepts, advantages (performance, DOM integration, etc.)
    * Text nodes (use current "slow-but-accurate" method for bounds)
        * How to handle multi-ling strings? SVG for that?
    * Image nodes
    * DOM nodes
    * Events
        * Shape hit regions (containsPoint/intersectsBounds)
        * Flags for whether strokes are considered for hit regions (use full text bounds as hit for now)
        * Investigate hit testing against DOM nodes
    * Accessibility / shadow DOM

Incomplete:
    refreshLayers implementation
    Think about multiple view implementations!
    Static analysis - linter - integrated into build?
    Vet recursive bounds code against empty area
    
    Test-based-dev? for Update vs Render
    Don't remove deprecated Rectangle 'class' - but copy over other non-completed function calls
        
    Ability to update size of canvas, etc.
    Visibility interaction with dirty paint / bounds, and events based on that
        * revert to setter/getter ?
        * Scene.updateLayer handling
    Don't send mark updates on invisible layers? Visibility change causes repaint?
    General optimization and organization so we can extract "self" from child rendering bounds, what is repainted, etc. better.
    Canvas fill gradients / patterns
        * Can we abstract this across SVG also?

User interaction Design:
    Can swipe "through" an object to start dragging it
    Can simultaneously move multiple objects / controls
    Can zoom / pan -- how to determine when user gestures can do this?
    * with DOM elements, can we essentially "PSwing" the event forwarding and emulate mouse/touch behavior? will CSS :hover work?

Performance:
    Consider child counts, so that we can decide which layers to keep in a layer rebuild?
    Piece improvements with direct piece.render calls instead of switch? -- profile
    Improved Dirty regions
        * not full union of bounding boxes
        * Kd-tree / quadtree acceleration if child count is high? 
    Caching nodes with off-screen canvases for performance
    Combining fills and strokes (or other state optimization -- fills require ensuring CCW/CW stays the same, so we need flags to whitelist)
    Efficiency checks for fullRender using the functional style => imperative
    Automated benchmarks
    Investigate whether bounding boxes can be smaller based on clip shapes
    Non-automated performance tests:
        * Compare Matrix3 Float32Array v. Array (Array seems slightly faster possibly?)
        * Consider a Canvas 2D context delegate to examine drawing calls for Easel / Scene / Custom / etc.
    Optimizing for V8:
        http://floitsch.blogspot.com/2012/03/optimizing-for-v8-introduction.html

Features:
    * User interaction
    Accessibility and shadow DOM see html5 scene graph google doc
    Non-canvas handling
    Retina-screen handling
    "Lifting" of DOM nodes to top layer if selected
    AnimateTo-style animation
    Clipping => Dead region handling (clipping needs to be stored in a shape array since it can only be intersected or reset in Canvas)
    Color handling?
    Investigate DAG version?
    Include MathJax text?

Cleanliness / Debugging:
    *** Debug layer
    x,y vs point handling for translation etc. since we lack overriding?
    Bounds2: rename styling from minX to minX
    Ability to create a debugging dump of scene graph
    Unit tests using canvas pixel querying
    Debugging traces removed with Closure compiler?

Other:
    Pull requests to underscore.js for FunctionalUtils wishlist
    Implement Bouncy example from the wishlist
    Report rgba alpha precision "bug" - spec says rgba(255,255,255,0.1112049520495820495802495) should not lose any digits on inspection after setting on context
    Highlighting and indexing of TODO items
