

Bugs:
    Browser bugs?:
        miterLimit off in Chrome 24.0.1312.52 m
        bevel instead of miter on the "close" part of the hex: Firefox 18.0.1
        Chrome 24.0.1312.52 m bug in zooming fillText() -- mobile Safari OK (maybe different from webkit, since it's not antialiased?)
    Report rgba alpha precision "bug" - spec says rgba(255,255,255,0.1112049520495820495802495) should not lose any digits on inspection after setting on context

Questions:
    Pre-rotate or post-rotate translation?
    Invisible nodes included in: {bounds, hit testing / enter / exit events}?
    _.extend will hopefully work on ES5 setter/getter pairs in the future?
        * try #.extend?
    Is any form of sub-tree opacity desired? (set opacity on X and everything below it has its opacity multiplied times that?)

Next:
    * Event dispatch
        * For up/down events, is enter/exit necessary?
        * Should all events hit through the root / scene? How to add listeners to all events?
        * Best pattern for handling drags / more persistence? Add listeners directly to finger?
            * Standard flags on fingers for whether they are performing an operation? dragging, etc.
            * A way to 'cancel' the operation a finger is currently doing, so it can switch to a different one?
    * Layering proof-of-concepts, advantages (performance, DOM integration, etc.)
    * DOM nodes
        * Handle correct layering of DOM nodes inside a layer, etc.
    * Events
        * Investigate hit testing against DOM nodes
    * IE9 Performance
        * Create 'delegate' context to examine -- self time dominated by fill() and stroke(), so it is probably IE9-canvas-specific
    * Accessibility / shadow DOM
    * WebGL Layer?

Incomplete:
    * Text node issues:
        * How to handle multi-ling strings? SVG for that?
    refreshLayers implementation
    Think about multiple view implementations!
    Static analysis - linter - integrated into build?
    Vet recursive bounds code against empty area
    
    Consider Rectangle deprecated?
    Refactor fill / stroke code in Node so that it can be used by subclasses, e.g. Rectangle, Text, etc.
        
    Visibility interaction with dirty paint / bounds, and events based on that
        * revert to setter/getter ?
        * Scene.updateLayer handling
    Don't send mark updates on invisible layers? Visibility change causes repaint?
    General optimization and organization so we can extract "self" from child rendering bounds, what is repainted, etc. better.
    Canvas fill gradients / patterns
        * Can we abstract this across SVG also?
    Shape completeness of operations: arc and bezier quadratic / cubic

User interaction Design:
    * Do invisible nodes get picked?
    * Mouse enter/exit needs to trigger for node add/remove
        * Does it make sense to hit-test every frame for this?
    Can swipe "through" an object to start dragging it
    Can simultaneously move multiple objects / controls
    Can zoom / pan -- how to determine when user gestures can do this?
    * with DOM elements, can we essentially "PSwing" the event forwarding and emulate mouse/touch behavior? will CSS :hover work?

Performance:
    Consider child counts, so that we can decide which layers to keep in a layer rebuild?
    Piece improvements with direct piece.render calls instead of switch? -- profile
    Improved Dirty regions
        * not full union of bounding boxes
        * Kd-tree / quadtree acceleration if child count is high? 
    Caching nodes with off-screen canvases for performance
    Combining fills and strokes (or other state optimization -- fills require ensuring CCW/CW stays the same, so we need flags to whitelist)
    Efficiency checks for fullRender using the functional style => imperative
    Automated benchmarks
    Investigate whether bounding boxes can be smaller based on clip shapes
    Non-automated performance tests:
        * Compare Matrix3 Float32Array v. Array (Array seems slightly faster possibly?)
        * Consider a Canvas 2D context delegate to examine drawing calls for Easel / Scene / Custom / etc.

Features:
    * User interaction
    Accessibility and shadow DOM see html5 scene graph google doc
    Retina-screen handling
    AnimateTo-style animation
    Clipping => Dead region handling (clipping needs to be stored in a shape array since it can only be intersected or reset in Canvas)
    Color handling?
    Investigate DAG version?
    Include MathJax text?
    WebGL Layers
    Property change events for nodes?

Cleanliness / Debugging:
    *** Debug layer
    Ability to create a debugging dump of scene graph

Other:
    Pull requests to underscore.js for FunctionalUtils wishlist
    Implement Bouncy example from the wishlist
    Highlighting and indexing of TODO items
