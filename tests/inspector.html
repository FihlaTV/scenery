<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1"/>
  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>Inspector (Scenery)</title>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../build/scenery.min.js"></script>

  <style type="text/css">
    /* Let content go to the edges */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      /*background-color: #ff0;*/
      overflow: hidden;
    }

    /* Have the #main div cover the entire viewport */
    #main {
      position: absolute; /* position !== inherit is required so that Scenery's absolutely-positioned children are placed correctly */
      left: 0;
      top: 0;
      background-color: #fff;
    }

  </style>
</head>

<body>

<!-- our scene graph will be in this div -->
<div id="main">
</div>

<script>
  window.assertions.enableAssert();

  var selectedTreeNodeProperty = new axon.Property( null );
  var activeTreeNodeProperty = new axon.Property( null );

  var previewTreeNodeProperty = new axon.DerivedProperty( [ selectedTreeNodeProperty, activeTreeNodeProperty ], function( selected, active ) {
    return selected ? selected : active;
  } );

  document.addEventListener( 'keyup', function( event ) {
    // Escape
    if ( event.keyCode === 27 ) {
      selectedTreeNodeProperty.value = null;
    }
  } );

  var TREE_FONT = new scenery.Font( { size: 12 } );

  function TreeNode( displayNode, trail ) {
    scenery.Node.call( this );

    var self = this;

    this.displayNode = displayNode;
    this.trail = trail;

    displayNode.addInputListener( {
      over: function( event ) {
        if ( event.target === displayNode ) {
          activeTreeNodeProperty.value = self;
          focusActive();
        }
      },
      out: function( event ) {
        if ( event.target === displayNode ) {
          activeTreeNodeProperty.value = null;
          focusSelected();
        }
      },
      down: function( event ) {
        if ( event.target === displayNode ) {
          selectedTreeNodeProperty.value = self;
          focusSelected();
        }
      }
    } );

    var expandedProperty = new axon.Property( true );

    var serialization = displayNode._serialization;
    var isVisible = _.every( trail.nodes, function( node ) {
      return node._serialization.options.visible !== false;
    } );

    var selfNode = new scenery.HBox( {
      spacing: 5
    } );

    var buttonSize = 12;
    var expandButton = new scenery.Rectangle( -buttonSize / 2, -buttonSize / 2, buttonSize, buttonSize, {
      children: [
        new scenery.Path( kite.Shape.regularPolygon( 3, buttonSize / 2.5 ), {
          fill: '#444'
        } )
      ],
      visible: false,
      cursor: 'pointer'
    } );
    expandButton.addInputListener( new scenery.FireListener( {
      fire: function() {
        expandedProperty.toggle();
      }
    } ) );
    selfNode.addChild( expandButton );

    selfNode.addChild( new scenery.Text( serialization.name, {
      font: TREE_FONT,
      pickable: false,
      fill: isVisible ? '#000' : '#444'
    } ) );
    if ( serialization.name !== serialization.type && serialization.type !== 'Node' ) {
      selfNode.addChild( new scenery.Text( '(' + serialization.type + ')', {
        font: TREE_FONT,
        pickable: false,
        fill: '#666'
      } ) );
    }
    if ( serialization.type === 'Text' ) {
      selfNode.addChild( new scenery.Text( '"' + displayNode.text + '"', {
        font: TREE_FONT,
        pickable: false,
        fill: '#666'
      } ) );
    }

    var selfBackground = this.selfBackground = scenery.Rectangle.bounds( selfNode.bounds, {
      children: [ selfNode ],
      cursor: 'pointer',
      fill: new axon.DerivedProperty( [ selectedTreeNodeProperty, activeTreeNodeProperty ], function( selected, active ) {
        if ( self === selected ) {
          return 'rgba(0,128,255,0.4)';
        }
        else if ( self === active ) {
          return 'rgba(0,128,255,0.2)';
        }
        else {
          return 'transparent';
        }
      } )
    } );
    selfBackground.addInputListener( {
      enter: function( event ) {
        activeTreeNodeProperty.value = self;
      },
      exit: function( event ) {
        activeTreeNodeProperty.value = null;
      }
    } );
    selfBackground.addInputListener( new scenery.FireListener( {
      fire: function() {
        selectedTreeNodeProperty.value = self;
      }
    } ) );
    this.addChild( selfBackground );


    var childrenNode = new scenery.VBox( {
      spacing: 0,
      align: 'left',
      children: displayNode.children.filter( function( child ) {
        return !!child._serialization;
      } ).map( function( child, index ) {
        return new TreeNode( child, trail.copy().addDescendant( child, index ) );
      } )
    } );

    var column = new scenery.Rectangle( {
      rectWidth: 2,
      rectHeight: 5,
      fill: 'rgba(0,0,0,0.1)'
    } );

    var expandedNode = new scenery.Node( {
      children: [
        childrenNode,
        // column
      ]
    } );

    if ( childrenNode.bounds.isFinite() ) {
      childrenNode.left = selfNode.left + 13;
      childrenNode.top = selfNode.bottom;
      column.centerX = selfNode.left + buttonSize / 2;
      column.top = selfNode.bottom;

      expandButton.visible = true;
      this.addChild( expandedNode );

      expandedProperty.link( function( expanded ) {
        expandButton.rotation = expanded ? Math.PI / 2 : 0;
        if ( expanded && !self.hasChild( expandedNode ) ) {
          self.addChild( expandedNode );
        }
        if ( !expanded && self.hasChild( expandedNode ) ) {
          self.removeChild( expandedNode );
        }
      } );

      childrenNode.onStatic( 'bounds', function() {
        column.rectHeight = childrenNode.height;
      } );
    }
  }
  phetCore.inherit( scenery.Node, TreeNode );

  var rightWidth = 500;
  var bottomHeight = 200;

  // initialize our scene
  var scene = new scenery.Node();
  var display = new scenery.Display( scene, {
    container: document.getElementById( 'main' )
  } );
  display.initializeEvents(); // sets up listeners on the document with preventDefault(), and forwards those events to our scene

  var snapshot = JSON.parse( localStorage.scenerySnapshot );
  var isDisplay = snapshot.type === 'Display';

  var subtree = isDisplay ? snapshot.tree : snapshot;
  var displayTree = scenery.deserialize( subtree );
  var backgroundColor = isDisplay ? scenery.deserialize( snapshot.backgroundColor ) : '#fff';
  var snapshotBounds = isDisplay ? new dot.Bounds2( 0, 0, snapshot.width, snapshot.height ) : displayTree.bounds.dilatedXY( displayTree.width * 0.05, displayTree.height * 0.05 );

  var overlayNode = new scenery.Node();
  var displayNode = new scenery.Node( {
    children: [
      scenery.Rectangle.bounds( snapshotBounds, {
        fill: backgroundColor
      } ),
      displayTree,
      overlayNode
    ],
    clipArea: kite.Shape.bounds( snapshotBounds )
  } );
  scene.addChild( displayNode );

  var treeMarginX = 8;
  var treeMarginY = 5;
  var rootTreeNode = new TreeNode( displayTree, new scenery.Trail( displayTree ) );
  rootTreeNode.x = treeMarginX;
  rootTreeNode.y = treeMarginY;
  var treeBackground = new scenery.Rectangle( {
    fill: '#fcfcfc',
    stroke: '#888'
  } );
  var treeContainer = new scenery.Node( {
    children: [
      treeBackground,
      rootTreeNode
    ]
  } );
  scene.addChild( treeContainer );
  function constrainTree() {
    if ( rootTreeNode.bottom < treeBackground.bottom - treeMarginY ) {
      rootTreeNode.bottom = treeBackground.bottom - treeMarginY;
    }
    if ( rootTreeNode.top > treeBackground.top + treeMarginY ) {
      rootTreeNode.top = treeBackground.top + treeMarginY;
    }
    if ( rootTreeNode.right < treeBackground.right - treeMarginX ) {
      rootTreeNode.right = treeBackground.right - treeMarginX;
    }
    if ( rootTreeNode.left > treeBackground.left + treeMarginX ) {
      rootTreeNode.left = treeBackground.left + treeMarginX;
    }
  }
  constrainTree();
  treeContainer.addInputListener( {
    wheel: function( event ) {
      var deltaX = event.domEvent.deltaX;
      var deltaY = event.domEvent.deltaY;
      var multiplier = 1;
      rootTreeNode.x -= deltaX;
      rootTreeNode.y -= deltaY;
      constrainTree();
    }
  } );

  function focusTreeNode( treeNode ) {
    var trail = treeNode.getUniqueTrailTo( rootTreeNode );
    var deltaY = trail.localToGlobalPoint( treeNode.selfBackground.center ).y - treeBackground.centerY;
    rootTreeNode.y -= deltaY;
    constrainTree();
  }
  function focusActive() {
    focusTreeNode( activeTreeNodeProperty.value );
  }
  function focusSelected() {
    if ( selectedTreeNodeProperty.value === null ) { return; }

    focusTreeNode( selectedTreeNodeProperty.value );
  }

  var localBoundsHighlight = new scenery.Path( null, {
    fill: 'rgba(0,128,255,0.4)',
    stroke: 'rgb(0,64,128)',
    lineWidth: 0.5
  } );
  overlayNode.addChild( localBoundsHighlight );

  activeTreeNodeProperty.link( function( treeNode ) {
    if ( treeNode ) {

      var trail = treeNode.trail;
      var matrix = trail.getMatrix();
      var localBounds = treeNode.displayNode.localBounds;

      if ( localBounds.isValid() ) {
        localBoundsHighlight.visible = true;
        localBoundsHighlight.shape = kite.Shape.polygon( [
          localBounds.leftTop,
          localBounds.leftBottom,
          localBounds.rightBottom,
          localBounds.rightTop
        ].map( function( point ) {
          return matrix.timesVector2( point );
        } ) );
      }
      else {
        localBoundsHighlight.visible = false;
      }
    }
    else {
      localBoundsHighlight.visible = false;
    }
  } );

  var previewContainer = new scenery.Node();
  var previewBackground = new scenery.Rectangle( {
    rectWidth: bottomHeight,
    rectHeight: bottomHeight,
    children: [ previewContainer ],
    fill: '#eee'
  } );
  scene.addChild( previewBackground );

  previewTreeNodeProperty.link( function( treeNode ) {
    if ( treeNode ) {
      var node = treeNode.displayNode;
      previewContainer.children = [ node ];
      if ( previewContainer.bounds.isValid() ) {
        previewContainer.visible = true;
        var scale = Math.min( bottomHeight / node.width, bottomHeight / node.height );
        previewContainer.setScaleMagnitude( scale * 0.9 );
        previewContainer.centerX = bottomHeight / 2;;
        previewContainer.centerY = bottomHeight / 2;;
      }
      else {
        previewContainer.visible = false;
      }
    }
    else {
      previewContainer.visible = false;
    }
  } );

  function layout() {
    var width = window.innerWidth;
    var height = window.innerHeight;
    display.setWidthHeight( width, height );

    var leftWidth = width - rightWidth;

    displayNode.setScaleMagnitude( Math.min( leftWidth / snapshotBounds.width, height / snapshotBounds.height ) );
    displayNode.centerX = leftWidth / 2;
    displayNode.centerY = height / 2;

    var treeLocalBounds = new dot.Bounds2( 0, 0, rightWidth, height - bottomHeight );
    treeContainer.x = leftWidth;
    treeContainer.clipArea = kite.Shape.bounds( treeLocalBounds );
    treeBackground.rectBounds = treeLocalBounds;

    previewBackground.x = width - bottomHeight;
    previewBackground.y = height - bottomHeight;
  }
  window.addEventListener( 'resize', layout );
  layout();

  /*---------------------------------------------------------------------------*
   * main loop
   *----------------------------------------------------------------------------*/

  display.updateOnRequestAnimationFrame();

</script>

</body>
</html>
