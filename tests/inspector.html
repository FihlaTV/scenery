<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1"/>
  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>Inspector (Scenery)</title>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../build/scenery.min.js"></script>

  <style type="text/css">
    /* Let content go to the edges */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      /*background-color: #ff0;*/
      overflow: hidden;
    }

    /* Have the #main div cover the entire viewport */
    #main {
      position: absolute; /* position !== inherit is required so that Scenery's absolutely-positioned children are placed correctly */
      left: 0;
      top: 0;
      background-color: #fff;
    }

  </style>
</head>

<body>

<!-- our scene graph will be in this div -->
<div id="main">
</div>

<script>
  window.assertions.enableAssert();

  var selectedTreeNodeProperty = new axon.Property( null );
  var activeTreeNodeProperty = new axon.Property( null );

  var TREE_FONT = new scenery.Font( { size: 12 } );

  function TreeNode( displayNode, trail ) {
    scenery.Node.call( this );

    var self = this;

    this.displayNode = displayNode;
    this.trail = trail;

    var serialization = displayNode._serialization;

    var selfNode = new scenery.HBox( {
      spacing: 5
    } );
    selfNode.addChild( new scenery.Text( serialization.name, {
      font: TREE_FONT,
      pickable: false
    } ) );
    if ( serialization.name !== serialization.type && serialization.type !== 'Node' ) {
      selfNode.addChild( new scenery.Text( '(' + serialization.type + ')', {
        font: TREE_FONT,
        pickable: false,
        fill: '#666'
      } ) );
    }
    if ( serialization.type === 'Text' ) {
      selfNode.addChild( new scenery.Text( '"' + displayNode.text + '"', {
        font: TREE_FONT,
        pickable: false,
        fill: '#666'
      } ) );
    }

    var selfBackground = scenery.Rectangle.bounds( selfNode.bounds );
    selfBackground.addInputListener( {
      enter: function( event ) {
        selfBackground.fill = 'rgba(0,128,255,0.2)';
        activeTreeNodeProperty.value = self;
      },
      exit: function( event ) {
        activeTreeNodeProperty.value = null;
        selfBackground.fill = null;
      }
    } );
    this.addChild( selfBackground );

    this.addChild( selfNode );



    var childrenNode = new scenery.VBox( {
      spacing: 0,
      align: 'left',
      children: displayNode.children.filter( function( child ) {
        return !!child._serialization;
      } ).map( function( child, index ) {
        return new TreeNode( child, trail.copy().addDescendant( child, index ) );
      } )
    } );

    var column = new scenery.Rectangle( {
      rectWidth: 2,
      rectHeight: 5,
      fill: 'rgba(0,0,0,0.1)'
    } );

    var expandedNode = new scenery.Node( {
      children: [
        childrenNode,
        column
      ]
    } );

    if ( childrenNode.bounds.isFinite() ) {
      childrenNode.left = selfNode.left + 13;
      childrenNode.top = selfNode.bottom;
      column.left = selfNode.left;
      column.top = selfNode.bottom;

      this.addChild( expandedNode );

      childrenNode.onStatic( 'bounds', function() {
        column.rectHeight = childrenNode.height;
      } );
    }
  }
  phetCore.inherit( scenery.Node, TreeNode );

  var rightWidth = 500;
  var bottomHeight = 250;

  // initialize our scene
  var scene = new scenery.Node();
  var display = new scenery.Display( scene, {
    container: document.getElementById( 'main' )
  } );
  display.initializeEvents(); // sets up listeners on the document with preventDefault(), and forwards those events to our scene

  var snapshot = JSON.parse( localStorage.scenerySnapshot );
  var isDisplay = snapshot.type === 'Display';

  var subtree = isDisplay ? snapshot.tree : snapshot;
  var displayTree = scenery.deserialize( subtree );
  var backgroundColor = isDisplay ? scenery.deserialize( snapshot.backgroundColor ) : '#fff';
  var snapshotBounds = isDisplay ? new dot.Bounds2( 0, 0, snapshot.width, snapshot.height ) : displayTree.bounds.dilatedXY( displayTree.width * 0.05, displayTree.height * 0.05 );

  var overlayNode = new scenery.Node();
  var displayNode = new scenery.Node( {
    children: [
      scenery.Rectangle.bounds( snapshotBounds, {
        fill: backgroundColor
      } ),
      displayTree,
      overlayNode
    ],
    clipArea: kite.Shape.bounds( snapshotBounds )
  } );
  scene.addChild( displayNode );

  var treeMarginX = 8;
  var treeMarginY = 5;
  var rootTreeNode = new TreeNode( displayTree, new scenery.Trail( displayTree ) );
  rootTreeNode.x = treeMarginX;
  rootTreeNode.y = treeMarginY;
  var treeBackground = new scenery.Rectangle( {
    fill: '#fafafa',
    stroke: '#aaa'
  } );
  var treeContainer = new scenery.Node( {
    children: [
      treeBackground,
      rootTreeNode
    ]
  } );
  scene.addChild( treeContainer );
  function constrainTree() {
    if ( rootTreeNode.bottom < treeBackground.bottom - treeMarginY ) {
      rootTreeNode.bottom = treeBackground.bottom - treeMarginY;
    }
    if ( rootTreeNode.top > treeBackground.top + treeMarginY ) {
      rootTreeNode.top = treeBackground.top + treeMarginY;
    }
    if ( rootTreeNode.right < treeBackground.right - treeMarginX ) {
      rootTreeNode.right = treeBackground.right - treeMarginX;
    }
    if ( rootTreeNode.left > treeBackground.left + treeMarginX ) {
      rootTreeNode.left = treeBackground.left + treeMarginX;
    }
  }
  constrainTree();
  treeContainer.addInputListener( {
    wheel: function( event ) {
      var deltaX = event.domEvent.deltaX;
      var deltaY = event.domEvent.deltaY;
      var multiplier = 1;
      rootTreeNode.x -= deltaX;
      rootTreeNode.y -= deltaY;
      constrainTree();
    }
  } );

  var localBoundsHighlight = new scenery.Path( null, {
    fill: 'rgba(0,128,255,0.2)',
    stroke: 'rgb(0,128,255)',
    lineWidth: 0.5
  } );
  overlayNode.addChild( localBoundsHighlight );

  activeTreeNodeProperty.link( function( treeNode ) {
    if ( treeNode ) {

      var trail = treeNode.trail;
      var matrix = trail.getMatrix();
      var localBounds = treeNode.displayNode.localBounds;

      if ( localBounds.isValid() ) {
        localBoundsHighlight.visible = true;
        localBoundsHighlight.shape = kite.Shape.polygon( [
          localBounds.leftTop,
          localBounds.leftBottom,
          localBounds.rightBottom,
          localBounds.rightTop
        ].map( function( point ) {
          return matrix.timesVector2( point );
        } ) );
      }
      else {
        localBoundsHighlight.visible = false;
      }
    }
    else {
      localBoundsHighlight.visible = false;
    }
  } );

  function layout() {
    var width = window.innerWidth;
    var height = window.innerHeight;
    display.setWidthHeight( width, height );

    var leftWidth = width - rightWidth;

    displayNode.setScaleMagnitude( Math.min( leftWidth / snapshotBounds.width, height / snapshotBounds.height ) );
    displayNode.centerX = leftWidth / 2;
    displayNode.centerY = height / 2;

    var treeLocalBounds = new dot.Bounds2( 0, 0, rightWidth, height - bottomHeight );
    treeContainer.x = leftWidth;
    treeContainer.clipArea = kite.Shape.bounds( treeLocalBounds );
    treeBackground.rectBounds = treeLocalBounds;
  }
  window.addEventListener( 'resize', layout );
  layout();

  /*---------------------------------------------------------------------------*
   * main loop
   *----------------------------------------------------------------------------*/

  display.updateOnRequestAnimationFrame();

</script>

</body>
</html>
