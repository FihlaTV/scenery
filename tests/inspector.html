<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1"/>
  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>Inspector (Scenery)</title>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../build/scenery.min.js"></script>

  <style type="text/css">
    /* Let content go to the edges */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      /*background-color: #ff0;*/
      overflow: hidden;
    }

    /* Have the #main div cover the entire viewport */
    #main {
      position: absolute; /* position !== inherit is required so that Scenery's absolutely-positioned children are placed correctly */
      left: 0;
      top: 0;
      background-color: #fff;
    }

  </style>
</head>

<body>

<!-- our scene graph will be in this div -->
<div id="main">
</div>

<script>
  window.assertions.enableAssert();

  var selectedTreeNodeProperty = new axon.Property( null );
  var activeTreeNodeProperty = new axon.Property( null );

  var previewTreeNodeProperty = new axon.DerivedProperty( [ selectedTreeNodeProperty, activeTreeNodeProperty ], function( selected, active ) {
    return selected ? selected : active;
  } );

  document.addEventListener( 'keyup', function( event ) {
    // Escape
    if ( event.keyCode === 27 ) {
      selectedTreeNodeProperty.value = null;
    }
  } );

  function Divider( preferredBoundsProperty, orientation, initialSeparatorLocation, pushFromMax ) {
    var self = this;

    this.minBoundsProperty = new axon.Property( new dot.Bounds2() );
    this.maxBoundsProperty = new axon.Property( new dot.Bounds2() );

    this.preferredBoundsProperty = preferredBoundsProperty;
    this.orientation = orientation;
    this.primaryCoordinate = orientation === 'horizontal' ? 'x' : 'y';
    this.secondaryCoordinate = orientation === 'horizontal' ? 'y' : 'x';
    this.primaryName = orientation === 'horizontal' ? 'width' : 'height';
    this.secondaryName = orientation === 'horizontal' ? 'height' : 'width';
    this.primaryRectName = orientation === 'horizontal' ? 'rectWidth' : 'rectHeight';
    this.secondaryRectName = orientation === 'horizontal' ? 'rectHeight' : 'rectWidth';
    this.minCoordinate = orientation === 'horizontal' ? 'left' : 'top';
    this.maxCoordinate = orientation === 'horizontal' ? 'right' : 'bottom';
    this.centerName = orientation === 'horizontal' ? 'centerX' : 'centerY';
    this.minimum = 50;

    this.separatorLocation = initialSeparatorLocation;

    scenery.Rectangle.call( this, {
      fill: '#666',
      cursor: orientation === 'horizontal' ? 'w-resize' : 'n-resize'
    } );
    this[ this.primaryRectName ] = 2;

    var dragListener = new scenery.DragListener( {
      drag: function( event ) {
        self.separatorLocation = dragListener.parentPoint[ self.primaryCoordinate ];
        self.layout();
      }
    } );
    this.addInputListener( dragListener );

    preferredBoundsProperty.link( function( newPreferredBounds, oldPreferredBounds ) {
      if ( pushFromMax && oldPreferredBounds ) {
        self.separatorLocation += newPreferredBounds[ self.maxCoordinate ] - oldPreferredBounds[ self.maxCoordinate ];
      }
      if ( !pushFromMax && oldPreferredBounds ) {
        self.separatorLocation += newPreferredBounds[ self.minCoordinate ] - oldPreferredBounds[ self.minCoordinate ];
      }
      self.layout();
    } );
  }
  phetCore.inherit( scenery.Rectangle, Divider, {
    layout: function() {
      var preferredBounds = this.preferredBoundsProperty.value;
      var separatorLocation = this.separatorLocation;

      if ( separatorLocation < preferredBounds[ this.minCoordinate ] + this.minimum ) {
        separatorLocation = this.minimum;
      }
      if ( separatorLocation > preferredBounds[ this.maxCoordinate ] - this.minimum ) {
        if ( preferredBounds[ this.primaryName ] >= this.minimum * 2 ) {
          separatorLocation = preferredBounds[ this.maxCoordinate ] - this.minimum;
        }
        else {
          separatorLocation = preferredBounds[ this.minCoordinate ] + preferredBounds[ this.primaryName ] / 2;
        }
      }

      this[ this.centerName ] = separatorLocation;
      this[ this.secondaryCoordinate ] = preferredBounds[ this.secondaryCoordinate ];
      this[ this.secondaryRectName ] = preferredBounds[ this.secondaryName ];

      if ( this.orientation === 'horizontal' ) {
        this.mouseArea = this.touchArea = this.localBounds.dilatedX( 5 );
      }
      else {
        this.mouseArea = this.touchArea = this.localBounds.dilatedY( 5 );
      }

      var minBounds = preferredBounds.copy();
      var maxBounds = preferredBounds.copy();
      if ( this.orientation === 'horizontal' ) {
        minBounds.maxX = separatorLocation - this.width / 2;
        maxBounds.minX = separatorLocation + this.width / 2;
      }
      else {
        minBounds.maxY = separatorLocation - this.height / 2;
        maxBounds.minY = separatorLocation + this.height / 2;
      }
      this.minBoundsProperty.value = minBounds;
      this.maxBoundsProperty.value = maxBounds;
    }
  } );

  function TreeNode( displayNode, trail ) {
    scenery.Node.call( this );

    var self = this;

    this.displayNode = displayNode;
    this.trail = trail;

    displayNode.addInputListener( {
      over: function( event ) {
        if ( event.target === displayNode ) {
          activeTreeNodeProperty.value = self;
          focusActive();
        }
      },
      out: function( event ) {
        if ( event.target === displayNode ) {
          activeTreeNodeProperty.value = null;
          focusSelected();
        }
      },
      down: function( event ) {
        if ( event.target === displayNode ) {
          selectedTreeNodeProperty.value = self;
          focusSelected();
        }
      }
    } );

    this.expandedProperty = new axon.Property( true );

    var serialization = displayNode._serialization;
    var isVisible = _.every( trail.nodes, function( node ) {
      return node._serialization.options.visible !== false;
    } );

    var selfNode = new scenery.HBox( {
      spacing: 5
    } );

    var buttonSize = 12;
    var expandButton = new scenery.Rectangle( -buttonSize / 2, -buttonSize / 2, buttonSize, buttonSize, {
      children: [
        new scenery.Path( kite.Shape.regularPolygon( 3, buttonSize / 2.5 ), {
          fill: '#444'
        } )
      ],
      visible: false,
      cursor: 'pointer'
    } );
    expandButton.addInputListener( new scenery.FireListener( {
      fire: function() {
        self.expandedProperty.toggle();
      }
    } ) );
    selfNode.addChild( expandButton );

    var TREE_FONT = new scenery.Font( { size: 12 } );

    selfNode.addChild( new scenery.Text( serialization.name, {
      font: TREE_FONT,
      pickable: false,
      fill: isVisible ? '#000' : '#444'
    } ) );
    if ( serialization.name !== serialization.type && serialization.type !== 'Node' ) {
      selfNode.addChild( new scenery.Text( '(' + serialization.type + ')', {
        font: TREE_FONT,
        pickable: false,
        fill: '#666'
      } ) );
    }
    if ( serialization.type === 'Text' ) {
      selfNode.addChild( new scenery.Text( '"' + displayNode.text + '"', {
        font: TREE_FONT,
        pickable: false,
        fill: '#666'
      } ) );
    }

    var selfBackground = this.selfBackground = scenery.Rectangle.bounds( selfNode.bounds, {
      children: [ selfNode ],
      cursor: 'pointer',
      fill: new axon.DerivedProperty( [ selectedTreeNodeProperty, activeTreeNodeProperty ], function( selected, active ) {
        if ( self === selected ) {
          return 'rgba(0,128,255,0.4)';
        }
        else if ( self === active ) {
          return 'rgba(0,128,255,0.2)';
        }
        else {
          return 'transparent';
        }
      } )
    } );
    selfBackground.addInputListener( {
      enter: function( event ) {
        activeTreeNodeProperty.value = self;
      },
      exit: function( event ) {
        activeTreeNodeProperty.value = null;
      }
    } );
    selfBackground.addInputListener( new scenery.FireListener( {
      fire: function() {
        selectedTreeNodeProperty.value = self;
      }
    } ) );
    this.addChild( selfBackground );

    this.childTreeNodes = displayNode.children.filter( function( child ) {
      return !!child._serialization;
    } ).map( function( child, index ) {
      return new TreeNode( child, trail.copy().addDescendant( child, index ) );
    } );

    var childrenNode = new scenery.VBox( {
      spacing: 0,
      align: 'left',
      children: this.childTreeNodes
    } );

    var column = new scenery.Rectangle( {
      rectWidth: 2,
      rectHeight: 5,
      fill: 'rgba(0,0,0,0.1)'
    } );

    var expandedNode = new scenery.Node( {
      children: [
        childrenNode,
        // column
      ]
    } );

    if ( childrenNode.bounds.isFinite() ) {
      childrenNode.left = selfNode.left + 13;
      childrenNode.top = selfNode.bottom;
      column.centerX = selfNode.left + buttonSize / 2;
      column.top = selfNode.bottom;

      expandButton.visible = true;
      this.addChild( expandedNode );

      self.expandedProperty.link( function( expanded ) {
        expandButton.rotation = expanded ? Math.PI / 2 : 0;
        if ( expanded && !self.hasChild( expandedNode ) ) {
          self.addChild( expandedNode );
        }
        if ( !expanded && self.hasChild( expandedNode ) ) {
          self.removeChild( expandedNode );
        }
      } );

      childrenNode.onStatic( 'bounds', function() {
        column.rectHeight = childrenNode.height;
      } );
    }
  }
  phetCore.inherit( scenery.Node, TreeNode, {
    expandRecusively: function() {
      this.expandedProperty.value = true;
      this.childTreeNodes.forEach( function( treeNode ) {
        treeNode.expandRecusively();
      } );
    },
    collapseRecursively: function() {
      this.expandedProperty.value = false;
      this.childTreeNodes.forEach( function( treeNode ) {
        treeNode.collapseRecursively();
      } );
    }
  } );

  var rightWidth = 500;
  var bottomHeight = 200;
  var pathHeight = 20;

  // initialize our scene
  var scene = new scenery.Node();
  var display = new scenery.Display( scene, {
    container: document.getElementById( 'main' )
  } );
  display.initializeEvents(); // sets up listeners on the document with preventDefault(), and forwards those events to our scene

  var snapshot = JSON.parse( localStorage.scenerySnapshot );
  var isDisplay = snapshot.type === 'Display';

  var subtree = isDisplay ? snapshot.tree : snapshot;
  var displayTree = scenery.deserialize( subtree );
  var backgroundColor = isDisplay ? scenery.deserialize( snapshot.backgroundColor ) : '#fff';
  var snapshotBounds = isDisplay ? new dot.Bounds2( 0, 0, snapshot.width, snapshot.height ) : displayTree.bounds.dilatedXY( displayTree.width * 0.05, displayTree.height * 0.05 );

  var overlayNode = new scenery.Node();
  var displayNode = new scenery.Node( {
    children: [
      scenery.Rectangle.bounds( snapshotBounds, {
        fill: backgroundColor
      } ),
      displayTree,
      overlayNode
    ],
    clipArea: kite.Shape.bounds( snapshotBounds )
  } );
  scene.addChild( displayNode );

  var treeMarginX = 8;
  var treeMarginY = 5;
  var rootTreeNode = new TreeNode( displayTree, new scenery.Trail( displayTree ) );
  rootTreeNode.x = treeMarginX;
  rootTreeNode.y = treeMarginY + pathHeight;
  var treeBackground = new scenery.Rectangle( {
    fill: '#fcfcfc',
    stroke: '#888'
  } );
  var treeControls = new scenery.HBox( {
    spacing: 5,
    children: [
      new scenery.Text( 'expand', {
        font: new scenery.Font( { size: 12 } ),
        fill: '#888',
        pointer: 'cursor',
        inputListeners: [ new scenery.FireListener( {
          fire: function() {
            rootTreeNode.expandRecusively();
          }
        } ) ]
      } ),
      new scenery.Text( 'collapse', {
        font: new scenery.Font( { size: 12 } ),
        fill: '#888',
        pointer: 'cursor',
        inputListeners: [ new scenery.FireListener( {
          fire: function() {
            rootTreeNode.collapseRecursively();
          }
        } ) ]
      } )
    ],
    y: rootTreeNode.y
  } );
  var treeContainer = new scenery.Node( {
    children: [
      treeBackground,
      rootTreeNode,
      treeControls
    ]
  } );
  scene.addChild( treeContainer );
  function constrainTree() {
    if ( rootTreeNode.bottom < treeBackground.bottom - treeMarginY ) {
      rootTreeNode.bottom = treeBackground.bottom - treeMarginY;
    }
    if ( rootTreeNode.top > treeBackground.top + treeMarginY ) {
      rootTreeNode.top = treeBackground.top + treeMarginY;
    }
    if ( rootTreeNode.right < treeBackground.right - treeMarginX ) {
      rootTreeNode.right = treeBackground.right - treeMarginX;
    }
    if ( rootTreeNode.left > treeBackground.left + treeMarginX ) {
      rootTreeNode.left = treeBackground.left + treeMarginX;
    }
  }
  treeContainer.addInputListener( {
    wheel: function( event ) {
      var deltaX = event.domEvent.deltaX;
      var deltaY = event.domEvent.deltaY;
      var multiplier = 1;
      rootTreeNode.x -= deltaX;
      rootTreeNode.y -= deltaY;
      constrainTree();
    }
  } );

  function focusTreeNode( treeNode ) {
    var trail = treeNode.getUniqueTrailTo( rootTreeNode );
    var deltaY = trail.localToGlobalPoint( treeNode.selfBackground.center ).y - treeBackground.centerY;
    rootTreeNode.y -= deltaY;
    constrainTree();
  }
  function focusActive() {
    focusTreeNode( activeTreeNodeProperty.value );
  }
  function focusSelected() {
    if ( selectedTreeNodeProperty.value === null ) { return; }

    focusTreeNode( selectedTreeNodeProperty.value );
  }

  var localBoundsHighlight = new scenery.Path( null, {
    fill: 'rgba(0,128,255,0.4)',
    stroke: 'rgb(0,64,128)',
    lineWidth: 0.5
  } );
  overlayNode.addChild( localBoundsHighlight );

  activeTreeNodeProperty.link( function( treeNode ) {
    if ( treeNode ) {

      var trail = treeNode.trail;
      var matrix = trail.getMatrix();
      var localBounds = treeNode.displayNode.localBounds;

      if ( localBounds.isValid() ) {
        localBoundsHighlight.visible = true;
        localBoundsHighlight.shape = kite.Shape.polygon( [
          localBounds.leftTop,
          localBounds.leftBottom,
          localBounds.rightBottom,
          localBounds.rightTop
        ].map( function( point ) {
          return matrix.timesVector2( point );
        } ) );
      }
      else {
        localBoundsHighlight.visible = false;
      }
    }
    else {
      localBoundsHighlight.visible = false;
    }
  } );

  var previewContainer = new scenery.Node();
  var previewBackground = new scenery.Rectangle( {
    rectWidth: bottomHeight,
    rectHeight: bottomHeight,
    children: [ previewContainer ],
    fill: '#eee'
  } );
  scene.addChild( previewBackground );

  previewTreeNodeProperty.link( function( treeNode ) {
    if ( treeNode ) {
      var node = treeNode.displayNode;
      previewContainer.children = [ node ];
      if ( previewContainer.bounds.isValid() ) {
        previewContainer.visible = true;
        var scale = Math.min( bottomHeight / node.width, bottomHeight / node.height );
        previewContainer.setScaleMagnitude( scale * 0.9 );
        previewContainer.centerX = bottomHeight / 2;;
        previewContainer.centerY = bottomHeight / 2;;
      }
      else {
        previewContainer.visible = false;
      }
    }
    else {
      previewContainer.visible = false;
    }
  } );

  var pathBackground = new scenery.Rectangle( {
    fill: '#333'
  } );
  var pathContainer = new scenery.HBox( {
    spacing: 5
  } );
  scene.addChild( pathBackground );
  scene.addChild( pathContainer );

  function layoutPathContainer() {
    if ( pathContainer.bounds.isValid() ) {
      pathContainer.left = pathBackground.left + 5;
      pathContainer.centerY = pathBackground.centerY;
    }
  }

  var PATH_FONT = new scenery.Font( { size: 12, weight: 'bold' } );
  previewTreeNodeProperty.link( function( treeNode ) {
    if ( treeNode ) {
      pathContainer.children = treeNode.trail.nodes.map( function( node ) {
        var name = node._serialization.name;
        if ( name === 'Node' ) {
          return new scenery.Text( '|', { font: PATH_FONT, fill: '#bbb' } );
        }
        else {
          return new scenery.Text( name, { font: PATH_FONT, fill: '#fff' } );
        }
      } );
    }
    else {
      pathContainer.children = [];
    }
    layoutPathContainer();
  } );

  var mainBoundsProperty = new axon.Property( new dot.Bounds2( 0, 0, window.innerWidth, window.innerHeight ) );

  var mainDivider = new Divider( mainBoundsProperty, 'horizontal', window.innerWidth - rightWidth, true );
  mainDivider.minBoundsProperty.link( function( leftBounds ) {
    displayNode.setScaleMagnitude( Math.min( leftBounds.width / snapshotBounds.width, leftBounds.height / snapshotBounds.height ) );
    displayNode.center = leftBounds.center;
  } );
  mainDivider.maxBoundsProperty.link( function( rightBounds ) {
    pathBackground.rectBounds = new dot.Bounds2( rightBounds.minX, rightBounds.minY, rightBounds.maxX, rightBounds.minY + pathHeight );
    pathContainer.maxWidth = pathBackground.width - 10;
    layoutPathContainer();

    var treeLocalBounds = new dot.Bounds2( 0, pathHeight, rightBounds.width, rightBounds.height - bottomHeight );
    treeContainer.x = rightBounds.left;
    treeContainer.clipArea = kite.Shape.bounds( treeLocalBounds );
    treeBackground.rectBounds = treeLocalBounds;
    treeControls.right = treeLocalBounds.right - 5;
    constrainTree();
  } );

  scene.addChild( mainDivider );

  function layout() {
    var width = window.innerWidth;
    var height = window.innerHeight;
    display.setWidthHeight( width, height );
    mainBoundsProperty.value = new dot.Bounds2( 0, 0, width, height );

    var leftWidth = width - rightWidth;

    previewBackground.x = width - bottomHeight;
    previewBackground.y = height - bottomHeight;
  }
  window.addEventListener( 'resize', layout );
  layout();

  /*---------------------------------------------------------------------------*
   * main loop
   *----------------------------------------------------------------------------*/

  display.updateOnRequestAnimationFrame();

</script>

</body>
</html>
