<!DOCTYPE html>
<html>
<!--
When run in the browser, this will run many random changes to a Scenery Node tree and update the display in an effort
to find any underlying bugs in the implementation. It requires many checks to make sure we are only doing supported
operations, so that any error discovered while running this is a bug. Additionally, we store the sequence of actions so
that any error can be reproduced.
-->
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Scenery Fuzzer</title>

  <script src="../../assert/js/assert.js"></script>
  <script src="../../sherpa/jquery-2.1.0.js"></script>
  <script src="../../sherpa/lodash-2.4.1.min.js"></script>
  <script src="../../sherpa/has.js"></script>

  <script type="text/javascript">
    // We want to trigger any assertions we can
    window.assertions.enableAssert();
    window.assertions.enableAssertSlow();
  </script>

  <script data-main="../js/config.js" src="../../sherpa/require-2.1.11.js"></script>

  <style>

  </style>

</head>
<body>

<script>
  var INITIAL_WIDTH = 640;
  var INITIAL_HEIGHT = 480;
  var INITIAL_BACKGROUND_COLOR = '#eee';
  var MIN_WIDTH = 320;
  var MIN_HEIGHT = 240;
  var MAX_WIDTH = 1024;
  var MAX_HEIGHT = 768;

  var fuzzing = true;

  require( [ 'config' ], function() {
    require( [ 'main', 'KITE/main', 'DOT/main', 'PHET_CORE/main' ], function( scenery, kite, dot, core ) {
      window.scenery = scenery;
      window.kite = kite;
      window.dot = dot;
      window.core = core;

      console.log( 'loaded' );

      function randomText() {
        var result = '';

        while ( Math.random() > 0.1 ) {
          result += String.fromCharCode( 97 + Math.floor( Math.random() * 26 ) );
        }

        return result;
      }

      var fuzzLog = window._fuzzLog = [];

      var nodes = window.nodes = {};
      var paths = window.paths = {};
      var texts = window.texts = {};

      fuzzLog.push( 'var root = new scenery.Node();' );
      nodes.root = new scenery.Node();

      fuzzLog.push( 'var display = new scenery.Display( root, { ' +
        'width: ' + INITIAL_WIDTH + ', ' +
        'height: ' + INITIAL_HEIGHT + ', '+
        'backgroundColor: \'' + INITIAL_BACKGROUND_COLOR + '\'' +
        ' } );' );
      var display = window.display = new scenery.Display( nodes.root, {
        width: INITIAL_WIDTH,
        height: INITIAL_HEIGHT,
        backgroundColor: INITIAL_BACKGROUND_COLOR
      } );

      fuzzLog.push( 'display.updateDisplay();' );
      display.updateDisplay();

      fuzzLog.push( 'document.body.appendChild( display.domElement );' );
      document.body.appendChild( display.domElement );

      var i;
      for ( i = 0; i < 7; i++ ) {
        fuzzLog.push( 'var node' + i + ' = new scenery.Node();' );
        nodes[ 'node' + i ] = new scenery.Node();
      }
      for ( i = 0; i < 4; i++ ) {
        fuzzLog.push( 'var path' + i + ' = new scenery.Path();' );
        paths[ 'path' + i ] = nodes[ 'path' + i ] = new scenery.Path();
      }
      for ( i = 0; i < 3; i++ ) {
        fuzzLog.push( 'var text' + i + ' = new scenery.Text( \'' + i + '!\' );' );
        texts[ 'text' + i ] = nodes[ 'path' + i ] = new scenery.Text( i + '!' );
      }

      function randomName( names ) {
        return names[ _.random( 0, names.length - 1 ) ];
      }

      function nameOf( node ) {
        var names = Object.keys( nodes );
        for ( var i = 0; i < names.length; i++ ) {
          if ( nodes[names[i]] === node ) {
            return names[i];
          }
        }
        throw new Error( 'bad node' );
      }

      function randomNodeName() {
        return randomName( Object.keys( nodes ) );
      }
      function randomNode() {
        return nodes[randomNodeName()];
      }

      function childChange() {
        var r = Math.random();

        var a = randomNode();

        if ( r < 0.5 ) {
          var b = randomNode();

          // attempt to add a node to another one
          if ( a.canAddChild( b ) ) {
            // insert it into a random place
            var index = _.random( 0, a.children.length );
            fuzzLog.push( nameOf( a ) + '.insertChild( ' + index + ', ' + nameOf( b ) + ' );' );
            a.insertChild( index, b );
          }
        }
        else {
          if ( a.children.length ) {
            var child = a.children[_.random( 0, a.children.length - 1 )];
            fuzzLog.push( nameOf( a ) + '.removeChild( ' + nameOf( child ) + ' );' );
            a.removeChild( child );
          }
        }
      }

      function directTransformChange() {
        var node = randomNode();

        var matrix;
        var matrixString;
        var a = Math.random();
        var b = Math.random();

        if ( a < 0.4 ) {
          var x = Math.random() * 200 - 100;
          var y = Math.random() * 200 - 100;
          matrix = dot.Matrix3.translation( x, y );
          matrixString = 'dot.Matrix3.translation( ' + x + ', ' + y + ' )';
        }
        else if ( a < 0.8 ) {
          // slightly scales up, but random => 0 undoes random => 1
          var phi = 1.61803398875;
          var scale = Math.random() + phi - 1;
          matrix = dot.Matrix3.scaling( scale );
          matrixString = 'dot.Matrix3.scaling( ' + scale + ' )';
        }
        else {
          var rotation = Math.random() * Math.PI * 2;
          matrix = dot.Matrix3.rotation2( rotation );
          matrixString = 'dot.Matrix3.rotation2( ' + rotation + ' )';
        }

        if ( b < 0.333 ) {
          fuzzLog.push( nameOf( node ) + '.transform.setMatrix( ' + matrixString + ' );' );
          node.transform.setMatrix( matrix );
        }
        else if ( b < 0.666 ){
          fuzzLog.push( nameOf( node ) + '.transform.prepend( ' + matrixString + ' );' );
          node.transform.prepend( matrix );
        }
        else {
          fuzzLog.push( nameOf( node ) + '.transform.append( ' + matrixString + ' );' );
          node.transform.append( matrix );
        }
      }

      (function step() {
        requestAnimationFrame( step );

        if ( fuzzing ) {
          while ( Math.random() < 0.9 ) {
            var r = Math.random();

            if ( r < 0.6 ) {
              childChange();
            }
            else {
              directTransformChange();
            }
          }

          fuzzLog.push( 'display.updateDisplay();' );
          display.updateDisplay();
        }
      })();

      window.startFuzz = function() {
        fuzzing = true;
      };
      window.endFuzz = function() {
        fuzzing = false;
      };

      core.extend( window, {
        get fuzzLog() {
          return this._fuzzLog.join( '\n' );
        }
      } );



      /*---------------------------------------------------------------------------*
       * Miscellaneous
       *----------------------------------------------------------------------------*/

      // window.fuzzLayers = function() {
      //   // disable the regular step
      //   basicSceneStep = false;
      //   fuzzStep = true;

      //   // disable the layer logging, or we'll spam ourselves to death
      //   scenery.disableLayerLogging();
      //   scenery.disableEventLogging();

      //   var lines = [];
      //   window.lines = lines;

      //   var nodes = [];
      //   var scene = new scenery.Scene( $( '<div>' ), { width: 640, height: 320 } );
      //   nodes.push( scene );

      //   _.times( 5, function() { nodes.push( new scenery.Node() ); } );
      //   _.times( 10, function() { nodes.push( new scenery.Path() ); } );
      //   // _.times( 5, function() { nodes.push( new scenery.DOM( document.createElement( 'div' ) ) ); } );

      //   function name( node ) {
      //     return node === scene ? 'scene' : node.constructor.name.toLowerCase() + node.id;
      //   }

      //   _.each( nodes, function( node ) {
      //     if ( node !== scene ) {
      //       lines.push( 'var ' + name( node ) + ' = ' + node.toString() + ';' );
      //     }
      //   } );

      //   (function fuzz(){
      //     // abort if desired
      //     if ( !fuzzStep ) {
      //       return;
      //     }

      //     var nodeMutators = [
      //       {
      //         weight: 1.0,
      //         f: function( node ) { node.renderer = 'canvas'; },
      //         mess: 'canvas renderer',
      //         line: function( node ) { return name( node ) + '.renderer = \'canvas\';' }
      //       },
      //       {
      //         weight: 1.0,
      //         f: function( node ) { node.renderer = 'svg'; },
      //         mess: 'svg renderer',
      //         line: function( node ) { return name( node ) + '.renderer = \'svg\';' }
      //       },
      //       {
      //         weight: 2.0,
      //         f: function( node ) { node.renderer = null; },
      //         mess: 'null renderer',
      //         line: function( node ) { return name( node ) + '.renderer = null;' }
      //       },
      //       {
      //         weight: 0.3,
      //         f: function( node ) { node.layerSplit = true; },
      //         mess: 'layerSplit true',
      //         line: function( node ) { return name( node ) + '.layerSplit = true;' }
      //       },
      //       {
      //         weight: 1.0,
      //         f: function( node ) { node.layerSplit = false; },
      //         mess: 'layerSplit false',
      //         line: function( node ) { return name( node ) + '.layerSplit = false;' }
      //       }
      //     ];

      //     var totalWeight = _.reduce( _.pluck( nodeMutators, 'weight' ), function( memo, num ) { return memo + num; }, 0 );

      //     _.times( 20, function() {
      //       window.beforeFuzzDebug = scene.getDebugHTML();
      //       window.beforeFuzzSerialization = scene.toStringWithChildren( true );

      //       var r = Math.random();

      //       // pick two different nodes at random
      //       var a = nodes[_.random( 0, nodes.length - 1 )];
      //       var b = nodes[_.random( 0, nodes.length - 1 )];

      //       if ( r < 0.333 ) {
      //         // attempt to add a node to another one
      //         if ( a.canAddChild( b ) ) {
      //           // insert it into a random place
      //           var index = _.random( 0, a.children.length );
      //           window.fuzzMessage = 'inserting child ' + b.id + ' into ' + a.id + ' at index ' + index;
      //           lines.push( name( a ) + '.insertChild( ' + index + ', ' + name( b ) + ' );' );
      //           a.insertChild( index, b );
      //         }
      //       } else if( r < 0.666 ) {
      //         if ( a.children.length ) {
      //           var child = a.children[_.random( 0, a.children.length - 1 )];
      //           window.fuzzMessage = 'removing child ' + child.id + ' to ' + a.id;
      //           lines.push( name( a ) + '.removeChild( ' + name( child ) + ' );' );
      //           a.removeChild( child );
      //         }
      //       } else {
      //         // pick a random modification from the weighted list
      //         var rr = Math.random() * totalWeight;
      //         for ( var i = 0; i < nodeMutators.length; i++ ) {
      //           var mutator = nodeMutators[i];
      //           rr -= mutator.weight;
      //           if ( rr <= 0 ) {
      //             window.fuzzMessage = 'mutating node ' + a.id + ' with ' + mutator.mess;
      //             lines.push( mutator.line( a ) );
      //             mutator.f( a );
      //             break;
      //           }
      //         }
      //       }

      //       scene.layerAudit();

      //     } );
      //     $( '#debug' ).html( scene.getDebugHTML() );

      //     // an error above will prevent this from running
      //     window.requestAnimationFrame( fuzz );
      //   })();
      // };
    } );
  } );
</script>
</body>
</html>
